/*
Audio playback and capture library. Choice of public domain or MIT-0. See license statements at the end of this file.
mini_al - v0.8.15 - 201x-xx-xx

David Reid - davidreidsoftware@gmail.com
*/

/*
ABOUT
=====
mini_al is a single file library for audio playback and capture. It's written in C (compilable as
C++) and released into the public domain.

Supported Backends:
  - WASAPI
  - DirectSound
  - WinMM
  - Core Audio (Apple)
  - ALSA
  - PulseAudio
  - JACK
  - sndio (OpenBSD)
  - audio(4) (NetBSD and OpenBSD)
  - OSS (FreeBSD)
  - AAudio (Android 8.0+)
  - OpenSL|ES (Android only)
  - Web Audio (Emscripten)
  - Null (Silence)

Supported Formats:
  - Unsigned 8-bit PCM
  - Signed 16-bit PCM
  - Signed 24-bit PCM (tightly packed)
  - Signed 32-bit PCM
  - IEEE 32-bit floating point PCM


USAGE
=====
mini_al is a single-file library. To use it, do something like the following in one .c file.
  #define MINI_AL_IMPLEMENTATION
  #include "mini_al.h"

You can then #include this file in other parts of the program as you would with any other header file.

mini_al uses an asynchronous, callback based API. You initialize a device with a configuration (sample rate,
channel count, etc.) which includes the callback you want to use to handle data transmission to/from the
device. In the callback you either read from a data pointer in the case of playback or write to it in the case
of capture.

Playback Example
----------------
  void data_callback(mal_device* pDevice, void* pOutput, const void* pInput, mal_uint32 frameCount)
  {
      mal_decoder* pDecoder = (mal_decoder*)pDevice->pUserData;
      if (pDecoder == NULL) {
          return;
      }
  
      mal_decoder_read_pcm_frames(pDecoder, frameCount, pOutput);
  }

  ...

  mal_device_config config = mal_device_config_init(mal_device_type_playback);
  config.playback.pDeviceID = NULL;
  config.playback.format    = decoder.outputFormat;
  config.playback.channels  = decoder.outputChannels;
  config.sampleRate         = decoder.outputSampleRate;
  config.dataCallback       = data_callback;
  config.pUserData          = &decoder;

  mal_device device;
  if (mal_device_init(NULL, &config, &device) != MAL_SUCCESS) {
      ... An error occurred ...
  }

  mal_device_start(&device);     // The device is sleeping by default so you'll need to start it manually.

  ...

  mal_device_uninit(&device);    // This will stop the device so no need to do that manually.


BUILDING
========
mini_al should Just Work by adding it to your project's source tree. You do not need to download or install
any dependencies. See below for platform-specific details.

If you want to disable a specific backend, #define the appropriate MAL_NO_* option before the implementation.

Note that GCC and Clang requires "-msse2", "-mavx2", etc. for SIMD optimizations.


Building for Windows
--------------------
The Windows build should compile clean on all popular compilers without the need to configure any include paths
nor link to any libraries.

Building for macOS and iOS
--------------------------
The macOS build should compile clean without the need to download any dependencies or link to any libraries or
frameworks. The iOS build needs to be compiled as Objective-C (sorry) and will need to link the relevant frameworks
but should Just Work with Xcode.

Building for Linux
------------------
The Linux build only requires linking to -ldl, -lpthread and -lm. You do not need any development packages.

Building for BSD
----------------
The BSD build only requires linking to -ldl, -lpthread and -lm. NetBSD uses audio(4), OpenBSD uses sndio and
FreeBSD uses OSS.

Building for Android
--------------------
AAudio is the highest priority backend on Android. This should work out out of the box without needing any kind of
compiler configuration. Support for AAudio starts with Android 8 which means older versions will fall back to
OpenSL|ES which requires API level 16+.

Building for Emscripten
-----------------------
The Emscripten build emits Web Audio JavaScript directly and should Just Work without any configuration.


NOTES
=====
- This library uses an asynchronous API for delivering and requesting audio data. Each device will have
  it's own worker thread which is managed by the library.
- If mal_device_init() is called with a device that's not aligned to the platform's natural alignment
  boundary (4 bytes on 32-bit, 8 bytes on 64-bit), it will _not_ be thread-safe. The reason for this
  is that it depends on members of mal_device being correctly aligned for atomic assignments.
- Sample data is always native-endian and interleaved. For example, mal_format_s16 means signed 16-bit
  integer samples, interleaved. Let me know if you need non-interleaved and I'll look into it.
- The sndio backend is currently only enabled on OpenBSD builds.
- The audio(4) backend is supported on OpenBSD, but you may need to disable sndiod before you can use it.
- Automatic stream routing is enabled on a per-backend basis. Support is explicitly enabled for WASAPI
  and Core Audio, however other backends such as PulseAudio may naturally support it, though not all have
  been tested.


BACKEND NUANCES
===============

PulseAudio
----------
- If you experience bad glitching/noise on Arch Linux, consider this fix from the Arch wiki:
    https://wiki.archlinux.org/index.php/PulseAudio/Troubleshooting#Glitches,_skips_or_crackling
  Alternatively, consider using a different backend such as ALSA.

Android
-------
- To capture audio on Android, remember to add the RECORD_AUDIO permission to your manifest:
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
- With OpenSL|ES, only a single mal_context can be active at any given time. This is due to a limitation with OpenSL|ES.
- With AAudio, only default devices are enumerated. This is due to AAudio not having an enumeration API (devices are
  enumerated through Java). You can however perform your own device enumeration through Java and then set the ID in the
  mal_device_id structure (mal_device_id.aaudio) and pass it to mal_device_init().
- The backend API will perform resampling where possible. The reason for this as opposed to using mini_al's built-in
  resampler is to take advantage of any potential device-specific optimizations the driver may implement.

UWP
---
- UWP only supports default playback and capture devices.
- UWP requires the Microphone capability to be enabled in the application's manifest (Package.appxmanifest):
      <Package ...>
          ...
          <Capabilities>
              <DeviceCapability Name="microphone" />
          </Capabilities>
      </Package>

Web Audio / Emscripten
----------------------
- The first time a context is initialized it will create a global object called "mal" whose primary purpose is to act
  as a factory for device objects.
- Currently the Web Audio backend uses ScriptProcessorNode's, but this may need to change later as they've been deprecated.
- Google is implementing a policy in their browsers that prevent automatic media output without first receiving some kind
  of user input. See here for details: https://developers.google.com/web/updates/2017/09/autoplay-policy-changes. Starting
  the device may fail if you try to start playback without first handling some kind of user input.


OPTIONS
=======
#define these options before including this file.

#define MAL_NO_WASAPI
  Disables the WASAPI backend.

#define MAL_NO_DSOUND
  Disables the DirectSound backend.

#define MAL_NO_WINMM
  Disables the WinMM backend.

#define MAL_NO_ALSA
  Disables the ALSA backend.

#define MAL_NO_PULSEAUDIO
  Disables the PulseAudio backend.

#define MAL_NO_JACK
  Disables the JACK backend.

#define MAL_NO_COREAUDIO
  Disables the Core Audio backend.

#define MAL_NO_SNDIO
  Disables the sndio backend.

#define MAL_NO_AUDIO4
  Disables the audio(4) backend.

#define MAL_NO_OSS
  Disables the OSS backend.

#define MAL_NO_AAUDIO
  Disables the AAudio backend.

#define MAL_NO_OPENSL
  Disables the OpenSL|ES backend.

#define MAL_NO_WEBAUDIO
  Disables the Web Audio backend.

#define MAL_NO_NULL
  Disables the null backend.

#define MAL_DEFAULT_PERIODS
  When a period count of 0 is specified when a device is initialized, it will default to this.

#define MAL_BASE_BUFFER_SIZE_IN_MILLISECONDS_LOW_LATENCY
#define MAL_BASE_BUFFER_SIZE_IN_MILLISECONDS_CONSERVATIVE
  When a buffer size of 0 is specified when a device is initialized it will default to a buffer of this size, depending
  on the chosen performance profile. These can be increased or decreased depending on your specific requirements.

#define MAL_NO_DECODING
  Disables the decoding APIs.

#define MAL_NO_DEVICE_IO
  Disables playback and recording. This will disable mal_context and mal_device APIs. This is useful if you only want to
  use mini_al's data conversion and/or decoding APIs. 

#define MAL_NO_STDIO
  Disables file IO APIs.

#define MAL_NO_SSE2
  Disables SSE2 optimizations.

#define MAL_NO_AVX2
  Disables AVX2 optimizations.

#define MAL_NO_AVX512
  Disables AVX-512 optimizations.

#define MAL_NO_NEON
  Disables NEON optimizations.

#define MAL_LOG_LEVEL <Level>
  Sets the logging level. Set level to one of the following:
    MAL_LOG_LEVEL_VERBOSE
    MAL_LOG_LEVEL_INFO
    MAL_LOG_LEVEL_WARNING
    MAL_LOG_LEVEL_ERROR

#define MAL_DEBUT_OUTPUT
  Enable printf() debug output.

#define MAL_COINIT_VALUE
  Windows only. The value to pass to internal calls to CoInitializeEx(). Defaults to COINIT_MULTITHREADED.


DEFINITIONS
===========
This section defines common terms used throughout mini_al. Unfortunately there is often ambiguity in the use of terms
throughout the audio space, so this section is intended to clarify how mini_al uses each term.

Sample
------
A sample is a single unit of audio data. If the sample format is f32, then one sample is one 32-bit floating point number.

Frame / PCM Frame
-----------------
A frame is a groups of samples equal to the number of channels. For a stereo stream a frame is 2 samples, a mono frame
is 1 sample, a 5.1 surround sound frame is 6 samples, etc. The terms "frame" and "PCM frame" are the same thing in
mini_al. Note that this is different to a compressed frame. If ever mini_al needs to refer to a compressed frame, such
as a FLAC frame, it will always clarify what it's referring to with something like "FLAC frame" or whatnot.

Channel
-------
A stream of monaural audio that is emitted from an individual speaker in a speaker system, or received from an individual
microphone in a microphone system. A stereo stream has two channels (a left channel, and a right channel), a 5.1 surround
sound system has 6 channels, etc. Some audio systems refer to a channel as a complex audio stream that's mixed with other
channels to produce the final mix - this is completely different to mini_al's use of the term "channel" and should not be
confused.

Sample Rate
-----------
The sample rate in mini_al is always expressed in Hz, such as 44100, 48000, etc. It's the number of PCM frames that are
processed per second.

Formats
-------
Throughout mini_al you will see references to different sample formats:
    u8  - Unsigned 8-bit integer
    s16 - Signed 16-bit integer
    s24 - Signed 24-bit integer (tightly packed).
    s32 - Signed 32-bit integer
    f32 - 32-bit floating point
*/

#ifndef mini_al_h
#define mini_al_h

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_MSC_VER)
    #pragma warning(push)
    #pragma warning(disable:4201)   // nonstandard extension used: nameless struct/union
    #pragma warning(disable:4324)   // structure was padded due to alignment specifier
#endif

// Platform/backend detection.
#ifdef _WIN32
    #define MAL_WIN32
    #if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_PC_APP || WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP)
        #define MAL_WIN32_UWP
    #else
        #define MAL_WIN32_DESKTOP
    #endif
#else
    #define MAL_POSIX
    #include <pthread.h>    // Unfortunate #include, but needed for pthread_t, pthread_mutex_t and pthread_cond_t types.

    #ifdef __unix__
        #define MAL_UNIX
        #if defined(__DragonFly__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
            #define MAL_BSD
        #endif
    #endif
    #ifdef __linux__
        #define MAL_LINUX
    #endif
    #ifdef __APPLE__
        #define MAL_APPLE
    #endif
    #ifdef __ANDROID__
        #define MAL_ANDROID
    #endif
    #ifdef __EMSCRIPTEN__
        #define MAL_EMSCRIPTEN
    #endif
#endif

#include <stddef.h> /* For size_t. */

/* Sized types. Prefer built-in types. Fall back to stdint. */
#ifdef _MSC_VER
    #if defined(__clang__)
        #pragma GCC diagnostic push
        #pragma GCC diagnostic ignored "-Wlanguage-extension-token"
        #pragma GCC diagnostic ignored "-Wc++11-long-long"
    #endif
    typedef   signed __int8  mal_int8;
    typedef unsigned __int8  mal_uint8;
    typedef   signed __int16 mal_int16;
    typedef unsigned __int16 mal_uint16;
    typedef   signed __int32 mal_int32;
    typedef unsigned __int32 mal_uint32;
    typedef   signed __int64 mal_int64;
    typedef unsigned __int64 mal_uint64;
    #if defined(__clang__)
        #pragma GCC diagnostic pop
    #endif
#else
    #define MAL_HAS_STDINT
    #include <stdint.h>
    typedef int8_t   mal_int8;
    typedef uint8_t  mal_uint8;
    typedef int16_t  mal_int16;
    typedef uint16_t mal_uint16;
    typedef int32_t  mal_int32;
    typedef uint32_t mal_uint32;
    typedef int64_t  mal_int64;
    typedef uint64_t mal_uint64;
#endif

#ifdef MAL_HAS_STDINT
    typedef uintptr_t mal_uintptr;
#else
    #if defined(_WIN32)
        #if defined(_WIN64)
            typedef mal_uint64 mal_uintptr;
        #else
            typedef mal_uint32 mal_uintptr;
        #endif
    #elif defined(__GNUC__)
        #if defined(__LP64__)
            typedef mal_uint64 mal_uintptr;
        #else
            typedef mal_uint32 mal_uintptr;
        #endif
    #else
        typedef mal_uint64 mal_uintptr;   /* Fallback. */
    #endif
#endif

typedef mal_uint8                   mal_bool8;
typedef mal_uint32                  mal_bool32;
#define MAL_TRUE                    1
#define MAL_FALSE                   0

typedef void* mal_handle;
typedef void* mal_ptr;
typedef void (* mal_proc)(void);

#if defined(_MSC_VER) && !defined(_WCHAR_T_DEFINED)
typedef mal_uint16 wchar_t;
#endif

// Define NULL for some compilers.
#ifndef NULL
#define NULL 0
#endif

#if defined(SIZE_MAX)
    #define MAL_SIZE_MAX    SIZE_MAX
#else
    #define MAL_SIZE_MAX    0xFFFFFFFF  /* When SIZE_MAX is not defined by the standard library just default to the maximum 32-bit unsigned integer. */
#endif


#ifdef _MSC_VER
#define MAL_INLINE __forceinline
#else
#ifdef __GNUC__
#define MAL_INLINE inline __attribute__((always_inline))
#else
#define MAL_INLINE inline
#endif
#endif

#ifdef _MSC_VER
#define MAL_ALIGN(alignment) __declspec(align(alignment))
#elif !defined(__DMC__)
#define MAL_ALIGN(alignment) __attribute__((aligned(alignment)))
#else
#define MAL_ALIGN(alignment)
#endif

#ifdef _MSC_VER
#define MAL_ALIGNED_STRUCT(alignment) MAL_ALIGN(alignment) struct
#else
#define MAL_ALIGNED_STRUCT(alignment) struct MAL_ALIGN(alignment)
#endif

// SIMD alignment in bytes. Currently set to 64 bytes in preparation for future AVX-512 optimizations.
#define MAL_SIMD_ALIGNMENT  64


// Logging levels
#define MAL_LOG_LEVEL_VERBOSE   4
#define MAL_LOG_LEVEL_INFO      3
#define MAL_LOG_LEVEL_WARNING   2
#define MAL_LOG_LEVEL_ERROR     1

#ifndef MAL_LOG_LEVEL
#define MAL_LOG_LEVEL           MAL_LOG_LEVEL_ERROR
#endif

typedef struct mal_context mal_context;
typedef struct mal_device mal_device;

typedef mal_uint8 mal_channel;
#define MAL_CHANNEL_NONE                                0
#define MAL_CHANNEL_MONO                                1
#define MAL_CHANNEL_FRONT_LEFT                          2
#define MAL_CHANNEL_FRONT_RIGHT                         3
#define MAL_CHANNEL_FRONT_CENTER                        4
#define MAL_CHANNEL_LFE                                 5
#define MAL_CHANNEL_BACK_LEFT                           6
#define MAL_CHANNEL_BACK_RIGHT                          7
#define MAL_CHANNEL_FRONT_LEFT_CENTER                   8
#define MAL_CHANNEL_FRONT_RIGHT_CENTER                  9
#define MAL_CHANNEL_BACK_CENTER                         10
#define MAL_CHANNEL_SIDE_LEFT                           11
#define MAL_CHANNEL_SIDE_RIGHT                          12
#define MAL_CHANNEL_TOP_CENTER                          13
#define MAL_CHANNEL_TOP_FRONT_LEFT                      14
#define MAL_CHANNEL_TOP_FRONT_CENTER                    15
#define MAL_CHANNEL_TOP_FRONT_RIGHT                     16
#define MAL_CHANNEL_TOP_BACK_LEFT                       17
#define MAL_CHANNEL_TOP_BACK_CENTER                     18
#define MAL_CHANNEL_TOP_BACK_RIGHT                      19
#define MAL_CHANNEL_AUX_0                               20
#define MAL_CHANNEL_AUX_1                               21
#define MAL_CHANNEL_AUX_2                               22
#define MAL_CHANNEL_AUX_3                               23
#define MAL_CHANNEL_AUX_4                               24
#define MAL_CHANNEL_AUX_5                               25
#define MAL_CHANNEL_AUX_6                               26
#define MAL_CHANNEL_AUX_7                               27
#define MAL_CHANNEL_AUX_8                               28
#define MAL_CHANNEL_AUX_9                               29
#define MAL_CHANNEL_AUX_10                              30
#define MAL_CHANNEL_AUX_11                              31
#define MAL_CHANNEL_AUX_12                              32
#define MAL_CHANNEL_AUX_13                              33
#define MAL_CHANNEL_AUX_14                              34
#define MAL_CHANNEL_AUX_15                              35
#define MAL_CHANNEL_AUX_16                              36
#define MAL_CHANNEL_AUX_17                              37
#define MAL_CHANNEL_AUX_18                              38
#define MAL_CHANNEL_AUX_19                              39
#define MAL_CHANNEL_AUX_20                              40
#define MAL_CHANNEL_AUX_21                              41
#define MAL_CHANNEL_AUX_22                              42
#define MAL_CHANNEL_AUX_23                              43
#define MAL_CHANNEL_AUX_24                              44
#define MAL_CHANNEL_AUX_25                              45
#define MAL_CHANNEL_AUX_26                              46
#define MAL_CHANNEL_AUX_27                              47
#define MAL_CHANNEL_AUX_28                              48
#define MAL_CHANNEL_AUX_29                              49
#define MAL_CHANNEL_AUX_30                              50
#define MAL_CHANNEL_AUX_31                              51
#define MAL_CHANNEL_LEFT                                MAL_CHANNEL_FRONT_LEFT
#define MAL_CHANNEL_RIGHT                               MAL_CHANNEL_FRONT_RIGHT
#define MAL_CHANNEL_POSITION_COUNT                      MAL_CHANNEL_AUX_31 + 1


typedef int mal_result;
#define MAL_SUCCESS                                      0

/* General errors. */
#define MAL_ERROR                                       -1      /* A generic error. */
#define MAL_INVALID_ARGS                                -2
#define MAL_INVALID_OPERATION                           -3
#define MAL_OUT_OF_MEMORY                               -4
#define MAL_ACCESS_DENIED                               -5
#define MAL_TOO_LARGE                                   -6
#define MAL_TIMEOUT                                     -7

/* General mini_al-specific errors. */
#define MAL_FORMAT_NOT_SUPPORTED                        -100
#define MAL_DEVICE_TYPE_NOT_SUPPORTED                   -101
#define MAL_SHARE_MODE_NOT_SUPPORTED                    -102
#define MAL_NO_BACKEND                                  -103
#define MAL_NO_DEVICE                                   -104
#define MAL_API_NOT_FOUND                               -105
#define MAL_INVALID_DEVICE_CONFIG                       -106

/* State errors. */
#define MAL_DEVICE_BUSY                                 -200
#define MAL_DEVICE_NOT_INITIALIZED                      -201
#define MAL_DEVICE_NOT_STARTED                          -202
#define MAL_DEVICE_UNAVAILABLE                          -203

/* Operation errors. */
#define MAL_FAILED_TO_MAP_DEVICE_BUFFER                 -300
#define MAL_FAILED_TO_UNMAP_DEVICE_BUFFER               -301
#define MAL_FAILED_TO_INIT_BACKEND                      -302
#define MAL_FAILED_TO_READ_DATA_FROM_CLIENT             -303
#define MAL_FAILED_TO_READ_DATA_FROM_DEVICE             -304
#define MAL_FAILED_TO_SEND_DATA_TO_CLIENT               -305
#define MAL_FAILED_TO_SEND_DATA_TO_DEVICE               -306
#define MAL_FAILED_TO_OPEN_BACKEND_DEVICE               -307
#define MAL_FAILED_TO_START_BACKEND_DEVICE              -308
#define MAL_FAILED_TO_STOP_BACKEND_DEVICE               -309
#define MAL_FAILED_TO_CONFIGURE_BACKEND_DEVICE          -310
#define MAL_FAILED_TO_CREATE_MUTEX                      -311
#define MAL_FAILED_TO_CREATE_EVENT                      -312
#define MAL_FAILED_TO_CREATE_THREAD                     -313


// Standard sample rates.
#define MAL_SAMPLE_RATE_8000                            8000
#define MAL_SAMPLE_RATE_11025                           11025
#define MAL_SAMPLE_RATE_16000                           16000
#define MAL_SAMPLE_RATE_22050                           22050
#define MAL_SAMPLE_RATE_24000                           24000
#define MAL_SAMPLE_RATE_32000                           32000
#define MAL_SAMPLE_RATE_44100                           44100
#define MAL_SAMPLE_RATE_48000                           48000
#define MAL_SAMPLE_RATE_88200                           88200
#define MAL_SAMPLE_RATE_96000                           96000
#define MAL_SAMPLE_RATE_176400                          176400
#define MAL_SAMPLE_RATE_192000                          192000
#define MAL_SAMPLE_RATE_352800                          352800
#define MAL_SAMPLE_RATE_384000                          384000

#define MAL_MIN_PCM_SAMPLE_SIZE_IN_BYTES                1   // For simplicity, mini_al does not support PCM samples that are not byte aligned.
#define MAL_MAX_PCM_SAMPLE_SIZE_IN_BYTES                8
#define MAL_MIN_CHANNELS                                1
#define MAL_MAX_CHANNELS                                32
#define MAL_MIN_SAMPLE_RATE                             MAL_SAMPLE_RATE_8000
#define MAL_MAX_SAMPLE_RATE                             MAL_SAMPLE_RATE_384000
#define MAL_SRC_SINC_MIN_WINDOW_WIDTH                   2
#define MAL_SRC_SINC_MAX_WINDOW_WIDTH                   32
#define MAL_SRC_SINC_DEFAULT_WINDOW_WIDTH               32
#define MAL_SRC_SINC_LOOKUP_TABLE_RESOLUTION            8
#define MAL_SRC_INPUT_BUFFER_SIZE_IN_SAMPLES            256

typedef enum
{
    mal_stream_format_pcm = 0,
} mal_stream_format;

typedef enum
{
    mal_stream_layout_interleaved = 0,
    mal_stream_layout_deinterleaved
} mal_stream_layout;

typedef enum
{
    mal_dither_mode_none = 0,
    mal_dither_mode_rectangle,
    mal_dither_mode_triangle
} mal_dither_mode;

typedef enum
{
    // I like to keep these explicitly defined because they're used as a key into a lookup table. When items are
    // added to this, make sure there are no gaps and that they're added to the lookup table in mal_get_bytes_per_sample().
    mal_format_unknown = 0,     // Mainly used for indicating an error, but also used as the default for the output format for decoders.
    mal_format_u8      = 1,
    mal_format_s16     = 2,     // Seems to be the most widely supported format.
    mal_format_s24     = 3,     // Tightly packed. 3 bytes per sample.
    mal_format_s32     = 4,
    mal_format_f32     = 5,
    mal_format_count
} mal_format;

typedef enum
{
    mal_channel_mix_mode_rectangular = 0,   // Simple averaging based on the plane(s) the channel is sitting on.
    mal_channel_mix_mode_simple,            // Drop excess channels; zeroed out extra channels.
    mal_channel_mix_mode_custom_weights,    // Use custom weights specified in mal_channel_router_config.
    mal_channel_mix_mode_planar_blend = mal_channel_mix_mode_rectangular,
    mal_channel_mix_mode_default = mal_channel_mix_mode_planar_blend
} mal_channel_mix_mode;

typedef enum
{
    mal_standard_channel_map_microsoft,
    mal_standard_channel_map_alsa,
    mal_standard_channel_map_rfc3551,   // Based off AIFF.
    mal_standard_channel_map_flac,
    mal_standard_channel_map_vorbis,
    mal_standard_channel_map_sound4,    // FreeBSD's sound(4).
    mal_standard_channel_map_sndio,     // www.sndio.org/tips.html
    mal_standard_channel_map_webaudio = mal_standard_channel_map_flac, // https://webaudio.github.io/web-audio-api/#ChannelOrdering. Only 1, 2, 4 and 6 channels are defined, but can fill in the gaps with logical assumptions.
    mal_standard_channel_map_default = mal_standard_channel_map_microsoft
} mal_standard_channel_map;

typedef enum
{
    mal_performance_profile_low_latency = 0,
    mal_performance_profile_conservative
} mal_performance_profile;


typedef struct mal_format_converter mal_format_converter;
typedef mal_uint32 (* mal_format_converter_read_proc)              (mal_format_converter* pConverter, mal_uint32 frameCount, void* pFramesOut, void* pUserData);
typedef mal_uint32 (* mal_format_converter_read_deinterleaved_proc)(mal_format_converter* pConverter, mal_uint32 frameCount, void** ppSamplesOut, void* pUserData);

typedef struct
{
    mal_format formatIn;
    mal_format formatOut;
    mal_uint32 channels;
    mal_stream_format streamFormatIn;
    mal_stream_format streamFormatOut;
    mal_dither_mode ditherMode;
    mal_bool32 noSSE2   : 1;
    mal_bool32 noAVX2   : 1;
    mal_bool32 noAVX512 : 1;
    mal_bool32 noNEON   : 1;
    mal_format_converter_read_proc onRead;
    mal_format_converter_read_deinterleaved_proc onReadDeinterleaved;
    void* pUserData;
} mal_format_converter_config;

struct mal_format_converter
{
    mal_format_converter_config config;
    mal_bool32 useSSE2   : 1;
    mal_bool32 useAVX2   : 1;
    mal_bool32 useAVX512 : 1;
    mal_bool32 useNEON   : 1;
    void (* onConvertPCM)(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode);
    void (* onInterleavePCM)(void* dst, const void** src, mal_uint64 frameCount, mal_uint32 channels);
    void (* onDeinterleavePCM)(void** dst, const void* src, mal_uint64 frameCount, mal_uint32 channels);
};



typedef struct mal_channel_router mal_channel_router;
typedef mal_uint32 (* mal_channel_router_read_deinterleaved_proc)(mal_channel_router* pRouter, mal_uint32 frameCount, void** ppSamplesOut, void* pUserData);

typedef struct
{
    mal_uint32 channelsIn;
    mal_uint32 channelsOut;
    mal_channel channelMapIn[MAL_MAX_CHANNELS];
    mal_channel channelMapOut[MAL_MAX_CHANNELS];
    mal_channel_mix_mode mixingMode;
    float weights[MAL_MAX_CHANNELS][MAL_MAX_CHANNELS];  // [in][out]. Only used when mixingMode is set to mal_channel_mix_mode_custom_weights.
    mal_bool32 noSSE2   : 1;
    mal_bool32 noAVX2   : 1;
    mal_bool32 noAVX512 : 1;
    mal_bool32 noNEON   : 1;
    mal_channel_router_read_deinterleaved_proc onReadDeinterleaved;
    void* pUserData;
} mal_channel_router_config;

struct mal_channel_router
{
    mal_channel_router_config config;
    mal_bool32 isPassthrough   : 1;
    mal_bool32 isSimpleShuffle : 1;
    mal_bool32 useSSE2         : 1;
    mal_bool32 useAVX2         : 1;
    mal_bool32 useAVX512       : 1;
    mal_bool32 useNEON         : 1;
    mal_uint8 shuffleTable[MAL_MAX_CHANNELS];
};



typedef struct mal_src mal_src;
typedef mal_uint32 (* mal_src_read_deinterleaved_proc)(mal_src* pSRC, mal_uint32 frameCount, void** ppSamplesOut, void* pUserData); // Returns the number of frames that were read.

typedef enum
{
    mal_src_algorithm_linear = 0,
    mal_src_algorithm_sinc,
    mal_src_algorithm_none,
    mal_src_algorithm_default = mal_src_algorithm_linear
} mal_src_algorithm;

typedef enum
{
    mal_src_sinc_window_function_hann = 0,
    mal_src_sinc_window_function_rectangular,
    mal_src_sinc_window_function_default = mal_src_sinc_window_function_hann
} mal_src_sinc_window_function;

typedef struct
{
    mal_src_sinc_window_function windowFunction;
    mal_uint32 windowWidth;
} mal_src_config_sinc;

typedef struct
{
    mal_uint32 sampleRateIn;
    mal_uint32 sampleRateOut;
    mal_uint32 channels;
    mal_src_algorithm algorithm;
    mal_bool32 neverConsumeEndOfInput : 1;
    mal_bool32 noSSE2   : 1;
    mal_bool32 noAVX2   : 1;
    mal_bool32 noAVX512 : 1;
    mal_bool32 noNEON   : 1;
    mal_src_read_deinterleaved_proc onReadDeinterleaved;
    void* pUserData;
    union
    {
        mal_src_config_sinc sinc;
    };
} mal_src_config;

MAL_ALIGNED_STRUCT(MAL_SIMD_ALIGNMENT) mal_src
{
    union
    {
        struct
        {
            MAL_ALIGN(MAL_SIMD_ALIGNMENT) float input[MAL_MAX_CHANNELS][MAL_SRC_INPUT_BUFFER_SIZE_IN_SAMPLES];
            float timeIn;
            mal_uint32 leftoverFrames;
        } linear;

        struct
        {
            MAL_ALIGN(MAL_SIMD_ALIGNMENT) float input[MAL_MAX_CHANNELS][MAL_SRC_SINC_MAX_WINDOW_WIDTH*2 + MAL_SRC_INPUT_BUFFER_SIZE_IN_SAMPLES];
            float timeIn;
            mal_uint32 inputFrameCount;     // The number of frames sitting in the input buffer, not including the first half of the window.
            mal_uint32 windowPosInSamples;  // An offset of <input>.
            float table[MAL_SRC_SINC_MAX_WINDOW_WIDTH*1 * MAL_SRC_SINC_LOOKUP_TABLE_RESOLUTION]; // Precomputed lookup table. The +1 is used to avoid the need for an overflow check.
        } sinc;
    };

    mal_src_config config;
    mal_bool32 isEndOfInputLoaded : 1;
    mal_bool32 useSSE2   : 1;
    mal_bool32 useAVX2   : 1;
    mal_bool32 useAVX512 : 1;
    mal_bool32 useNEON   : 1;
};

typedef struct mal_pcm_converter mal_pcm_converter;
typedef mal_uint32 (* mal_pcm_converter_read_proc)(mal_pcm_converter* pDSP, void* pSamplesOut, mal_uint32 frameCount, void* pUserData);

typedef struct
{
    mal_format formatIn;
    mal_uint32 channelsIn;
    mal_uint32 sampleRateIn;
    mal_channel channelMapIn[MAL_MAX_CHANNELS];
    mal_format formatOut;
    mal_uint32 channelsOut;
    mal_uint32 sampleRateOut;
    mal_channel channelMapOut[MAL_MAX_CHANNELS];
    mal_channel_mix_mode channelMixMode;
    mal_dither_mode ditherMode;
    mal_src_algorithm srcAlgorithm;
    mal_bool32 allowDynamicSampleRate;
    mal_bool32 neverConsumeEndOfInput : 1;  // <-- For SRC.
    mal_bool32 noSSE2   : 1;
    mal_bool32 noAVX2   : 1;
    mal_bool32 noAVX512 : 1;
    mal_bool32 noNEON   : 1;
    mal_pcm_converter_read_proc onRead;
    void* pUserData;
    union
    {
        mal_src_config_sinc sinc;
    };
} mal_pcm_converter_config;

MAL_ALIGNED_STRUCT(MAL_SIMD_ALIGNMENT) mal_pcm_converter
{
    mal_pcm_converter_read_proc onRead;
    void* pUserData;
    mal_format_converter formatConverterIn;             // For converting data to f32 in preparation for further processing.
    mal_format_converter formatConverterOut;            // For converting data to the requested output format. Used as the final step in the processing pipeline.
    mal_channel_router channelRouter;                   // For channel conversion.
    mal_src src;                                        // For sample rate conversion.
    mal_bool32 isDynamicSampleRateAllowed     : 1;      // mal_pcm_converter_set_input_sample_rate() and mal_pcm_converter_set_output_sample_rate() will fail if this is set to false.
    mal_bool32 isPreFormatConversionRequired  : 1;
    mal_bool32 isPostFormatConversionRequired : 1;
    mal_bool32 isChannelRoutingRequired       : 1;
    mal_bool32 isSRCRequired                  : 1;
    mal_bool32 isChannelRoutingAtStart        : 1;
    mal_bool32 isPassthrough                  : 1;      // <-- Will be set to true when the DSP pipeline is an optimized passthrough.
};


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// DATA CONVERSION
// ===============
//
// This section contains the APIs for data conversion. You will find everything here for channel mapping, sample format conversion, resampling, etc.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Channel Maps
// ============
//
// Below is the channel map used by mal_standard_channel_map_default:
//
// |---------------|------------------------------|
// | Channel Count | Mapping                      |
// |---------------|------------------------------|
// | 1 (Mono)      | 0: MAL_CHANNEL_MONO          |
// |---------------|------------------------------|
// | 2 (Stereo)    | 0: MAL_CHANNEL_FRONT_LEFT    |
// |               | 1: MAL_CHANNEL_FRONT_RIGHT   |
// |---------------|------------------------------|
// | 3             | 0: MAL_CHANNEL_FRONT_LEFT    |
// |               | 1: MAL_CHANNEL_FRONT_RIGHT   |
// |               | 2: MAL_CHANNEL_FRONT_CENTER  |
// |---------------|------------------------------|
// | 4 (Surround)  | 0: MAL_CHANNEL_FRONT_LEFT    |
// |               | 1: MAL_CHANNEL_FRONT_RIGHT   |
// |               | 2: MAL_CHANNEL_FRONT_CENTER  |
// |               | 3: MAL_CHANNEL_BACK_CENTER   |
// |---------------|------------------------------|
// | 5             | 0: MAL_CHANNEL_FRONT_LEFT    |
// |               | 1: MAL_CHANNEL_FRONT_RIGHT   |
// |               | 2: MAL_CHANNEL_FRONT_CENTER  |
// |               | 3: MAL_CHANNEL_BACK_LEFT     |
// |               | 4: MAL_CHANNEL_BACK_RIGHT    |
// |---------------|------------------------------|
// | 6 (5.1)       | 0: MAL_CHANNEL_FRONT_LEFT    |
// |               | 1: MAL_CHANNEL_FRONT_RIGHT   |
// |               | 2: MAL_CHANNEL_FRONT_CENTER  |
// |               | 3: MAL_CHANNEL_LFE           |
// |               | 4: MAL_CHANNEL_SIDE_LEFT     |
// |               | 5: MAL_CHANNEL_SIDE_RIGHT    |
// |---------------|------------------------------|
// | 7             | 0: MAL_CHANNEL_FRONT_LEFT    |
// |               | 1: MAL_CHANNEL_FRONT_RIGHT   |
// |               | 2: MAL_CHANNEL_FRONT_CENTER  |
// |               | 3: MAL_CHANNEL_LFE           |
// |               | 4: MAL_CHANNEL_BACK_CENTER   |
// |               | 4: MAL_CHANNEL_SIDE_LEFT     |
// |               | 5: MAL_CHANNEL_SIDE_RIGHT    |
// |---------------|------------------------------|
// | 8 (7.1)       | 0: MAL_CHANNEL_FRONT_LEFT    |
// |               | 1: MAL_CHANNEL_FRONT_RIGHT   |
// |               | 2: MAL_CHANNEL_FRONT_CENTER  |
// |               | 3: MAL_CHANNEL_LFE           |
// |               | 4: MAL_CHANNEL_BACK_LEFT     |
// |               | 5: MAL_CHANNEL_BACK_RIGHT    |
// |               | 6: MAL_CHANNEL_SIDE_LEFT     |
// |               | 7: MAL_CHANNEL_SIDE_RIGHT    |
// |---------------|------------------------------|
// | Other         | All channels set to 0. This  |
// |               | is equivalent to the same    |
// |               | mapping as the device.       |
// |---------------|------------------------------|
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Helper for retrieving a standard channel map.
void mal_get_standard_channel_map(mal_standard_channel_map standardChannelMap, mal_uint32 channels, mal_channel channelMap[MAL_MAX_CHANNELS]);

// Copies a channel map.
void mal_channel_map_copy(mal_channel* pOut, const mal_channel* pIn, mal_uint32 channels);


// Determines whether or not a channel map is valid.
//
// A blank channel map is valid (all channels set to MAL_CHANNEL_NONE). The way a blank channel map is handled is context specific, but
// is usually treated as a passthrough.
//
// Invalid channel maps:
//   - A channel map with no channels
//   - A channel map with more than one channel and a mono channel
mal_bool32 mal_channel_map_valid(mal_uint32 channels, const mal_channel channelMap[MAL_MAX_CHANNELS]);

// Helper for comparing two channel maps for equality.
//
// This assumes the channel count is the same between the two.
mal_bool32 mal_channel_map_equal(mal_uint32 channels, const mal_channel channelMapA[MAL_MAX_CHANNELS], const mal_channel channelMapB[MAL_MAX_CHANNELS]);

// Helper for determining if a channel map is blank (all channels set to MAL_CHANNEL_NONE).
mal_bool32 mal_channel_map_blank(mal_uint32 channels, const mal_channel channelMap[MAL_MAX_CHANNELS]);

// Helper for determining whether or not a channel is present in the given channel map.
mal_bool32 mal_channel_map_contains_channel_position(mal_uint32 channels, const mal_channel channelMap[MAL_MAX_CHANNELS], mal_channel channelPosition);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Format Conversion
// =================
// The format converter serves two purposes:
//   1) Conversion between data formats (u8 to f32, etc.)
//   2) Interleaving and deinterleaving
//
// When initializing a converter, you specify the input and output formats (u8, s16, etc.) and read callbacks. There are two read callbacks - one for
// interleaved input data (onRead) and another for deinterleaved input data (onReadDeinterleaved). You implement whichever is most convenient for you. You
// can implement both, but it's not recommended as it just introduces unnecessary complexity.
//
// To read data as interleaved samples, use mal_format_converter_read(). Otherwise use mal_format_converter_read_deinterleaved().
//
// Dithering
// ---------
// The format converter also supports dithering. Dithering can be set using ditherMode variable in the config, like so.
//
//   pConfig->ditherMode = mal_dither_mode_rectangle;
//
// The different dithering modes include the following, in order of efficiency:
//   - None:      mal_dither_mode_none
//   - Rectangle: mal_dither_mode_rectangle
//   - Triangle:  mal_dither_mode_triangle
//
// Note that even if the dither mode is set to something other than mal_dither_mode_none, it will be ignored for conversions where dithering is not needed.
// Dithering is available for the following conversions:
//   - s16 -> u8
//   - s24 -> u8
//   - s32 -> u8
//   - f32 -> u8
//   - s24 -> s16
//   - s32 -> s16
//   - f32 -> s16
//
// Note that it is not an error to pass something other than mal_dither_mode_none for conversions where dither is not used. It will just be ignored.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Initializes a format converter.
mal_result mal_format_converter_init(const mal_format_converter_config* pConfig, mal_format_converter* pConverter);

// Reads data from the format converter as interleaved channels.
mal_uint64 mal_format_converter_read(mal_format_converter* pConverter, mal_uint64 frameCount, void* pFramesOut, void* pUserData);

// Reads data from the format converter as deinterleaved channels.
mal_uint64 mal_format_converter_read_deinterleaved(mal_format_converter* pConverter, mal_uint64 frameCount, void** ppSamplesOut, void* pUserData);


// Helper for initializing a format converter config.
mal_format_converter_config mal_format_converter_config_init_new(void);
mal_format_converter_config mal_format_converter_config_init(mal_format formatIn, mal_format formatOut, mal_uint32 channels, mal_format_converter_read_proc onRead, void* pUserData);
mal_format_converter_config mal_format_converter_config_init_deinterleaved(mal_format formatIn, mal_format formatOut, mal_uint32 channels, mal_format_converter_read_deinterleaved_proc onReadDeinterleaved, void* pUserData);



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Channel Routing
// ===============
// There are two main things you can do with the channel router:
//   1) Rearrange channels
//   2) Convert from one channel count to another
//
// Channel Rearrangement
// ---------------------
// A simple example of channel rearrangement may be swapping the left and right channels in a stereo stream. To do this you just pass in the same channel
// count for both the input and output with channel maps that contain the same channels (in a different order).
//
// Channel Conversion
// ------------------
// The channel router can also convert from one channel count to another, such as converting a 5.1 stream to stero. When changing the channel count, the
// router will first perform a 1:1 mapping of channel positions that are present in both the input and output channel maps. The second thing it will do
// is distribute the input mono channel (if any) across all output channels, excluding any None and LFE channels. If there is an output mono channel, all
// input channels will be averaged, excluding any None and LFE channels.
//
// The last case to consider is when a channel position in the input channel map is not present in the output channel map, and vice versa. In this case the
// channel router will perform a blend of other related channels to produce an audible channel. There are several blending modes.
//   1) Simple
//      Unmatched channels are silenced.
//   2) Planar Blending
//      Channels are blended based on a set of planes that each speaker emits audio from.
//
// Rectangular / Planar Blending
// -----------------------------
// In this mode, channel positions are associated with a set of planes where the channel conceptually emits audio from. An example is the front/left speaker.
// This speaker is positioned to the front of the listener, so you can think of it as emitting audio from the front plane. It is also positioned to the left
// of the listener so you can think of it as also emitting audio from the left plane. Now consider the (unrealistic) situation where the input channel map
// contains only the front/left channel position, but the output channel map contains both the front/left and front/center channel. When deciding on the audio
// data to send to the front/center speaker (which has no 1:1 mapping with an input channel) we need to use some logic based on our available input channel
// positions.
//
// As mentioned earlier, our front/left speaker is, conceptually speaking, emitting audio from the front _and_ the left planes. Similarly, the front/center
// speaker is emitting audio from _only_ the front plane. What these two channels have in common is that they are both emitting audio from the front plane.
// Thus, it makes sense that the front/center speaker should receive some contribution from the front/left channel. How much contribution depends on their
// planar relationship (thus the name of this blending technique).
//
// Because the front/left channel is emitting audio from two planes (front and left), you can think of it as though it's willing to dedicate 50% of it's total
// volume to each of it's planes (a channel position emitting from 1 plane would be willing to given 100% of it's total volume to that plane, and a channel
// position emitting from 3 planes would be willing to given 33% of it's total volume to each plane). Similarly, the front/center speaker is emitting audio
// from only one plane so you can think of it as though it's willing to _take_ 100% of it's volume from front plane emissions. Now, since the front/left
// channel is willing to _give_ 50% of it's total volume to the front plane, and the front/center speaker is willing to _take_ 100% of it's total volume
// from the front, you can imagine that 50% of the front/left speaker will be given to the front/center speaker.
//
// Usage
// -----
// To use the channel router you need to specify three things:
//   1) The input channel count and channel map
//   2) The output channel count and channel map
//   3) The mixing mode to use in the case where a 1:1 mapping is unavailable
//
// Note that input and output data is always deinterleaved 32-bit floating point.
//
// Initialize the channel router with mal_channel_router_init(). You will need to pass in a config object which specifies the input and output configuration,
// mixing mode and a callback for sending data to the router. This callback will be called when input data needs to be sent to the router for processing. Note
// that the mixing mode is only used when a 1:1 mapping is unavailable. This includes the custom weights mode.
//
// Read data from the channel router with mal_channel_router_read_deinterleaved(). Output data is always 32-bit floating point.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Initializes a channel router where it is assumed that the input data is non-interleaved.
mal_result mal_channel_router_init(const mal_channel_router_config* pConfig, mal_channel_router* pRouter);

// Reads data from the channel router as deinterleaved channels.
mal_uint64 mal_channel_router_read_deinterleaved(mal_channel_router* pRouter, mal_uint64 frameCount, void** ppSamplesOut, void* pUserData);

// Helper for initializing a channel router config.
mal_channel_router_config mal_channel_router_config_init(mal_uint32 channelsIn, const mal_channel channelMapIn[MAL_MAX_CHANNELS], mal_uint32 channelsOut, const mal_channel channelMapOut[MAL_MAX_CHANNELS], mal_channel_mix_mode mixingMode, mal_channel_router_read_deinterleaved_proc onRead, void* pUserData);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Sample Rate Conversion
// ======================
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Initializes a sample rate conversion object.
mal_result mal_src_init(const mal_src_config* pConfig, mal_src* pSRC);

// Dynamically adjusts the sample rate.
//
// This is useful for dynamically adjust pitch. Keep in mind, however, that this will speed up or slow down the sound. If this
// is not acceptable you will need to use your own algorithm.
mal_result mal_src_set_sample_rate(mal_src* pSRC, mal_uint32 sampleRateIn, mal_uint32 sampleRateOut);

// Reads a number of frames.
//
// Returns the number of frames actually read.
mal_uint64 mal_src_read_deinterleaved(mal_src* pSRC, mal_uint64 frameCount, void** ppSamplesOut, void* pUserData);


// Helper for creating a sample rate conversion config.
mal_src_config mal_src_config_init_new(void);
mal_src_config mal_src_config_init(mal_uint32 sampleRateIn, mal_uint32 sampleRateOut, mal_uint32 channels, mal_src_read_deinterleaved_proc onReadDeinterleaved, void* pUserData);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Conversion
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Initializes a DSP object.
mal_result mal_pcm_converter_init(const mal_pcm_converter_config* pConfig, mal_pcm_converter* pDSP);

// Dynamically adjusts the input sample rate.
//
// This will fail is the DSP was not initialized with allowDynamicSampleRate.
//
// DEPRECATED. Use mal_pcm_converter_set_sample_rate() instead.
mal_result mal_pcm_converter_set_input_sample_rate(mal_pcm_converter* pDSP, mal_uint32 sampleRateOut);

// Dynamically adjusts the output sample rate.
//
// This is useful for dynamically adjust pitch. Keep in mind, however, that this will speed up or slow down the sound. If this
// is not acceptable you will need to use your own algorithm.
//
// This will fail is the DSP was not initialized with allowDynamicSampleRate.
//
// DEPRECATED. Use mal_pcm_converter_set_sample_rate() instead.
mal_result mal_pcm_converter_set_output_sample_rate(mal_pcm_converter* pDSP, mal_uint32 sampleRateOut);

// Dynamically adjusts the output sample rate.
//
// This is useful for dynamically adjust pitch. Keep in mind, however, that this will speed up or slow down the sound. If this
// is not acceptable you will need to use your own algorithm.
//
// This will fail is the DSP was not initialized with allowDynamicSampleRate.
mal_result mal_pcm_converter_set_sample_rate(mal_pcm_converter* pDSP, mal_uint32 sampleRateIn, mal_uint32 sampleRateOut);


// Reads a number of frames and runs them through the DSP processor.
mal_uint64 mal_pcm_converter_read(mal_pcm_converter* pDSP, void* pFramesOut, mal_uint64 frameCount);

// Helper for initializing a mal_pcm_converter_config object.
mal_pcm_converter_config mal_pcm_converter_config_init_new(void);
mal_pcm_converter_config mal_pcm_converter_config_init(mal_format formatIn, mal_uint32 channelsIn, mal_uint32 sampleRateIn, mal_format formatOut, mal_uint32 channelsOut, mal_uint32 sampleRateOut, mal_pcm_converter_read_proc onRead, void* pUserData);
mal_pcm_converter_config mal_pcm_converter_config_init_ex(mal_format formatIn, mal_uint32 channelsIn, mal_uint32 sampleRateIn, mal_channel channelMapIn[MAL_MAX_CHANNELS], mal_format formatOut, mal_uint32 channelsOut, mal_uint32 sampleRateOut,  mal_channel channelMapOut[MAL_MAX_CHANNELS], mal_pcm_converter_read_proc onRead, void* pUserData);


// High-level helper for doing a full format conversion in one go. Returns the number of output frames. Call this with pOut set to NULL to
// determine the required size of the output buffer.
//
// A return value of 0 indicates an error.
//
// This function is useful for one-off bulk conversions, but if you're streaming data you should use the DSP APIs instead.
mal_uint64 mal_convert_frames(void* pOut, mal_format formatOut, mal_uint32 channelsOut, mal_uint32 sampleRateOut, const void* pIn, mal_format formatIn, mal_uint32 channelsIn, mal_uint32 sampleRateIn, mal_uint64 frameCount);
mal_uint64 mal_convert_frames_ex(void* pOut, mal_format formatOut, mal_uint32 channelsOut, mal_uint32 sampleRateOut, mal_channel channelMapOut[MAL_MAX_CHANNELS], const void* pIn, mal_format formatIn, mal_uint32 channelsIn, mal_uint32 sampleRateIn, mal_channel channelMapIn[MAL_MAX_CHANNELS], mal_uint64 frameCount);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Ring Buffer
// ===========
//
// Features
// --------
// - Lock free (assuming single producer, single consumer)
// - Support for interleaved and deinterleaved streams
// - Allows the caller to allocate their own block of memory
//
// Usage
// -----
// - Call mal_rb_init() to initialize a simple buffer, with an optional pre-allocated buffer. If you pass in NULL
//   for the pre-allocated buffer, it will be allocated for you and free()'d in mal_rb_uninit(). If you pass in
//   your own pre-allocated buffer, free()-ing is left to you.
//
// - Call mal_rb_init_ex() if you need a deinterleaved buffer. The data for each sub-buffer is offset from each
//   other based on the stride. Use mal_rb_get_subbuffer_stride(), mal_rb_get_subbuffer_offset() and
//   mal_rb_get_subbuffer_ptr() to manage your sub-buffers.
//
// - Use mal_rb_acquire_read() and mal_rb_acquire_write() to retrieve a pointer to a section of the ring buffer.
//   You specify the number of bytes you need, and on output it will set to what was actually acquired. If the
//   read or write pointer is positioned such that the number of bytes requested will require a loop, it will be
//   clamped to the end of the buffer. Therefore, the number of bytes you're given may be less than the number
//   you requested.
//
// - After calling mal_rb_acquire_read/write(), you do your work on the buffer and then "commit" it with
//   mal_rb_commit_read/write(). This is where the read/write pointers are updated. When you commit you need to
//   pass in the buffer that was returned by the earlier call to mal_rb_acquire_read/write() and is only used
//   for validation. The number of bytes passed to mal_rb_commit_read/write() is what's used to increment the
//   pointers.
//
// - If you want to correct for drift between the write pointer and the read pointer you can use a combination
//   of mal_rb_pointer_distance(), mal_rb_seek_read() and mal_rb_seek_write(). Note that you can only move the
//   pointers forward, and you should only move the read pointer forward via the consumer thread, and the write
//   pointer forward by the producer thread. If there is too much space between the pointers, move the read
//   pointer forward. If there is too little space between the pointers, move the write pointer forward.
//
//
// Notes
// -----
// - Thread safety depends on a single producer, single consumer model. Only one thread is allowed to write, and
//   only one thread is allowed to read. The producer is the only one allowed to move the write pointer, and the
//   consumer is the only one allowed to move the read pointer.
// - Operates on bytes. Use mal_pcm_rb to operate in terms of PCM frames.
// - Maximum buffer size in bytes is 0x7FFFFFFF-(MAL_SIMD_ALIGNMENT-1) because of reasons.
//
//
// PCM Ring Buffer
// ===============
// This is the same as the regular ring buffer, except that it works on PCM frames instead of bytes.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
typedef struct
{
    void* pBuffer;
    mal_uint32 subbufferSizeInBytes;
    mal_uint32 subbufferCount;
    mal_uint32 subbufferStrideInBytes;
    volatile mal_uint32 encodedReadOffset;  /* Most significant bit is the loop flag. Lower 31 bits contains the actual offset in bytes. */
    volatile mal_uint32 encodedWriteOffset; /* Most significant bit is the loop flag. Lower 31 bits contains the actual offset in bytes. */
    mal_bool32 ownsBuffer          : 1;     /* Used to know whether or not mini_al is responsible for free()-ing the buffer. */
    mal_bool32 clearOnWriteAcquire : 1;     /* When set, clears the acquired write buffer before returning from mal_rb_acquire_write(). */
} mal_rb;

mal_result mal_rb_init_ex(size_t subbufferSizeInBytes, size_t subbufferCount, size_t subbufferStrideInBytes, void* pOptionalPreallocatedBuffer, mal_rb* pRB);
mal_result mal_rb_init(size_t bufferSizeInBytes, void* pOptionalPreallocatedBuffer, mal_rb* pRB);
void mal_rb_uninit(mal_rb* pRB);
mal_result mal_rb_acquire_read(mal_rb* pRB, size_t* pSizeInBytes, void** ppBufferOut);
mal_result mal_rb_commit_read(mal_rb* pRB, size_t sizeInBytes, void* pBufferOut);
mal_result mal_rb_acquire_write(mal_rb* pRB, size_t* pSizeInBytes, void** ppBufferOut);
mal_result mal_rb_commit_write(mal_rb* pRB, size_t sizeInBytes, void* pBufferOut);
mal_result mal_rb_seek_read(mal_rb* pRB, size_t offsetInBytes);
mal_result mal_rb_seek_write(mal_rb* pRB, size_t offsetInBytes);
mal_int32 mal_rb_pointer_distance(mal_rb* pRB);    /* Returns the distance between the write pointer and the read pointer. Should never be negative for a correct program. */
size_t mal_rb_get_subbuffer_size(mal_rb* pRB);
size_t mal_rb_get_subbuffer_stride(mal_rb* pRB);
size_t mal_rb_get_subbuffer_offset(mal_rb* pRB, size_t subbufferIndex);
void* mal_rb_get_subbuffer_ptr(mal_rb* pRB, size_t subbufferIndex, void* pBuffer);


typedef struct
{
    mal_rb rb;
    mal_format format;
    mal_uint32 channels;
} mal_pcm_rb;

mal_result mal_pcm_rb_init_ex(mal_format format, mal_uint32 channels, mal_uint32 subbufferSizeInFrames, mal_uint32 subbufferCount, mal_uint32 subbufferStrideInFrames, void* pOptionalPreallocatedBuffer, mal_pcm_rb* pRB);
mal_result mal_pcm_rb_init(mal_format format, mal_uint32 channels, mal_uint32 bufferSizeInFrames, void* pOptionalPreallocatedBuffer, mal_pcm_rb* pRB);
void mal_pcm_rb_uninit(mal_pcm_rb* pRB);
mal_result mal_pcm_rb_acquire_read(mal_pcm_rb* pRB, mal_uint32* pSizeInFrames, void** ppBufferOut);
mal_result mal_pcm_rb_commit_read(mal_pcm_rb* pRB, mal_uint32 sizeInFrames, void* pBufferOut);
mal_result mal_pcm_rb_acquire_write(mal_pcm_rb* pRB, mal_uint32* pSizeInFrames, void** ppBufferOut);
mal_result mal_pcm_rb_commit_write(mal_pcm_rb* pRB, mal_uint32 sizeInFrames, void* pBufferOut);
mal_result mal_pcm_rb_seek_read(mal_pcm_rb* pRB, mal_uint32 offsetInFrames);
mal_result mal_pcm_rb_seek_write(mal_pcm_rb* pRB, mal_uint32 offsetInFrames);
mal_int32 mal_pcm_rb_pointer_disance(mal_pcm_rb* pRB); /* Return value is in frames. */
mal_uint32 mal_pcm_rb_get_subbuffer_size(mal_pcm_rb* pRB);
mal_uint32 mal_pcm_rb_get_subbuffer_stride(mal_pcm_rb* pRB);
mal_uint32 mal_pcm_rb_get_subbuffer_offset(mal_pcm_rb* pRB, mal_uint32 subbufferIndex);
void* mal_pcm_rb_get_subbuffer_ptr(mal_pcm_rb* pRB, mal_uint32 subbufferIndex, void* pBuffer);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Miscellaneous Helpers
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// malloc(). Calls MAL_MALLOC().
void* mal_malloc(size_t sz);

// realloc(). Calls MAL_REALLOC().
void* mal_realloc(void* p, size_t sz);

// free(). Calls MAL_FREE().
void mal_free(void* p);

// Performs an aligned malloc, with the assumption that the alignment is a power of 2.
void* mal_aligned_malloc(size_t sz, size_t alignment);

// Free's an aligned malloc'd buffer.
void mal_aligned_free(void* p);

// Retrieves a friendly name for a format.
const char* mal_get_format_name(mal_format format);

// Blends two frames in floating point format.
void mal_blend_f32(float* pOut, float* pInA, float* pInB, float factor, mal_uint32 channels);

// Retrieves the size of a sample in bytes for the given format.
//
// This API is efficient and is implemented using a lookup table.
//
// Thread Safety: SAFE
//   This is API is pure.
mal_uint32 mal_get_bytes_per_sample(mal_format format);
static MAL_INLINE mal_uint32 mal_get_bytes_per_frame(mal_format format, mal_uint32 channels) { return mal_get_bytes_per_sample(format) * channels; }


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Format Conversion
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void mal_pcm_u8_to_s16(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_u8_to_s24(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_u8_to_s32(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_u8_to_f32(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_s16_to_u8(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_s16_to_s24(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_s16_to_s32(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_s16_to_f32(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_s24_to_u8(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_s24_to_s16(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_s24_to_s32(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_s24_to_f32(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_s32_to_u8(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_s32_to_s16(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_s32_to_s24(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_s32_to_f32(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_f32_to_u8(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_f32_to_s16(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_f32_to_s24(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_f32_to_s32(void* pOut, const void* pIn, mal_uint64 count, mal_dither_mode ditherMode);
void mal_pcm_convert(void* pOut, mal_format formatOut, const void* pIn, mal_format formatIn, mal_uint64 sampleCount, mal_dither_mode ditherMode);

// Deinterleaves an interleaved buffer.
void mal_deinterleave_pcm_frames(mal_format format, mal_uint32 channels, mal_uint64 frameCount, const void* pInterleavedPCMFrames, void** ppDeinterleavedPCMFrames);

// Interleaves a group of deinterleaved buffers.
void mal_interleave_pcm_frames(mal_format format, mal_uint32 channels, mal_uint64 frameCount, const void** ppDeinterleavedPCMFrames, void* pInterleavedPCMFrames);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// DEVICE I/O
// ==========
//
// This section contains the APIs for device playback and capture. Here is where you'll find mal_device_init(), etc.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef MAL_NO_DEVICE_IO
// Some backends are only supported on certain platforms.
#if defined(MAL_WIN32)
    #define MAL_SUPPORT_WASAPI
    #if defined(MAL_WIN32_DESKTOP)  // DirectSound and WinMM backends are only supported on desktop's.
        #define MAL_SUPPORT_DSOUND
        #define MAL_SUPPORT_WINMM
        #define MAL_SUPPORT_JACK    // JACK is technically supported on Windows, but I don't know how many people use it in practice...
    #endif
#endif
#if defined(MAL_UNIX)
    #if defined(MAL_LINUX)
        #if !defined(MAL_ANDROID)   // ALSA is not supported on Android.
            #define MAL_SUPPORT_ALSA
        #endif
    #endif
    #if !defined(MAL_BSD) && !defined(MAL_ANDROID) && !defined(MAL_EMSCRIPTEN)
        #define MAL_SUPPORT_PULSEAUDIO
        #define MAL_SUPPORT_JACK
    #endif
    #if defined(MAL_ANDROID)
        #define MAL_SUPPORT_AAUDIO
        #define MAL_SUPPORT_OPENSL
    #endif
    #if defined(__OpenBSD__)    // <-- Change this to "#if defined(MAL_BSD)" to enable sndio on all BSD flavors.
        #define MAL_SUPPORT_SNDIO   // sndio is only supported on OpenBSD for now. May be expanded later if there's demand.
    #endif
    #if defined(__NetBSD__) || defined(__OpenBSD__)
        #define MAL_SUPPORT_AUDIO4  // Only support audio(4) on platforms with known support.
    #endif
    #if defined(__FreeBSD__) || defined(__DragonFly__)
        #define MAL_SUPPORT_OSS     // Only support OSS on specific platforms with known support.
    #endif
#endif
#if defined(MAL_APPLE)
    #define MAL_SUPPORT_COREAUDIO
#endif
#if defined(MAL_EMSCRIPTEN)
    #define MAL_SUPPORT_WEBAUDIO
#endif

// Explicitly disable the Null backend for Emscripten because it uses a background thread which is not properly supported right now.
#if !defined(MAL_EMSCRIPTEN)
#define MAL_SUPPORT_NULL
#endif


#if !defined(MAL_NO_WASAPI) && defined(MAL_SUPPORT_WASAPI)
    #define MAL_ENABLE_WASAPI
#endif
#if !defined(MAL_NO_DSOUND) && defined(MAL_SUPPORT_DSOUND)
    #define MAL_ENABLE_DSOUND
#endif
#if !defined(MAL_NO_WINMM) && defined(MAL_SUPPORT_WINMM)
    #define MAL_ENABLE_WINMM
#endif
#if !defined(MAL_NO_ALSA) && defined(MAL_SUPPORT_ALSA)
    #define MAL_ENABLE_ALSA
#endif
#if !defined(MAL_NO_PULSEAUDIO) && defined(MAL_SUPPORT_PULSEAUDIO)
    #define MAL_ENABLE_PULSEAUDIO
#endif
#if !defined(MAL_NO_JACK) && defined(MAL_SUPPORT_JACK)
    #define MAL_ENABLE_JACK
#endif
#if !defined(MAL_NO_COREAUDIO) && defined(MAL_SUPPORT_COREAUDIO)
    #define MAL_ENABLE_COREAUDIO
#endif
#if !defined(MAL_NO_SNDIO) && defined(MAL_SUPPORT_SNDIO)
    #define MAL_ENABLE_SNDIO
#endif
#if !defined(MAL_NO_AUDIO4) && defined(MAL_SUPPORT_AUDIO4)
    #define MAL_ENABLE_AUDIO4
#endif
#if !defined(MAL_NO_OSS) && defined(MAL_SUPPORT_OSS)
    #define MAL_ENABLE_OSS
#endif
#if !defined(MAL_NO_AAUDIO) && defined(MAL_SUPPORT_AAUDIO)
    #define MAL_ENABLE_AAUDIO
#endif
#if !defined(MAL_NO_OPENSL) && defined(MAL_SUPPORT_OPENSL)
    #define MAL_ENABLE_OPENSL
#endif
#if !defined(MAL_NO_WEBAUDIO) && defined(MAL_SUPPORT_WEBAUDIO)
    #define MAL_ENABLE_WEBAUDIO
#endif
#if !defined(MAL_NO_NULL) && defined(MAL_SUPPORT_NULL)
    #define MAL_ENABLE_NULL
#endif

#ifdef MAL_SUPPORT_WASAPI
// We need a IMMNotificationClient object for WASAPI. 
typedef struct
{
    void* lpVtbl;
    mal_uint32 counter;
    mal_device* pDevice;
} mal_IMMNotificationClient;
#endif

/* Backend enums must be in priority order. */
typedef enum
{
    mal_backend_wasapi,
    mal_backend_dsound,
    mal_backend_winmm,
    mal_backend_coreaudio,
    mal_backend_sndio,
    mal_backend_audio4,
    mal_backend_oss,
    mal_backend_pulseaudio,
    mal_backend_alsa,
    mal_backend_jack,
    mal_backend_aaudio,
    mal_backend_opensl,
    mal_backend_webaudio,
    mal_backend_null    /* <-- Must always be the last item. Lowest priority, and used as the terminator for backend enumeration. */
} mal_backend;

// Thread priorties should be ordered such that the default priority of the worker thread is 0.
typedef enum
{
    mal_thread_priority_idle     = -5,
    mal_thread_priority_lowest   = -4,
    mal_thread_priority_low      = -3,
    mal_thread_priority_normal   = -2,
    mal_thread_priority_high     = -1,
    mal_thread_priority_highest  =  0,
    mal_thread_priority_realtime =  1,
    mal_thread_priority_default  =  0
} mal_thread_priority;

typedef struct
{
    mal_context* pContext;

    union
    {
#ifdef MAL_WIN32
        struct
        {
            /*HANDLE*/ mal_handle hThread;
        } win32;
#endif
#ifdef MAL_POSIX
        struct
        {
            pthread_t thread;
        } posix;
#endif
        int _unused;
    };
} mal_thread;

typedef struct
{
    mal_context* pContext;

    union
    {
#ifdef MAL_WIN32
        struct
        {
            /*HANDLE*/ mal_handle hMutex;
        } win32;
#endif
#ifdef MAL_POSIX
        struct
        {
            pthread_mutex_t mutex;
        } posix;
#endif
        int _unused;
    };
} mal_mutex;

typedef struct
{
    mal_context* pContext;

    union
    {
#ifdef MAL_WIN32
        struct
        {
            /*HANDLE*/ mal_handle hEvent;
        } win32;
#endif
#ifdef MAL_POSIX
        struct
        {
            pthread_mutex_t mutex;
            pthread_cond_t condition;
            mal_uint32 value;
        } posix;
#endif
        int _unused;
    };
} mal_event;


/*
The callback for processing audio data from the device.

pOutput is a pointer to a buffer that will receive audio data that will later be played back through the speakers. This will be non-null
for a playback or full-duplex device and null for a capture device.

pInput is a pointer to a buffer containing input data from the device. This will be non-null for a capture or full-duplex device, and
null for a playback device.

frameCount is the number of PCM frames to process. If an output buffer is provided (pOutput is not null), applications should write out
to the entire output buffer.

Do _not_ call any mini_al APIs from the callback. Attempting the stop the device can result in a deadlock. The proper way to stop the
device is to call mal_device_stop() from a different thread, normally the main application thread.
*/
typedef void (* mal_device_callback_proc)(mal_device* pDevice, void* pOutput, const void* pInput, mal_uint32 frameCount);

/*
The callback for when the device has been stopped.

This will be called when the device is stopped explicitly with mal_device_stop() and also called implicitly when the device is stopped
through external forces such as being unplugged or an internal error occuring.

Do not restart the device from the callback.
*/
typedef void (* mal_stop_proc)(mal_device* pDevice);

/*
The callback for handling log messages.

It is possible for pDevice to be null in which case the log originated from the context. If it is non-null you can assume the message
came from the device.

logLevel is one of the following:
    MAL_LOG_LEVEL_VERBOSE
    MAL_LOG_LEVEL_INFO
    MAL_LOG_LEVEL_WARNING
    MAL_LOG_LEVEL_ERROR
*/
typedef void (* mal_log_proc)(mal_context* pContext, mal_device* pDevice, mal_uint32 logLevel, const char* message);

typedef enum
{
    mal_device_type_playback = 1,
    mal_device_type_capture  = 2,
    mal_device_type_duplex   = mal_device_type_playback | mal_device_type_capture,
} mal_device_type;

typedef enum
{
    mal_share_mode_shared = 0,
    mal_share_mode_exclusive,
} mal_share_mode;

typedef union
{
#ifdef MAL_SUPPORT_WASAPI
    wchar_t wasapi[64];             // WASAPI uses a wchar_t string for identification.
#endif
#ifdef MAL_SUPPORT_DSOUND
    mal_uint8 dsound[16];           // DirectSound uses a GUID for identification.
#endif
#ifdef MAL_SUPPORT_WINMM
    /*UINT_PTR*/ mal_uint32 winmm;  // When creating a device, WinMM expects a Win32 UINT_PTR for device identification. In practice it's actually just a UINT.
#endif
#ifdef MAL_SUPPORT_ALSA
    char alsa[256];                 // ALSA uses a name string for identification.
#endif
#ifdef MAL_SUPPORT_PULSEAUDIO
    char pulse[256];                // PulseAudio uses a name string for identification.
#endif
#ifdef MAL_SUPPORT_JACK
    int jack;                       // JACK always uses default devices.
#endif
#ifdef MAL_SUPPORT_COREAUDIO
    char coreaudio[256];            // Core Audio uses a string for identification.
#endif
#ifdef MAL_SUPPORT_SNDIO
    char sndio[256];                // "snd/0", etc.
#endif
#ifdef MAL_SUPPORT_AUDIO4
    char audio4[256];               // "/dev/audio", etc.
#endif
#ifdef MAL_SUPPORT_OSS
    char oss[64];                   // "dev/dsp0", etc. "dev/dsp" for the default device.
#endif
#ifdef MAL_SUPPORT_AAUDIO
    mal_int32 aaudio;               // AAudio uses a 32-bit integer for identification.
#endif
#ifdef MAL_SUPPORT_OPENSL
    mal_uint32 opensl;              // OpenSL|ES uses a 32-bit unsigned integer for identification.
#endif
#ifdef MAL_SUPPORT_WEBAUDIO
    char webaudio[32];              // Web Audio always uses default devices for now, but if this changes it'll be a GUID.
#endif
#ifdef MAL_SUPPORT_NULL
    int nullbackend;                // The null backend uses an integer for device IDs.
#endif
} mal_device_id;

typedef struct
{
    // Basic info. This is the only information guaranteed to be filled in during device enumeration.
    mal_device_id id;
    char name[256];

    // Detailed info. As much of this is filled as possible with mal_context_get_device_info(). Note that you are allowed to initialize
    // a device with settings outside of this range, but it just means the data will be converted using mini_al's data conversion
    // pipeline before sending the data to/from the device. Most programs will need to not worry about these values, but it's provided
    // here mainly for informational purposes or in the rare case that someone might find it useful.
    //
    // These will be set to 0 when returned by mal_context_enumerate_devices() or mal_context_get_devices().
    mal_uint32 formatCount;
    mal_format formats[mal_format_count];
    mal_uint32 minChannels;
    mal_uint32 maxChannels;
    mal_uint32 minSampleRate;
    mal_uint32 maxSampleRate;
} mal_device_info;

typedef struct
{
    union
    {
        mal_int64 counter;
        double counterD;
    };
} mal_timer;

typedef struct
{
    mal_device_type deviceType;
    mal_uint32 sampleRate;
    mal_uint32 bufferSizeInFrames;
    mal_uint32 bufferSizeInMilliseconds;
    mal_uint32 periods;
    mal_performance_profile performanceProfile;
    mal_device_callback_proc dataCallback;
    mal_stop_proc stopCallback;
    void* pUserData;
    struct
    {
        mal_device_id* pDeviceID;
        mal_format format;
        mal_uint32 channels;
        mal_channel channelMap[MAL_MAX_CHANNELS];
        mal_share_mode shareMode;
    } playback;
    struct
    {
        mal_device_id* pDeviceID;
        mal_format format;
        mal_uint32 channels;
        mal_channel channelMap[MAL_MAX_CHANNELS];
        mal_share_mode shareMode;
    } capture;

    struct
    {
        mal_bool32 noMMap;  // Disables MMap mode.
    } alsa;
    struct
    {
        const char* pStreamNamePlayback;
        const char* pStreamNameCapture;
    } pulse;
} mal_device_config;

typedef struct
{
    mal_log_proc logCallback;
    mal_thread_priority threadPriority;

    struct
    {
        mal_bool32 useVerboseDeviceEnumeration;
    } alsa;

    struct
    {
        const char* pApplicationName;
        const char* pServerName;
        mal_bool32 tryAutoSpawn; // Enables autospawning of the PulseAudio daemon if necessary.
    } pulse;

    struct
    {
        const char* pClientName;
        mal_bool32 tryStartServer;
    } jack;
} mal_context_config;

typedef mal_bool32 (* mal_enum_devices_callback_proc)(mal_context* pContext, mal_device_type deviceType, const mal_device_info* pInfo, void* pUserData);

struct mal_context
{
    mal_backend backend;                    // DirectSound, ALSA, etc.
    mal_context_config config;
    mal_mutex deviceEnumLock;               // Used to make mal_context_get_devices() thread safe.
    mal_mutex deviceInfoLock;               // Used to make mal_context_get_device_info() thread safe.
    mal_uint32 deviceInfoCapacity;          // Total capacity of pDeviceInfos.
    mal_uint32 playbackDeviceInfoCount;
    mal_uint32 captureDeviceInfoCount;
    mal_device_info* pDeviceInfos;          // Playback devices first, then capture.
    mal_bool32 isBackendAsynchronous : 1;   // Set when the context is initialized. Set to 1 for asynchronous backends such as Core Audio and JACK. Do not modify.

    mal_result (* onUninit        )(mal_context* pContext);
    mal_bool32 (* onDeviceIDEqual )(mal_context* pContext, const mal_device_id* pID0, const mal_device_id* pID1);
    mal_result (* onEnumDevices   )(mal_context* pContext, mal_enum_devices_callback_proc callback, void* pUserData);    // Return false from the callback to stop enumeration.
    mal_result (* onGetDeviceInfo )(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, mal_device_info* pDeviceInfo);
    mal_result (* onDeviceInit    )(mal_context* pContext, const mal_device_config* pConfig, mal_device* pDevice);
    void       (* onDeviceUninit  )(mal_device* pDevice);
    mal_result (* onDeviceStart   )(mal_device* pDevice);
    mal_result (* onDeviceStop    )(mal_device* pDevice);
    mal_result (* onDeviceWrite   )(mal_device* pDevice, const void* pPCMFrames, mal_uint32 frameCount);    /* Data is in internal device format. */
    mal_result (* onDeviceRead    )(mal_device* pDevice,       void* pPCMFrames, mal_uint32 frameCount);    /* Data is in internal device format. */
    mal_result (* onDeviceMainLoop)(mal_device* pDevice);

    union
    {
#ifdef MAL_SUPPORT_WASAPI
        struct
        {
            int _unused;
        } wasapi;
#endif
#ifdef MAL_SUPPORT_DSOUND
        struct
        {
            mal_handle hDSoundDLL;
            mal_proc DirectSoundCreate;
            mal_proc DirectSoundEnumerateA;
            mal_proc DirectSoundCaptureCreate;
            mal_proc DirectSoundCaptureEnumerateA;
        } dsound;
#endif
#ifdef MAL_SUPPORT_WINMM
        struct
        {
            mal_handle hWinMM;
            mal_proc waveOutGetNumDevs;
            mal_proc waveOutGetDevCapsA;
            mal_proc waveOutOpen;
            mal_proc waveOutClose;
            mal_proc waveOutPrepareHeader;
            mal_proc waveOutUnprepareHeader;
            mal_proc waveOutWrite;
            mal_proc waveOutReset;
            mal_proc waveInGetNumDevs;
            mal_proc waveInGetDevCapsA;
            mal_proc waveInOpen;
            mal_proc waveInClose;
            mal_proc waveInPrepareHeader;
            mal_proc waveInUnprepareHeader;
            mal_proc waveInAddBuffer;
            mal_proc waveInStart;
            mal_proc waveInReset;
        } winmm;
#endif
#ifdef MAL_SUPPORT_ALSA
        struct
        {
            mal_handle asoundSO;
            mal_proc snd_pcm_open;
            mal_proc snd_pcm_close;
            mal_proc snd_pcm_hw_params_sizeof;
            mal_proc snd_pcm_hw_params_any;
            mal_proc snd_pcm_hw_params_set_format;
            mal_proc snd_pcm_hw_params_set_format_first;
            mal_proc snd_pcm_hw_params_get_format_mask;
            mal_proc snd_pcm_hw_params_set_channels_near;
            mal_proc snd_pcm_hw_params_set_rate_resample;
            mal_proc snd_pcm_hw_params_set_rate_near;
            mal_proc snd_pcm_hw_params_set_buffer_size_near;
            mal_proc snd_pcm_hw_params_set_periods_near;
            mal_proc snd_pcm_hw_params_set_access;
            mal_proc snd_pcm_hw_params_get_format;
            mal_proc snd_pcm_hw_params_get_channels;
            mal_proc snd_pcm_hw_params_get_channels_min;
            mal_proc snd_pcm_hw_params_get_channels_max;
            mal_proc snd_pcm_hw_params_get_rate;
            mal_proc snd_pcm_hw_params_get_rate_min;
            mal_proc snd_pcm_hw_params_get_rate_max;
            mal_proc snd_pcm_hw_params_get_buffer_size;
            mal_proc snd_pcm_hw_params_get_periods;
            mal_proc snd_pcm_hw_params_get_access;
            mal_proc snd_pcm_hw_params;
            mal_proc snd_pcm_sw_params_sizeof;
            mal_proc snd_pcm_sw_params_current;
            mal_proc snd_pcm_sw_params_get_boundary;
            mal_proc snd_pcm_sw_params_set_avail_min;
            mal_proc snd_pcm_sw_params_set_start_threshold;
            mal_proc snd_pcm_sw_params_set_stop_threshold;
            mal_proc snd_pcm_sw_params;
            mal_proc snd_pcm_format_mask_sizeof;
            mal_proc snd_pcm_format_mask_test;
            mal_proc snd_pcm_get_chmap;
            mal_proc snd_pcm_state;
            mal_proc snd_pcm_prepare;
            mal_proc snd_pcm_start;
            mal_proc snd_pcm_drop;
            mal_proc snd_pcm_drain;
            mal_proc snd_device_name_hint;
            mal_proc snd_device_name_get_hint;
            mal_proc snd_card_get_index;
            mal_proc snd_device_name_free_hint;
            mal_proc snd_pcm_mmap_begin;
            mal_proc snd_pcm_mmap_commit;
            mal_proc snd_pcm_recover;
            mal_proc snd_pcm_readi;
            mal_proc snd_pcm_writei;
            mal_proc snd_pcm_avail;
            mal_proc snd_pcm_avail_update;
            mal_proc snd_pcm_wait;
            mal_proc snd_pcm_info;
            mal_proc snd_pcm_info_sizeof;
            mal_proc snd_pcm_info_get_name;
            mal_proc snd_config_update_free_global;

            mal_mutex internalDeviceEnumLock;
        } alsa;
#endif
#ifdef MAL_SUPPORT_PULSEAUDIO
        struct
        {
            mal_handle pulseSO;
            mal_proc pa_mainloop_new;
            mal_proc pa_mainloop_free;
            mal_proc pa_mainloop_get_api;
            mal_proc pa_mainloop_iterate;
            mal_proc pa_mainloop_wakeup;
            mal_proc pa_context_new;
            mal_proc pa_context_unref;
            mal_proc pa_context_connect;
            mal_proc pa_context_disconnect;
            mal_proc pa_context_set_state_callback;
            mal_proc pa_context_get_state;
            mal_proc pa_context_get_sink_info_list;
            mal_proc pa_context_get_source_info_list;
            mal_proc pa_context_get_sink_info_by_name;
            mal_proc pa_context_get_source_info_by_name;
            mal_proc pa_operation_unref;
            mal_proc pa_operation_get_state;
            mal_proc pa_channel_map_init_extend;
            mal_proc pa_channel_map_valid;
            mal_proc pa_channel_map_compatible;
            mal_proc pa_stream_new;
            mal_proc pa_stream_unref;
            mal_proc pa_stream_connect_playback;
            mal_proc pa_stream_connect_record;
            mal_proc pa_stream_disconnect;
            mal_proc pa_stream_get_state;
            mal_proc pa_stream_get_sample_spec;
            mal_proc pa_stream_get_channel_map;
            mal_proc pa_stream_get_buffer_attr;
            mal_proc pa_stream_set_buffer_attr;
            mal_proc pa_stream_get_device_name;
            mal_proc pa_stream_set_write_callback;
            mal_proc pa_stream_set_read_callback;
            mal_proc pa_stream_flush;
            mal_proc pa_stream_drain;
            mal_proc pa_stream_is_corked;
            mal_proc pa_stream_cork;
            mal_proc pa_stream_trigger;
            mal_proc pa_stream_begin_write;
            mal_proc pa_stream_write;
            mal_proc pa_stream_peek;
            mal_proc pa_stream_drop;
            mal_proc pa_stream_writable_size;
            mal_proc pa_stream_readable_size;
        } pulse;
#endif
#ifdef MAL_SUPPORT_JACK
        struct
        {
            mal_handle jackSO;
            mal_proc jack_client_open;
            mal_proc jack_client_close;
            mal_proc jack_client_name_size;
            mal_proc jack_set_process_callback;
            mal_proc jack_set_buffer_size_callback;
            mal_proc jack_on_shutdown;
            mal_proc jack_get_sample_rate;
            mal_proc jack_get_buffer_size;
            mal_proc jack_get_ports;
            mal_proc jack_activate;
            mal_proc jack_deactivate;
            mal_proc jack_connect;
            mal_proc jack_port_register;
            mal_proc jack_port_name;
            mal_proc jack_port_get_buffer;
            mal_proc jack_free;
        } jack;
#endif
#ifdef MAL_SUPPORT_COREAUDIO
        struct
        {
            mal_handle hCoreFoundation;
            mal_proc CFStringGetCString;
            
            mal_handle hCoreAudio;
            mal_proc AudioObjectGetPropertyData;
            mal_proc AudioObjectGetPropertyDataSize;
            mal_proc AudioObjectSetPropertyData;
            mal_proc AudioObjectAddPropertyListener;
            
            mal_handle hAudioUnit;  // Could possibly be set to AudioToolbox on later versions of macOS.
            mal_proc AudioComponentFindNext;
            mal_proc AudioComponentInstanceDispose;
            mal_proc AudioComponentInstanceNew;
            mal_proc AudioOutputUnitStart;
            mal_proc AudioOutputUnitStop;
            mal_proc AudioUnitAddPropertyListener;
            mal_proc AudioUnitGetPropertyInfo;
            mal_proc AudioUnitGetProperty;
            mal_proc AudioUnitSetProperty;
            mal_proc AudioUnitInitialize;
            mal_proc AudioUnitRender;
            
            /*AudioComponent*/ mal_ptr component;
        } coreaudio;
#endif
#ifdef MAL_SUPPORT_SNDIO
        struct
        {
            mal_handle sndioSO;
            mal_proc sio_open;
            mal_proc sio_close;
            mal_proc sio_setpar;
            mal_proc sio_getpar;
            mal_proc sio_getcap;
            mal_proc sio_start;
            mal_proc sio_stop;
            mal_proc sio_read;
            mal_proc sio_write;
            mal_proc sio_onmove;
            mal_proc sio_nfds;
            mal_proc sio_pollfd;
            mal_proc sio_revents;
            mal_proc sio_eof;
            mal_proc sio_setvol;
            mal_proc sio_onvol;
            mal_proc sio_initpar;
        } sndio;
#endif
#ifdef MAL_SUPPORT_AUDIO4
        struct
        {
            int _unused;
        } audio4;
#endif
#ifdef MAL_SUPPORT_OSS
        struct
        {
            int versionMajor;
            int versionMinor;
        } oss;
#endif
#ifdef MAL_SUPPORT_AAUDIO
        struct
        {
            mal_handle hAAudio; /* libaaudio.so */
            mal_proc AAudio_createStreamBuilder;
            mal_proc AAudioStreamBuilder_delete;
            mal_proc AAudioStreamBuilder_setDeviceId;
            mal_proc AAudioStreamBuilder_setDirection;
            mal_proc AAudioStreamBuilder_setSharingMode;
            mal_proc AAudioStreamBuilder_setFormat;
            mal_proc AAudioStreamBuilder_setChannelCount;
            mal_proc AAudioStreamBuilder_setSampleRate;
            mal_proc AAudioStreamBuilder_setBufferCapacityInFrames;
            mal_proc AAudioStreamBuilder_setFramesPerDataCallback;
            mal_proc AAudioStreamBuilder_setDataCallback;
            mal_proc AAudioStreamBuilder_setPerformanceMode;
            mal_proc AAudioStreamBuilder_openStream;
            mal_proc AAudioStream_close;
            mal_proc AAudioStream_getState;
            mal_proc AAudioStream_waitForStateChange;
            mal_proc AAudioStream_getFormat;
            mal_proc AAudioStream_getChannelCount;
            mal_proc AAudioStream_getSampleRate;
            mal_proc AAudioStream_getBufferCapacityInFrames;
            mal_proc AAudioStream_getFramesPerDataCallback;
            mal_proc AAudioStream_getFramesPerBurst;
            mal_proc AAudioStream_requestStart;
            mal_proc AAudioStream_requestStop;
        } aaudio;
#endif
#ifdef MAL_SUPPORT_OPENSL
        struct
        {
            int _unused;
        } opensl;
#endif
#ifdef MAL_SUPPORT_WEBAUDIO
        struct
        {
            int _unused;
        } webaudio;
#endif
#ifdef MAL_SUPPORT_NULL
        struct
        {
            int _unused;
        } null_backend;
#endif
    };

    union
    {
#ifdef MAL_WIN32
        struct
        {
            /*HMODULE*/ mal_handle hOle32DLL;
            mal_proc CoInitializeEx;
            mal_proc CoUninitialize;
            mal_proc CoCreateInstance;
            mal_proc CoTaskMemFree;
            mal_proc PropVariantClear;
            mal_proc StringFromGUID2;

            /*HMODULE*/ mal_handle hUser32DLL;
            mal_proc GetForegroundWindow;
            mal_proc GetDesktopWindow;

            /*HMODULE*/ mal_handle hAdvapi32DLL;
            mal_proc RegOpenKeyExA;
            mal_proc RegCloseKey;
            mal_proc RegQueryValueExA;
        } win32;
#endif
#ifdef MAL_POSIX
        struct
        {
            mal_handle pthreadSO;
            mal_proc pthread_create;
            mal_proc pthread_join;
            mal_proc pthread_mutex_init;
            mal_proc pthread_mutex_destroy;
            mal_proc pthread_mutex_lock;
            mal_proc pthread_mutex_unlock;
            mal_proc pthread_cond_init;
            mal_proc pthread_cond_destroy;
            mal_proc pthread_cond_wait;
            mal_proc pthread_cond_signal;
            mal_proc pthread_attr_init;
            mal_proc pthread_attr_destroy;
            mal_proc pthread_attr_setschedpolicy;
            mal_proc pthread_attr_getschedparam;
            mal_proc pthread_attr_setschedparam;
        } posix;
#endif
        int _unused;
    };
};

MAL_ALIGNED_STRUCT(MAL_SIMD_ALIGNMENT) mal_device
{
    mal_context* pContext;
    mal_device_type type;
    mal_uint32 sampleRate;
    mal_uint32 state;
    mal_device_callback_proc onData;
    mal_stop_proc onStop;
    void* pUserData;                // Application defined data.
    mal_mutex lock;
    mal_event wakeupEvent;
    mal_event startEvent;
    mal_event stopEvent;
    mal_thread thread;
    mal_result workResult;          // This is set by the worker thread after it's finished doing a job.
    mal_bool32 usingDefaultSampleRate : 1;
    mal_bool32 usingDefaultBufferSize : 1;
    mal_bool32 usingDefaultPeriods    : 1;
    mal_bool32 isOwnerOfContext       : 1;  // When set to true, uninitializing the device will also uninitialize the context. Set to true when NULL is passed into mal_device_init().
    struct
    {
        char name[256]; /* Maybe temporary. Likely to be replaced with a query API. */
        mal_share_mode shareMode;       /* Set to whatever was passed in when the device was initialized. */
        mal_bool32 usingDefaultFormat     : 1;
        mal_bool32 usingDefaultChannels   : 1;
        mal_bool32 usingDefaultChannelMap : 1;
        mal_format format;
        mal_uint32 channels;
        mal_channel channelMap[MAL_MAX_CHANNELS];
        mal_format internalFormat;
        mal_uint32 internalChannels;
        mal_uint32 internalSampleRate;
        mal_channel internalChannelMap[MAL_MAX_CHANNELS];
        mal_uint32 internalBufferSizeInFrames;
        mal_uint32 internalPeriods;
        mal_pcm_converter converter;
        mal_uint32 _dspFrameCount;      // Internal use only. Used as the data source when reading from the device.
        const mal_uint8* _dspFrames;    // ^^^ AS ABOVE ^^^
    } playback;
    struct
    {
        char name[256]; /* Maybe temporary. Likely to be replaced with a query API. */
        mal_share_mode shareMode;       /* Set to whatever was passed in when the device was initialized. */
        mal_bool32 usingDefaultFormat     : 1;
        mal_bool32 usingDefaultChannels   : 1;
        mal_bool32 usingDefaultChannelMap : 1;
        mal_format format;
        mal_uint32 channels;
        mal_channel channelMap[MAL_MAX_CHANNELS];
        mal_format internalFormat;
        mal_uint32 internalChannels;
        mal_uint32 internalSampleRate;
        mal_channel internalChannelMap[MAL_MAX_CHANNELS];
        mal_uint32 internalBufferSizeInFrames;
        mal_uint32 internalPeriods;
        mal_pcm_converter converter;
        mal_uint32 _dspFrameCount;      // Internal use only. Used as the data source when reading from the device.
        const mal_uint8* _dspFrames;    // ^^^ AS ABOVE ^^^
    } capture;

    union
    {
#ifdef MAL_SUPPORT_WASAPI
        struct
        {
            /*IAudioClient**/ mal_ptr pAudioClientPlayback;
            /*IAudioClient**/ mal_ptr pAudioClientCapture;
            /*IAudioRenderClient**/ mal_ptr pRenderClient;
            /*IAudioCaptureClient**/ mal_ptr pCaptureClient;
            /*IMMDeviceEnumerator**/ mal_ptr pDeviceEnumerator; /* Used for IMMNotificationClient notifications. Required for detecting default device changes. */
            mal_IMMNotificationClient notificationClient;
            /*HANDLE*/ mal_handle hEventPlayback;               /* Used with the blocking API. Manual reset. Initialized to signaled. */
            /*HANDLE*/ mal_handle hEventCapture;                /* Used with the blocking API. Manual reset. Initialized to unsignaled. */
            void* pDeviceBufferPlayback;
            void* pDeviceBufferCapture;
            mal_uint32 deviceBufferFramesRemainingPlayback;
            mal_uint32 deviceBufferFramesRemainingCapture;
            mal_uint32 deviceBufferFramesCapacityPlayback;
            mal_uint32 deviceBufferFramesCapacityCapture;
            mal_uint32 periodSizeInFramesPlayback;
            mal_uint32 periodSizeInFramesCapture;
            mal_uint32 actualBufferSizeInFramesPlayback;        /* Value from GetBufferSize(). internalBufferSizeInFrames is not set to the _actual_ buffer size when low-latency shared mode is being used due to the way the IAudioClient3 API works. */
            mal_uint32 actualBufferSizeInFramesCapture;
            mal_uint32 originalBufferSizeInFrames;
            mal_uint32 originalBufferSizeInMilliseconds;
            mal_uint32 originalPeriods;
            mal_bool32 hasDefaultPlaybackDeviceChanged;         /* <-- Make sure this is always a whole 32-bits because we use atomic assignments. */
            mal_bool32 hasDefaultCaptureDeviceChanged;          /* <-- Make sure this is always a whole 32-bits because we use atomic assignments. */
            mal_bool32 isStarted;
        } wasapi;
#endif
#ifdef MAL_SUPPORT_DSOUND
        struct
        {
            /*LPDIRECTSOUND*/ mal_ptr pPlayback;
            /*LPDIRECTSOUNDBUFFER*/ mal_ptr pPlaybackPrimaryBuffer;
            /*LPDIRECTSOUNDBUFFER*/ mal_ptr pPlaybackBuffer;
            /*LPDIRECTSOUNDCAPTURE*/ mal_ptr pCapture;
            /*LPDIRECTSOUNDCAPTUREBUFFER*/ mal_ptr pCaptureBuffer;
            

            mal_uint32 iNextPeriodPlayback; /* Circular. Keeps track of the next period that's due for an update. */
            mal_uint32 iNextPeriodCapture;
            void* pMappedBufferPlayback;
            void* pMappedBufferCapture;
            mal_uint32 mappedBufferFramesRemainingPlayback;
            mal_uint32 mappedBufferFramesRemainingCapture;
            mal_uint32 mappedBufferFramesCapacityPlayback;
            mal_uint32 mappedBufferFramesCapacityCapture;
            mal_bool32 isStarted;
        } dsound;
#endif
#ifdef MAL_SUPPORT_WINMM
        struct
        {
            /*HWAVEOUT*/ mal_handle hDevicePlayback;
            /*HWAVEIN*/ mal_handle hDeviceCapture;
            /*HANDLE*/ mal_handle hEventPlayback;
            /*HANDLE*/ mal_handle hEventCapture;
            mal_uint32 fragmentSizeInFrames;
            mal_uint32 fragmentSizeInBytes;
            mal_uint32 iNextHeaderPlayback;             /* [0,periods). Used as an index into pWAVEHDRPlayback. */
            mal_uint32 iNextHeaderCapture;              /* [0,periods). Used as an index into pWAVEHDRCapture. */
            mal_uint32 headerFramesConsumedPlayback;    /* The number of PCM frames consumed in the buffer in pWAVEHEADER[iNextHeader]. */
            mal_uint32 headerFramesConsumedCapture;     /* ^^^ */
            /*WAVEHDR**/ mal_uint8* pWAVEHDRPlayback;   /* One instantiation for each period. */
            /*WAVEHDR**/ mal_uint8* pWAVEHDRCapture;    /* One instantiation for each period. */
            mal_uint8* pIntermediaryBufferPlayback;
            mal_uint8* pIntermediaryBufferCapture;
            mal_uint8* _pHeapData;                      /* Used internally and is used for the heap allocated data for the intermediary buffer and the WAVEHDR structures. */
            mal_bool32 isStarted;
        } winmm;
#endif
#ifdef MAL_SUPPORT_ALSA
        struct
        {
            /*snd_pcm_t**/ mal_ptr pPCMPlayback;
            /*snd_pcm_t**/ mal_ptr pPCMCapture;
            mal_bool32 isUsingMMapPlayback : 1;
            mal_bool32 isUsingMMapCapture  : 1;
        } alsa;
#endif
#ifdef MAL_SUPPORT_PULSEAUDIO
        struct
        {
            /*pa_mainloop**/ mal_ptr pMainLoop;
            /*pa_mainloop_api**/ mal_ptr pAPI;
            /*pa_context**/ mal_ptr pPulseContext;
            /*pa_stream**/ mal_ptr pStreamPlayback;
            /*pa_stream**/ mal_ptr pStreamCapture;
            /*pa_context_state*/ mal_uint32 pulseContextState;
            void* pMappedBufferPlayback;
            const void* pMappedBufferCapture;
            mal_uint32 mappedBufferFramesRemainingPlayback;
            mal_uint32 mappedBufferFramesRemainingCapture;
            mal_uint32 mappedBufferFramesCapacityPlayback;
            mal_uint32 mappedBufferFramesCapacityCapture;
            mal_bool32 breakFromMainLoop : 1;
        } pulse;
#endif
#ifdef MAL_SUPPORT_JACK
        struct
        {
            /*jack_client_t**/ mal_ptr pClient;
            /*jack_port_t**/ mal_ptr pPortsPlayback[MAL_MAX_CHANNELS];
            /*jack_port_t**/ mal_ptr pPortsCapture[MAL_MAX_CHANNELS];
            float* pIntermediaryBufferPlayback; // Typed as a float because JACK is always floating point.
            float* pIntermediaryBufferCapture;
            mal_pcm_rb duplexRB;
        } jack;
#endif
#ifdef MAL_SUPPORT_COREAUDIO
        struct
        {
            mal_uint32 deviceObjectIDPlayback;
            mal_uint32 deviceObjectIDCapture;
            /*AudioUnit*/ mal_ptr audioUnitPlayback;
            /*AudioUnit*/ mal_ptr audioUnitCapture;
            /*AudioBufferList**/ mal_ptr pAudioBufferList;  // Only used for input devices.
            mal_event stopEvent;
            mal_uint32 originalBufferSizeInFrames;
            mal_uint32 originalBufferSizeInMilliseconds;
            mal_uint32 originalPeriods;
            mal_bool32 isDefaultPlaybackDevice;
            mal_bool32 isDefaultCaptureDevice;
            mal_bool32 isSwitchingPlaybackDevice;   /* <-- Set to true when the default device has changed and mini_al is in the process of switching. */
            mal_bool32 isSwitchingCaptureDevice;    /* <-- Set to true when the default device has changed and mini_al is in the process of switching. */
            mal_pcm_rb duplexRB;
        } coreaudio;
#endif
#ifdef MAL_SUPPORT_SNDIO
        struct
        {
            mal_ptr handlePlayback;
            mal_ptr handleCapture;
            mal_bool32 isStartedPlayback;
            mal_bool32 isStartedCapture;
        } sndio;
#endif
#ifdef MAL_SUPPORT_AUDIO4
        struct
        {
            int fdPlayback;
            int fdCapture;
        } audio4;
#endif
#ifdef MAL_SUPPORT_OSS
        struct
        {
            int fdPlayback;
            int fdCapture;
        } oss;
#endif
#ifdef MAL_SUPPORT_AAUDIO
        struct
        {
            /*AAudioStream**/ mal_ptr pStreamPlayback;
            /*AAudioStream**/ mal_ptr pStreamCapture;
            mal_pcm_rb duplexRB;
        } aaudio;
#endif
#ifdef MAL_SUPPORT_OPENSL
        struct
        {
            /*SLObjectItf*/ mal_ptr pOutputMixObj;
            /*SLOutputMixItf*/ mal_ptr pOutputMix;
            /*SLObjectItf*/ mal_ptr pAudioPlayerObj;
            /*SLPlayItf*/ mal_ptr pAudioPlayer;
            /*SLObjectItf*/ mal_ptr pAudioRecorderObj;
            /*SLRecordItf*/ mal_ptr pAudioRecorder;
            /*SLAndroidSimpleBufferQueueItf*/ mal_ptr pBufferQueuePlayback;
            /*SLAndroidSimpleBufferQueueItf*/ mal_ptr pBufferQueueCapture;
            mal_uint32 currentBufferIndexPlayback;
            mal_uint32 currentBufferIndexCapture;
            mal_uint8* pBufferPlayback;     // This is malloc()'d and is used for storing audio data. Typed as mal_uint8 for easy offsetting.
            mal_uint8* pBufferCapture;
            mal_pcm_rb duplexRB;
        } opensl;
#endif
#ifdef MAL_SUPPORT_WEBAUDIO
        struct
        {
            int indexPlayback;  /* We use a factory on the JavaScript side to manage devices and use an index for JS/C interop. */
            int indexCapture;
            mal_pcm_rb duplexRB;    /* In external capture format. */
        } webaudio;
#endif
#ifdef MAL_SUPPORT_NULL
        struct
        {
            mal_thread deviceThread;
            mal_event operationEvent;
            mal_event operationCompletionEvent;
            mal_uint32 operation;
            mal_result operationResult;
            mal_timer timer;
            double priorRunTime;
            mal_uint32 currentPeriodFramesRemainingPlayback;
            mal_uint32 currentPeriodFramesRemainingCapture;
            mal_uint64 lastProcessedFramePlayback;
            mal_uint32 lastProcessedFrameCapture;
            mal_bool32 isStarted;
        } null_device;
#endif
    };
};
#if defined(_MSC_VER)
    #pragma warning(pop)
#endif

// Initializes a context.
//
// The context is used for selecting and initializing the relevant backends.
//
// Note that the location of the context cannot change throughout it's lifetime. Consider allocating
// the mal_context object with malloc() if this is an issue. The reason for this is that a pointer
// to the context is stored in the mal_device structure.
//
// <backends> is used to allow the application to prioritize backends depending on it's specific
// requirements. This can be null in which case it uses the default priority, which is as follows:
//   - WASAPI
//   - DirectSound
//   - WinMM
//   - Core Audio (Apple)
//   - sndio
//   - audio(4)
//   - OSS
//   - PulseAudio
//   - ALSA
//   - JACK
//   - AAudio
//   - OpenSL|ES
//   - Web Audio / Emscripten
//   - Null
//
// <pConfig> is used to configure the context. Use the logCallback config to set a callback for whenever a
// log message is posted. The priority of the worker thread can be set with the threadPriority config.
//
// It is recommended that only a single context is active at any given time because it's a bulky data
// structure which performs run-time linking for the relevant backends every time it's initialized.
//
// Return Value:
//   MAL_SUCCESS if successful; any other error code otherwise.
//
// Thread Safety: UNSAFE
mal_result mal_context_init(const mal_backend backends[], mal_uint32 backendCount, const mal_context_config* pConfig, mal_context* pContext);

// Uninitializes a context.
//
// Results are undefined if you call this while any device created by this context is still active.
//
// Return Value:
//   MAL_SUCCESS if successful; any other error code otherwise.
//
// Thread Safety: UNSAFE
mal_result mal_context_uninit(mal_context* pContext);

// Enumerates over every device (both playback and capture).
//
// This is a lower-level enumeration function to the easier to use mal_context_get_devices(). Use
// mal_context_enumerate_devices() if you would rather not incur an internal heap allocation, or
// it simply suits your code better.
//
// Do _not_ assume the first enumerated device of a given type is the default device.
//
// Some backends and platforms may only support default playback and capture devices.
//
// Note that this only retrieves the ID and name/description of the device. The reason for only
// retrieving basic information is that it would otherwise require opening the backend device in
// order to probe it for more detailed information which can be inefficient. Consider using
// mal_context_get_device_info() for this, but don't call it from within the enumeration callback.
//
// In general, you should not do anything complicated from within the callback. In particular, do
// not try initializing a device from within the callback.
//
// Consider using mal_context_get_devices() for a simpler and safer API, albeit at the expense of
// an internal heap allocation.
//
// Returning false from the callback will stop enumeration. Returning true will continue enumeration.
//
// Return Value:
//   MAL_SUCCESS if successful; any other error code otherwise.
//
// Thread Safety: SAFE
//   This is guarded using a simple mutex lock.
mal_result mal_context_enumerate_devices(mal_context* pContext, mal_enum_devices_callback_proc callback, void* pUserData);

// Retrieves basic information about every active playback and/or capture device.
//
// You can pass in NULL for the playback or capture lists in which case they'll be ignored.
//
// It is _not_ safe to assume the first device in the list is the default device.
//
// The returned pointers will become invalid upon the next call this this function, or when the
// context is uninitialized. Do not free the returned pointers.
//
// This function follows the same enumeration rules as mal_context_enumerate_devices(). See
// documentation for mal_context_enumerate_devices() for more information.
//
// Return Value:
//   MAL_SUCCESS if successful; any other error code otherwise.
//
// Thread Safety: SAFE
//   Since each call to this function invalidates the pointers from the previous call, you
//   should not be calling this simultaneously across multiple threads. Instead, you need to
//   make a copy of the returned data with your own higher level synchronization.
mal_result mal_context_get_devices(mal_context* pContext, mal_device_info** ppPlaybackDeviceInfos, mal_uint32* pPlaybackDeviceCount, mal_device_info** ppCaptureDeviceInfos, mal_uint32* pCaptureDeviceCount);

// Retrieves information about a device with the given ID.
//
// Do _not_ call this from within the mal_context_enumerate_devices() callback.
//
// It's possible for a device to have different information and capabilities depending on wether or
// not it's opened in shared or exclusive mode. For example, in shared mode, WASAPI always uses
// floating point samples for mixing, but in exclusive mode it can be anything. Therefore, this
// function allows you to specify which share mode you want information for. Note that not all
// backends and devices support shared or exclusive mode, in which case this function will fail
// if the requested share mode is unsupported.
//
// This leaves pDeviceInfo unmodified in the result of an error.
//
// Return Value:
//   MAL_SUCCESS if successful; any other error code otherwise.
//
// Thread Safety: SAFE
//   This is guarded using a simple mutex lock.
mal_result mal_context_get_device_info(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, mal_device_info* pDeviceInfo);

// Initializes a device.
//
// The context can be null in which case it uses the default. This is equivalent to passing in a
// context that was initialized like so:
//
//     mal_context_init(NULL, 0, NULL, &context);
//
// Do not pass in null for the context if you are needing to open multiple devices. You can,
// however, use null when initializing the first device, and then use device.pContext for the
// initialization of other devices.
//
// The device's configuration is controlled with pConfig. This allows you to configure the sample
// format, channel count, sample rate, etc. Before calling mal_device_init(), you will need to
// initialize a mal_device_config object using mal_device_config_init(). You must set the callback in
// the device config.
//
// Passing in 0 to any property in pConfig will force the use of a default value. In the case of
// sample format, channel count, sample rate and channel map it will default to the values used by
// the backend's internal device. For the size of the buffer you can set bufferSizeInFrames or
// bufferSizeInMilliseconds (if both are set it will prioritize bufferSizeInFrames). If both are
// set to zero, it will default to MAL_BASE_BUFFER_SIZE_IN_MILLISECONDS_LOW_LATENCY or
// MAL_BASE_BUFFER_SIZE_IN_MILLISECONDS_CONSERVATIVE, depending on whether or not performanceProfile
// is set to mal_performance_profile_low_latency or mal_performance_profile_conservative.
//
// If you request exclusive mode and the backend does not support it an error will be returned. For
// robustness, you may want to first try initializing the device in exclusive mode, and then fall back
// to shared mode if required. Alternatively you can just request shared mode (the default if you
// leave it unset in the config) which is the most reliable option. Some backends do not have a
// practical way of choosing whether or not the device should be exclusive or not (ALSA, for example)
// in which case it just acts as a hint. Unless you have special requirements you should try avoiding
// exclusive mode as it's intrusive to the user. Starting with Windows 10, mini_al will use low-latency
// shared mode where possible which may make exclusive mode unnecessary.
//
// When sending or receiving data to/from a device, mini_al will internally perform a format
// conversion to convert between the format specified by pConfig and the format used internally by
// the backend. If you pass in NULL for pConfig or 0 for the sample format, channel count,
// sample rate _and_ channel map, data transmission will run on an optimized pass-through fast path.
//
// The buffer size should be treated as a hint. mini_al will try it's best to use exactly what you
// ask for, but it may differ. You should not assume the number of frames specified in each call to
// the data callback is exactly what you originally specified.
//
// The <periods> property controls how frequently the background thread is woken to check for more
// data. It's tied to the buffer size, so as an example, if your buffer size is equivalent to 10
// milliseconds and you have 2 periods, the CPU will wake up approximately every 5 milliseconds.
//
// When compiling for UWP you must ensure you call this function on the main UI thread because the
// operating system may need to present the user with a message asking for permissions. Please refer
// to the official documentation for ActivateAudioInterfaceAsync() for more information.
//
// ALSA Specific: When initializing the default device, requesting shared mode will try using the
// "dmix" device for playback and the "dsnoop" device for capture. If these fail it will try falling
// back to the "hw" device.
//
// Return Value:
//   MAL_SUCCESS if successful; any other error code otherwise.
//
// Thread Safety: UNSAFE
//   It is not safe to call this function simultaneously for different devices because some backends
//   depend on and mutate global state (such as OpenSL|ES). The same applies to calling this at the
//   same time as mal_device_uninit().
mal_result mal_device_init(mal_context* pContext, const mal_device_config* pConfig, mal_device* pDevice);

// Initializes a device without a context, with extra parameters for controlling the configuration
// of the internal self-managed context.
//
// See mal_device_init() and mal_context_init().
mal_result mal_device_init_ex(const mal_backend backends[], mal_uint32 backendCount, const mal_context_config* pContextConfig, const mal_device_config* pConfig, mal_device* pDevice);

// Uninitializes a device.
//
// This will explicitly stop the device. You do not need to call mal_device_stop() beforehand, but it's
// harmless if you do.
//
// Return Value:
//   MAL_SUCCESS if successful; any other error code otherwise.
//
// Thread Safety: UNSAFE
//   As soon as this API is called the device should be considered undefined. All bets are off if you
//   try using the device at the same time as uninitializing it.
void mal_device_uninit(mal_device* pDevice);

// Sets the callback to use when the device has stopped, either explicitly or as a result of an error.
//
// Thread Safety: SAFE
//   This API is implemented as a simple atomic assignment.
void mal_device_set_stop_callback(mal_device* pDevice, mal_stop_proc proc);

// Activates the device. For playback devices this begins playback. For capture devices it begins
// recording.
//
// For a playback device, this will retrieve an initial chunk of audio data from the client before
// returning. The reason for this is to ensure there is valid audio data in the buffer, which needs
// to be done _before_ the device begins playback.
//
// This API waits until the backend device has been started for real by the worker thread. It also
// waits on a mutex for thread-safety.
//
// Return Value:
//   MAL_SUCCESS if successful; any other error code otherwise.
//
// Thread Safety: SAFE
mal_result mal_device_start(mal_device* pDevice);

// Puts the device to sleep, but does not uninitialize it. Use mal_device_start() to start it up again.
//
// This API needs to wait on the worker thread to stop the backend device properly before returning. It
// also waits on a mutex for thread-safety. In addition, some backends need to wait for the device to
// finish playback/recording of the current fragment which can take some time (usually proportionate to
// the buffer size that was specified at initialization time).
//
// This should not drop unprocessed samples. Backends are required to either pause the stream in-place
// or drain the buffer if pausing is not possible. The reason for this is that stopping the device and
// the resuming it with mal_device_start() (which you might do when your program loses focus) may result
// in a situation where those samples are never output to the speakers or received from the microphone
// which can in turn result in de-syncs.
//
// Return Value:
//   MAL_SUCCESS if successful; any other error code otherwise.
//
// Thread Safety: SAFE
mal_result mal_device_stop(mal_device* pDevice);

// Determines whether or not the device is started.
//
// This is implemented as a simple accessor.
//
// Return Value:
//   True if the device is started, false otherwise.
//
// Thread Safety: SAFE
//   If another thread calls mal_device_start() or mal_device_stop() at this same time as this function
//   is called, there's a very small chance the return value will be out of sync.
mal_bool32 mal_device_is_started(mal_device* pDevice);


// Helper function for initializing a mal_context_config object.
mal_context_config mal_context_config_init(void);

// Initializes a device config.
//
// By default, the device config will use native device settings (format, channels, sample rate, etc.). Using native
// settings means you will get an optimized pass-through data transmission pipeline to and from the device, but you will
// need to do all format conversions manually. Normally you would want to use a known format that your program can handle
// natively, which you can do by specifying it after this function returns, like so:
//
//     mal_device_config config = mal_device_config_init(mal_device_type_playback);
//     config.callback = my_data_callback;
//     config.pUserData = pMyUserData;
//     config.format = mal_format_f32;
//     config.channels = 2;
//     config.sampleRate = 44100;
//
// In this case mini_al will perform all of the necessary data conversion for you behind the scenes.
//
// Currently mini_al only supports asynchronous, callback based data delivery which means you must specify callback. A
// pointer to user data can also be specified which is set in the pUserData member of the mal_device object.
//
// To specify a channel map you can use mal_get_standard_channel_map():
//
//     mal_get_standard_channel_map(mal_standard_channel_map_default, config.channels, config.channelMap);
//
// Alternatively you can set the channel map manually if you need something specific or something that isn't one of mini_al's
// stock channel maps.
//
// By default the system's default device will be used. Set the pDeviceID member to a pointer to a mal_device_id object to 
// use a specific device. You can enumerate over the devices with mal_context_enumerate_devices() or mal_context_get_devices()
// which will give you access to the device ID. Set pDeviceID to NULL to use the default device.
//
// The device type can be one of the mal_device_type's:
//   mal_device_type_playback
//   mal_device_type_capture
//   mal_device_type_duplex
//
// Thread Safety: SAFE
mal_device_config mal_device_config_init(mal_device_type deviceType);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Utiltities
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Creates a mutex.
//
// A mutex must be created from a valid context. A mutex is initially unlocked.
mal_result mal_mutex_init(mal_context* pContext, mal_mutex* pMutex);

// Deletes a mutex.
void mal_mutex_uninit(mal_mutex* pMutex);

// Locks a mutex with an infinite timeout.
void mal_mutex_lock(mal_mutex* pMutex);

// Unlocks a mutex.
void mal_mutex_unlock(mal_mutex* pMutex);


// Retrieves a friendly name for a backend.
const char* mal_get_backend_name(mal_backend backend);

// Adjust buffer size based on a scaling factor.
//
// This just multiplies the base size by the scaling factor, making sure it's a size of at least 1.
mal_uint32 mal_scale_buffer_size(mal_uint32 baseBufferSize, float scale);

// Calculates a buffer size in milliseconds from the specified number of frames and sample rate.
mal_uint32 mal_calculate_buffer_size_in_milliseconds_from_frames(mal_uint32 bufferSizeInFrames, mal_uint32 sampleRate);

// Calculates a buffer size in frames from the specified number of milliseconds and sample rate.
mal_uint32 mal_calculate_buffer_size_in_frames_from_milliseconds(mal_uint32 bufferSizeInMilliseconds, mal_uint32 sampleRate);

// Retrieves the default buffer size in milliseconds based on the specified performance profile.
mal_uint32 mal_get_default_buffer_size_in_milliseconds(mal_performance_profile performanceProfile);

// Calculates a buffer size in frames for the specified performance profile and scale factor.
mal_uint32 mal_get_default_buffer_size_in_frames(mal_performance_profile performanceProfile, mal_uint32 sampleRate);

#endif  // MAL_NO_DEVICE_IO




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Decoding
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef MAL_NO_DECODING

typedef struct mal_decoder mal_decoder;

typedef enum
{
    mal_seek_origin_start,
    mal_seek_origin_current
} mal_seek_origin;

typedef size_t     (* mal_decoder_read_proc)             (mal_decoder* pDecoder, void* pBufferOut, size_t bytesToRead); // Returns the number of bytes read.
typedef mal_bool32 (* mal_decoder_seek_proc)             (mal_decoder* pDecoder, int byteOffset, mal_seek_origin origin);
typedef mal_result (* mal_decoder_seek_to_pcm_frame_proc)(mal_decoder* pDecoder, mal_uint64 frameIndex);
typedef mal_result (* mal_decoder_uninit_proc)           (mal_decoder* pDecoder);

typedef struct
{
    mal_format format;      // Set to 0 or mal_format_unknown to use the stream's internal format.
    mal_uint32 channels;    // Set to 0 to use the stream's internal channels.
    mal_uint32 sampleRate;  // Set to 0 to use the stream's internal sample rate.
    mal_channel channelMap[MAL_MAX_CHANNELS];
    mal_channel_mix_mode channelMixMode;
    mal_dither_mode ditherMode;
    mal_src_algorithm srcAlgorithm;
    union
    {
        mal_src_config_sinc sinc;
    } src;
} mal_decoder_config;

struct mal_decoder
{
    mal_decoder_read_proc onRead;
    mal_decoder_seek_proc onSeek;
    void* pUserData;
    mal_format  internalFormat;
    mal_uint32  internalChannels;
    mal_uint32  internalSampleRate;
    mal_channel internalChannelMap[MAL_MAX_CHANNELS];
    mal_format  outputFormat;
    mal_uint32  outputChannels;
    mal_uint32  outputSampleRate;
    mal_channel outputChannelMap[MAL_MAX_CHANNELS];
    mal_pcm_converter dsp;                // <-- Format conversion is achieved by running frames through this.
    mal_decoder_seek_to_pcm_frame_proc onSeekToPCMFrame;
    mal_decoder_uninit_proc onUninit;
    void* pInternalDecoder;     // <-- The drwav/drflac/stb_vorbis/etc. objects.
    struct
    {
        const mal_uint8* pData;
        size_t dataSize;
        size_t currentReadPos;
    } memory;   // Only used for decoders that were opened against a block of memory.
};

mal_decoder_config mal_decoder_config_init(mal_format outputFormat, mal_uint32 outputChannels, mal_uint32 outputSampleRate);

mal_result mal_decoder_init(mal_decoder_read_proc onRead, mal_decoder_seek_proc onSeek, void* pUserData, const mal_decoder_config* pConfig, mal_decoder* pDecoder);
mal_result mal_decoder_init_wav(mal_decoder_read_proc onRead, mal_decoder_seek_proc onSeek, void* pUserData, const mal_decoder_config* pConfig, mal_decoder* pDecoder);
mal_result mal_decoder_init_flac(mal_decoder_read_proc onRead, mal_decoder_seek_proc onSeek, void* pUserData, const mal_decoder_config* pConfig, mal_decoder* pDecoder);
mal_result mal_decoder_init_vorbis(mal_decoder_read_proc onRead, mal_decoder_seek_proc onSeek, void* pUserData, const mal_decoder_config* pConfig, mal_decoder* pDecoder);
mal_result mal_decoder_init_mp3(mal_decoder_read_proc onRead, mal_decoder_seek_proc onSeek, void* pUserData, const mal_decoder_config* pConfig, mal_decoder* pDecoder);
mal_result mal_decoder_init_raw(mal_decoder_read_proc onRead, mal_decoder_seek_proc onSeek, void* pUserData, const mal_decoder_config* pConfigIn, const mal_decoder_config* pConfigOut, mal_decoder* pDecoder);

mal_result mal_decoder_init_memory(const void* pData, size_t dataSize, const mal_decoder_config* pConfig, mal_decoder* pDecoder);
mal_result mal_decoder_init_memory_wav(const void* pData, size_t dataSize, const mal_decoder_config* pConfig, mal_decoder* pDecoder);
mal_result mal_decoder_init_memory_flac(const void* pData, size_t dataSize, const mal_decoder_config* pConfig, mal_decoder* pDecoder);
mal_result mal_decoder_init_memory_vorbis(const void* pData, size_t dataSize, const mal_decoder_config* pConfig, mal_decoder* pDecoder);
mal_result mal_decoder_init_memory_mp3(const void* pData, size_t dataSize, const mal_decoder_config* pConfig, mal_decoder* pDecoder);
mal_result mal_decoder_init_memory_raw(const void* pData, size_t dataSize, const mal_decoder_config* pConfigIn, const mal_decoder_config* pConfigOut, mal_decoder* pDecoder);

#ifndef MAL_NO_STDIO
mal_result mal_decoder_init_file(const char* pFilePath, const mal_decoder_config* pConfig, mal_decoder* pDecoder);
mal_result mal_decoder_init_file_wav(const char* pFilePath, const mal_decoder_config* pConfig, mal_decoder* pDecoder);
#endif

mal_result mal_decoder_uninit(mal_decoder* pDecoder);

mal_uint64 mal_decoder_read_pcm_frames(mal_decoder* pDecoder, void* pFramesOut, mal_uint64 frameCount);
mal_result mal_decoder_seek_to_pcm_frame(mal_decoder* pDecoder, mal_uint64 frameIndex);


// Helper for opening and decoding a file into a heap allocated block of memory. Free the returned pointer with mal_free(). On input,
// pConfig should be set to what you want. On output it will be set to what you got.
#ifndef MAL_NO_STDIO
mal_result mal_decode_file(const char* pFilePath, mal_decoder_config* pConfig, mal_uint64* pFrameCountOut, void** ppDataOut);
#endif
mal_result mal_decode_memory(const void* pData, size_t dataSize, mal_decoder_config* pConfig, mal_uint64* pFrameCountOut, void** ppDataOut);

#endif  // MAL_NO_DECODING


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Generation
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
    double amplitude;
    double periodsPerSecond;
    double delta;
    double time;
} mal_sine_wave;

mal_result mal_sine_wave_init(double amplitude, double period, mal_uint32 sampleRate, mal_sine_wave* pSineWave);
mal_uint64 mal_sine_wave_read_f32(mal_sine_wave* pSineWave, mal_uint64 count, float* pSamples);
mal_uint64 mal_sine_wave_read_f32_ex(mal_sine_wave* pSineWave, mal_uint64 frameCount, mal_uint32 channels, mal_stream_layout layout, float** ppFrames);


#ifdef __cplusplus
}
#endif
#endif  //mini_al_h


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// IMPLEMENTATION
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#if defined(MINI_AL_IMPLEMENTATION) || defined(MAL_IMPLEMENTATION)
#include <assert.h>
#include <limits.h> // For INT_MAX
#include <math.h>   // sin(), etc.

#if defined(MAL_DEBUG_OUTPUT)
#include <stdio.h>  // for printf() for debug output
#endif

#ifdef MAL_WIN32
#include <windows.h>
#include <objbase.h>
#include <mmreg.h>
#include <mmsystem.h>
#else
#include <stdlib.h> // For malloc()/free()
#include <string.h> // For memset()
#endif

#if defined(MAL_APPLE) && (__MAC_OS_X_VERSION_MIN_REQUIRED < 101200)
#include <mach/mach_time.h> // For mach_absolute_time()
#endif

#ifdef MAL_POSIX
#include <unistd.h>
#include <dlfcn.h>
#endif

#ifdef MAL_EMSCRIPTEN
#include <emscripten/emscripten.h>
#endif

#if !defined(MAL_64BIT) && !defined(MAL_32BIT)
#ifdef _WIN32
#ifdef _WIN64
#define MAL_64BIT
#else
#define MAL_32BIT
#endif
#endif
#endif

#if !defined(MAL_64BIT) && !defined(MAL_32BIT)
#ifdef __GNUC__
#ifdef __LP64__
#define MAL_64BIT
#else
#define MAL_32BIT
#endif
#endif
#endif

#if !defined(MAL_64BIT) && !defined(MAL_32BIT)
#include <stdint.h>
#if INTPTR_MAX == INT64_MAX
#define MAL_64BIT
#else
#define MAL_32BIT
#endif
#endif

// Architecture Detection
#if defined(__x86_64__) || defined(_M_X64)
#define MAL_X64
#elif defined(__i386) || defined(_M_IX86)
#define MAL_X86
#elif defined(__arm__) || defined(_M_ARM)
#define MAL_ARM
#endif

// Cannot currently support AVX-512 if AVX is disabled.
#if !defined(MAL_NO_AVX512) && defined(MAL_NO_AVX2)
#define MAL_NO_AVX512
#endif

// Intrinsics Support
#if defined(MAL_X64) || defined(MAL_X86)
    #if defined(_MSC_VER) && !defined(__clang__)
        // MSVC.
        #if !defined(MAL_NO_SSE2)   // Assume all MSVC compilers support SSE2 intrinsics.
            #define MAL_SUPPORT_SSE2
        #endif
        //#if _MSC_VER >= 1600 && !defined(MAL_NO_AVX)    // 2010
        //    #define MAL_SUPPORT_AVX
        //#endif
        #if _MSC_VER >= 1700 && !defined(MAL_NO_AVX2)   // 2012
            #define MAL_SUPPORT_AVX2
        #endif
        #if _MSC_VER >= 1910 && !defined(MAL_NO_AVX512) // 2017
            #define MAL_SUPPORT_AVX512
        #endif
    #else
        // Assume GNUC-style.
        #if defined(__SSE2__) && !defined(MAL_NO_SSE2)
            #define MAL_SUPPORT_SSE2
        #endif
        //#if defined(__AVX__) && !defined(MAL_NO_AVX)
        //    #define MAL_SUPPORT_AVX
        //#endif
        #if defined(__AVX2__) && !defined(MAL_NO_AVX2)
            #define MAL_SUPPORT_AVX2
        #endif
        #if defined(__AVX512F__) && !defined(MAL_NO_AVX512)
            #define MAL_SUPPORT_AVX512
        #endif
    #endif

    // If at this point we still haven't determined compiler support for the intrinsics just fall back to __has_include.
    #if !defined(__GNUC__) && !defined(__clang__) && defined(__has_include)
        #if !defined(MAL_SUPPORT_SSE2)   && !defined(MAL_NO_SSE2)   && __has_include(<emmintrin.h>)
            #define MAL_SUPPORT_SSE2
        #endif
        //#if !defined(MAL_SUPPORT_AVX)    && !defined(MAL_NO_AVX)    && __has_include(<immintrin.h>)
        //    #define MAL_SUPPORT_AVX
        //#endif
        #if !defined(MAL_SUPPORT_AVX2)   && !defined(MAL_NO_AVX2)   && __has_include(<immintrin.h>)
            #define MAL_SUPPORT_AVX2
        #endif
        #if !defined(MAL_SUPPORT_AVX512) && !defined(MAL_NO_AVX512) && __has_include(<zmmintrin.h>)
            #define MAL_SUPPORT_AVX512
        #endif
    #endif

    #if defined(MAL_SUPPORT_AVX512)
        #include <immintrin.h>  // Not a mistake. Intentionally including <immintrin.h> instead of <zmmintrin.h> because otherwise the compiler will complain.
    #elif defined(MAL_SUPPORT_AVX2) || defined(MAL_SUPPORT_AVX)
        #include <immintrin.h>
    #elif defined(MAL_SUPPORT_SSE2)
        #include <emmintrin.h>
    #endif
#endif

#if defined(MAL_ARM)
    #if !defined(MAL_NO_NEON) && (defined(__ARM_NEON) || defined(__aarch64__) || defined(_M_ARM64))
        #define MAL_SUPPORT_NEON
    #endif

    // Fall back to looking for the #include file.
    #if !defined(__GNUC__) && !defined(__clang__) && defined(__has_include)
        #if !defined(MAL_SUPPORT_NEON) && !defined(MAL_NO_NEON) && __has_include(<arm_neon.h>)
            #define MAL_SUPPORT_NEON
        #endif
    #endif

    #if defined(MAL_SUPPORT_NEON)
        #include <arm_neon.h>
    #endif
#endif

#if defined(_MSC_VER)
    #pragma warning(push)
    #pragma warning(disable:4752)   // found Intel(R) Advanced Vector Extensions; consider using /arch:AVX
#endif

#if defined(MAL_X64) || defined(MAL_X86)
    #if defined(_MSC_VER) && !defined(__clang__)
        #if _MSC_VER >= 1400
            #include <intrin.h>
            static MAL_INLINE void mal_cpuid(int info[4], int fid)
            {
                __cpuid(info, fid);
            }
        #else
            #define MAL_NO_CPUID
        #endif

        #if _MSC_VER >= 1600
            static MAL_INLINE unsigned __int64 mal_xgetbv(int reg)
            {
                return _xgetbv(reg);
            }
        #else
            #define MAL_NO_XGETBV
        #endif
    #elif (defined(__GNUC__) || defined(__clang__)) && !defined(MAL_ANDROID)
        static MAL_INLINE void mal_cpuid(int info[4], int fid)
        {
            // It looks like the -fPIC option uses the ebx register which GCC complains about. We can work around this by just using a different register, the
            // specific register of which I'm letting the compiler decide on. The "k" prefix is used to specify a 32-bit register. The {...} syntax is for
            // supporting different assembly dialects.
            //
            // What's basically happening is that we're saving and restoring the ebx register manually.
            #if defined(DRFLAC_X86) && defined(__PIC__)
                __asm__ __volatile__ (
                    "xchg{l} {%%}ebx, %k1;"
                    "cpuid;"
                    "xchg{l} {%%}ebx, %k1;"
                    : "=a"(info[0]), "=&r"(info[1]), "=c"(info[2]), "=d"(info[3]) : "a"(fid), "c"(0)
                );
            #else
                __asm__ __volatile__ (
                    "cpuid" : "=a"(info[0]), "=b"(info[1]), "=c"(info[2]), "=d"(info[3]) : "a"(fid), "c"(0)
                );
            #endif
        }

        static MAL_INLINE unsigned long long mal_xgetbv(int reg)
        {
            unsigned int hi;
            unsigned int lo;

            __asm__ __volatile__ (
                "xgetbv" : "=a"(lo), "=d"(hi) : "c"(reg)
            );

            return ((unsigned long long)hi << 32ULL) | (unsigned long long)lo;
        }
    #else
        #define MAL_NO_CPUID
        #define MAL_NO_XGETBV
    #endif
#else
    #define MAL_NO_CPUID
    #define MAL_NO_XGETBV
#endif

static MAL_INLINE mal_bool32 mal_has_sse2()
{
#if defined(MAL_SUPPORT_SSE2)
    #if (defined(MAL_X64) || defined(MAL_X86)) && !defined(MAL_NO_SSE2)
        #if defined(MAL_X64)
            return MAL_TRUE;    // 64-bit targets always support SSE2.
        #elif (defined(_M_IX86_FP) && _M_IX86_FP == 2) || defined(__SSE2__)
            return MAL_TRUE;    // If the compiler is allowed to freely generate SSE2 code we can assume support.
        #else
            #if defined(MAL_NO_CPUID)
                return MAL_FALSE;
            #else
                int info[4];
                mal_cpuid(info, 1);
                return (info[3] & (1 << 26)) != 0;
            #endif
        #endif
    #else
        return MAL_FALSE;       // SSE2 is only supported on x86 and x64 architectures.
    #endif
#else
    return MAL_FALSE;           // No compiler support.
#endif
}

#if 0
static MAL_INLINE mal_bool32 mal_has_avx()
{
#if defined(MAL_SUPPORT_AVX)
    #if (defined(MAL_X64) || defined(MAL_X86)) && !defined(MAL_NO_AVX)
        #if defined(_AVX_) || defined(__AVX__)
            return MAL_TRUE;    // If the compiler is allowed to freely generate AVX code we can assume support.
        #else
            // AVX requires both CPU and OS support.
            #if defined(MAL_NO_CPUID) || defined(MAL_NO_XGETBV)
                return MAL_FALSE;
            #else
                int info[4];
                mal_cpuid(info, 1);
                if (((info[2] & (1 << 27)) != 0) && ((info[2] & (1 << 28)) != 0)) {
                    mal_uint64 xrc = mal_xgetbv(0);
                    if ((xrc & 0x06) == 0x06) {
                        return MAL_TRUE;
                    } else {
                        return MAL_FALSE;
                    }
                } else {
                    return MAL_FALSE;
                }
            #endif
        #endif
    #else
        return MAL_FALSE;       // AVX is only supported on x86 and x64 architectures.
    #endif
#else
    return MAL_FALSE;           // No compiler support.
#endif
}
#endif

static MAL_INLINE mal_bool32 mal_has_avx2()
{
#if defined(MAL_SUPPORT_AVX2)
    #if (defined(MAL_X64) || defined(MAL_X86)) && !defined(MAL_NO_AVX2)
        #if defined(_AVX2_) || defined(__AVX2__)
            return MAL_TRUE;    // If the compiler is allowed to freely generate AVX2 code we can assume support.
        #else
            // AVX2 requires both CPU and OS support.
            #if defined(MAL_NO_CPUID) || defined(MAL_NO_XGETBV)
                return MAL_FALSE;
            #else
                int info1[4];
                int info7[4];
                mal_cpuid(info1, 1);
                mal_cpuid(info7, 7);
                if (((info1[2] & (1 << 27)) != 0) && ((info7[1] & (1 << 5)) != 0)) {
                    mal_uint64 xrc = mal_xgetbv(0);
                    if ((xrc & 0x06) == 0x06) {
                        return MAL_TRUE;
                    } else {
                        return MAL_FALSE;
                    }
                } else {
                    return MAL_FALSE;
                }
            #endif
        #endif
    #else
        return MAL_FALSE;       // AVX2 is only supported on x86 and x64 architectures.
    #endif
#else
    return MAL_FALSE;           // No compiler support.
#endif
}

static MAL_INLINE mal_bool32 mal_has_avx512f()
{
#if defined(MAL_SUPPORT_AVX512)
    #if (defined(MAL_X64) || defined(MAL_X86)) && !defined(MAL_NO_AVX512)
        #if defined(__AVX512F__)
            return MAL_TRUE;    // If the compiler is allowed to freely generate AVX-512F code we can assume support.
        #else
            // AVX-512 requires both CPU and OS support.
            #if defined(MAL_NO_CPUID) || defined(MAL_NO_XGETBV)
                return MAL_FALSE;
            #else
                int info1[4];
                int info7[4];
                mal_cpuid(info1, 1);
                mal_cpuid(info7, 7);
                if (((info1[2] & (1 << 27)) != 0) && ((info7[1] & (1 << 16)) != 0)) {
                    mal_uint64 xrc = mal_xgetbv(0);
                    if ((xrc & 0xE6) == 0xE6) {
                        return MAL_TRUE;
                    } else {
                        return MAL_FALSE;
                    }
                } else {
                    return MAL_FALSE;
                }
            #endif
        #endif
    #else
        return MAL_FALSE;       // AVX-512F is only supported on x86 and x64 architectures.
    #endif
#else
    return MAL_FALSE;           // No compiler support.
#endif
}

static MAL_INLINE mal_bool32 mal_has_neon()
{
#if defined(MAL_SUPPORT_NEON)
    #if defined(MAL_ARM) && !defined(MAL_NO_NEON)
        #if (defined(__ARM_NEON) || defined(__aarch64__) || defined(_M_ARM64))
            return MAL_TRUE;    // If the compiler is allowed to freely generate NEON code we can assume support.
        #else
            // TODO: Runtime check.
            return MAL_FALSE;
        #endif
    #else
        return MAL_FALSE;       // NEON is only supported on ARM architectures.
    #endif
#else
    return MAL_FALSE;           // No compiler support.
#endif
}


static MAL_INLINE mal_bool32 mal_is_little_endian()
{
#if defined(MAL_X86) || defined(MAL_X64)
    return MAL_TRUE;
#else
    int n = 1;
    return (*(char*)&n) == 1;
#endif
}

static MAL_INLINE mal_bool32 mal_is_big_endian()
{
    return !mal_is_little_endian();
}


#ifndef MAL_COINIT_VALUE
#define MAL_COINIT_VALUE    0   /* 0 = COINIT_MULTITHREADED*/
#endif



#ifndef MAL_PI
#define MAL_PI      3.14159265358979323846264f
#endif
#ifndef MAL_PI_D
#define MAL_PI_D    3.14159265358979323846264
#endif
#ifndef MAL_TAU
#define MAL_TAU     6.28318530717958647693f
#endif
#ifndef MAL_TAU_D
#define MAL_TAU_D   6.28318530717958647693
#endif


// The default format when mal_format_unknown (0) is requested when initializing a device.
#ifndef MAL_DEFAULT_FORMAT
#define MAL_DEFAULT_FORMAT                                  mal_format_f32
#endif

// The default channel count to use when 0 is used when initializing a device.
#ifndef MAL_DEFAULT_CHANNELS
#define MAL_DEFAULT_CHANNELS                                2
#endif

// The default sample rate to use when 0 is used when initializing a device.
#ifndef MAL_DEFAULT_SAMPLE_RATE
#define MAL_DEFAULT_SAMPLE_RATE                             48000
#endif

// Default periods when none is specified in mal_device_init(). More periods means more work on the CPU.
#ifndef MAL_DEFAULT_PERIODS
#define MAL_DEFAULT_PERIODS                                 3
#endif

// The base buffer size in milliseconds for low latency mode.
#ifndef MAL_BASE_BUFFER_SIZE_IN_MILLISECONDS_LOW_LATENCY
#define MAL_BASE_BUFFER_SIZE_IN_MILLISECONDS_LOW_LATENCY    25
#endif

// The base buffer size in milliseconds for conservative mode.
#ifndef MAL_BASE_BUFFER_SIZE_IN_MILLISECONDS_CONSERVATIVE
#define MAL_BASE_BUFFER_SIZE_IN_MILLISECONDS_CONSERVATIVE   150
#endif


// Standard sample rates, in order of priority.
mal_uint32 g_malStandardSampleRatePriorities[] = {
    MAL_SAMPLE_RATE_48000,  // Most common
    MAL_SAMPLE_RATE_44100,

    MAL_SAMPLE_RATE_32000,  // Lows
    MAL_SAMPLE_RATE_24000,
    MAL_SAMPLE_RATE_22050,

    MAL_SAMPLE_RATE_88200,  // Highs
    MAL_SAMPLE_RATE_96000,
    MAL_SAMPLE_RATE_176400,
    MAL_SAMPLE_RATE_192000,

    MAL_SAMPLE_RATE_16000,  // Extreme lows
    MAL_SAMPLE_RATE_11025,
    MAL_SAMPLE_RATE_8000,

    MAL_SAMPLE_RATE_352800, // Extreme highs
    MAL_SAMPLE_RATE_384000
};

mal_format g_malFormatPriorities[] = {
    mal_format_s16,         // Most common
    mal_format_f32,
    
    //mal_format_s24_32,    // Clean alignment
    mal_format_s32,
    
    mal_format_s24,         // Unclean alignment
    
    mal_format_u8           // Low quality
};



///////////////////////////////////////////////////////////////////////////////
//
// Standard Library Stuff
//
///////////////////////////////////////////////////////////////////////////////
#ifndef MAL_MALLOC
#ifdef MAL_WIN32
#define MAL_MALLOC(sz) HeapAlloc(GetProcessHeap(), 0, (sz))
#else
#define MAL_MALLOC(sz) malloc((sz))
#endif
#endif

#ifndef MAL_REALLOC
#ifdef MAL_WIN32
#define MAL_REALLOC(p, sz) (((sz) > 0) ? ((p) ? HeapReAlloc(GetProcessHeap(), 0, (p), (sz)) : HeapAlloc(GetProcessHeap(), 0, (sz))) : ((VOID*)(size_t)(HeapFree(GetProcessHeap(), 0, (p)) & 0)))
#else
#define MAL_REALLOC(p, sz) realloc((p), (sz))
#endif
#endif

#ifndef MAL_FREE
#ifdef MAL_WIN32
#define MAL_FREE(p) HeapFree(GetProcessHeap(), 0, (p))
#else
#define MAL_FREE(p) free((p))
#endif
#endif

#ifndef MAL_ZERO_MEMORY
#ifdef MAL_WIN32
#define MAL_ZERO_MEMORY(p, sz) ZeroMemory((p), (sz))
#else
#define MAL_ZERO_MEMORY(p, sz) memset((p), 0, (sz))
#endif
#endif

#ifndef MAL_COPY_MEMORY
#ifdef MAL_WIN32
#define MAL_COPY_MEMORY(dst, src, sz) CopyMemory((dst), (src), (sz))
#else
#define MAL_COPY_MEMORY(dst, src, sz) memcpy((dst), (src), (sz))
#endif
#endif

#ifndef MAL_ASSERT
#ifdef MAL_WIN32
#define MAL_ASSERT(condition) assert(condition)
#else
#define MAL_ASSERT(condition) assert(condition)
#endif
#endif

#define mal_zero_memory MAL_ZERO_MEMORY
#define mal_copy_memory MAL_COPY_MEMORY
#define mal_assert      MAL_ASSERT

#define mal_zero_object(p)          mal_zero_memory((p), sizeof(*(p)))
#define mal_countof(x)              (sizeof(x) / sizeof(x[0]))
#define mal_max(x, y)               (((x) > (y)) ? (x) : (y))
#define mal_min(x, y)               (((x) < (y)) ? (x) : (y))
#define mal_clamp(x, lo, hi)        (mal_max(lo, mal_min(x, hi)))
#define mal_offset_ptr(p, offset)   (((mal_uint8*)(p)) + (offset))

#define mal_buffer_frame_capacity(buffer, channels, format) (sizeof(buffer) / mal_get_bytes_per_sample(format) / (channels))


// Return Values:
//   0:  Success
//   22: EINVAL
//   34: ERANGE
//
// Not using symbolic constants for errors because I want to avoid #including errno.h
int mal_strcpy_s(char* dst, size_t dstSizeInBytes, const char* src)
{
    if (dst == 0) {
        return 22;
    }
    if (dstSizeInBytes == 0) {
        return 34;
    }
    if (src == 0) {
        dst[0] = '\0';
        return 22;
    }

    size_t i;
    for (i = 0; i < dstSizeInBytes && src[i] != '\0'; ++i) {
        dst[i] = src[i];
    }

    if (i < dstSizeInBytes) {
        dst[i] = '\0';
        return 0;
    }

    dst[0] = '\0';
    return 34;
}

int mal_strncpy_s(char* dst, size_t dstSizeInBytes, const char* src, size_t count)
{
    if (dst == 0) {
        return 22;
    }
    if (dstSizeInBytes == 0) {
        return 34;
    }
    if (src == 0) {
        dst[0] = '\0';
        return 22;
    }

    size_t maxcount = count;
    if (count == ((size_t)-1) || count >= dstSizeInBytes) {        // -1 = _TRUNCATE
        maxcount = dstSizeInBytes - 1;
    }

    size_t i;
    for (i = 0; i < maxcount && src[i] != '\0'; ++i) {
        dst[i] = src[i];
    }

    if (src[i] == '\0' || i == count || count == ((size_t)-1)) {
        dst[i] = '\0';
        return 0;
    }

    dst[0] = '\0';
    return 34;
}

int mal_strcat_s(char* dst, size_t dstSizeInBytes, const char* src)
{
    if (dst == 0) {
        return 22;
    }
    if (dstSizeInBytes == 0) {
        return 34;
    }
    if (src == 0) {
        dst[0] = '\0';
        return 22;
    }

    char* dstorig = dst;

    while (dstSizeInBytes > 0 && dst[0] != '\0') {
        dst += 1;
        dstSizeInBytes -= 1;
    }

    if (dstSizeInBytes == 0) {
        return 22;  // Unterminated.
    }


    while (dstSizeInBytes > 0 && src[0] != '\0') {
        *dst++ = *src++;
        dstSizeInBytes -= 1;
    }

    if (dstSizeInBytes > 0) {
        dst[0] = '\0';
    } else {
        dstorig[0] = '\0';
        return 34;
    }

    return 0;
}

int mal_itoa_s(int value, char* dst, size_t dstSizeInBytes, int radix)
{
    if (dst == NULL || dstSizeInBytes == 0) {
        return 22;
    }
    if (radix < 2 || radix > 36) {
        dst[0] = '\0';
        return 22;
    }

    int sign = (value < 0 && radix == 10) ? -1 : 1;     // The negative sign is only used when the base is 10.

    unsigned int valueU;
    if (value < 0) {
        valueU = -value;
    } else {
        valueU = value;
    }

    char* dstEnd = dst;
    do
    {
        int remainder = valueU % radix;
        if (remainder > 9) {
            *dstEnd = (char)((remainder - 10) + 'a');
        } else {
            *dstEnd = (char)(remainder + '0');
        }

        dstEnd += 1;
        dstSizeInBytes -= 1;
        valueU /= radix;
    } while (dstSizeInBytes > 0 && valueU > 0);

    if (dstSizeInBytes == 0) {
        dst[0] = '\0';
        return 22;  // Ran out of room in the output buffer.
    }

    if (sign < 0) {
        *dstEnd++ = '-';
        dstSizeInBytes -= 1;
    }

    if (dstSizeInBytes == 0) {
        dst[0] = '\0';
        return 22;  // Ran out of room in the output buffer.
    }

    *dstEnd = '\0';


    // At this point the string will be reversed.
    dstEnd -= 1;
    while (dst < dstEnd) {
        char temp = *dst;
        *dst = *dstEnd;
        *dstEnd = temp;

        dst += 1;
        dstEnd -= 1;
    }

    return 0;
}

int mal_strcmp(const char* str1, const char* str2)
{
    if (str1 == str2) return  0;

    // These checks differ from the standard implementation. It's not important, but I prefer
    // it just for sanity.
    if (str1 == NULL) return -1;
    if (str2 == NULL) return  1;

    for (;;) {
        if (str1[0] == '\0') {
            break;
        }
        if (str1[0] != str2[0]) {
            break;
        }

        str1 += 1;
        str2 += 1;
    }

    return ((unsigned char*)str1)[0] - ((unsigned char*)str2)[0];
}


// Thanks to good old Bit Twiddling Hacks for this one: http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
static MAL_INLINE unsigned int mal_next_power_of_2(unsigned int x)
{
    x--;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x++;

    return x;
}

static MAL_INLINE unsigned int mal_prev_power_of_2(unsigned int x)
{
    return mal_next_power_of_2(x) >> 1;
}

static MAL_INLINE unsigned int mal_round_to_power_of_2(unsigned int x)
{
    unsigned int prev = mal_prev_power_of_2(x);
    unsigned int next = mal_next_power_of_2(x);
    if ((next - x) > (x - prev)) {
        return prev;
    } else {
        return next;
    }
}

static MAL_INLINE unsigned int mal_count_set_bits(unsigned int x)
{
    unsigned int count = 0;
    while (x != 0) {
        if (x & 1) {
            count += 1;
        }
        
        x = x >> 1;
    }
    
    return count;
}



// Clamps an f32 sample to -1..1
static MAL_INLINE float mal_clip_f32(float x)
{
    if (x < -1) return -1;
    if (x > +1) return +1;
    return x;
}

static MAL_INLINE float mal_mix_f32(float x, float y, float a)
{
    return x*(1-a) + y*a;
}
static MAL_INLINE float mal_mix_f32_fast(float x, float y, float a)
{
    float r0 = (y - x);
    float r1 = r0*a;
    return x + r1;
    //return x + (y - x)*a;
}

#if defined(MAL_SUPPORT_SSE2)
static MAL_INLINE __m128 mal_mix_f32_fast__sse2(__m128 x, __m128 y, __m128 a)
{
    return _mm_add_ps(x, _mm_mul_ps(_mm_sub_ps(y, x), a));
}
#endif
#if defined(MAL_SUPPORT_AVX2)
static MAL_INLINE __m256 mal_mix_f32_fast__avx2(__m256 x, __m256 y, __m256 a)
{
    return _mm256_add_ps(x, _mm256_mul_ps(_mm256_sub_ps(y, x), a));
}
#endif
#if defined(MAL_SUPPORT_AVX512)
static MAL_INLINE __m512 mal_mix_f32_fast__avx512(__m512 x, __m512 y, __m512 a)
{
    return _mm512_add_ps(x, _mm512_mul_ps(_mm512_sub_ps(y, x), a));
}
#endif
#if defined(MAL_SUPPORT_NEON)
static MAL_INLINE float32x4_t mal_mix_f32_fast__neon(float32x4_t x, float32x4_t y, float32x4_t a)
{
    return vaddq_f32(x, vmulq_f32(vsubq_f32(y, x), a));
}
#endif


static MAL_INLINE double mal_mix_f64(double x, double y, double a)
{
    return x*(1-a) + y*a;
}
static MAL_INLINE double mal_mix_f64_fast(double x, double y, double a)
{
    return x + (y - x)*a;
}

static MAL_INLINE float mal_scale_to_range_f32(float x, float lo, float hi)
{
    return lo + x*(hi-lo);
}



// Random Number Generation
//
// mini_al uses the LCG random number generation algorithm. This is good enough for audio.
//
// Note that mini_al's LCG implementation uses global state which is _not_ thread-local. When this is called across
// multiple threads, results will be unpredictable. However, it won't crash and results will still be random enough
// for mini_al's purposes.
#define MAL_LCG_M   4294967296
#define MAL_LCG_A   1103515245
#define MAL_LCG_C   12345
static mal_int32 g_malLCG;

void mal_seed(mal_int32 seed)
{
    g_malLCG = seed;
}

mal_int32 mal_rand_s32()
{
    mal_int32 lcg = g_malLCG;
    mal_int32 r = (MAL_LCG_A * lcg + MAL_LCG_C) % MAL_LCG_M;
    g_malLCG = r;
    return r;
}

double mal_rand_f64()
{
    return (mal_rand_s32() + 0x80000000) / (double)0x7FFFFFFF;
}

float mal_rand_f32()
{
    return (float)mal_rand_f64();
}

static MAL_INLINE float mal_rand_range_f32(float lo, float hi)
{
    return mal_scale_to_range_f32(mal_rand_f32(), lo, hi);
}

static MAL_INLINE mal_int32 mal_rand_range_s32(mal_int32 lo, mal_int32 hi)
{
    double x = mal_rand_f64();
    return lo + (mal_int32)(x*(hi-lo));
}


static MAL_INLINE float mal_dither_f32_rectangle(float ditherMin, float ditherMax)
{
    return mal_rand_range_f32(ditherMin, ditherMax);
}

static MAL_INLINE float mal_dither_f32_triangle(float ditherMin, float ditherMax)
{
    float a = mal_rand_range_f32(ditherMin, 0);
    float b = mal_rand_range_f32(0, ditherMax);
    return a + b;
}

static MAL_INLINE float mal_dither_f32(mal_dither_mode ditherMode, float ditherMin, float ditherMax)
{
    if (ditherMode == mal_dither_mode_rectangle) {
        return mal_dither_f32_rectangle(ditherMin, ditherMax);
    }
    if (ditherMode == mal_dither_mode_triangle) {
        return mal_dither_f32_triangle(ditherMin, ditherMax);
    }

    return 0;
}

static MAL_INLINE mal_int32 mal_dither_s32(mal_dither_mode ditherMode, mal_int32 ditherMin, mal_int32 ditherMax)
{
    if (ditherMode == mal_dither_mode_rectangle) {
        mal_int32 a = mal_rand_range_s32(ditherMin, ditherMax);
        return a;
    }
    if (ditherMode == mal_dither_mode_triangle) {
        mal_int32 a = mal_rand_range_s32(ditherMin, 0);
        mal_int32 b = mal_rand_range_s32(0, ditherMax);
        return a + b;
    }

    return 0;
}


// Splits a buffer into parts of equal length and of the given alignment. The returned size of the split buffers will be a
// multiple of the alignment. The alignment must be a power of 2.
void mal_split_buffer(void* pBuffer, size_t bufferSize, size_t splitCount, size_t alignment, void** ppBuffersOut, size_t* pSplitSizeOut)
{
    if (pSplitSizeOut) {
        *pSplitSizeOut = 0;
    }

    if (pBuffer == NULL || bufferSize == 0 || splitCount == 0) {
        return;
    }

    if (alignment == 0) {
        alignment = 1;
    }

    mal_uintptr pBufferUnaligned = (mal_uintptr)pBuffer;
    mal_uintptr pBufferAligned = (pBufferUnaligned + (alignment-1)) & ~(alignment-1);
    size_t unalignedBytes = (size_t)(pBufferAligned - pBufferUnaligned);

    size_t splitSize = 0;
    if (bufferSize >= unalignedBytes) {
        splitSize = (bufferSize - unalignedBytes) / splitCount;
        splitSize = splitSize & ~(alignment-1);
    }

    if (ppBuffersOut != NULL) {
        for (size_t i = 0; i < splitCount; ++i) {
            ppBuffersOut[i] = (mal_uint8*)(pBufferAligned + (splitSize*i));
        }
    }

    if (pSplitSizeOut) {
        *pSplitSizeOut = splitSize;
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// Atomics
//
///////////////////////////////////////////////////////////////////////////////
#if defined(_WIN32) && !defined(__GNUC__)
#define mal_memory_barrier()            MemoryBarrier()
#define mal_atomic_exchange_32(a, b)    InterlockedExchange((LONG*)a, (LONG)b)
#define mal_atomic_exchange_64(a, b)    InterlockedExchange64((LONGLONG*)a, (LONGLONG)b)
#define mal_atomic_increment_32(a)      InterlockedIncrement((LONG*)a)
#define mal_atomic_decrement_32(a)      InterlockedDecrement((LONG*)a)
#else
#define mal_memory_barrier()            __sync_synchronize()
#define mal_atomic_exchange_32(a, b)    (void)__sync_lock_test_and_set(a, b); __sync_synchronize()
#define mal_atomic_exchange_64(a, b)    (void)__sync_lock_test_and_set(a, b); __sync_synchronize()
#define mal_atomic_increment_32(a)      __sync_add_and_fetch(a, 1)
#define mal_atomic_decrement_32(a)      __sync_sub_and_fetch(a, 1)
#endif

#ifdef MAL_64BIT
#define mal_atomic_exchange_ptr mal_atomic_exchange_64
#endif
#ifdef MAL_32BIT
#define mal_atomic_exchange_ptr mal_atomic_exchange_32
#endif


mal_uint32 mal_get_standard_sample_rate_priority_index(mal_uint32 sampleRate)   // Lower = higher priority
{
    for (mal_uint32 i = 0; i < mal_countof(g_malStandardSampleRatePriorities); ++i) {
        if (g_malStandardSampleRatePriorities[i] == sampleRate) {
            return i;
        }
    }

    return (mal_uint32)-1;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// DEVICE I/O
// ==========
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef MAL_NO_DEVICE_IO
// Unfortunately using runtime linking for pthreads causes problems. This has occurred for me when testing on FreeBSD. When
// using runtime linking, deadlocks can occur (for me it happens when loading data from fread()). It turns out that doing
// compile-time linking fixes this. I'm not sure why this happens, but the safest way I can think of to fix this is to simply
// disable runtime linking by default. To enable runtime linking, #define this before the implementation of this file. I am
// not officially supporting this, but I'm leaving it here in case it's useful for somebody, somewhere.
//#define MAL_USE_RUNTIME_LINKING_FOR_PTHREAD

// Disable run-time linking on certain backends.
#ifndef MAL_NO_RUNTIME_LINKING
    #if defined(MAL_ANDROID) || defined(MAL_EMSCRIPTEN)
        #define MAL_NO_RUNTIME_LINKING
    #endif
#endif

// Check if we have the necessary development packages for each backend at the top so we can use this to determine whether or not
// certain unused functions and variables can be excluded from the build to avoid warnings.
#ifdef MAL_ENABLE_WASAPI
    #define MAL_HAS_WASAPI      // Every compiler should support WASAPI
#endif
#ifdef MAL_ENABLE_DSOUND
    #define MAL_HAS_DSOUND      // Every compiler should support DirectSound.
#endif
#ifdef MAL_ENABLE_WINMM
    #define MAL_HAS_WINMM       // Every compiler I'm aware of supports WinMM.
#endif
#ifdef MAL_ENABLE_ALSA
    #define MAL_HAS_ALSA
    #ifdef MAL_NO_RUNTIME_LINKING
        #ifdef __has_include
            #if !__has_include(<alsa/asoundlib.h>)
                #undef MAL_HAS_ALSA
            #endif
        #endif
    #endif
#endif
#ifdef MAL_ENABLE_PULSEAUDIO
    #define MAL_HAS_PULSEAUDIO
    #ifdef MAL_NO_RUNTIME_LINKING
        #ifdef __has_include
            #if !__has_include(<pulse/pulseaudio.h>)
                #undef MAL_HAS_PULSEAUDIO
            #endif
        #endif
    #endif
#endif
#ifdef MAL_ENABLE_JACK
    #define MAL_HAS_JACK
    #ifdef MAL_NO_RUNTIME_LINKING
        #ifdef __has_include
            #if !__has_include(<jack/jack.h>)
                #undef MAL_HAS_JACK
            #endif
        #endif
    #endif
#endif
#ifdef MAL_ENABLE_COREAUDIO
    #define MAL_HAS_COREAUDIO
#endif
#ifdef MAL_ENABLE_SNDIO
    #define MAL_HAS_SNDIO
#endif
#ifdef MAL_ENABLE_AUDIO4
    #define MAL_HAS_AUDIO4
#endif
#ifdef MAL_ENABLE_OSS
    #define MAL_HAS_OSS
#endif
#ifdef MAL_ENABLE_AAUDIO
    #define MAL_HAS_AAUDIO
#endif
#ifdef MAL_ENABLE_OPENSL
    #define MAL_HAS_OPENSL
#endif
#ifdef MAL_ENABLE_WEBAUDIO
    #define MAL_HAS_WEBAUDIO
#endif
#ifdef MAL_ENABLE_NULL
    #define MAL_HAS_NULL    // Everything supports the null backend.
#endif

const char* mal_get_backend_name(mal_backend backend)
{
    switch (backend)
    {
        case mal_backend_wasapi:     return "WASAPI";
        case mal_backend_dsound:     return "DirectSound";
        case mal_backend_winmm:      return "WinMM";
        case mal_backend_coreaudio:  return "Core Audio";
        case mal_backend_sndio:      return "sndio";
        case mal_backend_audio4:     return "audio(4)";
        case mal_backend_oss:        return "OSS";
        case mal_backend_pulseaudio: return "PulseAudio";
        case mal_backend_alsa:       return "ALSA";
        case mal_backend_jack:       return "JACK";
        case mal_backend_aaudio:     return "AAudio";
        case mal_backend_opensl:     return "OpenSL|ES";
        case mal_backend_webaudio:   return "Web Audio";
        case mal_backend_null:       return "Null";
        default:                     return "Unknown";
    }
}



#ifdef MAL_WIN32
    #define MAL_THREADCALL WINAPI
    typedef unsigned long mal_thread_result;
#else
    #define MAL_THREADCALL
    typedef void* mal_thread_result;
#endif
typedef mal_thread_result (MAL_THREADCALL * mal_thread_entry_proc)(void* pData);

#ifdef MAL_WIN32
typedef HRESULT (WINAPI * MAL_PFN_CoInitializeEx)(LPVOID pvReserved, DWORD  dwCoInit);
typedef void    (WINAPI * MAL_PFN_CoUninitialize)();
typedef HRESULT (WINAPI * MAL_PFN_CoCreateInstance)(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv);
typedef void    (WINAPI * MAL_PFN_CoTaskMemFree)(LPVOID pv);
typedef HRESULT (WINAPI * MAL_PFN_PropVariantClear)(PROPVARIANT *pvar);
typedef int     (WINAPI * MAL_PFN_StringFromGUID2)(const GUID* const rguid, LPOLESTR lpsz, int cchMax);

typedef HWND (WINAPI * MAL_PFN_GetForegroundWindow)();
typedef HWND (WINAPI * MAL_PFN_GetDesktopWindow)();

// Microsoft documents these APIs as returning LSTATUS, but the Win32 API shipping with some compilers do not define it. It's just a LONG.
typedef LONG (WINAPI * MAL_PFN_RegOpenKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
typedef LONG (WINAPI * MAL_PFN_RegCloseKey)(HKEY hKey);
typedef LONG (WINAPI * MAL_PFN_RegQueryValueExA)(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
#endif


#define MAL_STATE_UNINITIALIZED     0
#define MAL_STATE_STOPPED           1   // The device's default state after initialization.
#define MAL_STATE_STARTED           2   // The worker thread is in it's main loop waiting for the driver to request or deliver audio data.
#define MAL_STATE_STARTING          3   // Transitioning from a stopped state to started.
#define MAL_STATE_STOPPING          4   // Transitioning from a started state to stopped.

#define MAL_DEFAULT_PLAYBACK_DEVICE_NAME    "Default Playback Device"
#define MAL_DEFAULT_CAPTURE_DEVICE_NAME     "Default Capture Device"


///////////////////////////////////////////////////////////////////////////////
//
// Timing
//
///////////////////////////////////////////////////////////////////////////////
#ifdef MAL_WIN32
LARGE_INTEGER g_mal_TimerFrequency = {{0}};
void mal_timer_init(mal_timer* pTimer)
{
    if (g_mal_TimerFrequency.QuadPart == 0) {
        QueryPerformanceFrequency(&g_mal_TimerFrequency);
    }

    LARGE_INTEGER counter;
    QueryPerformanceCounter(&counter);
    pTimer->counter = counter.QuadPart;
}

double mal_timer_get_time_in_seconds(mal_timer* pTimer)
{
    LARGE_INTEGER counter;
    if (!QueryPerformanceCounter(&counter)) {
        return 0;
    }

    return (double)(counter.QuadPart - pTimer->counter) / g_mal_TimerFrequency.QuadPart;
}
#elif defined(MAL_APPLE) && (__MAC_OS_X_VERSION_MIN_REQUIRED < 101200)
mal_uint64 g_mal_TimerFrequency = 0;
void mal_timer_init(mal_timer* pTimer)
{
    mach_timebase_info_data_t baseTime;
    mach_timebase_info(&baseTime);
    g_mal_TimerFrequency = (baseTime.denom * 1e9) / baseTime.numer;

    pTimer->counter = mach_absolute_time();
}

double mal_timer_get_time_in_seconds(mal_timer* pTimer)
{
    mal_uint64 newTimeCounter = mach_absolute_time();
    mal_uint64 oldTimeCounter = pTimer->counter;

    return (newTimeCounter - oldTimeCounter) / g_mal_TimerFrequency;
}
#elif defined(MAL_EMSCRIPTEN)
void mal_timer_init(mal_timer* pTimer)
{
    pTimer->counterD = emscripten_get_now();
}

double mal_timer_get_time_in_seconds(mal_timer* pTimer)
{
    return (emscripten_get_now() - pTimer->counterD) / 1000;    /* Emscripten is in milliseconds. */
}
#else
#if defined(CLOCK_MONOTONIC)
    #define MAL_CLOCK_ID CLOCK_MONOTONIC
#else
    #define MAL_CLOCK_ID CLOCK_REALTIME
#endif

void mal_timer_init(mal_timer* pTimer)
{
    struct timespec newTime;
    clock_gettime(MAL_CLOCK_ID, &newTime);

    pTimer->counter = (newTime.tv_sec * 1000000000) + newTime.tv_nsec;
}

double mal_timer_get_time_in_seconds(mal_timer* pTimer)
{
    struct timespec newTime;
    clock_gettime(MAL_CLOCK_ID, &newTime);

    mal_uint64 newTimeCounter = (newTime.tv_sec * 1000000000) + newTime.tv_nsec;
    mal_uint64 oldTimeCounter = pTimer->counter;

    return (newTimeCounter - oldTimeCounter) / 1000000000.0;
}
#endif


///////////////////////////////////////////////////////////////////////////////
//
// Dynamic Linking
//
///////////////////////////////////////////////////////////////////////////////
mal_handle mal_dlopen(const char* filename)
{
#ifdef _WIN32
#ifdef MAL_WIN32_DESKTOP
    return (mal_handle)LoadLibraryA(filename);
#else
    // *sigh* It appears there is no ANSI version of LoadPackagedLibrary()...
    WCHAR filenameW[4096];
    if (MultiByteToWideChar(CP_UTF8, 0, filename, -1, filenameW, sizeof(filenameW)) == 0) {
        return NULL;
    }

    return (mal_handle)LoadPackagedLibrary(filenameW, 0);
#endif
#else
    return (mal_handle)dlopen(filename, RTLD_NOW);
#endif
}

void mal_dlclose(mal_handle handle)
{
#ifdef _WIN32
    FreeLibrary((HMODULE)handle);
#else
    dlclose((void*)handle);
#endif
}

mal_proc mal_dlsym(mal_handle handle, const char* symbol)
{
#ifdef _WIN32
    return (mal_proc)GetProcAddress((HMODULE)handle, symbol);
#else
    return (mal_proc)dlsym((void*)handle, symbol);
#endif
}


///////////////////////////////////////////////////////////////////////////////
//
// Threading
//
///////////////////////////////////////////////////////////////////////////////
#ifdef MAL_WIN32
int mal_thread_priority_to_win32(mal_thread_priority priority)
{
    switch (priority) {
        case mal_thread_priority_idle:     return THREAD_PRIORITY_IDLE;
        case mal_thread_priority_lowest:   return THREAD_PRIORITY_LOWEST;
        case mal_thread_priority_low:      return THREAD_PRIORITY_BELOW_NORMAL;
        case mal_thread_priority_normal:   return THREAD_PRIORITY_NORMAL;
        case mal_thread_priority_high:     return THREAD_PRIORITY_ABOVE_NORMAL;
        case mal_thread_priority_highest:  return THREAD_PRIORITY_HIGHEST;
        case mal_thread_priority_realtime: return THREAD_PRIORITY_TIME_CRITICAL;
        default: return mal_thread_priority_normal;
    }
}

mal_result mal_thread_create__win32(mal_context* pContext, mal_thread* pThread, mal_thread_entry_proc entryProc, void* pData)
{
    pThread->win32.hThread = CreateThread(NULL, 0, entryProc, pData, 0, NULL);
    if (pThread->win32.hThread == NULL) {
        return MAL_FAILED_TO_CREATE_THREAD;
    }

    SetThreadPriority((HANDLE)pThread->win32.hThread, mal_thread_priority_to_win32(pContext->config.threadPriority));

    return MAL_SUCCESS;
}

void mal_thread_wait__win32(mal_thread* pThread)
{
    WaitForSingleObject(pThread->win32.hThread, INFINITE);
}

void mal_sleep__win32(mal_uint32 milliseconds)
{
    Sleep((DWORD)milliseconds);
}


mal_result mal_mutex_init__win32(mal_context* pContext, mal_mutex* pMutex)
{
    (void)pContext;

    pMutex->win32.hMutex = CreateEventA(NULL, FALSE, TRUE, NULL);
    if (pMutex->win32.hMutex == NULL) {
        return MAL_FAILED_TO_CREATE_MUTEX;
    }

    return MAL_SUCCESS;
}

void mal_mutex_uninit__win32(mal_mutex* pMutex)
{
    CloseHandle(pMutex->win32.hMutex);
}

void mal_mutex_lock__win32(mal_mutex* pMutex)
{
    WaitForSingleObject(pMutex->win32.hMutex, INFINITE);
}

void mal_mutex_unlock__win32(mal_mutex* pMutex)
{
    SetEvent(pMutex->win32.hMutex);
}


mal_result mal_event_init__win32(mal_context* pContext, mal_event* pEvent)
{
    (void)pContext;

    pEvent->win32.hEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
    if (pEvent->win32.hEvent == NULL) {
        return MAL_FAILED_TO_CREATE_EVENT;
    }

    return MAL_SUCCESS;
}

void mal_event_uninit__win32(mal_event* pEvent)
{
    CloseHandle(pEvent->win32.hEvent);
}

mal_bool32 mal_event_wait__win32(mal_event* pEvent)
{
    return WaitForSingleObject(pEvent->win32.hEvent, INFINITE) == WAIT_OBJECT_0;
}

mal_bool32 mal_event_signal__win32(mal_event* pEvent)
{
    return SetEvent(pEvent->win32.hEvent);
}
#endif


#ifdef MAL_POSIX
#include <sched.h>

typedef int (* mal_pthread_create_proc)(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
typedef int (* mal_pthread_join_proc)(pthread_t thread, void **retval);
typedef int (* mal_pthread_mutex_init_proc)(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr);
typedef int (* mal_pthread_mutex_destroy_proc)(pthread_mutex_t *__mutex);
typedef int (* mal_pthread_mutex_lock_proc)(pthread_mutex_t *__mutex);
typedef int (* mal_pthread_mutex_unlock_proc)(pthread_mutex_t *__mutex);
typedef int (* mal_pthread_cond_init_proc)(pthread_cond_t *__restrict __cond, const pthread_condattr_t *__restrict __cond_attr);
typedef int (* mal_pthread_cond_destroy_proc)(pthread_cond_t *__cond);
typedef int (* mal_pthread_cond_signal_proc)(pthread_cond_t *__cond);
typedef int (* mal_pthread_cond_wait_proc)(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex);
typedef int (* mal_pthread_attr_init_proc)(pthread_attr_t *attr);
typedef int (* mal_pthread_attr_destroy_proc)(pthread_attr_t *attr);
typedef int (* mal_pthread_attr_setschedpolicy_proc)(pthread_attr_t *attr, int policy);
typedef int (* mal_pthread_attr_getschedparam_proc)(const pthread_attr_t *attr, struct sched_param *param);
typedef int (* mal_pthread_attr_setschedparam_proc)(pthread_attr_t *attr, const struct sched_param *param);

mal_bool32 mal_thread_create__posix(mal_context* pContext, mal_thread* pThread, mal_thread_entry_proc entryProc, void* pData)
{
    pthread_attr_t* pAttr = NULL;

#if !defined(__EMSCRIPTEN__)
    // Try setting the thread priority. It's not critical if anything fails here.
    pthread_attr_t attr;
    if (((mal_pthread_attr_init_proc)pContext->posix.pthread_attr_init)(&attr) == 0) {
        int scheduler = -1;
        if (pContext->config.threadPriority == mal_thread_priority_idle) {
#ifdef SCHED_IDLE
            if (((mal_pthread_attr_setschedpolicy_proc)pContext->posix.pthread_attr_setschedpolicy)(&attr, SCHED_IDLE) == 0) {
                scheduler = SCHED_IDLE;
            }
#endif
        } else if (pContext->config.threadPriority == mal_thread_priority_realtime) {
#ifdef SCHED_FIFO
            if (((mal_pthread_attr_setschedpolicy_proc)pContext->posix.pthread_attr_setschedpolicy)(&attr, SCHED_FIFO) == 0) {
                scheduler = SCHED_FIFO;
            }
#endif
#ifdef MAL_LINUX
        } else {
            scheduler = sched_getscheduler(0);
#endif
        }

        if (scheduler != -1) {
            int priorityMin = sched_get_priority_min(scheduler);
            int priorityMax = sched_get_priority_max(scheduler);
            int priorityStep = (priorityMax - priorityMin) / 7;  // 7 = number of priorities supported by mini_al.

            struct sched_param sched;
            if (((mal_pthread_attr_getschedparam_proc)pContext->posix.pthread_attr_getschedparam)(&attr, &sched) == 0) {
                if (pContext->config.threadPriority == mal_thread_priority_idle) {
                    sched.sched_priority = priorityMin;
                } else if (pContext->config.threadPriority == mal_thread_priority_realtime) {
                    sched.sched_priority = priorityMax;
                } else {
                    sched.sched_priority += ((int)pContext->config.threadPriority + 5) * priorityStep;  // +5 because the lowest priority is -5.
                    if (sched.sched_priority < priorityMin) {
                        sched.sched_priority = priorityMin;
                    }
                    if (sched.sched_priority > priorityMax) {
                        sched.sched_priority = priorityMax;
                    }
                }

                if (((mal_pthread_attr_setschedparam_proc)pContext->posix.pthread_attr_setschedparam)(&attr, &sched) == 0) {
                    pAttr = &attr;
                }
            }
        }

        ((mal_pthread_attr_destroy_proc)pContext->posix.pthread_attr_destroy)(&attr);
    }
#endif

    int result = ((mal_pthread_create_proc)pContext->posix.pthread_create)(&pThread->posix.thread, pAttr, entryProc, pData);
    if (result != 0) {
        return MAL_FAILED_TO_CREATE_THREAD;
    }

    return MAL_SUCCESS;
}

void mal_thread_wait__posix(mal_thread* pThread)
{
    ((mal_pthread_join_proc)pThread->pContext->posix.pthread_join)(pThread->posix.thread, NULL);
}

void mal_sleep__posix(mal_uint32 milliseconds)
{
#ifdef MAL_EMSCRIPTEN
    (void)milliseconds;
    mal_assert(MAL_FALSE);  /* The Emscripten build should never sleep. */
#else
    usleep(milliseconds * 1000);    /* <-- usleep is in microseconds. */
#endif
}


mal_result mal_mutex_init__posix(mal_context* pContext, mal_mutex* pMutex)
{
    int result = ((mal_pthread_mutex_init_proc)pContext->posix.pthread_mutex_init)(&pMutex->posix.mutex, NULL);
    if (result != 0) {
        return MAL_FAILED_TO_CREATE_MUTEX;
    }

    return MAL_SUCCESS;
}

void mal_mutex_uninit__posix(mal_mutex* pMutex)
{
    ((mal_pthread_mutex_destroy_proc)pMutex->pContext->posix.pthread_mutex_destroy)(&pMutex->posix.mutex);
}

void mal_mutex_lock__posix(mal_mutex* pMutex)
{
    ((mal_pthread_mutex_lock_proc)pMutex->pContext->posix.pthread_mutex_lock)(&pMutex->posix.mutex);
}

void mal_mutex_unlock__posix(mal_mutex* pMutex)
{
    ((mal_pthread_mutex_unlock_proc)pMutex->pContext->posix.pthread_mutex_unlock)(&pMutex->posix.mutex);
}


mal_result mal_event_init__posix(mal_context* pContext, mal_event* pEvent)
{
    if (((mal_pthread_mutex_init_proc)pContext->posix.pthread_mutex_init)(&pEvent->posix.mutex, NULL) != 0) {
        return MAL_FAILED_TO_CREATE_MUTEX;
    }

    if (((mal_pthread_cond_init_proc)pContext->posix.pthread_cond_init)(&pEvent->posix.condition, NULL) != 0) {
        return MAL_FAILED_TO_CREATE_EVENT;
    }

    pEvent->posix.value = 0;
    return MAL_SUCCESS;
}

void mal_event_uninit__posix(mal_event* pEvent)
{
    ((mal_pthread_cond_destroy_proc)pEvent->pContext->posix.pthread_cond_destroy)(&pEvent->posix.condition);
    ((mal_pthread_mutex_destroy_proc)pEvent->pContext->posix.pthread_mutex_destroy)(&pEvent->posix.mutex);
}

mal_bool32 mal_event_wait__posix(mal_event* pEvent)
{
    ((mal_pthread_mutex_lock_proc)pEvent->pContext->posix.pthread_mutex_lock)(&pEvent->posix.mutex);
    {
        while (pEvent->posix.value == 0) {
            ((mal_pthread_cond_wait_proc)pEvent->pContext->posix.pthread_cond_wait)(&pEvent->posix.condition, &pEvent->posix.mutex);
        }
        pEvent->posix.value = 0;  // Auto-reset.
    }
    ((mal_pthread_mutex_unlock_proc)pEvent->pContext->posix.pthread_mutex_unlock)(&pEvent->posix.mutex);

    return MAL_TRUE;
}

mal_bool32 mal_event_signal__posix(mal_event* pEvent)
{
    ((mal_pthread_mutex_lock_proc)pEvent->pContext->posix.pthread_mutex_lock)(&pEvent->posix.mutex);
    {
        pEvent->posix.value = 1;
        ((mal_pthread_cond_signal_proc)pEvent->pContext->posix.pthread_cond_signal)(&pEvent->posix.condition);
    }
    ((mal_pthread_mutex_unlock_proc)pEvent->pContext->posix.pthread_mutex_unlock)(&pEvent->posix.mutex);

    return MAL_TRUE;
}
#endif

mal_result mal_thread_create(mal_context* pContext, mal_thread* pThread, mal_thread_entry_proc entryProc, void* pData)
{
    if (pContext == NULL || pThread == NULL || entryProc == NULL) return MAL_FALSE;

    pThread->pContext = pContext;

#ifdef MAL_WIN32
    return mal_thread_create__win32(pContext, pThread, entryProc, pData);
#endif
#ifdef MAL_POSIX
    return mal_thread_create__posix(pContext, pThread, entryProc, pData);
#endif
}

void mal_thread_wait(mal_thread* pThread)
{
    if (pThread == NULL) return;

#ifdef MAL_WIN32
    mal_thread_wait__win32(pThread);
#endif
#ifdef MAL_POSIX
    mal_thread_wait__posix(pThread);
#endif
}

void mal_sleep(mal_uint32 milliseconds)
{
#ifdef MAL_WIN32
    mal_sleep__win32(milliseconds);
#endif
#ifdef MAL_POSIX
    mal_sleep__posix(milliseconds);
#endif
}


mal_result mal_mutex_init(mal_context* pContext, mal_mutex* pMutex)
{
    if (pContext == NULL || pMutex == NULL) {
        return MAL_INVALID_ARGS;
    }

    pMutex->pContext = pContext;

#ifdef MAL_WIN32
    return mal_mutex_init__win32(pContext, pMutex);
#endif
#ifdef MAL_POSIX
    return mal_mutex_init__posix(pContext, pMutex);
#endif
}

void mal_mutex_uninit(mal_mutex* pMutex)
{
    if (pMutex == NULL || pMutex->pContext == NULL) return;

#ifdef MAL_WIN32
    mal_mutex_uninit__win32(pMutex);
#endif
#ifdef MAL_POSIX
    mal_mutex_uninit__posix(pMutex);
#endif
}

void mal_mutex_lock(mal_mutex* pMutex)
{
    if (pMutex == NULL || pMutex->pContext == NULL) return;

#ifdef MAL_WIN32
    mal_mutex_lock__win32(pMutex);
#endif
#ifdef MAL_POSIX
    mal_mutex_lock__posix(pMutex);
#endif
}

void mal_mutex_unlock(mal_mutex* pMutex)
{
    if (pMutex == NULL || pMutex->pContext == NULL) return;

#ifdef MAL_WIN32
    mal_mutex_unlock__win32(pMutex);
#endif
#ifdef MAL_POSIX
    mal_mutex_unlock__posix(pMutex);
#endif
}


mal_result mal_event_init(mal_context* pContext, mal_event* pEvent)
{
    if (pContext == NULL || pEvent == NULL) return MAL_FALSE;

    pEvent->pContext = pContext;

#ifdef MAL_WIN32
    return mal_event_init__win32(pContext, pEvent);
#endif
#ifdef MAL_POSIX
    return mal_event_init__posix(pContext, pEvent);
#endif
}

void mal_event_uninit(mal_event* pEvent)
{
    if (pEvent == NULL || pEvent->pContext == NULL) return;

#ifdef MAL_WIN32
    mal_event_uninit__win32(pEvent);
#endif
#ifdef MAL_POSIX
    mal_event_uninit__posix(pEvent);
#endif
}

mal_bool32 mal_event_wait(mal_event* pEvent)
{
    if (pEvent == NULL || pEvent->pContext == NULL) return MAL_FALSE;

#ifdef MAL_WIN32
    return mal_event_wait__win32(pEvent);
#endif
#ifdef MAL_POSIX
    return mal_event_wait__posix(pEvent);
#endif
}

mal_bool32 mal_event_signal(mal_event* pEvent)
{
    if (pEvent == NULL || pEvent->pContext == NULL) return MAL_FALSE;

#ifdef MAL_WIN32
    return mal_event_signal__win32(pEvent);
#endif
#ifdef MAL_POSIX
    return mal_event_signal__posix(pEvent);
#endif
}


mal_uint32 mal_get_best_sample_rate_within_range(mal_uint32 sampleRateMin, mal_uint32 sampleRateMax)
{
    // Normalize the range in case we were given something stupid.
    if (sampleRateMin < MAL_MIN_SAMPLE_RATE) {
        sampleRateMin = MAL_MIN_SAMPLE_RATE;
    }
    if (sampleRateMax > MAL_MAX_SAMPLE_RATE) {
        sampleRateMax = MAL_MAX_SAMPLE_RATE;
    }
    if (sampleRateMin > sampleRateMax) {
        sampleRateMin = sampleRateMax;
    }

    if (sampleRateMin == sampleRateMax) {
        return sampleRateMax;
    } else {
        for (size_t iStandardRate = 0; iStandardRate < mal_countof(g_malStandardSampleRatePriorities); ++iStandardRate) {
            mal_uint32 standardRate = g_malStandardSampleRatePriorities[iStandardRate];
            if (standardRate >= sampleRateMin && standardRate <= sampleRateMax) {
                return standardRate;
            }
        }
    }

    // Should never get here.
    mal_assert(MAL_FALSE);
    return 0;
}

mal_uint32 mal_get_closest_standard_sample_rate(mal_uint32 sampleRateIn)
{
    mal_uint32 closestRate = 0;
    mal_uint32 closestDiff = 0xFFFFFFFF;

    for (size_t iStandardRate = 0; iStandardRate < mal_countof(g_malStandardSampleRatePriorities); ++iStandardRate) {
        mal_uint32 standardRate = g_malStandardSampleRatePriorities[iStandardRate];

        mal_uint32 diff;
        if (sampleRateIn > standardRate) {
            diff = sampleRateIn - standardRate;
        } else {
            diff = standardRate - sampleRateIn;
        }

        if (diff == 0) {
            return standardRate;    // The input sample rate is a standard rate.
        }

        if (closestDiff > diff) {
            closestDiff = diff;
            closestRate = standardRate;
        }
    }

    return closestRate;
}


mal_uint32 mal_scale_buffer_size(mal_uint32 baseBufferSize, float scale)
{
    return mal_max(1, (mal_uint32)(baseBufferSize*scale));
}

mal_uint32 mal_calculate_buffer_size_in_milliseconds_from_frames(mal_uint32 bufferSizeInFrames, mal_uint32 sampleRate)
{
    return bufferSizeInFrames / (sampleRate/1000);
}

mal_uint32 mal_calculate_buffer_size_in_frames_from_milliseconds(mal_uint32 bufferSizeInMilliseconds, mal_uint32 sampleRate)
{
    return bufferSizeInMilliseconds * (sampleRate/1000); 
}

mal_uint32 mal_get_default_buffer_size_in_milliseconds(mal_performance_profile performanceProfile)
{
    if (performanceProfile == mal_performance_profile_low_latency) {
        return MAL_BASE_BUFFER_SIZE_IN_MILLISECONDS_LOW_LATENCY;
    } else {
        return MAL_BASE_BUFFER_SIZE_IN_MILLISECONDS_CONSERVATIVE;
    }
}

mal_uint32 mal_get_default_buffer_size_in_frames(mal_performance_profile performanceProfile, mal_uint32 sampleRate)
{
    mal_uint32 bufferSizeInMilliseconds = mal_get_default_buffer_size_in_milliseconds(performanceProfile);
    if (bufferSizeInMilliseconds == 0) {
        bufferSizeInMilliseconds = 1;
    }

    mal_uint32 sampleRateMS = (sampleRate/1000);
    if (sampleRateMS == 0) {
        sampleRateMS = 1;
    }

    return bufferSizeInMilliseconds * sampleRateMS;
}

mal_uint32 mal_get_fragment_size_in_bytes(mal_uint32 bufferSizeInFrames, mal_uint32 periods, mal_format format, mal_uint32 channels)
{
    mal_uint32 fragmentSizeInFrames = bufferSizeInFrames / periods;
    return fragmentSizeInFrames * mal_get_bytes_per_frame(format, channels);
}


const char* mal_log_level_to_string(mal_uint32 logLevel)
{
    switch (logLevel)
    {
        case MAL_LOG_LEVEL_VERBOSE: return "";
        case MAL_LOG_LEVEL_INFO:    return "INFO";
        case MAL_LOG_LEVEL_WARNING: return "WARNING";
        case MAL_LOG_LEVEL_ERROR:   return "ERROR";
        default:                    return "ERROR";
    }
}

// Posts a log message.
void mal_log(mal_context* pContext, mal_device* pDevice, mal_uint32 logLevel, const char* message)
{
    if (pContext == NULL) return;
    
#if defined(MAL_LOG_LEVEL)
    if (logLevel <= MAL_LOG_LEVEL) {
    #if defined(MAL_DEBUG_OUTPUT)
        if (logLevel <= MAL_LOG_LEVEL) {
            printf("%s: %s\n", mal_log_level_to_string(logLevel), message);
        }
    #endif
    
        mal_log_proc onLog = pContext->config.logCallback;
        if (onLog) {
            onLog(pContext, pDevice, logLevel, message);
        }
    }
#endif
}

// Posts an error. Throw a breakpoint in here if you're needing to debug. The return value is always "resultCode".
mal_result mal_context_post_error(mal_context* pContext, mal_device* pDevice, mal_uint32 logLevel, const char* message, mal_result resultCode)
{
    // Derive the context from the device if necessary.
    if (pContext == NULL) {
        if (pDevice != NULL) {
            pContext = pDevice->pContext;
        }
    }

    mal_log(pContext, pDevice, logLevel, message);
    return resultCode;
}

mal_result mal_post_error(mal_device* pDevice, mal_uint32 logLevel, const char* message, mal_result resultCode)
{
    return mal_context_post_error(NULL, pDevice, logLevel, message, resultCode);
}


mal_uint64 mal_calculate_frame_count_after_src(mal_uint32 sampleRateOut, mal_uint32 sampleRateIn, mal_uint64 frameCountIn)
{
    double srcRatio = (double)sampleRateOut / sampleRateIn;
    double frameCountOutF = frameCountIn * srcRatio;

    mal_uint64 frameCountOut = (mal_uint64)frameCountOutF;

    // If the output frame count is fractional, make sure we add an extra frame to ensure there's enough room for that last sample.
    if ((frameCountOutF - frameCountOut) > 0.0) {
        frameCountOut += 1;
    }

    return frameCountOut;
}


// The callback for reading from the client -> DSP -> device.
mal_uint32 mal_device__on_read_from_client(mal_pcm_converter* pDSP, void* pFramesOut, mal_uint32 frameCount, void* pUserData)
{
    (void)pDSP;

    mal_device* pDevice = (mal_device*)pUserData;
    mal_assert(pDevice != NULL);

    mal_device_callback_proc onData = pDevice->onData;
    if (onData) {
        onData(pDevice, pFramesOut, NULL, frameCount);
        return frameCount;
    }

    return 0;
}

/* The PCM converter callback for reading from a buffer. */
mal_uint32 mal_device__pcm_converter__on_read_from_buffer_capture(mal_pcm_converter* pConverter, void* pFramesOut, mal_uint32 frameCount, void* pUserData)
{
    mal_device* pDevice = (mal_device*)pUserData;
    mal_assert(pDevice != NULL);

    if (pDevice->capture._dspFrameCount == 0) {
        return 0;   // Nothing left.
    }

    mal_uint32 framesToRead = frameCount;
    if (framesToRead > pDevice->capture._dspFrameCount) {
        framesToRead = pDevice->capture._dspFrameCount;
    }

    mal_uint32 bytesToRead = framesToRead * mal_get_bytes_per_frame(pConverter->formatConverterIn.config.formatIn, pConverter->channelRouter.config.channelsIn);
    mal_copy_memory(pFramesOut, pDevice->capture._dspFrames, bytesToRead);
    pDevice->capture._dspFrameCount -= framesToRead;
    pDevice->capture._dspFrames     += bytesToRead;

    return framesToRead;
}

mal_uint32 mal_device__pcm_converter__on_read_from_buffer_playback(mal_pcm_converter* pConverter, void* pFramesOut, mal_uint32 frameCount, void* pUserData)
{
    mal_device* pDevice = (mal_device*)pUserData;
    mal_assert(pDevice != NULL);

    if (pDevice->playback._dspFrameCount == 0) {
        return 0;   // Nothing left.
    }

    mal_uint32 framesToRead = frameCount;
    if (framesToRead > pDevice->playback._dspFrameCount) {
        framesToRead = pDevice->playback._dspFrameCount;
    }

    mal_uint32 bytesToRead = framesToRead * mal_get_bytes_per_frame(pConverter->formatConverterIn.config.formatIn, pConverter->channelRouter.config.channelsIn);
    mal_copy_memory(pFramesOut, pDevice->playback._dspFrames, bytesToRead);
    pDevice->playback._dspFrameCount -= framesToRead;
    pDevice->playback._dspFrames     += bytesToRead;

    return framesToRead;
}



// A helper function for reading sample data from the client. Returns the number of samples read from the client. Remaining samples
// are filled with silence.
static MAL_INLINE mal_uint32 mal_device__read_frames_from_client(mal_device* pDevice, mal_uint32 frameCount, void* pSamples)
{
    mal_assert(pDevice != NULL);
    mal_assert(frameCount > 0);
    mal_assert(pSamples != NULL);

    mal_uint32 framesRead     = (mal_uint32)mal_pcm_converter_read(&pDevice->playback.converter, pSamples, frameCount);
    mal_uint32 samplesRead    = framesRead * pDevice->playback.internalChannels;
    mal_uint32 sampleSize     = mal_get_bytes_per_sample(pDevice->playback.internalFormat);
    mal_uint32 consumedBytes  = samplesRead*sampleSize;
    mal_uint32 remainingBytes = ((frameCount * pDevice->playback.internalChannels) - samplesRead)*sampleSize;
    mal_zero_memory((mal_uint8*)pSamples + consumedBytes, remainingBytes);

    return samplesRead;
}

// A helper for sending sample data to the client.
static MAL_INLINE void mal_device__send_frames_to_client(mal_device* pDevice, mal_uint32 frameCount, const void* pSamples)
{
    mal_assert(pDevice != NULL);
    mal_assert(frameCount > 0);
    mal_assert(pSamples != NULL);

    mal_device_callback_proc onData = pDevice->onData;
    if (onData) {
        pDevice->capture._dspFrameCount = frameCount;
        pDevice->capture._dspFrames = (const mal_uint8*)pSamples;

        mal_uint8 chunkBuffer[4096];
        mal_uint32 chunkFrameCount = sizeof(chunkBuffer) / mal_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels);

        for (;;) {
            mal_uint32 framesJustRead = (mal_uint32)mal_pcm_converter_read(&pDevice->capture.converter, chunkBuffer, chunkFrameCount);
            if (framesJustRead == 0) {
                break;
            }

            onData(pDevice, NULL, chunkBuffer, framesJustRead);

            if (framesJustRead < chunkFrameCount) {
                break;
            }
        }
    }
}

static mal_result mal_device__handle_duplex_callback_capture(mal_device* pDevice, mal_uint32 frameCount, const void* pFramesInInternalFormat, mal_pcm_rb* pRB)
{
    mal_assert(pDevice != NULL);
    mal_assert(frameCount > 0);
    mal_assert(pFramesInInternalFormat != NULL);
    mal_assert(pRB != NULL);

    mal_result result;
    
    pDevice->capture._dspFrameCount = (mal_uint32)frameCount;
    pDevice->capture._dspFrames     = (const mal_uint8*)pFramesInInternalFormat;

    /* Write to the ring buffer. The ring buffer is in the external format. */
    for (;;) {
        mal_uint32 framesProcessed;
        mal_uint32 framesToProcess = 256;
        void* pFramesInExternalFormat;
        result = mal_pcm_rb_acquire_write(pRB, &framesToProcess, &pFramesInExternalFormat);
        if (result != MAL_SUCCESS) {
            mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "Failed to acquire capture PCM frames from ring buffer.", result);
            break;
        }

        if (framesToProcess == 0) {
            if (mal_pcm_rb_pointer_disance(pRB) == (mal_int32)mal_pcm_rb_get_subbuffer_size(pRB)) {
                break;  /* Overrun. Not enough room in the ring buffer for input frame. Excess frames are dropped. */
            }
        }

        /* Convert. */
        framesProcessed = (mal_uint32)mal_pcm_converter_read(&pDevice->capture.converter, pFramesInExternalFormat, framesToProcess);

        result = mal_pcm_rb_commit_write(pRB, framesProcessed, pFramesInExternalFormat);
        if (result != MAL_SUCCESS) {
            mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "Failed to commit capture PCM frames to ring buffer.", result);
            break;
        }

        if (framesProcessed < framesToProcess) {
            break;  /* Done. */
        }
    }

    return MAL_SUCCESS;
}

static mal_result mal_device__handle_duplex_callback_playback(mal_device* pDevice, mal_uint32 frameCount, void* pFramesInInternalFormat, mal_pcm_rb* pRB)
{
    mal_assert(pDevice != NULL);
    mal_assert(frameCount > 0);
    mal_assert(pFramesInInternalFormat != NULL);
    mal_assert(pRB != NULL);
    
    /*
    Sitting in the ring buffer should be captured data from the capture callback in external format. If there's not enough data in there for
    the whole frameCount frames we just use silence instead for the input data.
    */
    mal_result result;
    mal_uint8 playbackFramesInExternalFormat[4096];
    mal_uint8 silentInputFrames[4096];
    mal_zero_memory(silentInputFrames, sizeof(silentInputFrames));

    /* We need to calculate how many output frames are required to be read from the client to completely fill frameCount internal frames. */
    mal_uint32 totalFramesToReadFromClient = (mal_uint32)mal_calculate_frame_count_after_src(pDevice->sampleRate, pDevice->playback.internalSampleRate, frameCount); // mal_pcm_converter_get_required_input_frame_count(&pDevice->playback.converter, (mal_uint32)frameCount);
    mal_uint32 totalFramesReadFromClient = 0;
    while (totalFramesReadFromClient < totalFramesToReadFromClient && mal_device_is_started(pDevice)) {
        mal_uint32 framesRemainingFromClient = (totalFramesToReadFromClient - totalFramesReadFromClient);
        mal_uint32 framesToProcessFromClient = sizeof(playbackFramesInExternalFormat) / mal_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels);
        if (framesToProcessFromClient > framesRemainingFromClient) {
            framesToProcessFromClient = framesRemainingFromClient;
        }

        /* We need to grab captured samples before firing the callback. If there's not enough input samples we just pass silence. */
        mal_uint32 inputFrameCount = framesToProcessFromClient;
        void* pInputFrames;
        result = mal_pcm_rb_acquire_read(pRB, &inputFrameCount, &pInputFrames);
        if (result == MAL_SUCCESS) {
            if (inputFrameCount > 0) {
                /* Use actual input frames. */
                pDevice->onData(pDevice, playbackFramesInExternalFormat, pInputFrames, inputFrameCount);
            } else {
                if (mal_pcm_rb_pointer_disance(pRB) == 0) {
                    break;  /* Underrun. */
                }
            }
            
            /* We're done with the captured samples. */
            result = mal_pcm_rb_commit_read(pRB, inputFrameCount, pInputFrames);
            if (result != MAL_SUCCESS) {
                break; /* Don't know what to do here... Just abandon ship. */
            }
        } else {
            /* Use silent input frames. */
            inputFrameCount = mal_min(
                sizeof(playbackFramesInExternalFormat) / mal_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels),
                sizeof(silentInputFrames)              / mal_get_bytes_per_frame(pDevice->capture.format,  pDevice->capture.channels)
            );

            pDevice->onData(pDevice, playbackFramesInExternalFormat, silentInputFrames, inputFrameCount);
        }

        /* We have samples in external format so now we need to convert to internal format and output to the device. */
        pDevice->playback._dspFrameCount = inputFrameCount;
        pDevice->playback._dspFrames     = (const mal_uint8*)playbackFramesInExternalFormat;
        mal_pcm_converter_read(&pDevice->playback.converter, pFramesInInternalFormat, inputFrameCount);

        totalFramesReadFromClient += inputFrameCount;
        pFramesInInternalFormat = mal_offset_ptr(pFramesInInternalFormat, inputFrameCount * mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels));
    }

    return MAL_SUCCESS;
}

// A helper for changing the state of the device.
static MAL_INLINE void mal_device__set_state(mal_device* pDevice, mal_uint32 newState)
{
    mal_atomic_exchange_32(&pDevice->state, newState);
}

// A helper for getting the state of the device.
static MAL_INLINE mal_uint32 mal_device__get_state(mal_device* pDevice)
{
    return pDevice->state;
}

/* A helper for determining whether or not the device is running in async mode. */
static MAL_INLINE mal_bool32 mal_device__is_async(mal_device* pDevice)
{
    return pDevice->onData != NULL;
}


#ifdef MAL_WIN32
    GUID MAL_GUID_KSDATAFORMAT_SUBTYPE_PCM        = {0x00000001, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}};
    GUID MAL_GUID_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT = {0x00000003, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}};
    //GUID MAL_GUID_KSDATAFORMAT_SUBTYPE_ALAW       = {0x00000006, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}};
    //GUID MAL_GUID_KSDATAFORMAT_SUBTYPE_MULAW      = {0x00000007, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}};
#endif


mal_bool32 mal_context__device_id_equal(mal_context* pContext, const mal_device_id* pID0, const mal_device_id* pID1)
{
    mal_assert(pContext != NULL);

    if (pID0 == pID1) return MAL_TRUE;

    if ((pID0 == NULL && pID1 != NULL) ||
        (pID0 != NULL && pID1 == NULL)) {
        return MAL_FALSE;
    }

    if (pContext->onDeviceIDEqual) {
        return pContext->onDeviceIDEqual(pContext, pID0, pID1);
    }

    return MAL_FALSE;
}


typedef struct
{
    mal_device_type deviceType;
    const mal_device_id* pDeviceID;
    char* pName;
    size_t nameBufferSize;
    mal_bool32 foundDevice;
} mal_context__try_get_device_name_by_id__enum_callback_data;

mal_bool32 mal_context__try_get_device_name_by_id__enum_callback(mal_context* pContext, mal_device_type deviceType, const mal_device_info* pDeviceInfo, void* pUserData)
{
    mal_context__try_get_device_name_by_id__enum_callback_data* pData = (mal_context__try_get_device_name_by_id__enum_callback_data*)pUserData;
    mal_assert(pData != NULL);

    if (pData->deviceType == deviceType) {
        if (pContext->onDeviceIDEqual(pContext, pData->pDeviceID, &pDeviceInfo->id)) {
            mal_strncpy_s(pData->pName, pData->nameBufferSize, pDeviceInfo->name, (size_t)-1);
            pData->foundDevice = MAL_TRUE;
        }
    }

    return !pData->foundDevice;
}

// Generic function for retrieving the name of a device by it's ID.
//
// This function simply enumerates every device and then retrieves the name of the first device that has the same ID.
mal_result mal_context__try_get_device_name_by_id(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, char* pName, size_t nameBufferSize)
{
    mal_assert(pContext != NULL);
    mal_assert(pName != NULL);

    if (pDeviceID == NULL) {
        return MAL_NO_DEVICE;
    }

    mal_context__try_get_device_name_by_id__enum_callback_data data;
    data.deviceType = deviceType;
    data.pDeviceID = pDeviceID;
    data.pName = pName;
    data.nameBufferSize = nameBufferSize;
    data.foundDevice = MAL_FALSE;
    mal_result result = mal_context_enumerate_devices(pContext, mal_context__try_get_device_name_by_id__enum_callback, &data);
    if (result != MAL_SUCCESS) {
        return result;
    }

    if (!data.foundDevice) {
        return MAL_NO_DEVICE;
    } else {
        return MAL_SUCCESS;
    }
}


mal_uint32 mal_get_format_priority_index(mal_format format) // Lower = better.
{
    for (mal_uint32 i = 0; i < mal_countof(g_malFormatPriorities); ++i) {
        if (g_malFormatPriorities[i] == format) {
            return i;
        }
    }

    // Getting here means the format could not be found or is equal to mal_format_unknown.
    return (mal_uint32)-1;
}

void mal_device__post_init_setup(mal_device* pDevice, mal_device_type deviceType);

///////////////////////////////////////////////////////////////////////////////
//
// Null Backend
//
///////////////////////////////////////////////////////////////////////////////
#ifdef MAL_HAS_NULL

#define MAL_DEVICE_OP_NONE__NULL    0
#define MAL_DEVICE_OP_START__NULL   1
#define MAL_DEVICE_OP_SUSPEND__NULL 2
#define MAL_DEVICE_OP_KILL__NULL    3

mal_thread_result MAL_THREADCALL mal_device_thread__null(void* pData)
{
    mal_device* pDevice = (mal_device*)pData;
    mal_assert(pDevice != NULL);

    for (;;) {  /* Keep the thread alive until the device is uninitialized. */
        /* Wait for an operation to be requested. */
        mal_event_wait(&pDevice->null_device.operationEvent);

        /* At this point an event should have been triggered. */

        /* Starting the device needs to put the thread into a loop. */
        if (pDevice->null_device.operation == MAL_DEVICE_OP_START__NULL) {
            mal_atomic_exchange_32(&pDevice->null_device.operation, MAL_DEVICE_OP_NONE__NULL);

            /* Reset the timer just in case. */
            mal_timer_init(&pDevice->null_device.timer);

            /* Keep looping until an operation has been requested. */
            while (pDevice->null_device.operation != MAL_DEVICE_OP_NONE__NULL && pDevice->null_device.operation != MAL_DEVICE_OP_START__NULL) {
                mal_sleep(10); /* Don't hog the CPU. */
            }

            /* Getting here means a suspend or kill operation has been requested. */
            mal_atomic_exchange_32(&pDevice->null_device.operationResult, MAL_SUCCESS);
            mal_event_signal(&pDevice->null_device.operationCompletionEvent);
            continue;
        }

        /* Suspending the device means we need to stop the timer and just continue the loop. */
        if (pDevice->null_device.operation == MAL_DEVICE_OP_SUSPEND__NULL) {
            mal_atomic_exchange_32(&pDevice->null_device.operation, MAL_DEVICE_OP_NONE__NULL);

            /* We need to add the current run time to the prior run time, then reset the timer. */
            pDevice->null_device.priorRunTime += mal_timer_get_time_in_seconds(&pDevice->null_device.timer);
            mal_timer_init(&pDevice->null_device.timer);

            /* We're done. */
            mal_atomic_exchange_32(&pDevice->null_device.operationResult, MAL_SUCCESS);
            mal_event_signal(&pDevice->null_device.operationCompletionEvent);
            continue;
        }

        /* Killing the device means we need to get out of this loop so that this thread can terminate. */
        if (pDevice->null_device.operation == MAL_DEVICE_OP_KILL__NULL) {
            mal_atomic_exchange_32(&pDevice->null_device.operation, MAL_DEVICE_OP_NONE__NULL);
            mal_atomic_exchange_32(&pDevice->null_device.operationResult, MAL_SUCCESS);
            mal_event_signal(&pDevice->null_device.operationCompletionEvent);
            break;
        }

        /* Getting a signal on a "none" operation probably means an error. Return invalid operation. */
        if (pDevice->null_device.operation == MAL_DEVICE_OP_NONE__NULL) {
            mal_assert(MAL_FALSE);  /* <-- Trigger this in debug mode to ensure developers are aware they're doing something wrong (or there's a bug in a mini_al). */
            mal_atomic_exchange_32(&pDevice->null_device.operationResult, MAL_INVALID_OPERATION);
            mal_event_signal(&pDevice->null_device.operationCompletionEvent);
            continue;   /* Continue the loop. Don't terminate. */
        }
    }

    return (mal_thread_result)0;
}

mal_result mal_device_do_operation__null(mal_device* pDevice, mal_uint32 operation)
{
    mal_atomic_exchange_32(&pDevice->null_device.operation, operation);
    if (!mal_event_signal(&pDevice->null_device.operationEvent)) {
        return MAL_ERROR;
    }

    if (!mal_event_wait(&pDevice->null_device.operationCompletionEvent)) {
        return MAL_ERROR;
    }

    return pDevice->null_device.operationResult;
}

mal_uint64 mal_device_get_total_run_time_in_frames__null(mal_device* pDevice)
{
    mal_uint32 internalSampleRate;
    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        internalSampleRate = pDevice->capture.internalSampleRate;
    } else {
        internalSampleRate = pDevice->playback.internalSampleRate;
    }


    return (mal_uint64)((pDevice->null_device.priorRunTime + mal_timer_get_time_in_seconds(&pDevice->null_device.timer)) * internalSampleRate);
}

mal_bool32 mal_context_is_device_id_equal__null(mal_context* pContext, const mal_device_id* pID0, const mal_device_id* pID1)
{
    mal_assert(pContext != NULL);
    mal_assert(pID0 != NULL);
    mal_assert(pID1 != NULL);
    (void)pContext;

    return pID0->nullbackend == pID1->nullbackend;
}

mal_result mal_context_enumerate_devices__null(mal_context* pContext, mal_enum_devices_callback_proc callback, void* pUserData)
{
    mal_assert(pContext != NULL);
    mal_assert(callback != NULL);

    mal_bool32 cbResult = MAL_TRUE;

    // Playback.
    if (cbResult) {
        mal_device_info deviceInfo;
        mal_zero_object(&deviceInfo);
        mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), "NULL Playback Device", (size_t)-1);
        cbResult = callback(pContext, mal_device_type_playback, &deviceInfo, pUserData);
    }

    // Capture.
    if (cbResult) {
        mal_device_info deviceInfo;
        mal_zero_object(&deviceInfo);
        mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), "NULL Capture Device", (size_t)-1);
        cbResult = callback(pContext, mal_device_type_capture, &deviceInfo, pUserData);
    }

    return MAL_SUCCESS;
}

mal_result mal_context_get_device_info__null(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, mal_device_info* pDeviceInfo)
{
    mal_assert(pContext != NULL);

    (void)pContext;
    (void)shareMode;

    if (pDeviceID != NULL && pDeviceID->nullbackend != 0) {
        return MAL_NO_DEVICE;   // Don't know the device.
    }

    // Name / Description
    if (deviceType == mal_device_type_playback) {
        mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), "NULL Playback Device", (size_t)-1);
    } else {
        mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), "NULL Capture Device", (size_t)-1);
    }

    // Support everything on the null backend.
    pDeviceInfo->formatCount = mal_format_count - 1;    // Minus one because we don't want to include mal_format_unknown.
    for (mal_uint32 iFormat = 0; iFormat < pDeviceInfo->formatCount; ++iFormat) {
        pDeviceInfo->formats[iFormat] = (mal_format)(iFormat + 1);  // +1 to skip over mal_format_unknown.
    }

    pDeviceInfo->minChannels   = 1;
    pDeviceInfo->maxChannels   = MAL_MAX_CHANNELS;
    pDeviceInfo->minSampleRate = MAL_SAMPLE_RATE_8000;
    pDeviceInfo->maxSampleRate = MAL_SAMPLE_RATE_384000;

    return MAL_SUCCESS;
}


void mal_device_uninit__null(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    /* Keep it clean and wait for the device thread to finish before returning. */
    mal_device_do_operation__null(pDevice, MAL_DEVICE_OP_KILL__NULL);

    /* At this point the loop in the device thread is as good as terminated so we can uninitialize our events. */
    mal_event_uninit(&pDevice->null_device.operationCompletionEvent);
    mal_event_uninit(&pDevice->null_device.operationEvent);
}

mal_result mal_device_init__null(mal_context* pContext, const mal_device_config* pConfig, mal_device* pDevice)
{
    (void)pContext;
    (void)pConfig;

    mal_result result;

    mal_assert(pDevice != NULL);

    mal_zero_object(&pDevice->null_device);

    mal_uint32 bufferSizeInFrames = pConfig->bufferSizeInFrames;
    if (bufferSizeInFrames == 0) {
        bufferSizeInFrames = mal_calculate_buffer_size_in_frames_from_milliseconds(pConfig->bufferSizeInMilliseconds, pConfig->sampleRate);
    }

    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        mal_strncpy_s(pDevice->capture.name,  sizeof(pDevice->capture.name),  "NULL Capture Device",  (size_t)-1);
        pDevice->capture.internalFormat             = pConfig->capture.format;
        pDevice->capture.internalChannels           = pConfig->capture.channels;
        mal_channel_map_copy(pDevice->capture.internalChannelMap, pConfig->capture.channelMap, pConfig->capture.channels);
        pDevice->capture.internalBufferSizeInFrames = bufferSizeInFrames;
        pDevice->capture.internalPeriods            = pConfig->periods;
    }
    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        mal_strncpy_s(pDevice->playback.name, sizeof(pDevice->playback.name), "NULL Playback Device", (size_t)-1);
        pDevice->playback.internalFormat             = pConfig->playback.format;
        pDevice->playback.internalChannels           = pConfig->playback.channels;
        mal_channel_map_copy(pDevice->playback.internalChannelMap, pConfig->playback.channelMap, pConfig->playback.channels);
        pDevice->playback.internalBufferSizeInFrames = bufferSizeInFrames;
        pDevice->playback.internalPeriods            = pConfig->periods;
    }

    /*
    In order to get timing right, we need to create a thread that does nothing but keeps track of the timer. This timer is started when the
    first period is "written" to it, and then stopped in mal_device_stop__null().
    */
    result = mal_event_init(pContext, &pDevice->null_device.operationEvent);
    if (result != MAL_SUCCESS) {
        return result;
    }

    result = mal_event_init(pContext, &pDevice->null_device.operationCompletionEvent);
    if (result != MAL_SUCCESS) {
        return result;
    }

    result = mal_thread_create(pContext, &pDevice->thread, mal_device_thread__null, pDevice);
    if (result != MAL_SUCCESS) {
        return result;
    }

    return MAL_SUCCESS;
}

mal_result mal_device_start__null(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    mal_device_do_operation__null(pDevice, MAL_DEVICE_OP_START__NULL);

    mal_atomic_exchange_32(&pDevice->null_device.isStarted, MAL_TRUE);
    return MAL_SUCCESS;
}

mal_result mal_device_stop__null(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    mal_device_do_operation__null(pDevice, MAL_DEVICE_OP_SUSPEND__NULL);

    mal_atomic_exchange_32(&pDevice->null_device.isStarted, MAL_FALSE);
    return MAL_SUCCESS;
}

mal_result mal_device_write__null(mal_device* pDevice, const void* pPCMFrames, mal_uint32 frameCount)
{
    mal_result result = MAL_SUCCESS;
    mal_uint32 totalPCMFramesProcessed;
    mal_bool32 wasStartedOnEntry;

    wasStartedOnEntry = pDevice->null_device.isStarted;

    /* Keep going until everything has been read. */
    totalPCMFramesProcessed = 0;
    while (totalPCMFramesProcessed < frameCount) {
        /* If there are any frames remaining in the current period, consume those first. */
        if (pDevice->null_device.currentPeriodFramesRemainingPlayback > 0) {
            mal_uint32 framesRemaining = (frameCount - totalPCMFramesProcessed);
            mal_uint32 framesToProcess = pDevice->null_device.currentPeriodFramesRemainingPlayback;
            if (framesToProcess > framesRemaining) {
                framesToProcess = framesRemaining;
            }

            /* We don't actually do anything with pPCMFrames, so just mark it as unused to prevent a warning. */
            (void)pPCMFrames;

            pDevice->null_device.currentPeriodFramesRemainingPlayback -= framesToProcess;
            totalPCMFramesProcessed += framesToProcess;
        }

        /* If we've consumed the current period we'll need to mark it as such an ensure the device is started if it's not already. */
        if (pDevice->null_device.currentPeriodFramesRemainingPlayback == 0) {
            pDevice->null_device.currentPeriodFramesRemainingPlayback = 0;

            if (!pDevice->null_device.isStarted && !wasStartedOnEntry) {
                result = mal_device_start__null(pDevice);
                if (result != MAL_SUCCESS) {
                    break;
                }
            }
        }

        /* If we've consumed the whole buffer we can return now. */
        mal_assert(totalPCMFramesProcessed <= frameCount);
        if (totalPCMFramesProcessed == frameCount) {
            break;
        }

        /* Getting here means we've still got more frames to consume, we but need to wait for it to become available. */
        mal_uint64 targetFrame = pDevice->null_device.lastProcessedFramePlayback;
        for (;;) {
            /* Stop waiting if the device has been stopped. */
            if (!pDevice->null_device.isStarted) {
                break;
            }

            mal_uint64 currentFrame = mal_device_get_total_run_time_in_frames__null(pDevice);
            if (currentFrame >= targetFrame) {
                break;
            }

            /* Getting here means we haven't yet reached the target sample, so continue waiting. */
            mal_sleep(10);
        }

        pDevice->null_device.lastProcessedFramePlayback          += pDevice->playback.internalBufferSizeInFrames / pDevice->playback.internalPeriods;
        pDevice->null_device.currentPeriodFramesRemainingPlayback = pDevice->playback.internalBufferSizeInFrames / pDevice->playback.internalPeriods;
    }

    return result;
}

mal_result mal_device_read__null(mal_device* pDevice, void* pPCMFrames, mal_uint32 frameCount)
{
    mal_result result = MAL_SUCCESS;
    mal_uint32 totalPCMFramesProcessed;

    /* The device needs to be started immediately. */
    if (!pDevice->null_device.isStarted) {
        result = mal_device_start__null(pDevice);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    /* Keep going until everything has been read. */
    totalPCMFramesProcessed = 0;
    while (totalPCMFramesProcessed < frameCount) {
        /* If there are any frames remaining in the current period, consume those first. */
        if (pDevice->null_device.currentPeriodFramesRemainingCapture > 0) {
            mal_uint32 bpf = mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
            mal_uint32 framesRemaining = (frameCount - totalPCMFramesProcessed);
            mal_uint32 framesToProcess = pDevice->null_device.currentPeriodFramesRemainingCapture;
            if (framesToProcess > framesRemaining) {
                framesToProcess = framesRemaining;
            }

            /* We need to ensured the output buffer is zeroed. */
            mal_zero_memory(mal_offset_ptr(pPCMFrames, totalPCMFramesProcessed*bpf), framesToProcess*bpf);

            pDevice->null_device.currentPeriodFramesRemainingCapture -= framesToProcess;
            totalPCMFramesProcessed += framesToProcess;
        }

        /* If we've consumed the current period we'll need to mark it as such an ensure the device is started if it's not already. */
        if (pDevice->null_device.currentPeriodFramesRemainingCapture == 0) {
            pDevice->null_device.currentPeriodFramesRemainingCapture = 0;
        }

        /* If we've consumed the whole buffer we can return now. */
        mal_assert(totalPCMFramesProcessed <= frameCount);
        if (totalPCMFramesProcessed == frameCount) {
            break;
        }

        /* Getting here means we've still got more frames to consume, we but need to wait for it to become available. */
        mal_uint64 targetFrame = pDevice->null_device.lastProcessedFrameCapture + (pDevice->capture.internalBufferSizeInFrames / pDevice->capture.internalPeriods);
        for (;;) {
            /* Stop waiting if the device has been stopped. */
            if (!pDevice->null_device.isStarted) {
                break;
            }

            mal_uint64 currentFrame = mal_device_get_total_run_time_in_frames__null(pDevice);
            if (currentFrame >= targetFrame) {
                break;
            }

            /* Getting here means we haven't yet reached the target sample, so continue waiting. */
            mal_sleep(10);
        }

        pDevice->null_device.lastProcessedFrameCapture          += pDevice->capture.internalBufferSizeInFrames / pDevice->capture.internalPeriods;
        pDevice->null_device.currentPeriodFramesRemainingCapture = pDevice->capture.internalBufferSizeInFrames / pDevice->capture.internalPeriods;
    }

    return result;
}

mal_result mal_context_uninit__null(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    mal_assert(pContext->backend == mal_backend_null);

    (void)pContext;
    return MAL_SUCCESS;
}

mal_result mal_context_init__null(mal_context* pContext)
{
    mal_assert(pContext != NULL);

    pContext->onUninit              = mal_context_uninit__null;
    pContext->onDeviceIDEqual       = mal_context_is_device_id_equal__null;
    pContext->onEnumDevices         = mal_context_enumerate_devices__null;
    pContext->onGetDeviceInfo       = mal_context_get_device_info__null;
    pContext->onDeviceInit          = mal_device_init__null;
    pContext->onDeviceUninit        = mal_device_uninit__null;
    pContext->onDeviceStart         = mal_device_start__null;
    pContext->onDeviceStop          = mal_device_stop__null;
    pContext->onDeviceWrite         = mal_device_write__null;
    pContext->onDeviceRead          = mal_device_read__null;

    /* The null backend always works. */
    return MAL_SUCCESS;
}
#endif


///////////////////////////////////////////////////////////////////////////////
//
// WIN32 COMMON
//
///////////////////////////////////////////////////////////////////////////////
#if defined(MAL_WIN32)
#if defined(MAL_WIN32_DESKTOP)
    #define mal_CoInitializeEx(pContext, pvReserved, dwCoInit)                          ((MAL_PFN_CoInitializeEx)pContext->win32.CoInitializeEx)(pvReserved, dwCoInit)
    #define mal_CoUninitialize(pContext)                                                ((MAL_PFN_CoUninitialize)pContext->win32.CoUninitialize)()
    #define mal_CoCreateInstance(pContext, rclsid, pUnkOuter, dwClsContext, riid, ppv)  ((MAL_PFN_CoCreateInstance)pContext->win32.CoCreateInstance)(rclsid, pUnkOuter, dwClsContext, riid, ppv)
    #define mal_CoTaskMemFree(pContext, pv)                                             ((MAL_PFN_CoTaskMemFree)pContext->win32.CoTaskMemFree)(pv)
    #define mal_PropVariantClear(pContext, pvar)                                        ((MAL_PFN_PropVariantClear)pContext->win32.PropVariantClear)(pvar)
#else
    #define mal_CoInitializeEx(pContext, pvReserved, dwCoInit)                          CoInitializeEx(pvReserved, dwCoInit)
    #define mal_CoUninitialize(pContext)                                                CoUninitialize()
    #define mal_CoCreateInstance(pContext, rclsid, pUnkOuter, dwClsContext, riid, ppv)  CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv)
    #define mal_CoTaskMemFree(pContext, pv)                                             CoTaskMemFree(pv)
    #define mal_PropVariantClear(pContext, pvar)                                        PropVariantClear(pvar)
#endif

#if !defined(MAXULONG_PTR)
typedef size_t DWORD_PTR;
#endif

#if !defined(WAVE_FORMAT_44M08)
#define WAVE_FORMAT_44M08 0x00000100
#define WAVE_FORMAT_44S08 0x00000200
#define WAVE_FORMAT_44M16 0x00000400
#define WAVE_FORMAT_44S16 0x00000800
#define WAVE_FORMAT_48M08 0x00001000
#define WAVE_FORMAT_48S08 0x00002000
#define WAVE_FORMAT_48M16 0x00004000
#define WAVE_FORMAT_48S16 0x00008000
#define WAVE_FORMAT_96M08 0x00010000
#define WAVE_FORMAT_96S08 0x00020000
#define WAVE_FORMAT_96M16 0x00040000
#define WAVE_FORMAT_96S16 0x00080000
#endif

#ifndef SPEAKER_FRONT_LEFT
#define SPEAKER_FRONT_LEFT            0x1
#define SPEAKER_FRONT_RIGHT           0x2
#define SPEAKER_FRONT_CENTER          0x4
#define SPEAKER_LOW_FREQUENCY         0x8
#define SPEAKER_BACK_LEFT             0x10
#define SPEAKER_BACK_RIGHT            0x20
#define SPEAKER_FRONT_LEFT_OF_CENTER  0x40
#define SPEAKER_FRONT_RIGHT_OF_CENTER 0x80
#define SPEAKER_BACK_CENTER           0x100
#define SPEAKER_SIDE_LEFT             0x200
#define SPEAKER_SIDE_RIGHT            0x400
#define SPEAKER_TOP_CENTER            0x800
#define SPEAKER_TOP_FRONT_LEFT        0x1000
#define SPEAKER_TOP_FRONT_CENTER      0x2000
#define SPEAKER_TOP_FRONT_RIGHT       0x4000
#define SPEAKER_TOP_BACK_LEFT         0x8000
#define SPEAKER_TOP_BACK_CENTER       0x10000
#define SPEAKER_TOP_BACK_RIGHT        0x20000
#endif

// The SDK that comes with old versions of MSVC (VC6, for example) does not appear to define WAVEFORMATEXTENSIBLE. We
// define our own implementation in this case.
#if (defined(_MSC_VER) && !defined(_WAVEFORMATEXTENSIBLE_)) || defined(__DMC__)
typedef struct
{
    WAVEFORMATEX Format;
    union
    {
        WORD wValidBitsPerSample;
        WORD wSamplesPerBlock;
        WORD wReserved;
    } Samples;
    DWORD dwChannelMask;
    GUID SubFormat;
} WAVEFORMATEXTENSIBLE;
#endif

#ifndef WAVE_FORMAT_EXTENSIBLE
#define WAVE_FORMAT_EXTENSIBLE  0xFFFE
#endif

#ifndef WAVE_FORMAT_IEEE_FLOAT
#define WAVE_FORMAT_IEEE_FLOAT  0x0003
#endif

GUID MAL_GUID_NULL = {0x00000000, 0x0000, 0x0000, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};

// Converts an individual Win32-style channel identifier (SPEAKER_FRONT_LEFT, etc.) to mini_al.
mal_uint8 mal_channel_id_to_mal__win32(DWORD id)
{
    switch (id)
    {
        case SPEAKER_FRONT_LEFT:            return MAL_CHANNEL_FRONT_LEFT;
        case SPEAKER_FRONT_RIGHT:           return MAL_CHANNEL_FRONT_RIGHT;
        case SPEAKER_FRONT_CENTER:          return MAL_CHANNEL_FRONT_CENTER;
        case SPEAKER_LOW_FREQUENCY:         return MAL_CHANNEL_LFE;
        case SPEAKER_BACK_LEFT:             return MAL_CHANNEL_BACK_LEFT;
        case SPEAKER_BACK_RIGHT:            return MAL_CHANNEL_BACK_RIGHT;
        case SPEAKER_FRONT_LEFT_OF_CENTER:  return MAL_CHANNEL_FRONT_LEFT_CENTER;
        case SPEAKER_FRONT_RIGHT_OF_CENTER: return MAL_CHANNEL_FRONT_RIGHT_CENTER;
        case SPEAKER_BACK_CENTER:           return MAL_CHANNEL_BACK_CENTER;
        case SPEAKER_SIDE_LEFT:             return MAL_CHANNEL_SIDE_LEFT;
        case SPEAKER_SIDE_RIGHT:            return MAL_CHANNEL_SIDE_RIGHT;
        case SPEAKER_TOP_CENTER:            return MAL_CHANNEL_TOP_CENTER;
        case SPEAKER_TOP_FRONT_LEFT:        return MAL_CHANNEL_TOP_FRONT_LEFT;
        case SPEAKER_TOP_FRONT_CENTER:      return MAL_CHANNEL_TOP_FRONT_CENTER;
        case SPEAKER_TOP_FRONT_RIGHT:       return MAL_CHANNEL_TOP_FRONT_RIGHT;
        case SPEAKER_TOP_BACK_LEFT:         return MAL_CHANNEL_TOP_BACK_LEFT;
        case SPEAKER_TOP_BACK_CENTER:       return MAL_CHANNEL_TOP_BACK_CENTER;
        case SPEAKER_TOP_BACK_RIGHT:        return MAL_CHANNEL_TOP_BACK_RIGHT;
        default: return 0;
    }
}

// Converts an individual mini_al channel identifier (MAL_CHANNEL_FRONT_LEFT, etc.) to Win32-style.
DWORD mal_channel_id_to_win32(DWORD id)
{
    switch (id)
    {
        case MAL_CHANNEL_MONO:               return SPEAKER_FRONT_CENTER;
        case MAL_CHANNEL_FRONT_LEFT:         return SPEAKER_FRONT_LEFT;
        case MAL_CHANNEL_FRONT_RIGHT:        return SPEAKER_FRONT_RIGHT;
        case MAL_CHANNEL_FRONT_CENTER:       return SPEAKER_FRONT_CENTER;
        case MAL_CHANNEL_LFE:                return SPEAKER_LOW_FREQUENCY;
        case MAL_CHANNEL_BACK_LEFT:          return SPEAKER_BACK_LEFT;
        case MAL_CHANNEL_BACK_RIGHT:         return SPEAKER_BACK_RIGHT;
        case MAL_CHANNEL_FRONT_LEFT_CENTER:  return SPEAKER_FRONT_LEFT_OF_CENTER;
        case MAL_CHANNEL_FRONT_RIGHT_CENTER: return SPEAKER_FRONT_RIGHT_OF_CENTER;
        case MAL_CHANNEL_BACK_CENTER:        return SPEAKER_BACK_CENTER;
        case MAL_CHANNEL_SIDE_LEFT:          return SPEAKER_SIDE_LEFT;
        case MAL_CHANNEL_SIDE_RIGHT:         return SPEAKER_SIDE_RIGHT;
        case MAL_CHANNEL_TOP_CENTER:         return SPEAKER_TOP_CENTER;
        case MAL_CHANNEL_TOP_FRONT_LEFT:     return SPEAKER_TOP_FRONT_LEFT;
        case MAL_CHANNEL_TOP_FRONT_CENTER:   return SPEAKER_TOP_FRONT_CENTER;
        case MAL_CHANNEL_TOP_FRONT_RIGHT:    return SPEAKER_TOP_FRONT_RIGHT;
        case MAL_CHANNEL_TOP_BACK_LEFT:      return SPEAKER_TOP_BACK_LEFT;
        case MAL_CHANNEL_TOP_BACK_CENTER:    return SPEAKER_TOP_BACK_CENTER;
        case MAL_CHANNEL_TOP_BACK_RIGHT:     return SPEAKER_TOP_BACK_RIGHT;
        default: return 0;
    }
}

// Converts a channel mapping to a Win32-style channel mask.
DWORD mal_channel_map_to_channel_mask__win32(const mal_channel channelMap[MAL_MAX_CHANNELS], mal_uint32 channels)
{
    DWORD dwChannelMask = 0;
    for (mal_uint32 iChannel = 0; iChannel < channels; ++iChannel) {
        dwChannelMask |= mal_channel_id_to_win32(channelMap[iChannel]);
    }

    return dwChannelMask;
}

// Converts a Win32-style channel mask to a mini_al channel map.
void mal_channel_mask_to_channel_map__win32(DWORD dwChannelMask, mal_uint32 channels, mal_channel channelMap[MAL_MAX_CHANNELS])
{
    if (channels == 1 && dwChannelMask == 0) {
        channelMap[0] = MAL_CHANNEL_MONO;
    } else if (channels == 2 && dwChannelMask == 0) {
        channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
        channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
    } else {
        if (channels == 1 && (dwChannelMask & SPEAKER_FRONT_CENTER) != 0) {
            channelMap[0] = MAL_CHANNEL_MONO;
        } else {
            // Just iterate over each bit.
            mal_uint32 iChannel = 0;
            for (mal_uint32 iBit = 0; iBit < 32; ++iBit) {
                DWORD bitValue = (dwChannelMask & (1UL << iBit));
                if (bitValue != 0) {
                    // The bit is set.
                    channelMap[iChannel] = mal_channel_id_to_mal__win32(bitValue);
                    iChannel += 1;
                }
            }
        }
    }
}

#ifdef __cplusplus
mal_bool32 mal_is_guid_equal(const void* a, const void* b)
{
    return IsEqualGUID(*(const GUID*)a, *(const GUID*)b);
}
#else
#define mal_is_guid_equal(a, b) IsEqualGUID((const GUID*)a, (const GUID*)b)
#endif

mal_format mal_format_from_WAVEFORMATEX(const WAVEFORMATEX* pWF)
{
    mal_assert(pWF != NULL);

    if (pWF->wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
        const WAVEFORMATEXTENSIBLE* pWFEX = (const WAVEFORMATEXTENSIBLE*)pWF;
        if (mal_is_guid_equal(&pWFEX->SubFormat, &MAL_GUID_KSDATAFORMAT_SUBTYPE_PCM)) {
            if (pWFEX->Samples.wValidBitsPerSample == 32) {
                return mal_format_s32;
            }
            if (pWFEX->Samples.wValidBitsPerSample == 24) {
                if (pWFEX->Format.wBitsPerSample == 32) {
                    //return mal_format_s24_32;
                }
                if (pWFEX->Format.wBitsPerSample == 24) {
                    return mal_format_s24;
                }
            }
            if (pWFEX->Samples.wValidBitsPerSample == 16) {
                return mal_format_s16;
            }
            if (pWFEX->Samples.wValidBitsPerSample == 8) {
                return mal_format_u8;
            }
        }
        if (mal_is_guid_equal(&pWFEX->SubFormat, &MAL_GUID_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)) {
            if (pWFEX->Samples.wValidBitsPerSample == 32) {
                return mal_format_f32;
            }
            //if (pWFEX->Samples.wValidBitsPerSample == 64) {
            //    return mal_format_f64;
            //}
        }
    } else {
        if (pWF->wFormatTag == WAVE_FORMAT_PCM) {
            if (pWF->wBitsPerSample == 32) {
                return mal_format_s32;
            }
            if (pWF->wBitsPerSample == 24) {
                return mal_format_s24;
            }
            if (pWF->wBitsPerSample == 16) {
                return mal_format_s16;
            }
            if (pWF->wBitsPerSample == 8) {
                return mal_format_u8;
            }
        }
        if (pWF->wFormatTag == WAVE_FORMAT_IEEE_FLOAT) {
            if (pWF->wBitsPerSample == 32) {
                return mal_format_f32;
            }
            if (pWF->wBitsPerSample == 64) {
                //return mal_format_f64;
            }
        }
    }

    return mal_format_unknown;
}
#endif


///////////////////////////////////////////////////////////////////////////////
//
// WASAPI Backend
//
///////////////////////////////////////////////////////////////////////////////
#ifdef MAL_HAS_WASAPI
//#if defined(_MSC_VER)
//    #pragma warning(push)
//    #pragma warning(disable:4091)   // 'typedef ': ignored on left of '' when no variable is declared
//#endif
//#include <audioclient.h>
//#include <mmdeviceapi.h>
//#if defined(_MSC_VER)
//    #pragma warning(pop)
//#endif


// Some compilers don't define VerifyVersionInfoW. Need to write this ourselves.
#if defined(__DMC__)
#define _WIN32_WINNT_VISTA      0x0600
#define VER_MINORVERSION        0x01
#define VER_MAJORVERSION        0x02
#define VER_SERVICEPACKMAJOR    0x20
#define VER_GREATER_EQUAL       0x03

typedef struct  {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR szCSDVersion[128];
    WORD  wServicePackMajor;
    WORD  wServicePackMinor;
    WORD  wSuiteMask;
    BYTE  wProductType;
    BYTE  wReserved;
} mal_OSVERSIONINFOEXW;

BOOL WINAPI VerifyVersionInfoW(mal_OSVERSIONINFOEXW* lpVersionInfo, DWORD dwTypeMask, DWORDLONG dwlConditionMask);
ULONGLONG WINAPI VerSetConditionMask(ULONGLONG dwlConditionMask, DWORD dwTypeBitMask, BYTE dwConditionMask);
#else
typedef OSVERSIONINFOEXW mal_OSVERSIONINFOEXW;
#endif


#ifndef PROPERTYKEY_DEFINED
#define PROPERTYKEY_DEFINED
typedef struct
{
    GUID fmtid;
    DWORD pid;
} PROPERTYKEY;
#endif

// Some compilers don't define PropVariantInit(). We just do this ourselves since it's just a memset().
static MAL_INLINE void mal_PropVariantInit(PROPVARIANT* pProp)
{
    mal_zero_object(pProp);
}


const PROPERTYKEY MAL_PKEY_Device_FriendlyName             = {{0xA45C254E, 0xDF1C, 0x4EFD, {0x80, 0x20, 0x67, 0xD1, 0x46, 0xA8, 0x50, 0xE0}}, 14};
const PROPERTYKEY MAL_PKEY_AudioEngine_DeviceFormat        = {{0xF19F064D, 0x82C,  0x4E27, {0xBC, 0x73, 0x68, 0x82, 0xA1, 0xBB, 0x8E, 0x4C}},  0};

const IID MAL_IID_IUnknown                                 = {0x00000000, 0x0000, 0x0000, {0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46}}; // 00000000-0000-0000-C000-000000000046
const IID MAL_IID_IAgileObject                             = {0x94EA2B94, 0xE9CC, 0x49E0, {0xC0, 0xFF, 0xEE, 0x64, 0xCA, 0x8F, 0x5B, 0x90}}; // 94EA2B94-E9CC-49E0-C0FF-EE64CA8F5B90

const IID MAL_IID_IAudioClient                             = {0x1CB9AD4C, 0xDBFA, 0x4C32, {0xB1, 0x78, 0xC2, 0xF5, 0x68, 0xA7, 0x03, 0xB2}}; // 1CB9AD4C-DBFA-4C32-B178-C2F568A703B2 = __uuidof(IAudioClient)
const IID MAL_IID_IAudioClient2                            = {0x726778CD, 0xF60A, 0x4EDA, {0x82, 0xDE, 0xE4, 0x76, 0x10, 0xCD, 0x78, 0xAA}}; // 726778CD-F60A-4EDA-82DE-E47610CD78AA = __uuidof(IAudioClient2)
const IID MAL_IID_IAudioClient3                            = {0x7ED4EE07, 0x8E67, 0x4CD4, {0x8C, 0x1A, 0x2B, 0x7A, 0x59, 0x87, 0xAD, 0x42}}; // 7ED4EE07-8E67-4CD4-8C1A-2B7A5987AD42 = __uuidof(IAudioClient3)
const IID MAL_IID_IAudioRenderClient                       = {0xF294ACFC, 0x3146, 0x4483, {0xA7, 0xBF, 0xAD, 0xDC, 0xA7, 0xC2, 0x60, 0xE2}}; // F294ACFC-3146-4483-A7BF-ADDCA7C260E2 = __uuidof(IAudioRenderClient)
const IID MAL_IID_IAudioCaptureClient                      = {0xC8ADBD64, 0xE71E, 0x48A0, {0xA4, 0xDE, 0x18, 0x5C, 0x39, 0x5C, 0xD3, 0x17}}; // C8ADBD64-E71E-48A0-A4DE-185C395CD317 = __uuidof(IAudioCaptureClient)
const IID MAL_IID_IMMNotificationClient                    = {0x7991EEC9, 0x7E89, 0x4D85, {0x83, 0x90, 0x6C, 0x70, 0x3C, 0xEC, 0x60, 0xC0}}; // 7991EEC9-7E89-4D85-8390-6C703CEC60C0 = __uuidof(IMMNotificationClient)
#ifndef MAL_WIN32_DESKTOP
const IID MAL_IID_DEVINTERFACE_AUDIO_RENDER                = {0xE6327CAD, 0xDCEC, 0x4949, {0xAE, 0x8A, 0x99, 0x1E, 0x97, 0x6A, 0x79, 0xD2}}; // E6327CAD-DCEC-4949-AE8A-991E976A79D2
const IID MAL_IID_DEVINTERFACE_AUDIO_CAPTURE               = {0x2EEF81BE, 0x33FA, 0x4800, {0x96, 0x70, 0x1C, 0xD4, 0x74, 0x97, 0x2C, 0x3F}}; // 2EEF81BE-33FA-4800-9670-1CD474972C3F
const IID MAL_IID_IActivateAudioInterfaceCompletionHandler = {0x41D949AB, 0x9862, 0x444A, {0x80, 0xF6, 0xC2, 0x61, 0x33, 0x4D, 0xA5, 0xEB}}; // 41D949AB-9862-444A-80F6-C261334DA5EB
#endif

const IID MAL_CLSID_MMDeviceEnumerator_Instance            = {0xBCDE0395, 0xE52F, 0x467C, {0x8E, 0x3D, 0xC4, 0x57, 0x92, 0x91, 0x69, 0x2E}}; // BCDE0395-E52F-467C-8E3D-C4579291692E = __uuidof(MMDeviceEnumerator)
const IID MAL_IID_IMMDeviceEnumerator_Instance             = {0xA95664D2, 0x9614, 0x4F35, {0xA7, 0x46, 0xDE, 0x8D, 0xB6, 0x36, 0x17, 0xE6}}; // A95664D2-9614-4F35-A746-DE8DB63617E6 = __uuidof(IMMDeviceEnumerator)
#ifdef __cplusplus
#define MAL_CLSID_MMDeviceEnumerator MAL_CLSID_MMDeviceEnumerator_Instance
#define MAL_IID_IMMDeviceEnumerator  MAL_IID_IMMDeviceEnumerator_Instance
#else
#define MAL_CLSID_MMDeviceEnumerator &MAL_CLSID_MMDeviceEnumerator_Instance
#define MAL_IID_IMMDeviceEnumerator  &MAL_IID_IMMDeviceEnumerator_Instance
#endif

typedef struct mal_IUnknown                                 mal_IUnknown;
#ifdef MAL_WIN32_DESKTOP
#define MAL_MM_DEVICE_STATE_ACTIVE                          1
#define MAL_MM_DEVICE_STATE_DISABLED                        2
#define MAL_MM_DEVICE_STATE_NOTPRESENT                      4
#define MAL_MM_DEVICE_STATE_UNPLUGGED                       8

typedef struct mal_IMMDeviceEnumerator                      mal_IMMDeviceEnumerator;
typedef struct mal_IMMDeviceCollection                      mal_IMMDeviceCollection;
typedef struct mal_IMMDevice                                mal_IMMDevice;
#else
typedef struct mal_IActivateAudioInterfaceCompletionHandler mal_IActivateAudioInterfaceCompletionHandler;
typedef struct mal_IActivateAudioInterfaceAsyncOperation    mal_IActivateAudioInterfaceAsyncOperation;
#endif
typedef struct mal_IPropertyStore                           mal_IPropertyStore;
typedef struct mal_IAudioClient                             mal_IAudioClient;
typedef struct mal_IAudioClient2                            mal_IAudioClient2;
typedef struct mal_IAudioClient3                            mal_IAudioClient3;
typedef struct mal_IAudioRenderClient                       mal_IAudioRenderClient;
typedef struct mal_IAudioCaptureClient                      mal_IAudioCaptureClient;

typedef mal_int64                                           MAL_REFERENCE_TIME;

#define MAL_AUDCLNT_STREAMFLAGS_CROSSPROCESS                0x00010000
#define MAL_AUDCLNT_STREAMFLAGS_LOOPBACK                    0x00020000
#define MAL_AUDCLNT_STREAMFLAGS_EVENTCALLBACK               0x00040000
#define MAL_AUDCLNT_STREAMFLAGS_NOPERSIST                   0x00080000
#define MAL_AUDCLNT_STREAMFLAGS_RATEADJUST                  0x00100000
#define MAL_AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY         0x08000000
#define MAL_AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM              0x80000000
#define MAL_AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED          0x10000000
#define MAL_AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE               0x20000000
#define MAL_AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED    0x40000000

// We only care about a few error codes.
#define MAL_AUDCLNT_E_INVALID_DEVICE_PERIOD                 (-2004287456)
#define MAL_AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED               (-2004287463)
#define MAL_AUDCLNT_S_BUFFER_EMPTY                          (143196161)
#define MAL_AUDCLNT_E_DEVICE_IN_USE                         (-2004287478)

typedef enum
{
    mal_eRender  = 0,
    mal_eCapture = 1,
    mal_eAll     = 2
} mal_EDataFlow;

typedef enum
{
    mal_eConsole        = 0,
    mal_eMultimedia     = 1,
    mal_eCommunications = 2
} mal_ERole;

typedef enum
{
    MAL_AUDCLNT_SHAREMODE_SHARED,
    MAL_AUDCLNT_SHAREMODE_EXCLUSIVE
} MAL_AUDCLNT_SHAREMODE;

typedef enum
{
    MAL_AudioCategory_Other = 0,    // <-- mini_al is only caring about Other.
} MAL_AUDIO_STREAM_CATEGORY;

typedef struct
{
    UINT32 cbSize;
    BOOL bIsOffload;
    MAL_AUDIO_STREAM_CATEGORY eCategory;
} mal_AudioClientProperties;

// IUnknown
typedef struct
{
    // IUnknown
    HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_IUnknown* pThis, const IID* const riid, void** ppObject);
    ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_IUnknown* pThis);
    ULONG   (STDMETHODCALLTYPE * Release)       (mal_IUnknown* pThis);
} mal_IUnknownVtbl;
struct mal_IUnknown
{
    mal_IUnknownVtbl* lpVtbl;
};
HRESULT mal_IUnknown_QueryInterface(mal_IUnknown* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
ULONG   mal_IUnknown_AddRef(mal_IUnknown* pThis)                                                 { return pThis->lpVtbl->AddRef(pThis); }
ULONG   mal_IUnknown_Release(mal_IUnknown* pThis)                                                { return pThis->lpVtbl->Release(pThis); }

#ifdef MAL_WIN32_DESKTOP
    // IMMNotificationClient
    typedef struct
    {
        // IUnknown
        HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_IMMNotificationClient* pThis, const IID* const riid, void** ppObject);
        ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_IMMNotificationClient* pThis);
        ULONG   (STDMETHODCALLTYPE * Release)       (mal_IMMNotificationClient* pThis);

        // IMMNotificationClient
        HRESULT (STDMETHODCALLTYPE * OnDeviceStateChanged)  (mal_IMMNotificationClient* pThis, LPCWSTR pDeviceID, DWORD dwNewState);
        HRESULT (STDMETHODCALLTYPE * OnDeviceAdded)         (mal_IMMNotificationClient* pThis, LPCWSTR pDeviceID);
        HRESULT (STDMETHODCALLTYPE * OnDeviceRemoved)       (mal_IMMNotificationClient* pThis, LPCWSTR pDeviceID);
        HRESULT (STDMETHODCALLTYPE * OnDefaultDeviceChanged)(mal_IMMNotificationClient* pThis, mal_EDataFlow dataFlow, mal_ERole role, LPCWSTR pDefaultDeviceID);
        HRESULT (STDMETHODCALLTYPE * OnPropertyValueChanged)(mal_IMMNotificationClient* pThis, LPCWSTR pDeviceID, const PROPERTYKEY key);
    } mal_IMMNotificationClientVtbl;

    // IMMDeviceEnumerator
    typedef struct
    {
        // IUnknown
        HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_IMMDeviceEnumerator* pThis, const IID* const riid, void** ppObject);
        ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_IMMDeviceEnumerator* pThis);
        ULONG   (STDMETHODCALLTYPE * Release)       (mal_IMMDeviceEnumerator* pThis);

        // IMMDeviceEnumerator
        HRESULT (STDMETHODCALLTYPE * EnumAudioEndpoints)                    (mal_IMMDeviceEnumerator* pThis, mal_EDataFlow dataFlow, DWORD dwStateMask, mal_IMMDeviceCollection** ppDevices);
        HRESULT (STDMETHODCALLTYPE * GetDefaultAudioEndpoint)               (mal_IMMDeviceEnumerator* pThis, mal_EDataFlow dataFlow, mal_ERole role, mal_IMMDevice** ppEndpoint);
        HRESULT (STDMETHODCALLTYPE * GetDevice)                             (mal_IMMDeviceEnumerator* pThis, LPCWSTR pID, mal_IMMDevice** ppDevice);
        HRESULT (STDMETHODCALLTYPE * RegisterEndpointNotificationCallback)  (mal_IMMDeviceEnumerator* pThis, mal_IMMNotificationClient* pClient);
        HRESULT (STDMETHODCALLTYPE * UnregisterEndpointNotificationCallback)(mal_IMMDeviceEnumerator* pThis, mal_IMMNotificationClient* pClient);
    } mal_IMMDeviceEnumeratorVtbl;
    struct mal_IMMDeviceEnumerator
    {
        mal_IMMDeviceEnumeratorVtbl* lpVtbl;
    };
    HRESULT mal_IMMDeviceEnumerator_QueryInterface(mal_IMMDeviceEnumerator* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
    ULONG   mal_IMMDeviceEnumerator_AddRef(mal_IMMDeviceEnumerator* pThis)                                                 { return pThis->lpVtbl->AddRef(pThis); }
    ULONG   mal_IMMDeviceEnumerator_Release(mal_IMMDeviceEnumerator* pThis)                                                { return pThis->lpVtbl->Release(pThis); }
    HRESULT mal_IMMDeviceEnumerator_EnumAudioEndpoints(mal_IMMDeviceEnumerator* pThis, mal_EDataFlow dataFlow, DWORD dwStateMask, mal_IMMDeviceCollection** ppDevices) { return pThis->lpVtbl->EnumAudioEndpoints(pThis, dataFlow, dwStateMask, ppDevices); }
    HRESULT mal_IMMDeviceEnumerator_GetDefaultAudioEndpoint(mal_IMMDeviceEnumerator* pThis, mal_EDataFlow dataFlow, mal_ERole role, mal_IMMDevice** ppEndpoint) { return pThis->lpVtbl->GetDefaultAudioEndpoint(pThis, dataFlow, role, ppEndpoint); }
    HRESULT mal_IMMDeviceEnumerator_GetDevice(mal_IMMDeviceEnumerator* pThis, LPCWSTR pID, mal_IMMDevice** ppDevice)       { return pThis->lpVtbl->GetDevice(pThis, pID, ppDevice); }
    HRESULT mal_IMMDeviceEnumerator_RegisterEndpointNotificationCallback(mal_IMMDeviceEnumerator* pThis, mal_IMMNotificationClient* pClient) { return pThis->lpVtbl->RegisterEndpointNotificationCallback(pThis, pClient); }
    HRESULT mal_IMMDeviceEnumerator_UnregisterEndpointNotificationCallback(mal_IMMDeviceEnumerator* pThis, mal_IMMNotificationClient* pClient) { return pThis->lpVtbl->UnregisterEndpointNotificationCallback(pThis, pClient); }


    // IMMDeviceCollection
    typedef struct
    {
        // IUnknown
        HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_IMMDeviceCollection* pThis, const IID* const riid, void** ppObject);
        ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_IMMDeviceCollection* pThis);
        ULONG   (STDMETHODCALLTYPE * Release)       (mal_IMMDeviceCollection* pThis);

        // IMMDeviceCollection
        HRESULT (STDMETHODCALLTYPE * GetCount)(mal_IMMDeviceCollection* pThis, UINT* pDevices);
        HRESULT (STDMETHODCALLTYPE * Item)    (mal_IMMDeviceCollection* pThis, UINT nDevice, mal_IMMDevice** ppDevice);
    } mal_IMMDeviceCollectionVtbl;
    struct mal_IMMDeviceCollection
    {
        mal_IMMDeviceCollectionVtbl* lpVtbl;
    };
    HRESULT mal_IMMDeviceCollection_QueryInterface(mal_IMMDeviceCollection* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
    ULONG   mal_IMMDeviceCollection_AddRef(mal_IMMDeviceCollection* pThis)                                                 { return pThis->lpVtbl->AddRef(pThis); }
    ULONG   mal_IMMDeviceCollection_Release(mal_IMMDeviceCollection* pThis)                                                { return pThis->lpVtbl->Release(pThis); }
    HRESULT mal_IMMDeviceCollection_GetCount(mal_IMMDeviceCollection* pThis, UINT* pDevices)                               { return pThis->lpVtbl->GetCount(pThis, pDevices); }
    HRESULT mal_IMMDeviceCollection_Item(mal_IMMDeviceCollection* pThis, UINT nDevice, mal_IMMDevice** ppDevice)           { return pThis->lpVtbl->Item(pThis, nDevice, ppDevice); }


    // IMMDevice
    typedef struct
    {
        // IUnknown
        HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_IMMDevice* pThis, const IID* const riid, void** ppObject);
        ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_IMMDevice* pThis);
        ULONG   (STDMETHODCALLTYPE * Release)       (mal_IMMDevice* pThis);

        // IMMDevice
        HRESULT (STDMETHODCALLTYPE * Activate)         (mal_IMMDevice* pThis, const IID* const iid, DWORD dwClsCtx, PROPVARIANT* pActivationParams, void** ppInterface);
        HRESULT (STDMETHODCALLTYPE * OpenPropertyStore)(mal_IMMDevice* pThis, DWORD stgmAccess, mal_IPropertyStore** ppProperties);
        HRESULT (STDMETHODCALLTYPE * GetId)            (mal_IMMDevice* pThis, LPWSTR *pID);
        HRESULT (STDMETHODCALLTYPE * GetState)         (mal_IMMDevice* pThis, DWORD *pState);
    } mal_IMMDeviceVtbl;
    struct mal_IMMDevice
    {
        mal_IMMDeviceVtbl* lpVtbl;
    };
    HRESULT mal_IMMDevice_QueryInterface(mal_IMMDevice* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
    ULONG   mal_IMMDevice_AddRef(mal_IMMDevice* pThis)                                                 { return pThis->lpVtbl->AddRef(pThis); }
    ULONG   mal_IMMDevice_Release(mal_IMMDevice* pThis)                                                { return pThis->lpVtbl->Release(pThis); }
    HRESULT mal_IMMDevice_Activate(mal_IMMDevice* pThis, const IID* const iid, DWORD dwClsCtx, PROPVARIANT* pActivationParams, void** ppInterface) { return pThis->lpVtbl->Activate(pThis, iid, dwClsCtx, pActivationParams, ppInterface); }
    HRESULT mal_IMMDevice_OpenPropertyStore(mal_IMMDevice* pThis, DWORD stgmAccess, mal_IPropertyStore** ppProperties) { return pThis->lpVtbl->OpenPropertyStore(pThis, stgmAccess, ppProperties); }
    HRESULT mal_IMMDevice_GetId(mal_IMMDevice* pThis, LPWSTR *pID)                                     { return pThis->lpVtbl->GetId(pThis, pID); }
    HRESULT mal_IMMDevice_GetState(mal_IMMDevice* pThis, DWORD *pState)                                { return pThis->lpVtbl->GetState(pThis, pState); }
#else
    // IActivateAudioInterfaceAsyncOperation
    typedef struct
    {
        // IUnknown
        HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_IActivateAudioInterfaceAsyncOperation* pThis, const IID* const riid, void** ppObject);
        ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_IActivateAudioInterfaceAsyncOperation* pThis);
        ULONG   (STDMETHODCALLTYPE * Release)       (mal_IActivateAudioInterfaceAsyncOperation* pThis);

        // IActivateAudioInterfaceAsyncOperation
        HRESULT (STDMETHODCALLTYPE * GetActivateResult)(mal_IActivateAudioInterfaceAsyncOperation* pThis, HRESULT *pActivateResult, mal_IUnknown** ppActivatedInterface);
    } mal_IActivateAudioInterfaceAsyncOperationVtbl;
    struct mal_IActivateAudioInterfaceAsyncOperation
    {
        mal_IActivateAudioInterfaceAsyncOperationVtbl* lpVtbl;
    };
    HRESULT mal_IActivateAudioInterfaceAsyncOperation_QueryInterface(mal_IActivateAudioInterfaceAsyncOperation* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
    ULONG   mal_IActivateAudioInterfaceAsyncOperation_AddRef(mal_IActivateAudioInterfaceAsyncOperation* pThis)                                                 { return pThis->lpVtbl->AddRef(pThis); }
    ULONG   mal_IActivateAudioInterfaceAsyncOperation_Release(mal_IActivateAudioInterfaceAsyncOperation* pThis)                                                { return pThis->lpVtbl->Release(pThis); }
    HRESULT mal_IActivateAudioInterfaceAsyncOperation_GetActivateResult(mal_IActivateAudioInterfaceAsyncOperation* pThis, HRESULT *pActivateResult, mal_IUnknown** ppActivatedInterface) { return pThis->lpVtbl->GetActivateResult(pThis, pActivateResult, ppActivatedInterface); }
#endif

// IPropertyStore
typedef struct
{
    // IUnknown
    HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_IPropertyStore* pThis, const IID* const riid, void** ppObject);
    ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_IPropertyStore* pThis);
    ULONG   (STDMETHODCALLTYPE * Release)       (mal_IPropertyStore* pThis);

    // IPropertyStore
    HRESULT (STDMETHODCALLTYPE * GetCount)(mal_IPropertyStore* pThis, DWORD* pPropCount);
    HRESULT (STDMETHODCALLTYPE * GetAt)   (mal_IPropertyStore* pThis, DWORD propIndex, PROPERTYKEY* pPropKey);
    HRESULT (STDMETHODCALLTYPE * GetValue)(mal_IPropertyStore* pThis, const PROPERTYKEY* const pKey, PROPVARIANT* pPropVar);
    HRESULT (STDMETHODCALLTYPE * SetValue)(mal_IPropertyStore* pThis, const PROPERTYKEY* const pKey, const PROPVARIANT* const pPropVar);
    HRESULT (STDMETHODCALLTYPE * Commit)  (mal_IPropertyStore* pThis);
} mal_IPropertyStoreVtbl;
struct mal_IPropertyStore
{
    mal_IPropertyStoreVtbl* lpVtbl;
};
HRESULT mal_IPropertyStore_QueryInterface(mal_IPropertyStore* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
ULONG   mal_IPropertyStore_AddRef(mal_IPropertyStore* pThis)                                                 { return pThis->lpVtbl->AddRef(pThis); }
ULONG   mal_IPropertyStore_Release(mal_IPropertyStore* pThis)                                                { return pThis->lpVtbl->Release(pThis); }
HRESULT mal_IPropertyStore_GetCount(mal_IPropertyStore* pThis, DWORD* pPropCount)                            { return pThis->lpVtbl->GetCount(pThis, pPropCount); }
HRESULT mal_IPropertyStore_GetAt(mal_IPropertyStore* pThis, DWORD propIndex, PROPERTYKEY* pPropKey)          { return pThis->lpVtbl->GetAt(pThis, propIndex, pPropKey); }
HRESULT mal_IPropertyStore_GetValue(mal_IPropertyStore* pThis, const PROPERTYKEY* const pKey, PROPVARIANT* pPropVar) { return pThis->lpVtbl->GetValue(pThis, pKey, pPropVar); }
HRESULT mal_IPropertyStore_SetValue(mal_IPropertyStore* pThis, const PROPERTYKEY* const pKey, const PROPVARIANT* const pPropVar) { return pThis->lpVtbl->SetValue(pThis, pKey, pPropVar); }
HRESULT mal_IPropertyStore_Commit(mal_IPropertyStore* pThis)                                                 { return pThis->lpVtbl->Commit(pThis); }


// IAudioClient
typedef struct
{
    // IUnknown
    HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_IAudioClient* pThis, const IID* const riid, void** ppObject);
    ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_IAudioClient* pThis);
    ULONG   (STDMETHODCALLTYPE * Release)       (mal_IAudioClient* pThis);

    // IAudioClient
    HRESULT (STDMETHODCALLTYPE * Initialize)       (mal_IAudioClient* pThis, MAL_AUDCLNT_SHAREMODE shareMode, DWORD streamFlags, MAL_REFERENCE_TIME bufferDuration, MAL_REFERENCE_TIME periodicity, const WAVEFORMATEX* pFormat, const GUID* pAudioSessionGuid);
    HRESULT (STDMETHODCALLTYPE * GetBufferSize)    (mal_IAudioClient* pThis, mal_uint32* pNumBufferFrames);
    HRESULT (STDMETHODCALLTYPE * GetStreamLatency) (mal_IAudioClient* pThis, MAL_REFERENCE_TIME* pLatency);
    HRESULT (STDMETHODCALLTYPE * GetCurrentPadding)(mal_IAudioClient* pThis, mal_uint32* pNumPaddingFrames);
    HRESULT (STDMETHODCALLTYPE * IsFormatSupported)(mal_IAudioClient* pThis, MAL_AUDCLNT_SHAREMODE shareMode, const WAVEFORMATEX* pFormat, WAVEFORMATEX** ppClosestMatch);
    HRESULT (STDMETHODCALLTYPE * GetMixFormat)     (mal_IAudioClient* pThis, WAVEFORMATEX** ppDeviceFormat);
    HRESULT (STDMETHODCALLTYPE * GetDevicePeriod)  (mal_IAudioClient* pThis, MAL_REFERENCE_TIME* pDefaultDevicePeriod, MAL_REFERENCE_TIME* pMinimumDevicePeriod);
    HRESULT (STDMETHODCALLTYPE * Start)            (mal_IAudioClient* pThis);
    HRESULT (STDMETHODCALLTYPE * Stop)             (mal_IAudioClient* pThis);
    HRESULT (STDMETHODCALLTYPE * Reset)            (mal_IAudioClient* pThis);
    HRESULT (STDMETHODCALLTYPE * SetEventHandle)   (mal_IAudioClient* pThis, HANDLE eventHandle);
    HRESULT (STDMETHODCALLTYPE * GetService)       (mal_IAudioClient* pThis, const IID* const riid, void** pp);
} mal_IAudioClientVtbl;
struct mal_IAudioClient
{
    mal_IAudioClientVtbl* lpVtbl;
};
HRESULT mal_IAudioClient_QueryInterface(mal_IAudioClient* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
ULONG   mal_IAudioClient_AddRef(mal_IAudioClient* pThis)                                                 { return pThis->lpVtbl->AddRef(pThis); }
ULONG   mal_IAudioClient_Release(mal_IAudioClient* pThis)                                                { return pThis->lpVtbl->Release(pThis); }
HRESULT mal_IAudioClient_Initialize(mal_IAudioClient* pThis, MAL_AUDCLNT_SHAREMODE shareMode, DWORD streamFlags, MAL_REFERENCE_TIME bufferDuration, MAL_REFERENCE_TIME periodicity, const WAVEFORMATEX* pFormat, const GUID* pAudioSessionGuid) { return pThis->lpVtbl->Initialize(pThis, shareMode, streamFlags, bufferDuration, periodicity, pFormat, pAudioSessionGuid); }
HRESULT mal_IAudioClient_GetBufferSize(mal_IAudioClient* pThis, mal_uint32* pNumBufferFrames)                { return pThis->lpVtbl->GetBufferSize(pThis, pNumBufferFrames); }
HRESULT mal_IAudioClient_GetStreamLatency(mal_IAudioClient* pThis, MAL_REFERENCE_TIME* pLatency)             { return pThis->lpVtbl->GetStreamLatency(pThis, pLatency); }
HRESULT mal_IAudioClient_GetCurrentPadding(mal_IAudioClient* pThis, mal_uint32* pNumPaddingFrames)           { return pThis->lpVtbl->GetCurrentPadding(pThis, pNumPaddingFrames); }
HRESULT mal_IAudioClient_IsFormatSupported(mal_IAudioClient* pThis, MAL_AUDCLNT_SHAREMODE shareMode, const WAVEFORMATEX* pFormat, WAVEFORMATEX** ppClosestMatch) { return pThis->lpVtbl->IsFormatSupported(pThis, shareMode, pFormat, ppClosestMatch); }
HRESULT mal_IAudioClient_GetMixFormat(mal_IAudioClient* pThis, WAVEFORMATEX** ppDeviceFormat)            { return pThis->lpVtbl->GetMixFormat(pThis, ppDeviceFormat); }
HRESULT mal_IAudioClient_GetDevicePeriod(mal_IAudioClient* pThis, MAL_REFERENCE_TIME* pDefaultDevicePeriod, MAL_REFERENCE_TIME* pMinimumDevicePeriod) { return pThis->lpVtbl->GetDevicePeriod(pThis, pDefaultDevicePeriod, pMinimumDevicePeriod); }
HRESULT mal_IAudioClient_Start(mal_IAudioClient* pThis)                                                  { return pThis->lpVtbl->Start(pThis); }
HRESULT mal_IAudioClient_Stop(mal_IAudioClient* pThis)                                                   { return pThis->lpVtbl->Stop(pThis); }
HRESULT mal_IAudioClient_Reset(mal_IAudioClient* pThis)                                                  { return pThis->lpVtbl->Reset(pThis); }
HRESULT mal_IAudioClient_SetEventHandle(mal_IAudioClient* pThis, HANDLE eventHandle)                     { return pThis->lpVtbl->SetEventHandle(pThis, eventHandle); }
HRESULT mal_IAudioClient_GetService(mal_IAudioClient* pThis, const IID* const riid, void** pp)           { return pThis->lpVtbl->GetService(pThis, riid, pp); }

// IAudioClient2
typedef struct
{
    // IUnknown
    HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_IAudioClient2* pThis, const IID* const riid, void** ppObject);
    ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_IAudioClient2* pThis);
    ULONG   (STDMETHODCALLTYPE * Release)       (mal_IAudioClient2* pThis);

    // IAudioClient
    HRESULT (STDMETHODCALLTYPE * Initialize)       (mal_IAudioClient2* pThis, MAL_AUDCLNT_SHAREMODE shareMode, DWORD streamFlags, MAL_REFERENCE_TIME bufferDuration, MAL_REFERENCE_TIME periodicity, const WAVEFORMATEX* pFormat, const GUID* pAudioSessionGuid);
    HRESULT (STDMETHODCALLTYPE * GetBufferSize)    (mal_IAudioClient2* pThis, mal_uint32* pNumBufferFrames);
    HRESULT (STDMETHODCALLTYPE * GetStreamLatency) (mal_IAudioClient2* pThis, MAL_REFERENCE_TIME* pLatency);
    HRESULT (STDMETHODCALLTYPE * GetCurrentPadding)(mal_IAudioClient2* pThis, mal_uint32* pNumPaddingFrames);
    HRESULT (STDMETHODCALLTYPE * IsFormatSupported)(mal_IAudioClient2* pThis, MAL_AUDCLNT_SHAREMODE shareMode, const WAVEFORMATEX* pFormat, WAVEFORMATEX** ppClosestMatch);
    HRESULT (STDMETHODCALLTYPE * GetMixFormat)     (mal_IAudioClient2* pThis, WAVEFORMATEX** ppDeviceFormat);
    HRESULT (STDMETHODCALLTYPE * GetDevicePeriod)  (mal_IAudioClient2* pThis, MAL_REFERENCE_TIME* pDefaultDevicePeriod, MAL_REFERENCE_TIME* pMinimumDevicePeriod);
    HRESULT (STDMETHODCALLTYPE * Start)            (mal_IAudioClient2* pThis);
    HRESULT (STDMETHODCALLTYPE * Stop)             (mal_IAudioClient2* pThis);
    HRESULT (STDMETHODCALLTYPE * Reset)            (mal_IAudioClient2* pThis);
    HRESULT (STDMETHODCALLTYPE * SetEventHandle)   (mal_IAudioClient2* pThis, HANDLE eventHandle);
    HRESULT (STDMETHODCALLTYPE * GetService)       (mal_IAudioClient2* pThis, const IID* const riid, void** pp);

    // IAudioClient2
    HRESULT (STDMETHODCALLTYPE * IsOffloadCapable)   (mal_IAudioClient2* pThis, MAL_AUDIO_STREAM_CATEGORY category, BOOL* pOffloadCapable);
    HRESULT (STDMETHODCALLTYPE * SetClientProperties)(mal_IAudioClient2* pThis, const mal_AudioClientProperties* pProperties);
    HRESULT (STDMETHODCALLTYPE * GetBufferSizeLimits)(mal_IAudioClient2* pThis, const WAVEFORMATEX* pFormat, BOOL eventDriven, MAL_REFERENCE_TIME* pMinBufferDuration, MAL_REFERENCE_TIME* pMaxBufferDuration);
} mal_IAudioClient2Vtbl;
struct mal_IAudioClient2
{
    mal_IAudioClient2Vtbl* lpVtbl;
};
HRESULT mal_IAudioClient2_QueryInterface(mal_IAudioClient2* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
ULONG   mal_IAudioClient2_AddRef(mal_IAudioClient2* pThis)                                                 { return pThis->lpVtbl->AddRef(pThis); }
ULONG   mal_IAudioClient2_Release(mal_IAudioClient2* pThis)                                                { return pThis->lpVtbl->Release(pThis); }
HRESULT mal_IAudioClient2_Initialize(mal_IAudioClient2* pThis, MAL_AUDCLNT_SHAREMODE shareMode, DWORD streamFlags, MAL_REFERENCE_TIME bufferDuration, MAL_REFERENCE_TIME periodicity, const WAVEFORMATEX* pFormat, const GUID* pAudioSessionGuid) { return pThis->lpVtbl->Initialize(pThis, shareMode, streamFlags, bufferDuration, periodicity, pFormat, pAudioSessionGuid); }
HRESULT mal_IAudioClient2_GetBufferSize(mal_IAudioClient2* pThis, mal_uint32* pNumBufferFrames)                { return pThis->lpVtbl->GetBufferSize(pThis, pNumBufferFrames); }
HRESULT mal_IAudioClient2_GetStreamLatency(mal_IAudioClient2* pThis, MAL_REFERENCE_TIME* pLatency)             { return pThis->lpVtbl->GetStreamLatency(pThis, pLatency); }
HRESULT mal_IAudioClient2_GetCurrentPadding(mal_IAudioClient2* pThis, mal_uint32* pNumPaddingFrames)           { return pThis->lpVtbl->GetCurrentPadding(pThis, pNumPaddingFrames); }
HRESULT mal_IAudioClient2_IsFormatSupported(mal_IAudioClient2* pThis, MAL_AUDCLNT_SHAREMODE shareMode, const WAVEFORMATEX* pFormat, WAVEFORMATEX** ppClosestMatch) { return pThis->lpVtbl->IsFormatSupported(pThis, shareMode, pFormat, ppClosestMatch); }
HRESULT mal_IAudioClient2_GetMixFormat(mal_IAudioClient2* pThis, WAVEFORMATEX** ppDeviceFormat)            { return pThis->lpVtbl->GetMixFormat(pThis, ppDeviceFormat); }
HRESULT mal_IAudioClient2_GetDevicePeriod(mal_IAudioClient2* pThis, MAL_REFERENCE_TIME* pDefaultDevicePeriod, MAL_REFERENCE_TIME* pMinimumDevicePeriod) { return pThis->lpVtbl->GetDevicePeriod(pThis, pDefaultDevicePeriod, pMinimumDevicePeriod); }
HRESULT mal_IAudioClient2_Start(mal_IAudioClient2* pThis)                                                  { return pThis->lpVtbl->Start(pThis); }
HRESULT mal_IAudioClient2_Stop(mal_IAudioClient2* pThis)                                                   { return pThis->lpVtbl->Stop(pThis); }
HRESULT mal_IAudioClient2_Reset(mal_IAudioClient2* pThis)                                                  { return pThis->lpVtbl->Reset(pThis); }
HRESULT mal_IAudioClient2_SetEventHandle(mal_IAudioClient2* pThis, HANDLE eventHandle)                     { return pThis->lpVtbl->SetEventHandle(pThis, eventHandle); }
HRESULT mal_IAudioClient2_GetService(mal_IAudioClient2* pThis, const IID* const riid, void** pp)           { return pThis->lpVtbl->GetService(pThis, riid, pp); }
HRESULT mal_IAudioClient2_IsOffloadCapable(mal_IAudioClient2* pThis, MAL_AUDIO_STREAM_CATEGORY category, BOOL* pOffloadCapable) { return pThis->lpVtbl->IsOffloadCapable(pThis, category, pOffloadCapable); }
HRESULT mal_IAudioClient2_SetClientProperties(mal_IAudioClient2* pThis, const mal_AudioClientProperties* pProperties)           { return pThis->lpVtbl->SetClientProperties(pThis, pProperties); }
HRESULT mal_IAudioClient2_GetBufferSizeLimits(mal_IAudioClient2* pThis, const WAVEFORMATEX* pFormat, BOOL eventDriven, MAL_REFERENCE_TIME* pMinBufferDuration, MAL_REFERENCE_TIME* pMaxBufferDuration) { return pThis->lpVtbl->GetBufferSizeLimits(pThis, pFormat, eventDriven, pMinBufferDuration, pMaxBufferDuration); }


// IAudioClient3
typedef struct
{
    // IUnknown
    HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_IAudioClient3* pThis, const IID* const riid, void** ppObject);
    ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_IAudioClient3* pThis);
    ULONG   (STDMETHODCALLTYPE * Release)       (mal_IAudioClient3* pThis);

    // IAudioClient
    HRESULT (STDMETHODCALLTYPE * Initialize)       (mal_IAudioClient3* pThis, MAL_AUDCLNT_SHAREMODE shareMode, DWORD streamFlags, MAL_REFERENCE_TIME bufferDuration, MAL_REFERENCE_TIME periodicity, const WAVEFORMATEX* pFormat, const GUID* pAudioSessionGuid);
    HRESULT (STDMETHODCALLTYPE * GetBufferSize)    (mal_IAudioClient3* pThis, mal_uint32* pNumBufferFrames);
    HRESULT (STDMETHODCALLTYPE * GetStreamLatency) (mal_IAudioClient3* pThis, MAL_REFERENCE_TIME* pLatency);
    HRESULT (STDMETHODCALLTYPE * GetCurrentPadding)(mal_IAudioClient3* pThis, mal_uint32* pNumPaddingFrames);
    HRESULT (STDMETHODCALLTYPE * IsFormatSupported)(mal_IAudioClient3* pThis, MAL_AUDCLNT_SHAREMODE shareMode, const WAVEFORMATEX* pFormat, WAVEFORMATEX** ppClosestMatch);
    HRESULT (STDMETHODCALLTYPE * GetMixFormat)     (mal_IAudioClient3* pThis, WAVEFORMATEX** ppDeviceFormat);
    HRESULT (STDMETHODCALLTYPE * GetDevicePeriod)  (mal_IAudioClient3* pThis, MAL_REFERENCE_TIME* pDefaultDevicePeriod, MAL_REFERENCE_TIME* pMinimumDevicePeriod);
    HRESULT (STDMETHODCALLTYPE * Start)            (mal_IAudioClient3* pThis);
    HRESULT (STDMETHODCALLTYPE * Stop)             (mal_IAudioClient3* pThis);
    HRESULT (STDMETHODCALLTYPE * Reset)            (mal_IAudioClient3* pThis);
    HRESULT (STDMETHODCALLTYPE * SetEventHandle)   (mal_IAudioClient3* pThis, HANDLE eventHandle);
    HRESULT (STDMETHODCALLTYPE * GetService)       (mal_IAudioClient3* pThis, const IID* const riid, void** pp);

    // IAudioClient2
    HRESULT (STDMETHODCALLTYPE * IsOffloadCapable)   (mal_IAudioClient3* pThis, MAL_AUDIO_STREAM_CATEGORY category, BOOL* pOffloadCapable);
    HRESULT (STDMETHODCALLTYPE * SetClientProperties)(mal_IAudioClient3* pThis, const mal_AudioClientProperties* pProperties);
    HRESULT (STDMETHODCALLTYPE * GetBufferSizeLimits)(mal_IAudioClient3* pThis, const WAVEFORMATEX* pFormat, BOOL eventDriven, MAL_REFERENCE_TIME* pMinBufferDuration, MAL_REFERENCE_TIME* pMaxBufferDuration);

    // IAudioClient3
    HRESULT (STDMETHODCALLTYPE * GetSharedModeEnginePeriod)       (mal_IAudioClient3* pThis, const WAVEFORMATEX* pFormat, UINT32* pDefaultPeriodInFrames, UINT32* pFundamentalPeriodInFrames, UINT32* pMinPeriodInFrames, UINT32* pMaxPeriodInFrames);
    HRESULT (STDMETHODCALLTYPE * GetCurrentSharedModeEnginePeriod)(mal_IAudioClient3* pThis, WAVEFORMATEX** ppFormat, UINT32* pCurrentPeriodInFrames);
    HRESULT (STDMETHODCALLTYPE * InitializeSharedAudioStream)     (mal_IAudioClient3* pThis, DWORD streamFlags, UINT32 periodInFrames, const WAVEFORMATEX* pFormat, const GUID* pAudioSessionGuid);
} mal_IAudioClient3Vtbl;
struct mal_IAudioClient3
{
    mal_IAudioClient3Vtbl* lpVtbl;
};
HRESULT mal_IAudioClient3_QueryInterface(mal_IAudioClient3* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
ULONG   mal_IAudioClient3_AddRef(mal_IAudioClient3* pThis)                                                 { return pThis->lpVtbl->AddRef(pThis); }
ULONG   mal_IAudioClient3_Release(mal_IAudioClient3* pThis)                                                { return pThis->lpVtbl->Release(pThis); }
HRESULT mal_IAudioClient3_Initialize(mal_IAudioClient3* pThis, MAL_AUDCLNT_SHAREMODE shareMode, DWORD streamFlags, MAL_REFERENCE_TIME bufferDuration, MAL_REFERENCE_TIME periodicity, const WAVEFORMATEX* pFormat, const GUID* pAudioSessionGuid) { return pThis->lpVtbl->Initialize(pThis, shareMode, streamFlags, bufferDuration, periodicity, pFormat, pAudioSessionGuid); }
HRESULT mal_IAudioClient3_GetBufferSize(mal_IAudioClient3* pThis, mal_uint32* pNumBufferFrames)                { return pThis->lpVtbl->GetBufferSize(pThis, pNumBufferFrames); }
HRESULT mal_IAudioClient3_GetStreamLatency(mal_IAudioClient3* pThis, MAL_REFERENCE_TIME* pLatency)             { return pThis->lpVtbl->GetStreamLatency(pThis, pLatency); }
HRESULT mal_IAudioClient3_GetCurrentPadding(mal_IAudioClient3* pThis, mal_uint32* pNumPaddingFrames)           { return pThis->lpVtbl->GetCurrentPadding(pThis, pNumPaddingFrames); }
HRESULT mal_IAudioClient3_IsFormatSupported(mal_IAudioClient3* pThis, MAL_AUDCLNT_SHAREMODE shareMode, const WAVEFORMATEX* pFormat, WAVEFORMATEX** ppClosestMatch) { return pThis->lpVtbl->IsFormatSupported(pThis, shareMode, pFormat, ppClosestMatch); }
HRESULT mal_IAudioClient3_GetMixFormat(mal_IAudioClient3* pThis, WAVEFORMATEX** ppDeviceFormat)            { return pThis->lpVtbl->GetMixFormat(pThis, ppDeviceFormat); }
HRESULT mal_IAudioClient3_GetDevicePeriod(mal_IAudioClient3* pThis, MAL_REFERENCE_TIME* pDefaultDevicePeriod, MAL_REFERENCE_TIME* pMinimumDevicePeriod) { return pThis->lpVtbl->GetDevicePeriod(pThis, pDefaultDevicePeriod, pMinimumDevicePeriod); }
HRESULT mal_IAudioClient3_Start(mal_IAudioClient3* pThis)                                                  { return pThis->lpVtbl->Start(pThis); }
HRESULT mal_IAudioClient3_Stop(mal_IAudioClient3* pThis)                                                   { return pThis->lpVtbl->Stop(pThis); }
HRESULT mal_IAudioClient3_Reset(mal_IAudioClient3* pThis)                                                  { return pThis->lpVtbl->Reset(pThis); }
HRESULT mal_IAudioClient3_SetEventHandle(mal_IAudioClient3* pThis, HANDLE eventHandle)                     { return pThis->lpVtbl->SetEventHandle(pThis, eventHandle); }
HRESULT mal_IAudioClient3_GetService(mal_IAudioClient3* pThis, const IID* const riid, void** pp)           { return pThis->lpVtbl->GetService(pThis, riid, pp); }
HRESULT mal_IAudioClient3_IsOffloadCapable(mal_IAudioClient3* pThis, MAL_AUDIO_STREAM_CATEGORY category, BOOL* pOffloadCapable) { return pThis->lpVtbl->IsOffloadCapable(pThis, category, pOffloadCapable); }
HRESULT mal_IAudioClient3_SetClientProperties(mal_IAudioClient3* pThis, const mal_AudioClientProperties* pProperties)           { return pThis->lpVtbl->SetClientProperties(pThis, pProperties); }
HRESULT mal_IAudioClient3_GetBufferSizeLimits(mal_IAudioClient3* pThis, const WAVEFORMATEX* pFormat, BOOL eventDriven, MAL_REFERENCE_TIME* pMinBufferDuration, MAL_REFERENCE_TIME* pMaxBufferDuration) { return pThis->lpVtbl->GetBufferSizeLimits(pThis, pFormat, eventDriven, pMinBufferDuration, pMaxBufferDuration); }
HRESULT mal_IAudioClient3_GetSharedModeEnginePeriod(mal_IAudioClient3* pThis, const WAVEFORMATEX* pFormat, UINT32* pDefaultPeriodInFrames, UINT32* pFundamentalPeriodInFrames, UINT32* pMinPeriodInFrames, UINT32* pMaxPeriodInFrames) { return pThis->lpVtbl->GetSharedModeEnginePeriod(pThis, pFormat, pDefaultPeriodInFrames, pFundamentalPeriodInFrames, pMinPeriodInFrames, pMaxPeriodInFrames); }
HRESULT mal_IAudioClient3_GetCurrentSharedModeEnginePeriod(mal_IAudioClient3* pThis, WAVEFORMATEX** ppFormat, UINT32* pCurrentPeriodInFrames) { return pThis->lpVtbl->GetCurrentSharedModeEnginePeriod(pThis, ppFormat, pCurrentPeriodInFrames); }
HRESULT mal_IAudioClient3_InitializeSharedAudioStream(mal_IAudioClient3* pThis, DWORD streamFlags, UINT32 periodInFrames, const WAVEFORMATEX* pFormat, const GUID* pAudioSessionGUID) { return pThis->lpVtbl->InitializeSharedAudioStream(pThis, streamFlags, periodInFrames, pFormat, pAudioSessionGUID); }


// IAudioRenderClient
typedef struct
{
    // IUnknown
    HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_IAudioRenderClient* pThis, const IID* const riid, void** ppObject);
    ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_IAudioRenderClient* pThis);
    ULONG   (STDMETHODCALLTYPE * Release)       (mal_IAudioRenderClient* pThis);

    // IAudioRenderClient
    HRESULT (STDMETHODCALLTYPE * GetBuffer)    (mal_IAudioRenderClient* pThis, mal_uint32 numFramesRequested, BYTE** ppData);
    HRESULT (STDMETHODCALLTYPE * ReleaseBuffer)(mal_IAudioRenderClient* pThis, mal_uint32 numFramesWritten, DWORD dwFlags);
} mal_IAudioRenderClientVtbl;
struct mal_IAudioRenderClient
{
    mal_IAudioRenderClientVtbl* lpVtbl;
};
HRESULT mal_IAudioRenderClient_QueryInterface(mal_IAudioRenderClient* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
ULONG   mal_IAudioRenderClient_AddRef(mal_IAudioRenderClient* pThis)                                                 { return pThis->lpVtbl->AddRef(pThis); }
ULONG   mal_IAudioRenderClient_Release(mal_IAudioRenderClient* pThis)                                                { return pThis->lpVtbl->Release(pThis); }
HRESULT mal_IAudioRenderClient_GetBuffer(mal_IAudioRenderClient* pThis, mal_uint32 numFramesRequested, BYTE** ppData)    { return pThis->lpVtbl->GetBuffer(pThis, numFramesRequested, ppData); }
HRESULT mal_IAudioRenderClient_ReleaseBuffer(mal_IAudioRenderClient* pThis, mal_uint32 numFramesWritten, DWORD dwFlags)  { return pThis->lpVtbl->ReleaseBuffer(pThis, numFramesWritten, dwFlags); }


// IAudioCaptureClient
typedef struct
{
    // IUnknown
    HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_IAudioCaptureClient* pThis, const IID* const riid, void** ppObject);
    ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_IAudioCaptureClient* pThis);
    ULONG   (STDMETHODCALLTYPE * Release)       (mal_IAudioCaptureClient* pThis);

    // IAudioRenderClient
    HRESULT (STDMETHODCALLTYPE * GetBuffer)        (mal_IAudioCaptureClient* pThis, BYTE** ppData, mal_uint32* pNumFramesToRead, DWORD* pFlags, mal_uint64* pDevicePosition, mal_uint64* pQPCPosition);
    HRESULT (STDMETHODCALLTYPE * ReleaseBuffer)    (mal_IAudioCaptureClient* pThis, mal_uint32 numFramesRead);
    HRESULT (STDMETHODCALLTYPE * GetNextPacketSize)(mal_IAudioCaptureClient* pThis, mal_uint32* pNumFramesInNextPacket);
} mal_IAudioCaptureClientVtbl;
struct mal_IAudioCaptureClient
{
    mal_IAudioCaptureClientVtbl* lpVtbl;
};
HRESULT mal_IAudioCaptureClient_QueryInterface(mal_IAudioCaptureClient* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
ULONG   mal_IAudioCaptureClient_AddRef(mal_IAudioCaptureClient* pThis)                                                 { return pThis->lpVtbl->AddRef(pThis); }
ULONG   mal_IAudioCaptureClient_Release(mal_IAudioCaptureClient* pThis)                                                { return pThis->lpVtbl->Release(pThis); }
HRESULT mal_IAudioCaptureClient_GetBuffer(mal_IAudioCaptureClient* pThis, BYTE** ppData, mal_uint32* pNumFramesToRead, DWORD* pFlags, mal_uint64* pDevicePosition, mal_uint64* pQPCPosition) { return pThis->lpVtbl->GetBuffer(pThis, ppData, pNumFramesToRead, pFlags, pDevicePosition, pQPCPosition); }
HRESULT mal_IAudioCaptureClient_ReleaseBuffer(mal_IAudioCaptureClient* pThis, mal_uint32 numFramesRead)                    { return pThis->lpVtbl->ReleaseBuffer(pThis, numFramesRead); }
HRESULT mal_IAudioCaptureClient_GetNextPacketSize(mal_IAudioCaptureClient* pThis, mal_uint32* pNumFramesInNextPacket)      { return pThis->lpVtbl->GetNextPacketSize(pThis, pNumFramesInNextPacket); }

#ifndef MAL_WIN32_DESKTOP
#include <mmdeviceapi.h>
typedef struct mal_completion_handler_uwp mal_completion_handler_uwp;

typedef struct
{
    // IUnknown
    HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_completion_handler_uwp* pThis, const IID* const riid, void** ppObject);
    ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_completion_handler_uwp* pThis);
    ULONG   (STDMETHODCALLTYPE * Release)       (mal_completion_handler_uwp* pThis);

    // IActivateAudioInterfaceCompletionHandler
    HRESULT (STDMETHODCALLTYPE * ActivateCompleted)(mal_completion_handler_uwp* pThis, mal_IActivateAudioInterfaceAsyncOperation* pActivateOperation);
} mal_completion_handler_uwp_vtbl;
struct mal_completion_handler_uwp
{
    mal_completion_handler_uwp_vtbl* lpVtbl;
    mal_uint32 counter;
    HANDLE hEvent;
};

HRESULT STDMETHODCALLTYPE mal_completion_handler_uwp_QueryInterface(mal_completion_handler_uwp* pThis, const IID* const riid, void** ppObject)
{
    // We need to "implement" IAgileObject which is just an indicator that's used internally by WASAPI for some multithreading management. To
    // "implement" this, we just make sure we return pThis when the IAgileObject is requested.
    if (!mal_is_guid_equal(riid, &MAL_IID_IUnknown) && !mal_is_guid_equal(riid, &MAL_IID_IActivateAudioInterfaceCompletionHandler) && !mal_is_guid_equal(riid, &MAL_IID_IAgileObject)) {
        *ppObject = NULL;
        return E_NOINTERFACE;
    }

    // Getting here means the IID is IUnknown or IMMNotificationClient.
    *ppObject = (void*)pThis;
    ((mal_completion_handler_uwp_vtbl*)pThis->lpVtbl)->AddRef(pThis);
    return S_OK;
}

ULONG STDMETHODCALLTYPE mal_completion_handler_uwp_AddRef(mal_completion_handler_uwp* pThis)
{
    return (ULONG)mal_atomic_increment_32(&pThis->counter);
}

ULONG STDMETHODCALLTYPE mal_completion_handler_uwp_Release(mal_completion_handler_uwp* pThis)
{
    mal_uint32 newRefCount = mal_atomic_decrement_32(&pThis->counter);
    if (newRefCount == 0) {
        return 0;   // We don't free anything here because we never allocate the object on the heap.
    }

    return (ULONG)newRefCount;
}

HRESULT STDMETHODCALLTYPE mal_completion_handler_uwp_ActivateCompleted(mal_completion_handler_uwp* pThis, mal_IActivateAudioInterfaceAsyncOperation* pActivateOperation)
{
    (void)pActivateOperation;
    SetEvent(pThis->hEvent);
    return S_OK;
}


static mal_completion_handler_uwp_vtbl g_malCompletionHandlerVtblInstance = {
    mal_completion_handler_uwp_QueryInterface,
    mal_completion_handler_uwp_AddRef,
    mal_completion_handler_uwp_Release,
    mal_completion_handler_uwp_ActivateCompleted
};

mal_result mal_completion_handler_uwp_init(mal_completion_handler_uwp* pHandler)
{
    mal_assert(pHandler != NULL);
    mal_zero_object(pHandler);

    pHandler->lpVtbl = &g_malCompletionHandlerVtblInstance;
    pHandler->counter = 1;
    pHandler->hEvent = CreateEventA(NULL, FALSE, FALSE, NULL);
    if (pHandler->hEvent == NULL) {
        return MAL_ERROR;
    }

    return MAL_SUCCESS;
}

void mal_completion_handler_uwp_uninit(mal_completion_handler_uwp* pHandler)
{
    if (pHandler->hEvent != NULL) {
        CloseHandle(pHandler->hEvent);
    }
}

void mal_completion_handler_uwp_wait(mal_completion_handler_uwp* pHandler)
{
    WaitForSingleObject(pHandler->hEvent, INFINITE);
}
#endif  // !MAL_WIN32_DESKTOP

// We need a virtual table for our notification client object that's used for detecting changes to the default device.
#ifdef MAL_WIN32_DESKTOP
HRESULT STDMETHODCALLTYPE mal_IMMNotificationClient_QueryInterface(mal_IMMNotificationClient* pThis, const IID* const riid, void** ppObject)
{
    // We care about two interfaces - IUnknown and IMMNotificationClient. If the requested IID is something else
    // we just return E_NOINTERFACE. Otherwise we need to increment the reference counter and return S_OK.
    if (!mal_is_guid_equal(riid, &MAL_IID_IUnknown) && !mal_is_guid_equal(riid, &MAL_IID_IMMNotificationClient)) {
        *ppObject = NULL;
        return E_NOINTERFACE;
    }

    // Getting here means the IID is IUnknown or IMMNotificationClient.
    *ppObject = (void*)pThis;
    ((mal_IMMNotificationClientVtbl*)pThis->lpVtbl)->AddRef(pThis);
    return S_OK;
}

ULONG STDMETHODCALLTYPE mal_IMMNotificationClient_AddRef(mal_IMMNotificationClient* pThis)
{
    return (ULONG)mal_atomic_increment_32(&pThis->counter);
}

ULONG STDMETHODCALLTYPE mal_IMMNotificationClient_Release(mal_IMMNotificationClient* pThis)
{
    mal_uint32 newRefCount = mal_atomic_decrement_32(&pThis->counter);
    if (newRefCount == 0) {
        return 0;   // We don't free anything here because we never allocate the object on the heap.
    }

    return (ULONG)newRefCount;
}


HRESULT STDMETHODCALLTYPE mal_IMMNotificationClient_OnDeviceStateChanged(mal_IMMNotificationClient* pThis, LPCWSTR pDeviceID, DWORD dwNewState)
{
#ifdef MAL_DEBUG_OUTPUT
    printf("IMMNotificationClient_OnDeviceStateChanged(pDeviceID=%S, dwNewState=%u)\n", (pDeviceID != NULL) ? pDeviceID : L"(NULL)", (unsigned int)dwNewState);
#endif

    (void)pThis;
    (void)pDeviceID;
    (void)dwNewState;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE mal_IMMNotificationClient_OnDeviceAdded(mal_IMMNotificationClient* pThis, LPCWSTR pDeviceID)
{
#ifdef MAL_DEBUG_OUTPUT
    printf("IMMNotificationClient_OnDeviceAdded(pDeviceID=%S)\n", (pDeviceID != NULL) ? pDeviceID : L"(NULL)");
#endif

    // We don't need to worry about this event for our purposes.
    (void)pThis;
    (void)pDeviceID;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE mal_IMMNotificationClient_OnDeviceRemoved(mal_IMMNotificationClient* pThis, LPCWSTR pDeviceID)
{
#ifdef MAL_DEBUG_OUTPUT
    printf("IMMNotificationClient_OnDeviceRemoved(pDeviceID=%S)\n", (pDeviceID != NULL) ? pDeviceID : L"(NULL)");
#endif

    // We don't need to worry about this event for our purposes.
    (void)pThis;
    (void)pDeviceID;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE mal_IMMNotificationClient_OnDefaultDeviceChanged(mal_IMMNotificationClient* pThis, mal_EDataFlow dataFlow, mal_ERole role, LPCWSTR pDefaultDeviceID)
{
#ifdef MAL_DEBUG_OUTPUT
    printf("IMMNotificationClient_OnDefaultDeviceChanged(dataFlow=%d, role=%d, pDefaultDeviceID=%S)\n", dataFlow, role, (pDefaultDeviceID != NULL) ? pDefaultDeviceID : L"(NULL)");
#endif

    // We only ever use the eConsole role in mini_al.
    if (role != mal_eConsole) {
        return S_OK;
    }

    // We only care about devices with the same data flow and role as the current device.
    if (pThis->pDevice->type == mal_device_type_playback && dataFlow != mal_eRender ||
        pThis->pDevice->type == mal_device_type_capture  && dataFlow != mal_eCapture) {
        return S_OK;
    }

    // Not currently supporting automatic stream routing in exclusive mode. This is not working correctly on my machine due to
    // AUDCLNT_E_DEVICE_IN_USE errors when reinitializing the device. If this is a bug in mini_al, we can try re-enabling this once
    // it's fixed.
    if (dataFlow == mal_eRender  && pThis->pDevice->playback.shareMode == mal_share_mode_exclusive ||
        dataFlow == mal_eCapture && pThis->pDevice->capture.shareMode  == mal_share_mode_exclusive) {
        return S_OK;
    }

    // We don't change the device here - we change it in the worker thread to keep synchronization simple. To do this I'm just setting a flag to
    // indicate that the default device has changed.
    if (dataFlow == mal_eRender) {
        mal_atomic_exchange_32(&pThis->pDevice->wasapi.hasDefaultPlaybackDeviceChanged, MAL_TRUE);
    }
    if (dataFlow == mal_eCapture) {
        mal_atomic_exchange_32(&pThis->pDevice->wasapi.hasDefaultCaptureDeviceChanged,  MAL_TRUE);
    }

    (void)pDefaultDeviceID;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE mal_IMMNotificationClient_OnPropertyValueChanged(mal_IMMNotificationClient* pThis, LPCWSTR pDeviceID, const PROPERTYKEY key)
{
#ifdef MAL_DEBUG_OUTPUT
    printf("IMMNotificationClient_OnPropertyValueChanged(pDeviceID=%S)\n", (pDeviceID != NULL) ? pDeviceID : L"(NULL)");
#endif

    (void)pThis;
    (void)pDeviceID;
    (void)key;
    return S_OK;
}

static mal_IMMNotificationClientVtbl g_malNotificationCientVtbl = {
    mal_IMMNotificationClient_QueryInterface,
    mal_IMMNotificationClient_AddRef,
    mal_IMMNotificationClient_Release,
    mal_IMMNotificationClient_OnDeviceStateChanged,
    mal_IMMNotificationClient_OnDeviceAdded,
    mal_IMMNotificationClient_OnDeviceRemoved,
    mal_IMMNotificationClient_OnDefaultDeviceChanged,
    mal_IMMNotificationClient_OnPropertyValueChanged
};
#endif  // MAL_WIN32_DESKTOP

#ifdef MAL_WIN32_DESKTOP
typedef mal_IMMDevice mal_WASAPIDeviceInterface;
#else
typedef mal_IUnknown mal_WASAPIDeviceInterface;
#endif



mal_bool32 mal_context_is_device_id_equal__wasapi(mal_context* pContext, const mal_device_id* pID0, const mal_device_id* pID1)
{
    mal_assert(pContext != NULL);
    mal_assert(pID0 != NULL);
    mal_assert(pID1 != NULL);
    (void)pContext;

    return memcmp(pID0->wasapi, pID1->wasapi, sizeof(pID0->wasapi)) == 0;
}

void mal_set_device_info_from_WAVEFORMATEX(const WAVEFORMATEX* pWF, mal_device_info* pInfo)
{
    mal_assert(pWF != NULL);
    mal_assert(pInfo != NULL);

    pInfo->formatCount   = 1;
    pInfo->formats[0]    = mal_format_from_WAVEFORMATEX(pWF);
    pInfo->minChannels   = pWF->nChannels;
    pInfo->maxChannels   = pWF->nChannels;
    pInfo->minSampleRate = pWF->nSamplesPerSec;
    pInfo->maxSampleRate = pWF->nSamplesPerSec;
}

mal_result mal_context_get_device_info_from_IAudioClient__wasapi(mal_context* pContext, /*mal_IMMDevice**/void* pMMDevice, mal_IAudioClient* pAudioClient, mal_share_mode shareMode, mal_device_info* pInfo)
{
    mal_assert(pAudioClient != NULL);
    mal_assert(pInfo != NULL);

    // We use a different technique to retrieve the device information depending on whether or not we are using shared or exclusive mode.
    if (shareMode == mal_share_mode_shared) {
        // Shared Mode. We use GetMixFormat() here.
        WAVEFORMATEX* pWF = NULL;
        HRESULT hr = mal_IAudioClient_GetMixFormat((mal_IAudioClient*)pAudioClient, (WAVEFORMATEX**)&pWF);
        if (SUCCEEDED(hr)) {
            mal_set_device_info_from_WAVEFORMATEX(pWF, pInfo);
            return MAL_SUCCESS;
        } else {
            return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to retrieve mix format for device info retrieval.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }
    } else {
        // Exlcusive Mode. We repeatedly call IsFormatSupported() here. This is not currently support on UWP.
#ifdef MAL_WIN32_DESKTOP
        // The first thing to do is get the format from PKEY_AudioEngine_DeviceFormat. This should give us a channel count we assume is
        // correct which will simplify our searching.
        mal_IPropertyStore *pProperties;
        HRESULT hr = mal_IMMDevice_OpenPropertyStore((mal_IMMDevice*)pMMDevice, STGM_READ, &pProperties);
        if (SUCCEEDED(hr)) {
            PROPVARIANT var;
            mal_PropVariantInit(&var);

            hr = mal_IPropertyStore_GetValue(pProperties, &MAL_PKEY_AudioEngine_DeviceFormat, &var);
            if (SUCCEEDED(hr)) {
                WAVEFORMATEX* pWF = (WAVEFORMATEX*)var.blob.pBlobData;
                mal_set_device_info_from_WAVEFORMATEX(pWF, pInfo);

                // In my testing, the format returned by PKEY_AudioEngine_DeviceFormat is suitable for exclusive mode so we check this format
                // first. If this fails, fall back to a search.
                hr = mal_IAudioClient_IsFormatSupported((mal_IAudioClient*)pAudioClient, MAL_AUDCLNT_SHAREMODE_EXCLUSIVE, pWF, NULL);
                mal_PropVariantClear(pContext, &var);

                if (FAILED(hr)) {
                    // The format returned by PKEY_AudioEngine_DeviceFormat is not supported, so fall back to a search. We assume the channel
                    // count returned by MAL_PKEY_AudioEngine_DeviceFormat is valid and correct. For simplicity we're only returning one format.
                    mal_uint32 channels = pInfo->minChannels;

                    mal_format formatsToSearch[] = {
                        mal_format_s16,
                        mal_format_s24,
                        //mal_format_s24_32,
                        mal_format_f32,
                        mal_format_s32,
                        mal_format_u8
                    };

                    mal_channel defaultChannelMap[MAL_MAX_CHANNELS];
                    mal_get_standard_channel_map(mal_standard_channel_map_microsoft, channels, defaultChannelMap);

                    WAVEFORMATEXTENSIBLE wf;
                    mal_zero_object(&wf);
                    wf.Format.cbSize     = sizeof(wf);
                    wf.Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
                    wf.Format.nChannels  = (WORD)channels;
                    wf.dwChannelMask     = mal_channel_map_to_channel_mask__win32(defaultChannelMap, channels);

                    mal_bool32 found = MAL_FALSE;
                    for (mal_uint32 iFormat = 0; iFormat < mal_countof(formatsToSearch); ++iFormat) {
                        mal_format format = formatsToSearch[iFormat];

                        wf.Format.wBitsPerSample       = (WORD)mal_get_bytes_per_sample(format)*8;
                        wf.Format.nBlockAlign          = (wf.Format.nChannels * wf.Format.wBitsPerSample) / 8;
                        wf.Format.nAvgBytesPerSec      = wf.Format.nBlockAlign * wf.Format.nSamplesPerSec;
                        wf.Samples.wValidBitsPerSample = /*(format == mal_format_s24_32) ? 24 :*/ wf.Format.wBitsPerSample;
                        if (format == mal_format_f32) {
                            wf.SubFormat = MAL_GUID_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
                        } else {
                            wf.SubFormat = MAL_GUID_KSDATAFORMAT_SUBTYPE_PCM;
                        }

                        for (mal_uint32 iSampleRate = 0; iSampleRate < mal_countof(g_malStandardSampleRatePriorities); ++iSampleRate) {
                            wf.Format.nSamplesPerSec = g_malStandardSampleRatePriorities[iSampleRate];

                            hr = mal_IAudioClient_IsFormatSupported((mal_IAudioClient*)pAudioClient, MAL_AUDCLNT_SHAREMODE_EXCLUSIVE, (WAVEFORMATEX*)&wf, NULL);
                            if (SUCCEEDED(hr)) {
                                mal_set_device_info_from_WAVEFORMATEX((WAVEFORMATEX*)&wf, pInfo);
                                found = MAL_TRUE;
                                break;
                            }
                        }

                        if (found) {
                            break;
                        }
                    }

                    if (!found) {
                        mal_IPropertyStore_Release(pProperties);
                        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to find suitable device format for device info retrieval.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
                    }
                }
            } else {
                mal_IPropertyStore_Release(pProperties);
                return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to retrieve device format for device info retrieval.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
            }
        } else {
            return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to open property store for device info retrieval.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        return MAL_SUCCESS;
#else
        // Exclusive mode not fully supported in UWP right now.
        return MAL_ERROR;
#endif
    }
}

#ifdef MAL_WIN32_DESKTOP
mal_result mal_context_get_MMDevice__wasapi(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_IMMDevice** ppMMDevice)
{
    mal_assert(pContext != NULL);
    mal_assert(ppMMDevice != NULL);

    mal_IMMDeviceEnumerator* pDeviceEnumerator;
    HRESULT hr = mal_CoCreateInstance(pContext, MAL_CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, MAL_IID_IMMDeviceEnumerator, (void**)&pDeviceEnumerator);
    if (FAILED(hr)) {
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to create IMMDeviceEnumerator.", MAL_FAILED_TO_INIT_BACKEND);
    }

    if (pDeviceID == NULL) {
        hr = mal_IMMDeviceEnumerator_GetDefaultAudioEndpoint(pDeviceEnumerator, (deviceType == mal_device_type_playback) ? mal_eRender : mal_eCapture, mal_eConsole, ppMMDevice);
    } else {
        hr = mal_IMMDeviceEnumerator_GetDevice(pDeviceEnumerator, pDeviceID->wasapi, ppMMDevice);
    }

    mal_IMMDeviceEnumerator_Release(pDeviceEnumerator);
    if (FAILED(hr)) {
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to retrieve IMMDevice.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
    }

    return MAL_SUCCESS;
}

mal_result mal_context_get_device_info_from_MMDevice__wasapi(mal_context* pContext, mal_IMMDevice* pMMDevice, mal_share_mode shareMode, mal_bool32 onlySimpleInfo, mal_device_info* pInfo)
{
    mal_assert(pContext != NULL);
    mal_assert(pMMDevice != NULL);
    mal_assert(pInfo != NULL);

    // ID.
    LPWSTR id;
    HRESULT hr = mal_IMMDevice_GetId(pMMDevice, &id);
    if (SUCCEEDED(hr)) {
        size_t idlen = wcslen(id);
        if (idlen+1 > mal_countof(pInfo->id.wasapi)) {
            mal_CoTaskMemFree(pContext, id);
            mal_assert(MAL_FALSE);  // NOTE: If this is triggered, please report it. It means the format of the ID must haved change and is too long to fit in our fixed sized buffer.
            return MAL_ERROR;
        }

        mal_copy_memory(pInfo->id.wasapi, id, idlen * sizeof(wchar_t));
        pInfo->id.wasapi[idlen] = '\0';

        mal_CoTaskMemFree(pContext, id);
    }

    {
        mal_IPropertyStore *pProperties;
        hr = mal_IMMDevice_OpenPropertyStore(pMMDevice, STGM_READ, &pProperties);
        if (SUCCEEDED(hr)) {
            PROPVARIANT var;

            // Description / Friendly Name
            mal_PropVariantInit(&var);
            hr = mal_IPropertyStore_GetValue(pProperties, &MAL_PKEY_Device_FriendlyName, &var);
            if (SUCCEEDED(hr)) {
                WideCharToMultiByte(CP_UTF8, 0, var.pwszVal, -1, pInfo->name, sizeof(pInfo->name), 0, FALSE);
                mal_PropVariantClear(pContext, &var);
            }

            mal_IPropertyStore_Release(pProperties);
        }
    }

    // Format
    if (!onlySimpleInfo) {
        mal_IAudioClient* pAudioClient;
        hr = mal_IMMDevice_Activate(pMMDevice, &MAL_IID_IAudioClient, CLSCTX_ALL, NULL, (void**)&pAudioClient);
        if (SUCCEEDED(hr)) {
            mal_result result = mal_context_get_device_info_from_IAudioClient__wasapi(pContext, pMMDevice, pAudioClient, shareMode, pInfo);
            
            mal_IAudioClient_Release(pAudioClient);
            return result;
        } else {
            return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to activate audio client for device info retrieval.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_context_enumerate_device_collection__wasapi(mal_context* pContext, mal_IMMDeviceCollection* pDeviceCollection, mal_device_type deviceType, mal_enum_devices_callback_proc callback, void* pUserData)
{
    mal_assert(pContext != NULL);
    mal_assert(callback != NULL);

    UINT deviceCount;
    HRESULT hr = mal_IMMDeviceCollection_GetCount(pDeviceCollection, &deviceCount);
    if (FAILED(hr)) {
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to get playback device count.", MAL_NO_DEVICE);
    }

    for (mal_uint32 iDevice = 0; iDevice < deviceCount; ++iDevice) {
        mal_device_info deviceInfo;
        mal_zero_object(&deviceInfo);

        mal_IMMDevice* pMMDevice;
        hr = mal_IMMDeviceCollection_Item(pDeviceCollection, iDevice, &pMMDevice);
        if (SUCCEEDED(hr)) {
            mal_result result = mal_context_get_device_info_from_MMDevice__wasapi(pContext, pMMDevice, mal_share_mode_shared, MAL_TRUE, &deviceInfo);   // MAL_TRUE = onlySimpleInfo.

            mal_IMMDevice_Release(pMMDevice);
            if (result == MAL_SUCCESS) {
                mal_bool32 cbResult = callback(pContext, deviceType, &deviceInfo, pUserData);
                if (cbResult == MAL_FALSE) {
                    break;
                }
            }
        }
    }

    return MAL_SUCCESS;
}
#endif

#ifdef MAL_WIN32_DESKTOP
mal_result mal_context_get_IAudioClient_Desktop__wasapi(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_IAudioClient** ppAudioClient, mal_IMMDevice** ppMMDevice)
{
    mal_result result;
    HRESULT hr;

    mal_assert(pContext != NULL);
    mal_assert(ppAudioClient != NULL);
    mal_assert(ppMMDevice != NULL);

    result = mal_context_get_MMDevice__wasapi(pContext, deviceType, pDeviceID, ppMMDevice);
    if (result != MAL_SUCCESS) {
        return result;
    }

    hr = mal_IMMDevice_Activate(*ppMMDevice, &MAL_IID_IAudioClient, CLSCTX_ALL, NULL, (void**)ppAudioClient);
    if (FAILED(hr)) {
        return MAL_FAILED_TO_OPEN_BACKEND_DEVICE;
    }

    return MAL_SUCCESS;
}
#else
mal_result mal_context_get_IAudioClient_UWP__wasapi(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_IAudioClient** ppAudioClient, mal_IUnknown** ppActivatedInterface)
{
    mal_assert(pContext != NULL);
    mal_assert(ppAudioClient != NULL);

    mal_IActivateAudioInterfaceAsyncOperation *pAsyncOp = NULL;
    mal_completion_handler_uwp completionHandler;

    IID iid;
    if (pDeviceID != NULL) {
        mal_copy_memory(&iid, pDeviceID->wasapi, sizeof(iid));
    } else {
        if (deviceType == mal_device_type_playback) {
            iid = MAL_IID_DEVINTERFACE_AUDIO_RENDER;
        } else {
            iid = MAL_IID_DEVINTERFACE_AUDIO_CAPTURE;
        }
    }

    LPOLESTR iidStr;
#if defined(__cplusplus)
    HRESULT hr = StringFromIID(iid, &iidStr);
#else
    HRESULT hr = StringFromIID(&iid, &iidStr);
#endif
    if (FAILED(hr)) {
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to convert device IID to string for ActivateAudioInterfaceAsync(). Out of memory.", MAL_OUT_OF_MEMORY);
    }

    mal_result result = mal_completion_handler_uwp_init(&completionHandler);
    if (result != MAL_SUCCESS) {
        mal_CoTaskMemFree(pContext, iidStr);
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to create event for waiting for ActivateAudioInterfaceAsync().", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
    }

#if defined(__cplusplus)
    hr = ActivateAudioInterfaceAsync(iidStr, MAL_IID_IAudioClient, NULL, (IActivateAudioInterfaceCompletionHandler*)&completionHandler, (IActivateAudioInterfaceAsyncOperation**)&pAsyncOp);
#else
    hr = ActivateAudioInterfaceAsync(iidStr, &MAL_IID_IAudioClient, NULL, (IActivateAudioInterfaceCompletionHandler*)&completionHandler, (IActivateAudioInterfaceAsyncOperation**)&pAsyncOp);
#endif
    if (FAILED(hr)) {
        mal_completion_handler_uwp_uninit(&completionHandler);
        mal_CoTaskMemFree(pContext, iidStr);
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[WASAPI] ActivateAudioInterfaceAsync() failed.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
    }

    mal_CoTaskMemFree(pContext, iidStr);

    // Wait for the async operation for finish.
    mal_completion_handler_uwp_wait(&completionHandler);
    mal_completion_handler_uwp_uninit(&completionHandler);

    HRESULT activateResult;
    mal_IUnknown* pActivatedInterface;
    hr = mal_IActivateAudioInterfaceAsyncOperation_GetActivateResult(pAsyncOp, &activateResult, &pActivatedInterface);
    mal_IActivateAudioInterfaceAsyncOperation_Release(pAsyncOp);

    if (FAILED(hr) || FAILED(activateResult)) {
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to activate device.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
    }

    // Here is where we grab the IAudioClient interface.
    hr = mal_IUnknown_QueryInterface(pActivatedInterface, &MAL_IID_IAudioClient, (void**)ppAudioClient);
    if (FAILED(hr)) {
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to query IAudioClient interface.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
    }

    if (ppActivatedInterface) {
        *ppActivatedInterface = pActivatedInterface;
    } else {
        mal_IUnknown_Release(pActivatedInterface);
    }

    return MAL_SUCCESS;
}
#endif

mal_result mal_context_get_IAudioClient__wasapi(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_IAudioClient** ppAudioClient, mal_WASAPIDeviceInterface** ppDeviceInterface)
{
#ifdef MAL_WIN32_DESKTOP
    return mal_context_get_IAudioClient_Desktop__wasapi(pContext, deviceType, pDeviceID, ppAudioClient, ppDeviceInterface);
#else
    return mal_context_get_IAudioClient_UWP__wasapi(pContext, deviceType, pDeviceID, ppAudioClient, ppDeviceInterface);
#endif
}


mal_result mal_context_enumerate_devices__wasapi(mal_context* pContext, mal_enum_devices_callback_proc callback, void* pUserData)
{
    mal_assert(pContext != NULL);
    mal_assert(callback != NULL);

    // Different enumeration for desktop and UWP.
#ifdef MAL_WIN32_DESKTOP
    // Desktop
    mal_IMMDeviceEnumerator* pDeviceEnumerator;
    HRESULT hr = mal_CoCreateInstance(pContext, MAL_CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, MAL_IID_IMMDeviceEnumerator, (void**)&pDeviceEnumerator);
    if (FAILED(hr)) {
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to create device enumerator.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
    }

    mal_IMMDeviceCollection* pDeviceCollection;

    // Playback.
    hr = mal_IMMDeviceEnumerator_EnumAudioEndpoints(pDeviceEnumerator, mal_eRender, MAL_MM_DEVICE_STATE_ACTIVE, &pDeviceCollection);
    if (SUCCEEDED(hr)) {
        mal_context_enumerate_device_collection__wasapi(pContext, pDeviceCollection, mal_device_type_playback, callback, pUserData);
        mal_IMMDeviceCollection_Release(pDeviceCollection);
    }

    // Capture.
    hr = mal_IMMDeviceEnumerator_EnumAudioEndpoints(pDeviceEnumerator, mal_eCapture, MAL_MM_DEVICE_STATE_ACTIVE, &pDeviceCollection);
    if (SUCCEEDED(hr)) {
        mal_context_enumerate_device_collection__wasapi(pContext, pDeviceCollection, mal_device_type_capture, callback, pUserData);
        mal_IMMDeviceCollection_Release(pDeviceCollection);
    }

    mal_IMMDeviceEnumerator_Release(pDeviceEnumerator);
#else
    // UWP
    //
    // The MMDevice API is only supported on desktop applications. For now, while I'm still figuring out how to properly enumerate
    // over devices without using MMDevice, I'm restricting devices to defaults.
    //
    // Hint: DeviceInformation::FindAllAsync() with DeviceClass.AudioCapture/AudioRender. https://blogs.windows.com/buildingapps/2014/05/15/real-time-audio-in-windows-store-and-windows-phone-apps/
    if (callback) {
        mal_bool32 cbResult = MAL_TRUE;

        // Playback.
        if (cbResult) {
            mal_device_info deviceInfo;
            mal_zero_object(&deviceInfo);
            mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MAL_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
            cbResult = callback(pContext, mal_device_type_playback, &deviceInfo, pUserData);
        }

        // Capture.
        if (cbResult) {
            mal_device_info deviceInfo;
            mal_zero_object(&deviceInfo);
            mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MAL_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
            cbResult = callback(pContext, mal_device_type_capture, &deviceInfo, pUserData);
        }
    }
#endif

    return MAL_SUCCESS;
}

mal_result mal_context_get_device_info__wasapi(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, mal_device_info* pDeviceInfo)
{
#ifdef MAL_WIN32_DESKTOP
    mal_IMMDevice* pMMDevice = NULL;
    mal_result result = mal_context_get_MMDevice__wasapi(pContext, deviceType, pDeviceID, &pMMDevice);
    if (result != MAL_SUCCESS) {
        return result;
    }

    result = mal_context_get_device_info_from_MMDevice__wasapi(pContext, pMMDevice, shareMode, MAL_FALSE, pDeviceInfo);   // MAL_FALSE = !onlySimpleInfo.

    mal_IMMDevice_Release(pMMDevice);
    return result;
#else
    // UWP currently only uses default devices.
    if (deviceType == mal_device_type_playback) {
        mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MAL_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
    } else {
        mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MAL_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
    }

    // Not currently supporting exclusive mode on UWP.
    if (shareMode == mal_share_mode_exclusive) {
        return MAL_ERROR;
    }

    mal_IAudioClient* pAudioClient;
    mal_result result = mal_context_get_IAudioClient_UWP__wasapi(pContext, deviceType, pDeviceID, &pAudioClient, NULL);
    if (result != MAL_SUCCESS) {
        return result;
    }

    result = mal_context_get_device_info_from_IAudioClient__wasapi(pContext, NULL, pAudioClient, shareMode, pDeviceInfo);

    mal_IAudioClient_Release(pAudioClient);
    return result;
#endif
}

void mal_device_uninit__wasapi(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

#ifdef MAL_WIN32_DESKTOP
    if (pDevice->wasapi.pDeviceEnumerator) {
        ((mal_IMMDeviceEnumerator*)pDevice->wasapi.pDeviceEnumerator)->lpVtbl->UnregisterEndpointNotificationCallback((mal_IMMDeviceEnumerator*)pDevice->wasapi.pDeviceEnumerator, &pDevice->wasapi.notificationClient);
        mal_IMMDeviceEnumerator_Release((mal_IMMDeviceEnumerator*)pDevice->wasapi.pDeviceEnumerator);
    }
#endif

    if (pDevice->wasapi.pRenderClient) {
        mal_IAudioRenderClient_Release((mal_IAudioRenderClient*)pDevice->wasapi.pRenderClient);
    }
    if (pDevice->wasapi.pCaptureClient) {
        mal_IAudioCaptureClient_Release((mal_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient);
    }

    if (pDevice->wasapi.pAudioClientPlayback) {
        mal_IAudioClient_Release((mal_IAudioClient*)pDevice->wasapi.pAudioClientPlayback);
    }
    if (pDevice->wasapi.pAudioClientCapture) {
        mal_IAudioClient_Release((mal_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
    }

    if (pDevice->wasapi.hEventPlayback) {
        CloseHandle(pDevice->wasapi.hEventPlayback);
    }
    if (pDevice->wasapi.hEventCapture) {
        CloseHandle(pDevice->wasapi.hEventCapture);
    }
}


typedef struct
{
    // Input.
    mal_format formatIn;
    mal_uint32 channelsIn;
    mal_uint32 sampleRateIn;
    mal_channel channelMapIn[MAL_MAX_CHANNELS];
    mal_uint32 bufferSizeInFramesIn;
    mal_uint32 bufferSizeInMillisecondsIn;
    mal_uint32 periodsIn;
    mal_bool32 usingDefaultFormat;
    mal_bool32 usingDefaultChannels;
    mal_bool32 usingDefaultSampleRate;
    mal_bool32 usingDefaultChannelMap;
    mal_share_mode shareMode;

    // Output.
    mal_IAudioClient* pAudioClient;
    mal_IAudioRenderClient* pRenderClient;
    mal_IAudioCaptureClient* pCaptureClient;
    mal_format formatOut;
    mal_uint32 channelsOut;
    mal_uint32 sampleRateOut;
    mal_channel channelMapOut[MAL_MAX_CHANNELS];
    mal_uint32 bufferSizeInFramesOut;
    mal_uint32 periodSizeInFramesOut;
    mal_uint32 periodsOut;
    char deviceName[256];
} mal_device_init_internal_data__wasapi;

mal_result mal_device_init_internal__wasapi(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_device_init_internal_data__wasapi* pData)
{
    (void)pContext;

    mal_assert(pContext != NULL);
    mal_assert(pData != NULL);

    /* This function is only used to initialize one device type: either playback or capture. Never full-duplex. */
    if (deviceType == mal_device_type_duplex) {
        return MAL_INVALID_ARGS;
    }

    pData->pAudioClient = NULL;
    pData->pRenderClient = NULL;
    pData->pCaptureClient = NULL;
    

    HRESULT hr;
    mal_result result = MAL_SUCCESS;
    const char* errorMsg = "";
    MAL_AUDCLNT_SHAREMODE shareMode = MAL_AUDCLNT_SHAREMODE_SHARED;
    MAL_REFERENCE_TIME bufferDurationInMicroseconds;
    mal_bool32 wasInitializedUsingIAudioClient3 = MAL_FALSE;
    WAVEFORMATEXTENSIBLE wf;
    mal_WASAPIDeviceInterface* pDeviceInterface = NULL;

    result = mal_context_get_IAudioClient__wasapi(pContext, deviceType, pDeviceID, &pData->pAudioClient, &pDeviceInterface);
    if (result != MAL_SUCCESS) {
        goto done;
    }


    // Try enabling hardware offloading.
    mal_IAudioClient2* pAudioClient2;
    hr = mal_IAudioClient_QueryInterface(pData->pAudioClient, &MAL_IID_IAudioClient2, (void**)&pAudioClient2);
    if (SUCCEEDED(hr)) {
        BOOL isHardwareOffloadingSupported = 0;
        hr = mal_IAudioClient2_IsOffloadCapable(pAudioClient2, MAL_AudioCategory_Other, &isHardwareOffloadingSupported);
        if (SUCCEEDED(hr) && isHardwareOffloadingSupported) {
            mal_AudioClientProperties clientProperties;
            mal_zero_object(&clientProperties);
            clientProperties.cbSize = sizeof(clientProperties);
            clientProperties.bIsOffload = 1;
            clientProperties.eCategory = MAL_AudioCategory_Other;
            mal_IAudioClient2_SetClientProperties(pAudioClient2, &clientProperties);
        }
    }


    // Here is where we try to determine the best format to use with the device. If the client if wanting exclusive mode, first try finding the best format for that. If this fails, fall back to shared mode.
    result = MAL_FORMAT_NOT_SUPPORTED;
    if (pData->shareMode == mal_share_mode_exclusive) {
    #ifdef MAL_WIN32_DESKTOP
        // In exclusive mode on desktop we always use the backend's native format.
        mal_IPropertyStore* pStore = NULL;
        hr = mal_IMMDevice_OpenPropertyStore(pDeviceInterface, STGM_READ, &pStore);
        if (SUCCEEDED(hr)) {
            PROPVARIANT prop;
            mal_PropVariantInit(&prop);
            hr = mal_IPropertyStore_GetValue(pStore, &MAL_PKEY_AudioEngine_DeviceFormat, &prop);
            if (SUCCEEDED(hr)) {
                WAVEFORMATEX* pActualFormat = (WAVEFORMATEX*)prop.blob.pBlobData;
                hr = mal_IAudioClient_IsFormatSupported((mal_IAudioClient*)pData->pAudioClient, MAL_AUDCLNT_SHAREMODE_EXCLUSIVE, pActualFormat, NULL);
                if (SUCCEEDED(hr)) {
                    mal_copy_memory(&wf, pActualFormat, sizeof(WAVEFORMATEXTENSIBLE));
                }

                mal_PropVariantClear(pContext, &prop);
            }

            mal_IPropertyStore_Release(pStore);
        }
    #else
        // I do not know how to query the device's native format on UWP so for now I'm just disabling support for
        // exclusive mode. The alternative is to enumerate over different formats and check IsFormatSupported()
        // until you find one that works.
        //
        // TODO: Add support for exclusive mode to UWP.
        hr = S_FALSE;
    #endif

        if (hr == S_OK) {
            shareMode = MAL_AUDCLNT_SHAREMODE_EXCLUSIVE;
            result = MAL_SUCCESS;
        } else {
            result = MAL_SHARE_MODE_NOT_SUPPORTED;
        }
    } else {
        // In shared mode we are always using the format reported by the operating system.
        WAVEFORMATEXTENSIBLE* pNativeFormat = NULL;
        hr = mal_IAudioClient_GetMixFormat((mal_IAudioClient*)pData->pAudioClient, (WAVEFORMATEX**)&pNativeFormat);
        if (hr != S_OK) {
            result = MAL_FORMAT_NOT_SUPPORTED;
        } else {
            mal_copy_memory(&wf, pNativeFormat, sizeof(wf));
            result = MAL_SUCCESS;
        }

        mal_CoTaskMemFree(pContext, pNativeFormat);

        shareMode = MAL_AUDCLNT_SHAREMODE_SHARED;
    }

    // Return an error if we still haven't found a format.
    if (result != MAL_SUCCESS) {
        errorMsg = "[WASAPI] Failed to find best device mix format.";
        goto done;
    }

    pData->formatOut = mal_format_from_WAVEFORMATEX((WAVEFORMATEX*)&wf);
    pData->channelsOut = wf.Format.nChannels;
    pData->sampleRateOut = wf.Format.nSamplesPerSec;

    // Get the internal channel map based on the channel mask.
    mal_channel_mask_to_channel_map__win32(wf.dwChannelMask, pData->channelsOut, pData->channelMapOut);

    // If we're using a default buffer size we need to calculate it based on the efficiency of the system.
    pData->periodsOut = pData->periodsIn;
    pData->bufferSizeInFramesOut = pData->bufferSizeInFramesIn;
    if (pData->bufferSizeInFramesOut == 0) {
        pData->bufferSizeInFramesOut = mal_calculate_buffer_size_in_frames_from_milliseconds(pData->bufferSizeInMillisecondsIn, pData->sampleRateOut);
    }

    bufferDurationInMicroseconds = ((mal_uint64)pData->bufferSizeInFramesOut * 1000 * 1000) / pData->sampleRateOut;


    // Slightly different initialization for shared and exclusive modes. We try exclusive mode first, and if it fails, fall back to shared mode.
    if (shareMode == MAL_AUDCLNT_SHAREMODE_EXCLUSIVE) {
        MAL_REFERENCE_TIME bufferDuration = (bufferDurationInMicroseconds / pData->periodsOut) * 10;

        // If the periodicy is too small, Initialize() will fail with AUDCLNT_E_INVALID_DEVICE_PERIOD. In this case we should just keep increasing
        // it and trying it again.
        hr = E_FAIL;
        for (;;) {
            hr = mal_IAudioClient_Initialize((mal_IAudioClient*)pData->pAudioClient, shareMode, MAL_AUDCLNT_STREAMFLAGS_EVENTCALLBACK, bufferDuration, bufferDuration, (WAVEFORMATEX*)&wf, NULL);
            if (hr == MAL_AUDCLNT_E_INVALID_DEVICE_PERIOD) {
                if (bufferDuration > 500*10000) {
                    break;
                } else {
                    if (bufferDuration == 0) {  // <-- Just a sanity check to prevent an infinit loop. Should never happen, but it makes me feel better.
                        break;
                    }

                    bufferDuration = bufferDuration * 2;
                    continue;
                }
            } else {
                break;
            }
        }
        
        if (hr == MAL_AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED) {
            UINT bufferSizeInFrames;
            hr = mal_IAudioClient_GetBufferSize((mal_IAudioClient*)pData->pAudioClient, &bufferSizeInFrames);
            if (SUCCEEDED(hr)) {
                bufferDuration = (MAL_REFERENCE_TIME)((10000.0 * 1000 / wf.Format.nSamplesPerSec * bufferSizeInFrames) + 0.5);

                // Unfortunately we need to release and re-acquire the audio client according to MSDN. Seems silly - why not just call IAudioClient_Initialize() again?!
                mal_IAudioClient_Release((mal_IAudioClient*)pData->pAudioClient);

            #ifdef MAL_WIN32_DESKTOP
                hr = mal_IMMDevice_Activate(pDeviceInterface, &MAL_IID_IAudioClient, CLSCTX_ALL, NULL, (void**)&pData->pAudioClient);
            #else
                hr = mal_IUnknown_QueryInterface(pDeviceInterface, &MAL_IID_IAudioClient, (void**)&pData->pAudioClient);
            #endif

                if (SUCCEEDED(hr)) {
                    hr = mal_IAudioClient_Initialize((mal_IAudioClient*)pData->pAudioClient, shareMode, MAL_AUDCLNT_STREAMFLAGS_EVENTCALLBACK, bufferDuration, bufferDuration, (WAVEFORMATEX*)&wf, NULL);
                }
            }
        }

        if (FAILED(hr)) {
            /* Failed to initialize in exclusive mode. Don't fall back to shared mode - instead tell the client about it. They can reinitialize in shared mode if they want. */
            if (hr == E_ACCESSDENIED) {
                errorMsg = "[WASAPI] Failed to initialize device in exclusive mode. Access denied.", result = MAL_ACCESS_DENIED;
            } else if (hr == MAL_AUDCLNT_E_DEVICE_IN_USE) {
                errorMsg = "[WASAPI] Failed to initialize device in exclusive mode. Device in use.", result = MAL_DEVICE_BUSY;
            } else {
                errorMsg = "[WASAPI] Failed to initialize device in exclusive mode."; result = MAL_SHARE_MODE_NOT_SUPPORTED;
            }
            goto done;
        }
    }

    if (shareMode == MAL_AUDCLNT_SHAREMODE_SHARED) {
        /* Low latency shared mode via IAudioClient3. */
#ifndef MAL_WASAPI_NO_LOW_LATENCY_SHARED_MODE
        mal_IAudioClient3* pAudioClient3 = NULL;
        hr = mal_IAudioClient_QueryInterface(pData->pAudioClient, &MAL_IID_IAudioClient3, (void**)&pAudioClient3);
        if (SUCCEEDED(hr)) {
            UINT32 defaultPeriodInFrames;
            UINT32 fundamentalPeriodInFrames;
            UINT32 minPeriodInFrames;
            UINT32 maxPeriodInFrames;
            hr = mal_IAudioClient3_GetSharedModeEnginePeriod(pAudioClient3, (WAVEFORMATEX*)&wf, &defaultPeriodInFrames, &fundamentalPeriodInFrames, &minPeriodInFrames, &maxPeriodInFrames);
            if (SUCCEEDED(hr)) {
                UINT32 desiredPeriodInFrames = pData->bufferSizeInFramesOut / pData->periodsOut;
                UINT32 actualPeriodInFrames  = desiredPeriodInFrames;

                /* Make sure the period size is a multiple of fundamentalPeriodInFrames. */
                actualPeriodInFrames = actualPeriodInFrames / fundamentalPeriodInFrames;
                actualPeriodInFrames = actualPeriodInFrames * fundamentalPeriodInFrames;

                /* The period needs to be clamped between minPeriodInFrames and maxPeriodInFrames. */
                actualPeriodInFrames = mal_clamp(actualPeriodInFrames, minPeriodInFrames, maxPeriodInFrames);

                /* If the client requested a largish buffer than we don't actually want to use low latency shared mode because it forces small buffers. */
                if (actualPeriodInFrames >= desiredPeriodInFrames) {
                    hr = mal_IAudioClient3_InitializeSharedAudioStream(pAudioClient3, MAL_AUDCLNT_STREAMFLAGS_EVENTCALLBACK, actualPeriodInFrames, (WAVEFORMATEX*)&wf, NULL);
                    if (SUCCEEDED(hr)) {
                        wasInitializedUsingIAudioClient3 = MAL_TRUE;
                        pData->periodSizeInFramesOut = actualPeriodInFrames;
                        pData->bufferSizeInFramesOut = actualPeriodInFrames * pData->periodsOut;
                    }
                }
            }

            mal_IAudioClient3_Release(pAudioClient3);
            pAudioClient3 = NULL;
        }
#endif

        // If we don't have an IAudioClient3 then we need to use the normal initialization routine.
        if (!wasInitializedUsingIAudioClient3) {
            MAL_REFERENCE_TIME bufferDuration = bufferDurationInMicroseconds*10;
            hr = mal_IAudioClient_Initialize((mal_IAudioClient*)pData->pAudioClient, shareMode, MAL_AUDCLNT_STREAMFLAGS_EVENTCALLBACK, bufferDuration, 0, (WAVEFORMATEX*)&wf, NULL);
            if (FAILED(hr)) {
                if (hr == E_ACCESSDENIED) {
                    errorMsg = "[WASAPI] Failed to initialize device. Access denied.", result = MAL_ACCESS_DENIED;
                } else if (hr == MAL_AUDCLNT_E_DEVICE_IN_USE) {
                    errorMsg = "[WASAPI] Failed to initialize device. Device in use.", result = MAL_DEVICE_BUSY;
                } else {
                    errorMsg = "[WASAPI] Failed to initialize device.", result = MAL_FAILED_TO_OPEN_BACKEND_DEVICE;
                }

                goto done;
            }
        }
    }

    if (!wasInitializedUsingIAudioClient3) {
        hr = mal_IAudioClient_GetBufferSize((mal_IAudioClient*)pData->pAudioClient, &pData->bufferSizeInFramesOut);
        if (FAILED(hr)) {
            errorMsg = "[WASAPI] Failed to get audio client's actual buffer size.", result = MAL_FAILED_TO_OPEN_BACKEND_DEVICE;
            goto done;
        }

        pData->periodSizeInFramesOut = pData->bufferSizeInFramesOut / pData->periodsOut;
    }

    if (deviceType == mal_device_type_playback) {
        hr = mal_IAudioClient_GetService((mal_IAudioClient*)pData->pAudioClient, &MAL_IID_IAudioRenderClient, (void**)&pData->pRenderClient);
    } else {
        hr = mal_IAudioClient_GetService((mal_IAudioClient*)pData->pAudioClient, &MAL_IID_IAudioCaptureClient, (void**)&pData->pCaptureClient);
    }

    if (FAILED(hr)) {
        errorMsg = "[WASAPI] Failed to get audio client service.", result = MAL_API_NOT_FOUND;
        goto done;
    }


    // Grab the name of the device.
#ifdef MAL_WIN32_DESKTOP
    mal_IPropertyStore *pProperties;
    hr = mal_IMMDevice_OpenPropertyStore(pDeviceInterface, STGM_READ, &pProperties);
    if (SUCCEEDED(hr)) {
        PROPVARIANT varName;
        mal_PropVariantInit(&varName);
        hr = mal_IPropertyStore_GetValue(pProperties, &MAL_PKEY_Device_FriendlyName, &varName);
        if (SUCCEEDED(hr)) {
            WideCharToMultiByte(CP_UTF8, 0, varName.pwszVal, -1, pData->deviceName, sizeof(pData->deviceName), 0, FALSE);
            mal_PropVariantClear(pContext, &varName);
        }

        mal_IPropertyStore_Release(pProperties);
    }
#endif

done:
    // Clean up.
#ifdef MAL_WIN32_DESKTOP
    if (pDeviceInterface != NULL) {
        mal_IMMDevice_Release(pDeviceInterface);
    }
#else
    if (pDeviceInterface != NULL) {
        mal_IUnknown_Release(pDeviceInterface);
    }
#endif

    if (result != MAL_SUCCESS) {
        if (pData->pRenderClient) {
            mal_IAudioRenderClient_Release((mal_IAudioRenderClient*)pData->pRenderClient);
            pData->pRenderClient = NULL;
        }
        if (pData->pCaptureClient) {
            mal_IAudioCaptureClient_Release((mal_IAudioCaptureClient*)pData->pCaptureClient);
            pData->pCaptureClient = NULL;
        }
        if (pData->pAudioClient) {
            mal_IAudioClient_Release((mal_IAudioClient*)pData->pAudioClient);
            pData->pAudioClient = NULL;
        }

        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, errorMsg, result);
    } else {
        return MAL_SUCCESS;
    }
}

mal_result mal_device_reinit__wasapi(mal_device* pDevice, mal_device_type deviceType)
{
    mal_assert(pDevice != NULL);

    // We only re-initialize the playback or capture device. Never a full-duplex device.
    if (deviceType == mal_device_type_duplex) {
        return MAL_INVALID_ARGS;
    }

    mal_device_init_internal_data__wasapi data;
    if (deviceType == mal_device_type_capture) {
        data.formatIn               = pDevice->capture.format;
        data.channelsIn             = pDevice->capture.channels;
        mal_copy_memory(data.channelMapIn, pDevice->capture.channelMap, sizeof(pDevice->capture.channelMap));
        data.shareMode              = pDevice->capture.shareMode;
        data.usingDefaultFormat     = pDevice->capture.usingDefaultFormat;
        data.usingDefaultChannels   = pDevice->capture.usingDefaultChannels;
        data.usingDefaultChannelMap = pDevice->capture.usingDefaultChannelMap;
    } else {
        data.formatIn               = pDevice->playback.format;
        data.channelsIn             = pDevice->playback.channels;
        mal_copy_memory(data.channelMapIn, pDevice->playback.channelMap, sizeof(pDevice->playback.channelMap));
        data.shareMode              = pDevice->playback.shareMode;
        data.usingDefaultFormat     = pDevice->playback.usingDefaultFormat;
        data.usingDefaultChannels   = pDevice->playback.usingDefaultChannels;
        data.usingDefaultChannelMap = pDevice->playback.usingDefaultChannelMap;
    }
    
    data.sampleRateIn               = pDevice->sampleRate;
    data.usingDefaultSampleRate     = pDevice->usingDefaultSampleRate;
    data.bufferSizeInFramesIn       = pDevice->wasapi.originalBufferSizeInFrames;
    data.bufferSizeInMillisecondsIn = pDevice->wasapi.originalBufferSizeInMilliseconds;
    data.periodsIn                  = pDevice->wasapi.originalPeriods;
    mal_result result = mal_device_init_internal__wasapi(pDevice->pContext, deviceType, NULL, &data);
    if (result != MAL_SUCCESS) {
        return result;
    }

    // At this point we have some new objects ready to go. We need to uninitialize the previous ones and then set the new ones.
    if (deviceType == mal_device_type_capture) {
        if (pDevice->wasapi.pCaptureClient) {
            mal_IAudioCaptureClient_Release((mal_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient);
            pDevice->wasapi.pCaptureClient = NULL;
        }

        if (pDevice->wasapi.pAudioClientCapture) {
            mal_IAudioClient_Release((mal_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
            pDevice->wasapi.pAudioClientCapture = NULL;
        }

        pDevice->wasapi.pAudioClientCapture         = data.pAudioClient;
        pDevice->wasapi.pCaptureClient              = data.pCaptureClient;

        pDevice->capture.internalFormat             = data.formatOut;
        pDevice->capture.internalChannels           = data.channelsOut;
        pDevice->capture.internalSampleRate         = data.sampleRateOut;
        mal_copy_memory(pDevice->capture.internalChannelMap, data.channelMapOut, sizeof(data.channelMapOut));
        pDevice->capture.internalBufferSizeInFrames = data.bufferSizeInFramesOut;
        pDevice->capture.internalPeriods            = data.periodsOut;
        mal_strcpy_s(pDevice->capture.name, sizeof(pDevice->capture.name), data.deviceName);

        mal_IAudioClient_SetEventHandle((mal_IAudioClient*)pDevice->wasapi.pAudioClientCapture,  pDevice->wasapi.hEventCapture);

        pDevice->wasapi.periodSizeInFramesCapture = data.periodSizeInFramesOut;
        mal_IAudioClient_GetBufferSize((mal_IAudioClient*)pDevice->wasapi.pAudioClientCapture, &pDevice->wasapi.actualBufferSizeInFramesCapture);

        /* The device may be in a started state. If so we need to immediately restart it. */
        if (pDevice->wasapi.isStarted) {
            HRESULT hr = mal_IAudioClient_Start((mal_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
            if (FAILED(hr)) {
                return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to start internal capture device after reinitialization.", MAL_FAILED_TO_START_BACKEND_DEVICE);
            }
        }
    }

    if (deviceType == mal_device_type_playback) {
        if (pDevice->wasapi.pRenderClient) {
            mal_IAudioRenderClient_Release((mal_IAudioRenderClient*)pDevice->wasapi.pRenderClient);
            pDevice->wasapi.pRenderClient = NULL;
        }

        if (pDevice->wasapi.pAudioClientPlayback) {
            mal_IAudioClient_Release((mal_IAudioClient*)pDevice->wasapi.pAudioClientPlayback);
            pDevice->wasapi.pAudioClientPlayback = NULL;
        }

        pDevice->wasapi.pAudioClientPlayback         = data.pAudioClient;
        pDevice->wasapi.pRenderClient                = data.pRenderClient;

        pDevice->playback.internalFormat             = data.formatOut;
        pDevice->playback.internalChannels           = data.channelsOut;
        pDevice->playback.internalSampleRate         = data.sampleRateOut;
        mal_copy_memory(pDevice->playback.internalChannelMap, data.channelMapOut, sizeof(data.channelMapOut));
        pDevice->playback.internalBufferSizeInFrames = data.bufferSizeInFramesOut;
        pDevice->playback.internalPeriods            = data.periodsOut;
        mal_strcpy_s(pDevice->playback.name, sizeof(pDevice->playback.name), data.deviceName);

        mal_IAudioClient_SetEventHandle((mal_IAudioClient*)pDevice->wasapi.pAudioClientPlayback, pDevice->wasapi.hEventPlayback);

        pDevice->wasapi.periodSizeInFramesPlayback = data.periodSizeInFramesOut;
        mal_IAudioClient_GetBufferSize((mal_IAudioClient*)pDevice->wasapi.pAudioClientPlayback, &pDevice->wasapi.actualBufferSizeInFramesPlayback);

        /* The device may be in a started state. If so we need to immediately restart it. */
        if (pDevice->wasapi.isStarted) {
            HRESULT hr = mal_IAudioClient_Start((mal_IAudioClient*)pDevice->wasapi.pAudioClientPlayback);
            if (FAILED(hr)) {
                return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to start internal playback device after reinitialization.", MAL_FAILED_TO_START_BACKEND_DEVICE);
            }
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_device_init__wasapi(mal_context* pContext, const mal_device_config* pConfig, mal_device* pDevice)
{
    mal_result result = MAL_SUCCESS;
    const char* errorMsg = "";

    (void)pContext;

    mal_assert(pContext != NULL);
    mal_assert(pDevice != NULL);

    mal_zero_object(&pDevice->wasapi);
    pDevice->wasapi.originalBufferSizeInFrames       = pConfig->bufferSizeInFrames;
    pDevice->wasapi.originalBufferSizeInMilliseconds = pConfig->bufferSizeInMilliseconds;
    pDevice->wasapi.originalPeriods                  = pConfig->periods;

    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        mal_device_init_internal_data__wasapi data;
        data.formatIn                   = pConfig->capture.format;
        data.channelsIn                 = pConfig->capture.channels;
        data.sampleRateIn               = pConfig->sampleRate;
        mal_copy_memory(data.channelMapIn, pConfig->capture.channelMap, sizeof(pConfig->capture.channelMap));
        data.usingDefaultFormat         = pDevice->capture.usingDefaultFormat;
        data.usingDefaultChannels       = pDevice->capture.usingDefaultChannels;
        data.usingDefaultSampleRate     = pDevice->usingDefaultSampleRate;
        data.usingDefaultChannelMap     = pDevice->capture.usingDefaultChannelMap;
        data.shareMode                  = pConfig->capture.shareMode;
        data.bufferSizeInFramesIn       = pConfig->bufferSizeInFrames;
        data.bufferSizeInMillisecondsIn = pConfig->bufferSizeInMilliseconds;
        data.periodsIn                  = pConfig->periods;

        result = mal_device_init_internal__wasapi(pDevice->pContext, mal_device_type_capture, pConfig->capture.pDeviceID, &data);
        if (result != MAL_SUCCESS) {
            return result;
        }

        pDevice->wasapi.pAudioClientCapture         = data.pAudioClient;
        pDevice->wasapi.pCaptureClient              = data.pCaptureClient;

        pDevice->capture.internalFormat             = data.formatOut;
        pDevice->capture.internalChannels           = data.channelsOut;
        pDevice->capture.internalSampleRate         = data.sampleRateOut;
        mal_copy_memory(pDevice->capture.internalChannelMap, data.channelMapOut, sizeof(data.channelMapOut));
        pDevice->capture.internalBufferSizeInFrames = data.bufferSizeInFramesOut;
        pDevice->capture.internalPeriods            = data.periodsOut;
        mal_strcpy_s(pDevice->capture.name, sizeof(pDevice->capture.name), data.deviceName);

        /*
        The event for capture needs to be manual reset for the same reason as playback. We keep the initial state set to unsignaled,
        however, because we want to block until we actually have something for the first call to mal_device_read().
        */
        pDevice->wasapi.hEventCapture = CreateEventA(NULL, TRUE, FALSE, NULL);  /* Manual reset, unsignaled by default. */
        if (pDevice->wasapi.hEventCapture == NULL) {
            if (pDevice->wasapi.pCaptureClient != NULL) {
                mal_IAudioCaptureClient_Release((mal_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient);
                pDevice->wasapi.pCaptureClient = NULL;
            }
            if (pDevice->wasapi.pAudioClientCapture != NULL) {
                mal_IAudioClient_Release((mal_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
                pDevice->wasapi.pAudioClientCapture = NULL;
            }

            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to create event for capture.", MAL_FAILED_TO_CREATE_EVENT);
        }
        mal_IAudioClient_SetEventHandle((mal_IAudioClient*)pDevice->wasapi.pAudioClientCapture, pDevice->wasapi.hEventCapture);

        pDevice->wasapi.periodSizeInFramesCapture = data.periodSizeInFramesOut;
        mal_IAudioClient_GetBufferSize((mal_IAudioClient*)pDevice->wasapi.pAudioClientCapture, &pDevice->wasapi.actualBufferSizeInFramesCapture);
    }

    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        mal_device_init_internal_data__wasapi data;
        data.formatIn                   = pConfig->playback.format;
        data.channelsIn                 = pConfig->playback.channels;
        data.sampleRateIn               = pConfig->sampleRate;
        mal_copy_memory(data.channelMapIn, pConfig->playback.channelMap, sizeof(pConfig->playback.channelMap));
        data.usingDefaultFormat         = pDevice->playback.usingDefaultFormat;
        data.usingDefaultChannels       = pDevice->playback.usingDefaultChannels;
        data.usingDefaultSampleRate     = pDevice->usingDefaultSampleRate;
        data.usingDefaultChannelMap     = pDevice->playback.usingDefaultChannelMap;
        data.shareMode                  = pConfig->playback.shareMode;
        data.bufferSizeInFramesIn       = pConfig->bufferSizeInFrames;
        data.bufferSizeInMillisecondsIn = pConfig->bufferSizeInMilliseconds;
        data.periodsIn                  = pConfig->periods;

        result = mal_device_init_internal__wasapi(pDevice->pContext, mal_device_type_playback, pConfig->playback.pDeviceID, &data);
        if (result != MAL_SUCCESS) {
            if (pConfig->deviceType == mal_device_type_duplex) {
                if (pDevice->wasapi.pCaptureClient != NULL) {
                    mal_IAudioCaptureClient_Release((mal_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient);
                    pDevice->wasapi.pCaptureClient = NULL;
                }
                if (pDevice->wasapi.pAudioClientCapture != NULL) {
                    mal_IAudioClient_Release((mal_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
                    pDevice->wasapi.pAudioClientCapture = NULL;
                }

                CloseHandle(pDevice->wasapi.hEventCapture);
                pDevice->wasapi.hEventCapture = NULL;
            }
            return result;
        }

        pDevice->wasapi.pAudioClientPlayback         = data.pAudioClient;
        pDevice->wasapi.pRenderClient                = data.pRenderClient;

        pDevice->playback.internalFormat             = data.formatOut;
        pDevice->playback.internalChannels           = data.channelsOut;
        pDevice->playback.internalSampleRate         = data.sampleRateOut;
        mal_copy_memory(pDevice->playback.internalChannelMap, data.channelMapOut, sizeof(data.channelMapOut));
        pDevice->playback.internalBufferSizeInFrames = data.bufferSizeInFramesOut;
        pDevice->playback.internalPeriods            = data.periodsOut;
        mal_strcpy_s(pDevice->playback.name, sizeof(pDevice->playback.name), data.deviceName);

        /*
        The event for playback is needs to be manual reset because we want to explicitly control the fact that it becomes signalled
        only after the whole available space has been filled, never before.

        The playback event also needs to be initially set to a signaled state so that the first call to mal_device_write() is able
        to get passed WaitForMultipleObjects().
        */
        pDevice->wasapi.hEventPlayback = CreateEventA(NULL, TRUE, TRUE, NULL);  /* Manual reset, signaled by default. */
        if (pDevice->wasapi.hEventPlayback == NULL) {
            if (pConfig->deviceType == mal_device_type_duplex) {
                if (pDevice->wasapi.pCaptureClient != NULL) {
                    mal_IAudioCaptureClient_Release((mal_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient);
                    pDevice->wasapi.pCaptureClient = NULL;
                }
                if (pDevice->wasapi.pAudioClientCapture != NULL) {
                    mal_IAudioClient_Release((mal_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
                    pDevice->wasapi.pAudioClientCapture = NULL;
                }

                CloseHandle(pDevice->wasapi.hEventCapture);
                pDevice->wasapi.hEventCapture = NULL;
            }

            if (pDevice->wasapi.pRenderClient != NULL) {
                mal_IAudioRenderClient_Release((mal_IAudioRenderClient*)pDevice->wasapi.pRenderClient);
                pDevice->wasapi.pRenderClient = NULL;
            }
            if (pDevice->wasapi.pAudioClientPlayback != NULL) {
                mal_IAudioClient_Release((mal_IAudioClient*)pDevice->wasapi.pAudioClientPlayback);
                pDevice->wasapi.pAudioClientPlayback = NULL;
            }

            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to create event for playback.", MAL_FAILED_TO_CREATE_EVENT);
        }
        mal_IAudioClient_SetEventHandle((mal_IAudioClient*)pDevice->wasapi.pAudioClientPlayback, pDevice->wasapi.hEventPlayback);

        pDevice->wasapi.periodSizeInFramesPlayback = data.periodSizeInFramesOut;
        mal_IAudioClient_GetBufferSize((mal_IAudioClient*)pDevice->wasapi.pAudioClientPlayback, &pDevice->wasapi.actualBufferSizeInFramesPlayback);
    }


    // We need to get notifications of when the default device changes. We do this through a device enumerator by
    // registering a IMMNotificationClient with it. We only care about this if it's the default device.
#ifdef MAL_WIN32_DESKTOP
    mal_IMMDeviceEnumerator* pDeviceEnumerator;
    HRESULT hr = mal_CoCreateInstance(pContext, MAL_CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, MAL_IID_IMMDeviceEnumerator, (void**)&pDeviceEnumerator);
    if (FAILED(hr)) {
        errorMsg = "[WASAPI] Failed to create device enumerator.", result = MAL_FAILED_TO_OPEN_BACKEND_DEVICE;
        goto done;
    }

    pDevice->wasapi.notificationClient.lpVtbl  = (void*)&g_malNotificationCientVtbl;
    pDevice->wasapi.notificationClient.counter = 1;
    pDevice->wasapi.notificationClient.pDevice = pDevice;

    hr = pDeviceEnumerator->lpVtbl->RegisterEndpointNotificationCallback(pDeviceEnumerator, &pDevice->wasapi.notificationClient);
    if (SUCCEEDED(hr)) {
        pDevice->wasapi.pDeviceEnumerator = (mal_ptr)pDeviceEnumerator;
    } else {
        // Not the end of the world if we fail to register the notification callback. We just won't support automatic stream routing.
        mal_IMMDeviceEnumerator_Release(pDeviceEnumerator);
    }
#endif

    mal_atomic_exchange_32(&pDevice->wasapi.isStarted, MAL_FALSE);

    result = MAL_SUCCESS;

done:
    // Clean up.
    if (result != MAL_SUCCESS) {
        mal_device_uninit__wasapi(pDevice);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, errorMsg, result);
    } else {
        return MAL_SUCCESS;
    }
}

mal_result mal_device_start__wasapi(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    HRESULT hr;

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        hr = mal_IAudioClient_Start((mal_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
        if (FAILED(hr)) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to start internal capture device.", MAL_FAILED_TO_START_BACKEND_DEVICE);
        }
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        hr = mal_IAudioClient_Start((mal_IAudioClient*)pDevice->wasapi.pAudioClientPlayback);
        if (FAILED(hr)) {
            if (pDevice->type == mal_device_type_duplex) {
                mal_IAudioClient_Stop((mal_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
                mal_IAudioClient_Reset((mal_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
            }
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to start internal playback device.", MAL_FAILED_TO_START_BACKEND_DEVICE);
        }
    }

    mal_atomic_exchange_32(&pDevice->wasapi.isStarted, MAL_TRUE);
    return MAL_SUCCESS;
}

mal_result mal_device_stop__wasapi(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        if (pDevice->wasapi.pAudioClientCapture == NULL) {
            return MAL_DEVICE_NOT_INITIALIZED;
        }

        HRESULT hr = mal_IAudioClient_Stop((mal_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
        if (FAILED(hr)) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to stop internal capture device.", MAL_FAILED_TO_STOP_BACKEND_DEVICE);
        }

        /* The audio client needs to be reset otherwise restarting will fail. */
        hr = mal_IAudioClient_Reset((mal_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
        if (FAILED(hr)) {
#ifdef MAL_DEBUG_OUTPUT
            printf("IAudioClient_Reset (Capture) Returned %d\n", (int)hr);
#endif
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to reset internal capture device.", MAL_FAILED_TO_STOP_BACKEND_DEVICE);
        }
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        if (pDevice->wasapi.pAudioClientPlayback == NULL) {
            return MAL_DEVICE_NOT_INITIALIZED;
        }

        /* TODO: Wait until every sample that was written by the callback has been processed. */

        HRESULT hr = mal_IAudioClient_Stop((mal_IAudioClient*)pDevice->wasapi.pAudioClientPlayback);
        if (FAILED(hr)) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to stop internal playback device.", MAL_FAILED_TO_STOP_BACKEND_DEVICE);
        }

        /* The audio client needs to be reset otherwise restarting will fail. */
        hr = mal_IAudioClient_Reset((mal_IAudioClient*)pDevice->wasapi.pAudioClientPlayback);
        if (FAILED(hr)) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to reset internal playback device.", MAL_FAILED_TO_STOP_BACKEND_DEVICE);
        }
    }

    mal_atomic_exchange_32(&pDevice->wasapi.isStarted, MAL_FALSE);
    return MAL_SUCCESS;
}


mal_result mal_device__get_available_frames__wasapi(mal_device* pDevice, mal_IAudioClient* pAudioClient, mal_uint32* pFrameCount)
{
    mal_assert(pDevice != NULL);
    mal_assert(pFrameCount != NULL);
    
    *pFrameCount = 0;

    if ((mal_ptr)pAudioClient != pDevice->wasapi.pAudioClientPlayback && (mal_ptr)pAudioClient != pDevice->wasapi.pAudioClientCapture) {
        return MAL_INVALID_OPERATION;
    }

    mal_uint32 paddingFramesCount;
    HRESULT hr = mal_IAudioClient_GetCurrentPadding(pAudioClient, &paddingFramesCount);
    if (FAILED(hr)) {
        return MAL_DEVICE_UNAVAILABLE;
    }

    // Slightly different rules for exclusive and shared modes.
    mal_share_mode shareMode = ((mal_ptr)pAudioClient == pDevice->wasapi.pAudioClientPlayback) ? pDevice->playback.shareMode : pDevice->capture.shareMode;
    if (shareMode == mal_share_mode_exclusive) {
        *pFrameCount = paddingFramesCount;
    } else {
        if ((mal_ptr)pAudioClient == pDevice->wasapi.pAudioClientPlayback) {
            *pFrameCount = pDevice->wasapi.actualBufferSizeInFramesPlayback - paddingFramesCount;
        } else {
            *pFrameCount = paddingFramesCount;
        }
    }

    return MAL_SUCCESS;
}

mal_bool32 mal_device_is_reroute_required__wasapi(mal_device* pDevice, mal_device_type deviceType)
{
    mal_assert(pDevice != NULL);

    if (deviceType == mal_device_type_playback) {
        return pDevice->wasapi.hasDefaultPlaybackDeviceChanged;
    }

    if (deviceType == mal_device_type_capture) {
        return pDevice->wasapi.hasDefaultCaptureDeviceChanged;
    }
    
    return MAL_FALSE;
}

mal_result mal_device_reroute__wasapi(mal_device* pDevice, mal_device_type deviceType)
{
    if (deviceType == mal_device_type_duplex) {
        return MAL_INVALID_ARGS;
    }

    if (deviceType == mal_device_type_playback) {
        mal_atomic_exchange_32(&pDevice->wasapi.hasDefaultPlaybackDeviceChanged, MAL_FALSE);
    }
    if (deviceType == mal_device_type_capture) {
        mal_atomic_exchange_32(&pDevice->wasapi.hasDefaultCaptureDeviceChanged,  MAL_FALSE);
    }
    

    #ifdef MAL_DEBUG_OUTPUT
        printf("=== CHANGING DEVICE ===\n");
    #endif

    mal_result result = mal_device_reinit__wasapi(pDevice, deviceType);
    if (result != MAL_SUCCESS) {
        return result;
    }

    mal_device__post_init_setup(pDevice, deviceType);

    return MAL_SUCCESS;
}

mal_result mal_device_write__wasapi(mal_device* pDevice, const void* pPCMFrames, mal_uint32 frameCount)
{
    mal_result result = MAL_SUCCESS;
    mal_bool32 wasStartedOnEntry;
    mal_bool32 exitOuterLoop = MAL_FALSE;
    mal_uint32 totalFramesWritten;
    HRESULT hr;
    DWORD waitResult;

    wasStartedOnEntry = pDevice->wasapi.isStarted;

    /* Try to write every frame. */
    totalFramesWritten = 0;
    while (totalFramesWritten < frameCount) {
        /*
        If we've already got a pointer to the device buffer we will want to fill that up first. Once it's consumed we'll want to reset
        the event and set the cached pointer to NULL.
        */
        if (pDevice->wasapi.pDeviceBufferPlayback != NULL && pDevice->wasapi.deviceBufferFramesRemainingPlayback > 0) {
            mal_uint32 bpf = mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
            mal_uint32 deviceBufferFramesConsumed = pDevice->wasapi.deviceBufferFramesCapacityPlayback - pDevice->wasapi.deviceBufferFramesRemainingPlayback;

            void* pDst = (mal_uint8*)pDevice->wasapi.pDeviceBufferPlayback + (deviceBufferFramesConsumed * bpf);
            const void* pSrc = (const mal_uint8*)pPCMFrames + (totalFramesWritten * bpf);
            mal_uint32  framesToCopy = mal_min(pDevice->wasapi.deviceBufferFramesRemainingPlayback, (frameCount - totalFramesWritten));
            mal_copy_memory(pDst, pSrc, framesToCopy * bpf);

            pDevice->wasapi.deviceBufferFramesRemainingPlayback -= framesToCopy;
            totalFramesWritten += framesToCopy;
        }

        /* Getting here means we've consumed the device buffer and need to wait for more to become available. */
        if (pDevice->wasapi.deviceBufferFramesCapacityPlayback > 0 && pDevice->wasapi.deviceBufferFramesRemainingPlayback == 0) {
            hr = mal_IAudioRenderClient_ReleaseBuffer((mal_IAudioRenderClient*)pDevice->wasapi.pRenderClient, pDevice->wasapi.deviceBufferFramesCapacityPlayback, 0);
            pDevice->wasapi.pDeviceBufferPlayback = NULL;
            pDevice->wasapi.deviceBufferFramesRemainingPlayback = 0;
            pDevice->wasapi.deviceBufferFramesCapacityPlayback = 0;

            if (FAILED(hr)) {
                result = MAL_FAILED_TO_UNMAP_DEVICE_BUFFER;
                mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to release internal buffer from playback device after writing to the device.", result);
                break;
            }

            ResetEvent(pDevice->wasapi.hEventPlayback);

            /*
            After releasing the buffer, if the device is not started we need to do so. Note from MSDN:

                The event handle should be in the nonsignaled state at the time that the client calls the Start method.

            This means we should start the device only after setting the event to non-signaled (after the call to ResetEvent()).
            */
            if (!pDevice->wasapi.isStarted && !wasStartedOnEntry) {
                result = mal_device_start__wasapi(pDevice);
                if (result != MAL_SUCCESS) {
                    break;
                }
            }
        }

        mal_assert(totalFramesWritten <= frameCount);
        if (totalFramesWritten == frameCount) {
            break;
        }

        /* Wait for data to become available. Exclusive mode is slightly different. We always wait and then use the exact frame count returned by GetCurrentPadding(). */
        for (;;) {
            if (pDevice->playback.shareMode == mal_share_mode_exclusive) {
                waitResult = WaitForSingleObject(pDevice->wasapi.hEventPlayback, INFINITE);
                if (waitResult == WAIT_FAILED) {
                    result = MAL_ERROR;
                    exitOuterLoop = MAL_TRUE;
                    break;  /* An error occurred while waiting for the event. */
                }
            }

            /* If the device has been stopped don't continue. */
            if (!pDevice->wasapi.isStarted && wasStartedOnEntry) {
                exitOuterLoop = MAL_TRUE;
                break;
            }

            /* We may need to reroute the device. */
            if (mal_device_is_reroute_required__wasapi(pDevice, mal_device_type_playback)) {
                result = mal_device_reroute__wasapi(pDevice, mal_device_type_playback);
                if (result != MAL_SUCCESS) {
                    exitOuterLoop = MAL_TRUE;
                    break;
                }
            }

            /*
            Check what's available. If there's not enough data available we need to wait. How much data must be available depends on whether or not the
            device is in playback-only mode or duplex mode. In playback-only mode we only care about a period being available. In duplex mode we want at
            least a whole period in the buffer ready for playback in addition to a whole period being available.
            */
            result = mal_device__get_available_frames__wasapi(pDevice, (mal_IAudioClient*)pDevice->wasapi.pAudioClientPlayback, &pDevice->wasapi.deviceBufferFramesCapacityPlayback);
            if (result != MAL_SUCCESS) {
                exitOuterLoop = MAL_TRUE;
                break;
            }

            /* In exclusive mode, the frame count needs to exactly match the value returned by GetCurrentPadding(). */
            if (pDevice->playback.shareMode == mal_share_mode_exclusive && pDevice->wasapi.deviceBufferFramesCapacityPlayback > 0) {
                break;
            }

            mal_uint32 minAvailableFrames = pDevice->wasapi.periodSizeInFramesPlayback;
            if (pDevice->type == mal_device_type_duplex) {
                if (!pDevice->wasapi.isStarted) {
                    minAvailableFrames = pDevice->wasapi.periodSizeInFramesPlayback*2;
                }
            }

            if (pDevice->wasapi.deviceBufferFramesCapacityPlayback >= minAvailableFrames) {
                pDevice->wasapi.deviceBufferFramesCapacityPlayback  = minAvailableFrames;
                break;
            }

            //printf("TRACE: WAITING\n");

            /* Getting here means we need to wait for more data. */
            waitResult = WaitForSingleObject(pDevice->wasapi.hEventPlayback, INFINITE);
            if (waitResult == WAIT_FAILED) {
                result = MAL_ERROR;
                exitOuterLoop = MAL_TRUE;
                break;  /* An error occurred while waiting for the event. */
            }
        }

        if (exitOuterLoop) {
            break;
        }

        hr = mal_IAudioRenderClient_GetBuffer((mal_IAudioRenderClient*)pDevice->wasapi.pRenderClient, pDevice->wasapi.deviceBufferFramesCapacityPlayback, (BYTE**)&pDevice->wasapi.pDeviceBufferPlayback);
        if (FAILED(hr)) {
            result = MAL_FAILED_TO_MAP_DEVICE_BUFFER;
            mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to retrieve internal buffer from playback device in preparation for writing to the device.", result);
            break;
        }

        pDevice->wasapi.deviceBufferFramesRemainingPlayback = pDevice->wasapi.deviceBufferFramesCapacityPlayback;
        //printf("TRACE 1: Playback: %d, %d\n", pDevice->wasapi.deviceBufferFramesCapacityPlayback, pDevice->wasapi.periodSizeInFramesPlayback);
    }

    return result;
}

mal_result mal_device_read__wasapi(mal_device* pDevice, void* pPCMFrames, mal_uint32 frameCount)
{
    mal_result result = MAL_SUCCESS;
    mal_uint32 totalFramesRead;
    HRESULT hr;
    DWORD waitResult;
    DWORD flags;    /* Passed to IAudioCaptureClient_GetBuffer(). */

    /*
    This is mostly the same as mal_device_write__wasapi() with only a few exceptions:
        - If the device is not already started, it's started immediately.
    */
    if (!pDevice->wasapi.isStarted) {
        result = mal_device_start__wasapi(pDevice);
        if (result != MAL_SUCCESS) {
            return result;  /* Failed to auto-start device. */
        }
    }

    /* Try to read every frame. */
    totalFramesRead = 0;
    while (totalFramesRead < frameCount) {
        /* Make sure we consume any cached data before waiting for more. */
        if (pDevice->wasapi.pDeviceBufferCapture != NULL && pDevice->wasapi.deviceBufferFramesRemainingCapture > 0) {
            mal_uint32 bpf = mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
            mal_uint32 deviceBufferFramesConsumed = pDevice->wasapi.deviceBufferFramesCapacityCapture - pDevice->wasapi.deviceBufferFramesRemainingCapture;

            void* pDst = (mal_uint8*)pPCMFrames + (totalFramesRead * bpf);
            const void* pSrc = (const mal_uint8*)pDevice->wasapi.pDeviceBufferCapture + (deviceBufferFramesConsumed * bpf);
            mal_uint32  framesToCopy = mal_min(pDevice->wasapi.deviceBufferFramesRemainingCapture, (frameCount - totalFramesRead));
            mal_copy_memory(pDst, pSrc, framesToCopy * bpf);

            pDevice->wasapi.deviceBufferFramesRemainingCapture -= framesToCopy;
            totalFramesRead += framesToCopy;
        }

        /* Getting here means we've consumed the device buffer and need to wait for more to become available. */
        if (pDevice->wasapi.deviceBufferFramesCapacityCapture > 0 && pDevice->wasapi.deviceBufferFramesRemainingCapture == 0) {
            hr = mal_IAudioCaptureClient_ReleaseBuffer((mal_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient, pDevice->wasapi.deviceBufferFramesCapacityCapture);
            pDevice->wasapi.pDeviceBufferCapture = NULL;
            pDevice->wasapi.deviceBufferFramesRemainingCapture = 0;
            pDevice->wasapi.deviceBufferFramesCapacityCapture = 0;

            if (FAILED(hr)) {
                result = MAL_FAILED_TO_UNMAP_DEVICE_BUFFER;
                mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to release internal buffer from capture device after reading from the device.", result);
                break;
            }

            /*
            If we're running in full-duplex mode and there's too much data in the buffer we need to discard some to ensure we don't get stuck stradling the
            edge of the buffer and causing endless glitching.
            */
            if (pDevice->type == mal_device_type_duplex) {
                mal_uint32 framesAvailable;
                result = mal_device__get_available_frames__wasapi(pDevice, (mal_IAudioClient*)pDevice->wasapi.pAudioClientCapture, &framesAvailable);
                if (result == MAL_SUCCESS) {
                    if (framesAvailable > (pDevice->wasapi.periodSizeInFramesCapture*(pDevice->capture.internalPeriods-1))) {
                        mal_uint32 framesToDiscard = framesAvailable - pDevice->wasapi.periodSizeInFramesCapture;
                        if (framesToDiscard > 0) {
                            BYTE* pUnused;
                            hr = mal_IAudioCaptureClient_GetBuffer((mal_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient, &pUnused, &framesToDiscard, &flags, NULL, NULL);
                            if (SUCCEEDED(hr)) {
                            #ifdef MAL_DEBUG_OUTPUT
                                printf("[WASAPI] (Duplex/Capture) Discarding %d frames...\n", framesToDiscard);
                            #endif
                                mal_IAudioCaptureClient_ReleaseBuffer((mal_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient, framesToDiscard);
                            }
                        }
                    }
                }
            }

            ResetEvent(pDevice->wasapi.hEventCapture);
        }

        mal_assert(totalFramesRead <= frameCount);
        if (totalFramesRead == frameCount) {
            break;
        }

        /* Wait for data. */
        if (pDevice->type == mal_device_type_capture) {
            waitResult = WaitForSingleObject(pDevice->wasapi.hEventCapture, INFINITE);
        } else {
            if (pDevice->playback.shareMode == mal_share_mode_shared) {
                waitResult = WaitForSingleObject(pDevice->wasapi.hEventCapture, INFINITE);
            } else {
                waitResult = WaitForSingleObject(pDevice->wasapi.hEventPlayback, INFINITE); /* Wait on the exclusive-mode playback event instead. */
            }
        }
        if (waitResult == WAIT_FAILED) {
            result = MAL_ERROR;
            break;  /* An error occurred while waiting for the event. */
        }

        /* If the device has been stopped don't continue. */
        if (!pDevice->wasapi.isStarted) {
            break;
        }

        /* We may need to reroute the device. */
        if (mal_device_is_reroute_required__wasapi(pDevice, mal_device_type_capture)) {
            result = mal_device_reroute__wasapi(pDevice, mal_device_type_capture);
            if (result != MAL_SUCCESS) {
                break;
            }
        }

        /* The device buffer has become available, so now we need to get a pointer to it. */
        result = mal_device__get_available_frames__wasapi(pDevice, (mal_IAudioClient*)pDevice->wasapi.pAudioClientCapture, &pDevice->wasapi.deviceBufferFramesCapacityCapture);
        if (result != MAL_SUCCESS) {
            break;
        }

        //printf("TRACE 1: capacity capture: %d, %d\n", pDevice->wasapi.deviceBufferFramesCapacityCapture, pDevice->wasapi.periodSizeInFramesCapture);

        /* In exclusive mode, the frame count needs to exactly match the value returned by GetCurrentPadding(). */
        if (pDevice->playback.shareMode != mal_share_mode_exclusive) {
            if (pDevice->wasapi.deviceBufferFramesCapacityCapture > pDevice->wasapi.periodSizeInFramesCapture) {
                pDevice->wasapi.deviceBufferFramesCapacityCapture = pDevice->wasapi.periodSizeInFramesCapture;
            }
        }

        hr = mal_IAudioCaptureClient_GetBuffer((mal_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient, (BYTE**)&pDevice->wasapi.pDeviceBufferCapture, &pDevice->wasapi.deviceBufferFramesCapacityCapture, &flags, NULL, NULL);
        if (FAILED(hr)) {
            result = MAL_FAILED_TO_MAP_DEVICE_BUFFER;
            mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WASAPI] Failed to retrieve internal buffer from capture device in preparation for writing to the device.", result);
            break;
        }

        pDevice->wasapi.deviceBufferFramesRemainingCapture = pDevice->wasapi.deviceBufferFramesCapacityCapture;
    }

    return result;
}

mal_result mal_context_uninit__wasapi(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    mal_assert(pContext->backend == mal_backend_wasapi);
    (void)pContext;

    return MAL_SUCCESS;
}

mal_result mal_context_init__wasapi(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    (void)pContext;

    mal_result result = MAL_SUCCESS;

#ifdef MAL_WIN32_DESKTOP
    // WASAPI is only supported in Vista SP1 and newer. The reason for SP1 and not the base version of Vista is that event-driven
    // exclusive mode does not work until SP1.
    mal_OSVERSIONINFOEXW osvi;
    mal_zero_object(&osvi);
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    osvi.dwMajorVersion = HIBYTE(_WIN32_WINNT_VISTA);
    osvi.dwMinorVersion = LOBYTE(_WIN32_WINNT_VISTA);
    osvi.wServicePackMajor = 1;
    if (VerifyVersionInfoW(&osvi, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR, VerSetConditionMask(VerSetConditionMask(VerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL), VER_MINORVERSION, VER_GREATER_EQUAL), VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL))) {
        result = MAL_SUCCESS;
    } else {
        result = MAL_NO_BACKEND;
    }
#endif

    if (result != MAL_SUCCESS) {
        return result;
    }

    pContext->onUninit              = mal_context_uninit__wasapi;
    pContext->onDeviceIDEqual       = mal_context_is_device_id_equal__wasapi;
    pContext->onEnumDevices         = mal_context_enumerate_devices__wasapi;
    pContext->onGetDeviceInfo       = mal_context_get_device_info__wasapi;
    pContext->onDeviceInit          = mal_device_init__wasapi;
    pContext->onDeviceUninit        = mal_device_uninit__wasapi;
    pContext->onDeviceStart         = NULL; /* Not used. Started in onDeviceWrite/onDeviceRead. */
    pContext->onDeviceStop          = mal_device_stop__wasapi;
    pContext->onDeviceWrite         = mal_device_write__wasapi;
    pContext->onDeviceRead          = mal_device_read__wasapi;

    return result;
}
#endif

///////////////////////////////////////////////////////////////////////////////
//
// DirectSound Backend
//
///////////////////////////////////////////////////////////////////////////////
#ifdef MAL_HAS_DSOUND
//#include <dsound.h>

GUID MAL_GUID_IID_DirectSoundNotify = {0xb0210783, 0x89cd, 0x11d0, {0xaf, 0x08, 0x00, 0xa0, 0xc9, 0x25, 0xcd, 0x16}};

// mini_al only uses priority or exclusive modes.
#define MAL_DSSCL_NORMAL                 1
#define MAL_DSSCL_PRIORITY               2
#define MAL_DSSCL_EXCLUSIVE              3
#define MAL_DSSCL_WRITEPRIMARY           4

#define MAL_DSCAPS_PRIMARYMONO           0x00000001
#define MAL_DSCAPS_PRIMARYSTEREO         0x00000002
#define MAL_DSCAPS_PRIMARY8BIT           0x00000004
#define MAL_DSCAPS_PRIMARY16BIT          0x00000008
#define MAL_DSCAPS_CONTINUOUSRATE        0x00000010
#define MAL_DSCAPS_EMULDRIVER            0x00000020
#define MAL_DSCAPS_CERTIFIED             0x00000040
#define MAL_DSCAPS_SECONDARYMONO         0x00000100
#define MAL_DSCAPS_SECONDARYSTEREO       0x00000200
#define MAL_DSCAPS_SECONDARY8BIT         0x00000400
#define MAL_DSCAPS_SECONDARY16BIT        0x00000800

#define MAL_DSBCAPS_PRIMARYBUFFER        0x00000001
#define MAL_DSBCAPS_STATIC               0x00000002
#define MAL_DSBCAPS_LOCHARDWARE          0x00000004
#define MAL_DSBCAPS_LOCSOFTWARE          0x00000008
#define MAL_DSBCAPS_CTRL3D               0x00000010
#define MAL_DSBCAPS_CTRLFREQUENCY        0x00000020
#define MAL_DSBCAPS_CTRLPAN              0x00000040
#define MAL_DSBCAPS_CTRLVOLUME           0x00000080
#define MAL_DSBCAPS_CTRLPOSITIONNOTIFY   0x00000100
#define MAL_DSBCAPS_CTRLFX               0x00000200
#define MAL_DSBCAPS_STICKYFOCUS          0x00004000
#define MAL_DSBCAPS_GLOBALFOCUS          0x00008000
#define MAL_DSBCAPS_GETCURRENTPOSITION2  0x00010000
#define MAL_DSBCAPS_MUTE3DATMAXDISTANCE  0x00020000
#define MAL_DSBCAPS_LOCDEFER             0x00040000
#define MAL_DSBCAPS_TRUEPLAYPOSITION     0x00080000

#define MAL_DSBPLAY_LOOPING              0x00000001
#define MAL_DSBPLAY_LOCHARDWARE          0x00000002
#define MAL_DSBPLAY_LOCSOFTWARE          0x00000004
#define MAL_DSBPLAY_TERMINATEBY_TIME     0x00000008
#define MAL_DSBPLAY_TERMINATEBY_DISTANCE 0x00000010
#define MAL_DSBPLAY_TERMINATEBY_PRIORITY 0x00000020

#define MAL_DSCBSTART_LOOPING            0x00000001

typedef struct
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwBufferBytes;
    DWORD dwReserved;
    WAVEFORMATEX* lpwfxFormat;
    GUID guid3DAlgorithm;
} MAL_DSBUFFERDESC;

typedef struct
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwBufferBytes;
    DWORD dwReserved;
    WAVEFORMATEX* lpwfxFormat;
    DWORD dwFXCount;
    void* lpDSCFXDesc;  // <-- mini_al doesn't use this, so set to void*.
} MAL_DSCBUFFERDESC;

typedef struct
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwMinSecondarySampleRate;
    DWORD dwMaxSecondarySampleRate;
    DWORD dwPrimaryBuffers;
    DWORD dwMaxHwMixingAllBuffers;
    DWORD dwMaxHwMixingStaticBuffers;
    DWORD dwMaxHwMixingStreamingBuffers;
    DWORD dwFreeHwMixingAllBuffers;
    DWORD dwFreeHwMixingStaticBuffers;
    DWORD dwFreeHwMixingStreamingBuffers;
    DWORD dwMaxHw3DAllBuffers;
    DWORD dwMaxHw3DStaticBuffers;
    DWORD dwMaxHw3DStreamingBuffers;
    DWORD dwFreeHw3DAllBuffers;
    DWORD dwFreeHw3DStaticBuffers;
    DWORD dwFreeHw3DStreamingBuffers;
    DWORD dwTotalHwMemBytes;
    DWORD dwFreeHwMemBytes;
    DWORD dwMaxContigFreeHwMemBytes;
    DWORD dwUnlockTransferRateHwBuffers;
    DWORD dwPlayCpuOverheadSwBuffers;
    DWORD dwReserved1;
    DWORD dwReserved2;
} MAL_DSCAPS;

typedef struct
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwBufferBytes;
    DWORD dwUnlockTransferRate;
    DWORD dwPlayCpuOverhead;
} MAL_DSBCAPS;

typedef struct
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwFormats;
    DWORD dwChannels;
} MAL_DSCCAPS;

typedef struct
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwBufferBytes;
    DWORD dwReserved;
} MAL_DSCBCAPS;

typedef struct
{
    DWORD  dwOffset;
    HANDLE hEventNotify;
} MAL_DSBPOSITIONNOTIFY;

typedef struct mal_IDirectSound              mal_IDirectSound;
typedef struct mal_IDirectSoundBuffer        mal_IDirectSoundBuffer;
typedef struct mal_IDirectSoundCapture       mal_IDirectSoundCapture;
typedef struct mal_IDirectSoundCaptureBuffer mal_IDirectSoundCaptureBuffer;
typedef struct mal_IDirectSoundNotify        mal_IDirectSoundNotify;


// COM objects. The way these work is that you have a vtable (a list of function pointers, kind of
// like how C++ works internally), and then you have a structure with a single member, which is a
// pointer to the vtable. The vtable is where the methods of the object are defined. Methods need
// to be in a specific order, and parent classes need to have their methods declared first.

// IDirectSound
typedef struct
{
    // IUnknown
    HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_IDirectSound* pThis, const IID* const riid, void** ppObject);
    ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_IDirectSound* pThis);
    ULONG   (STDMETHODCALLTYPE * Release)       (mal_IDirectSound* pThis);

    // IDirectSound
    HRESULT (STDMETHODCALLTYPE * CreateSoundBuffer)   (mal_IDirectSound* pThis, const MAL_DSBUFFERDESC* pDSBufferDesc, mal_IDirectSoundBuffer** ppDSBuffer, void* pUnkOuter);
    HRESULT (STDMETHODCALLTYPE * GetCaps)             (mal_IDirectSound* pThis, MAL_DSCAPS* pDSCaps);
    HRESULT (STDMETHODCALLTYPE * DuplicateSoundBuffer)(mal_IDirectSound* pThis, mal_IDirectSoundBuffer* pDSBufferOriginal, mal_IDirectSoundBuffer** ppDSBufferDuplicate);
    HRESULT (STDMETHODCALLTYPE * SetCooperativeLevel) (mal_IDirectSound* pThis, HWND hwnd, DWORD dwLevel);
    HRESULT (STDMETHODCALLTYPE * Compact)             (mal_IDirectSound* pThis);
    HRESULT (STDMETHODCALLTYPE * GetSpeakerConfig)    (mal_IDirectSound* pThis, DWORD* pSpeakerConfig);
    HRESULT (STDMETHODCALLTYPE * SetSpeakerConfig)    (mal_IDirectSound* pThis, DWORD dwSpeakerConfig);
    HRESULT (STDMETHODCALLTYPE * Initialize)          (mal_IDirectSound* pThis, const GUID* pGuidDevice);
} mal_IDirectSoundVtbl;
struct mal_IDirectSound
{
    mal_IDirectSoundVtbl* lpVtbl;
};
HRESULT mal_IDirectSound_QueryInterface(mal_IDirectSound* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
ULONG   mal_IDirectSound_AddRef(mal_IDirectSound* pThis)                                                 { return pThis->lpVtbl->AddRef(pThis); }
ULONG   mal_IDirectSound_Release(mal_IDirectSound* pThis)                                                { return pThis->lpVtbl->Release(pThis); }
HRESULT mal_IDirectSound_CreateSoundBuffer(mal_IDirectSound* pThis, const MAL_DSBUFFERDESC* pDSBufferDesc, mal_IDirectSoundBuffer** ppDSBuffer, void* pUnkOuter) { return pThis->lpVtbl->CreateSoundBuffer(pThis, pDSBufferDesc, ppDSBuffer, pUnkOuter); }
HRESULT mal_IDirectSound_GetCaps(mal_IDirectSound* pThis, MAL_DSCAPS* pDSCaps)                           { return pThis->lpVtbl->GetCaps(pThis, pDSCaps); }
HRESULT mal_IDirectSound_DuplicateSoundBuffer(mal_IDirectSound* pThis, mal_IDirectSoundBuffer* pDSBufferOriginal, mal_IDirectSoundBuffer** ppDSBufferDuplicate) { return pThis->lpVtbl->DuplicateSoundBuffer(pThis, pDSBufferOriginal, ppDSBufferDuplicate); }
HRESULT mal_IDirectSound_SetCooperativeLevel(mal_IDirectSound* pThis, HWND hwnd, DWORD dwLevel)          { return pThis->lpVtbl->SetCooperativeLevel(pThis, hwnd, dwLevel); }
HRESULT mal_IDirectSound_Compact(mal_IDirectSound* pThis)                                                { return pThis->lpVtbl->Compact(pThis); }
HRESULT mal_IDirectSound_GetSpeakerConfig(mal_IDirectSound* pThis, DWORD* pSpeakerConfig)                { return pThis->lpVtbl->GetSpeakerConfig(pThis, pSpeakerConfig); }
HRESULT mal_IDirectSound_SetSpeakerConfig(mal_IDirectSound* pThis, DWORD dwSpeakerConfig)                { return pThis->lpVtbl->SetSpeakerConfig(pThis, dwSpeakerConfig); }
HRESULT mal_IDirectSound_Initialize(mal_IDirectSound* pThis, const GUID* pGuidDevice)                    { return pThis->lpVtbl->Initialize(pThis, pGuidDevice); }


// IDirectSoundBuffer
typedef struct
{
    // IUnknown
    HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_IDirectSoundBuffer* pThis, const IID* const riid, void** ppObject);
    ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_IDirectSoundBuffer* pThis);
    ULONG   (STDMETHODCALLTYPE * Release)       (mal_IDirectSoundBuffer* pThis);

    // IDirectSoundBuffer
    HRESULT (STDMETHODCALLTYPE * GetCaps)           (mal_IDirectSoundBuffer* pThis, MAL_DSBCAPS* pDSBufferCaps);
    HRESULT (STDMETHODCALLTYPE * GetCurrentPosition)(mal_IDirectSoundBuffer* pThis, DWORD* pCurrentPlayCursor, DWORD* pCurrentWriteCursor);
    HRESULT (STDMETHODCALLTYPE * GetFormat)         (mal_IDirectSoundBuffer* pThis, WAVEFORMATEX* pFormat, DWORD dwSizeAllocated, DWORD* pSizeWritten);
    HRESULT (STDMETHODCALLTYPE * GetVolume)         (mal_IDirectSoundBuffer* pThis, LONG* pVolume);
    HRESULT (STDMETHODCALLTYPE * GetPan)            (mal_IDirectSoundBuffer* pThis, LONG* pPan);
    HRESULT (STDMETHODCALLTYPE * GetFrequency)      (mal_IDirectSoundBuffer* pThis, DWORD* pFrequency);
    HRESULT (STDMETHODCALLTYPE * GetStatus)         (mal_IDirectSoundBuffer* pThis, DWORD* pStatus);
    HRESULT (STDMETHODCALLTYPE * Initialize)        (mal_IDirectSoundBuffer* pThis, mal_IDirectSound* pDirectSound, const MAL_DSBUFFERDESC* pDSBufferDesc);
    HRESULT (STDMETHODCALLTYPE * Lock)              (mal_IDirectSoundBuffer* pThis, DWORD dwOffset, DWORD dwBytes, void** ppAudioPtr1, DWORD* pAudioBytes1, void** ppAudioPtr2, DWORD* pAudioBytes2, DWORD dwFlags);
    HRESULT (STDMETHODCALLTYPE * Play)              (mal_IDirectSoundBuffer* pThis, DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags);
    HRESULT (STDMETHODCALLTYPE * SetCurrentPosition)(mal_IDirectSoundBuffer* pThis, DWORD dwNewPosition);
    HRESULT (STDMETHODCALLTYPE * SetFormat)         (mal_IDirectSoundBuffer* pThis, const WAVEFORMATEX* pFormat);
    HRESULT (STDMETHODCALLTYPE * SetVolume)         (mal_IDirectSoundBuffer* pThis, LONG volume);
    HRESULT (STDMETHODCALLTYPE * SetPan)            (mal_IDirectSoundBuffer* pThis, LONG pan);
    HRESULT (STDMETHODCALLTYPE * SetFrequency)      (mal_IDirectSoundBuffer* pThis, DWORD dwFrequency);
    HRESULT (STDMETHODCALLTYPE * Stop)              (mal_IDirectSoundBuffer* pThis);
    HRESULT (STDMETHODCALLTYPE * Unlock)            (mal_IDirectSoundBuffer* pThis, void* pAudioPtr1, DWORD dwAudioBytes1, void* pAudioPtr2, DWORD dwAudioBytes2);
    HRESULT (STDMETHODCALLTYPE * Restore)           (mal_IDirectSoundBuffer* pThis);
} mal_IDirectSoundBufferVtbl;
struct mal_IDirectSoundBuffer
{
    mal_IDirectSoundBufferVtbl* lpVtbl;
};
HRESULT mal_IDirectSoundBuffer_QueryInterface(mal_IDirectSoundBuffer* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
ULONG   mal_IDirectSoundBuffer_AddRef(mal_IDirectSoundBuffer* pThis)                                                 { return pThis->lpVtbl->AddRef(pThis); }
ULONG   mal_IDirectSoundBuffer_Release(mal_IDirectSoundBuffer* pThis)                                                { return pThis->lpVtbl->Release(pThis); }
HRESULT mal_IDirectSoundBuffer_GetCaps(mal_IDirectSoundBuffer* pThis, MAL_DSBCAPS* pDSBufferCaps)                    { return pThis->lpVtbl->GetCaps(pThis, pDSBufferCaps); }
HRESULT mal_IDirectSoundBuffer_GetCurrentPosition(mal_IDirectSoundBuffer* pThis, DWORD* pCurrentPlayCursor, DWORD* pCurrentWriteCursor) { return pThis->lpVtbl->GetCurrentPosition(pThis, pCurrentPlayCursor, pCurrentWriteCursor); }
HRESULT mal_IDirectSoundBuffer_GetFormat(mal_IDirectSoundBuffer* pThis, WAVEFORMATEX* pFormat, DWORD dwSizeAllocated, DWORD* pSizeWritten) { return pThis->lpVtbl->GetFormat(pThis, pFormat, dwSizeAllocated, pSizeWritten); }
HRESULT mal_IDirectSoundBuffer_GetVolume(mal_IDirectSoundBuffer* pThis, LONG* pVolume)                               { return pThis->lpVtbl->GetVolume(pThis, pVolume); }
HRESULT mal_IDirectSoundBuffer_GetPan(mal_IDirectSoundBuffer* pThis, LONG* pPan)                                     { return pThis->lpVtbl->GetPan(pThis, pPan); }
HRESULT mal_IDirectSoundBuffer_GetFrequency(mal_IDirectSoundBuffer* pThis, DWORD* pFrequency)                        { return pThis->lpVtbl->GetFrequency(pThis, pFrequency); }
HRESULT mal_IDirectSoundBuffer_GetStatus(mal_IDirectSoundBuffer* pThis, DWORD* pStatus)                              { return pThis->lpVtbl->GetStatus(pThis, pStatus); }
HRESULT mal_IDirectSoundBuffer_Initialize(mal_IDirectSoundBuffer* pThis, mal_IDirectSound* pDirectSound, const MAL_DSBUFFERDESC* pDSBufferDesc) { return pThis->lpVtbl->Initialize(pThis, pDirectSound, pDSBufferDesc); }
HRESULT mal_IDirectSoundBuffer_Lock(mal_IDirectSoundBuffer* pThis, DWORD dwOffset, DWORD dwBytes, void** ppAudioPtr1, DWORD* pAudioBytes1, void** ppAudioPtr2, DWORD* pAudioBytes2, DWORD dwFlags) { return pThis->lpVtbl->Lock(pThis, dwOffset, dwBytes, ppAudioPtr1, pAudioBytes1, ppAudioPtr2, pAudioBytes2, dwFlags); }
HRESULT mal_IDirectSoundBuffer_Play(mal_IDirectSoundBuffer* pThis, DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) { return pThis->lpVtbl->Play(pThis, dwReserved1, dwPriority, dwFlags); }
HRESULT mal_IDirectSoundBuffer_SetCurrentPosition(mal_IDirectSoundBuffer* pThis, DWORD dwNewPosition)                { return pThis->lpVtbl->SetCurrentPosition(pThis, dwNewPosition); }
HRESULT mal_IDirectSoundBuffer_SetFormat(mal_IDirectSoundBuffer* pThis, const WAVEFORMATEX* pFormat)                 { return pThis->lpVtbl->SetFormat(pThis, pFormat); }
HRESULT mal_IDirectSoundBuffer_SetVolume(mal_IDirectSoundBuffer* pThis, LONG volume)                                 { return pThis->lpVtbl->SetVolume(pThis, volume); }
HRESULT mal_IDirectSoundBuffer_SetPan(mal_IDirectSoundBuffer* pThis, LONG pan)                                       { return pThis->lpVtbl->SetPan(pThis, pan); }
HRESULT mal_IDirectSoundBuffer_SetFrequency(mal_IDirectSoundBuffer* pThis, DWORD dwFrequency)                        { return pThis->lpVtbl->SetFrequency(pThis, dwFrequency); }
HRESULT mal_IDirectSoundBuffer_Stop(mal_IDirectSoundBuffer* pThis)                                                   { return pThis->lpVtbl->Stop(pThis); }
HRESULT mal_IDirectSoundBuffer_Unlock(mal_IDirectSoundBuffer* pThis, void* pAudioPtr1, DWORD dwAudioBytes1, void* pAudioPtr2, DWORD dwAudioBytes2) { return pThis->lpVtbl->Unlock(pThis, pAudioPtr1, dwAudioBytes1, pAudioPtr2, dwAudioBytes2); }
HRESULT mal_IDirectSoundBuffer_Restore(mal_IDirectSoundBuffer* pThis)                                                { return pThis->lpVtbl->Restore(pThis); }


// IDirectSoundCapture
typedef struct
{
    // IUnknown
    HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_IDirectSoundCapture* pThis, const IID* const riid, void** ppObject);
    ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_IDirectSoundCapture* pThis);
    ULONG   (STDMETHODCALLTYPE * Release)       (mal_IDirectSoundCapture* pThis);

    // IDirectSoundCapture
    HRESULT (STDMETHODCALLTYPE * CreateCaptureBuffer)(mal_IDirectSoundCapture* pThis, const MAL_DSCBUFFERDESC* pDSCBufferDesc, mal_IDirectSoundCaptureBuffer** ppDSCBuffer, void* pUnkOuter);
    HRESULT (STDMETHODCALLTYPE * GetCaps)            (mal_IDirectSoundCapture* pThis, MAL_DSCCAPS* pDSCCaps);
    HRESULT (STDMETHODCALLTYPE * Initialize)         (mal_IDirectSoundCapture* pThis, const GUID* pGuidDevice);
} mal_IDirectSoundCaptureVtbl;
struct mal_IDirectSoundCapture
{
    mal_IDirectSoundCaptureVtbl* lpVtbl;
};
HRESULT mal_IDirectSoundCapture_QueryInterface(mal_IDirectSoundCapture* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
ULONG   mal_IDirectSoundCapture_AddRef(mal_IDirectSoundCapture* pThis)                                                 { return pThis->lpVtbl->AddRef(pThis); }
ULONG   mal_IDirectSoundCapture_Release(mal_IDirectSoundCapture* pThis)                                                { return pThis->lpVtbl->Release(pThis); }
HRESULT mal_IDirectSoundCapture_CreateCaptureBuffer(mal_IDirectSoundCapture* pThis, const MAL_DSCBUFFERDESC* pDSCBufferDesc, mal_IDirectSoundCaptureBuffer** ppDSCBuffer, void* pUnkOuter) { return pThis->lpVtbl->CreateCaptureBuffer(pThis, pDSCBufferDesc, ppDSCBuffer, pUnkOuter); }
HRESULT mal_IDirectSoundCapture_GetCaps            (mal_IDirectSoundCapture* pThis, MAL_DSCCAPS* pDSCCaps)             { return pThis->lpVtbl->GetCaps(pThis, pDSCCaps); }
HRESULT mal_IDirectSoundCapture_Initialize         (mal_IDirectSoundCapture* pThis, const GUID* pGuidDevice)           { return pThis->lpVtbl->Initialize(pThis, pGuidDevice); }


// IDirectSoundCaptureBuffer
typedef struct
{
    // IUnknown
    HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_IDirectSoundCaptureBuffer* pThis, const IID* const riid, void** ppObject);
    ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_IDirectSoundCaptureBuffer* pThis);
    ULONG   (STDMETHODCALLTYPE * Release)       (mal_IDirectSoundCaptureBuffer* pThis);

    // IDirectSoundCaptureBuffer
    HRESULT (STDMETHODCALLTYPE * GetCaps)           (mal_IDirectSoundCaptureBuffer* pThis, MAL_DSCBCAPS* pDSCBCaps);
    HRESULT (STDMETHODCALLTYPE * GetCurrentPosition)(mal_IDirectSoundCaptureBuffer* pThis, DWORD* pCapturePosition, DWORD* pReadPosition);
    HRESULT (STDMETHODCALLTYPE * GetFormat)         (mal_IDirectSoundCaptureBuffer* pThis, WAVEFORMATEX* pFormat, DWORD dwSizeAllocated, DWORD* pSizeWritten);
    HRESULT (STDMETHODCALLTYPE * GetStatus)         (mal_IDirectSoundCaptureBuffer* pThis, DWORD* pStatus);
    HRESULT (STDMETHODCALLTYPE * Initialize)        (mal_IDirectSoundCaptureBuffer* pThis, mal_IDirectSoundCapture* pDirectSoundCapture, const MAL_DSCBUFFERDESC* pDSCBufferDesc);
    HRESULT (STDMETHODCALLTYPE * Lock)              (mal_IDirectSoundCaptureBuffer* pThis, DWORD dwOffset, DWORD dwBytes, void** ppAudioPtr1, DWORD* pAudioBytes1, void** ppAudioPtr2, DWORD* pAudioBytes2, DWORD dwFlags);
    HRESULT (STDMETHODCALLTYPE * Start)             (mal_IDirectSoundCaptureBuffer* pThis, DWORD dwFlags);
    HRESULT (STDMETHODCALLTYPE * Stop)              (mal_IDirectSoundCaptureBuffer* pThis);
    HRESULT (STDMETHODCALLTYPE * Unlock)            (mal_IDirectSoundCaptureBuffer* pThis, void* pAudioPtr1, DWORD dwAudioBytes1, void* pAudioPtr2, DWORD dwAudioBytes2);
} mal_IDirectSoundCaptureBufferVtbl;
struct mal_IDirectSoundCaptureBuffer
{
    mal_IDirectSoundCaptureBufferVtbl* lpVtbl;
};
HRESULT mal_IDirectSoundCaptureBuffer_QueryInterface(mal_IDirectSoundCaptureBuffer* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
ULONG   mal_IDirectSoundCaptureBuffer_AddRef(mal_IDirectSoundCaptureBuffer* pThis)                                                 { return pThis->lpVtbl->AddRef(pThis); }
ULONG   mal_IDirectSoundCaptureBuffer_Release(mal_IDirectSoundCaptureBuffer* pThis)                                                { return pThis->lpVtbl->Release(pThis); }
HRESULT mal_IDirectSoundCaptureBuffer_GetCaps(mal_IDirectSoundCaptureBuffer* pThis, MAL_DSCBCAPS* pDSCBCaps)                       { return pThis->lpVtbl->GetCaps(pThis, pDSCBCaps); }
HRESULT mal_IDirectSoundCaptureBuffer_GetCurrentPosition(mal_IDirectSoundCaptureBuffer* pThis, DWORD* pCapturePosition, DWORD* pReadPosition) { return pThis->lpVtbl->GetCurrentPosition(pThis, pCapturePosition, pReadPosition); }
HRESULT mal_IDirectSoundCaptureBuffer_GetFormat(mal_IDirectSoundCaptureBuffer* pThis, WAVEFORMATEX* pFormat, DWORD dwSizeAllocated, DWORD* pSizeWritten) { return pThis->lpVtbl->GetFormat(pThis, pFormat, dwSizeAllocated, pSizeWritten); }
HRESULT mal_IDirectSoundCaptureBuffer_GetStatus(mal_IDirectSoundCaptureBuffer* pThis, DWORD* pStatus)                              { return pThis->lpVtbl->GetStatus(pThis, pStatus); }
HRESULT mal_IDirectSoundCaptureBuffer_Initialize(mal_IDirectSoundCaptureBuffer* pThis, mal_IDirectSoundCapture* pDirectSoundCapture, const MAL_DSCBUFFERDESC* pDSCBufferDesc) { return pThis->lpVtbl->Initialize(pThis, pDirectSoundCapture, pDSCBufferDesc); }
HRESULT mal_IDirectSoundCaptureBuffer_Lock(mal_IDirectSoundCaptureBuffer* pThis, DWORD dwOffset, DWORD dwBytes, void** ppAudioPtr1, DWORD* pAudioBytes1, void** ppAudioPtr2, DWORD* pAudioBytes2, DWORD dwFlags) { return pThis->lpVtbl->Lock(pThis, dwOffset, dwBytes, ppAudioPtr1, pAudioBytes1, ppAudioPtr2, pAudioBytes2, dwFlags); }
HRESULT mal_IDirectSoundCaptureBuffer_Start(mal_IDirectSoundCaptureBuffer* pThis, DWORD dwFlags)                                   { return pThis->lpVtbl->Start(pThis, dwFlags); }
HRESULT mal_IDirectSoundCaptureBuffer_Stop(mal_IDirectSoundCaptureBuffer* pThis)                                                   { return pThis->lpVtbl->Stop(pThis); }
HRESULT mal_IDirectSoundCaptureBuffer_Unlock(mal_IDirectSoundCaptureBuffer* pThis, void* pAudioPtr1, DWORD dwAudioBytes1, void* pAudioPtr2, DWORD dwAudioBytes2) { return pThis->lpVtbl->Unlock(pThis, pAudioPtr1, dwAudioBytes1, pAudioPtr2, dwAudioBytes2); }


// IDirectSoundNotify
typedef struct
{
    // IUnknown
    HRESULT (STDMETHODCALLTYPE * QueryInterface)(mal_IDirectSoundNotify* pThis, const IID* const riid, void** ppObject);
    ULONG   (STDMETHODCALLTYPE * AddRef)        (mal_IDirectSoundNotify* pThis);
    ULONG   (STDMETHODCALLTYPE * Release)       (mal_IDirectSoundNotify* pThis);

    // IDirectSoundNotify
    HRESULT (STDMETHODCALLTYPE * SetNotificationPositions)(mal_IDirectSoundNotify* pThis, DWORD dwPositionNotifies, const MAL_DSBPOSITIONNOTIFY* pPositionNotifies);
} mal_IDirectSoundNotifyVtbl;
struct mal_IDirectSoundNotify
{
    mal_IDirectSoundNotifyVtbl* lpVtbl;
};
HRESULT mal_IDirectSoundNotify_QueryInterface(mal_IDirectSoundNotify* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
ULONG   mal_IDirectSoundNotify_AddRef(mal_IDirectSoundNotify* pThis)                                                 { return pThis->lpVtbl->AddRef(pThis); }
ULONG   mal_IDirectSoundNotify_Release(mal_IDirectSoundNotify* pThis)                                                { return pThis->lpVtbl->Release(pThis); }
HRESULT mal_IDirectSoundNotify_SetNotificationPositions(mal_IDirectSoundNotify* pThis, DWORD dwPositionNotifies, const MAL_DSBPOSITIONNOTIFY* pPositionNotifies) { return pThis->lpVtbl->SetNotificationPositions(pThis, dwPositionNotifies, pPositionNotifies); }


typedef BOOL    (CALLBACK * mal_DSEnumCallbackAProc)             (LPGUID pDeviceGUID, LPCSTR pDeviceDescription, LPCSTR pModule, LPVOID pContext);
typedef HRESULT (WINAPI   * mal_DirectSoundCreateProc)           (const GUID* pcGuidDevice, mal_IDirectSound** ppDS8, LPUNKNOWN pUnkOuter);
typedef HRESULT (WINAPI   * mal_DirectSoundEnumerateAProc)       (mal_DSEnumCallbackAProc pDSEnumCallback, LPVOID pContext);
typedef HRESULT (WINAPI   * mal_DirectSoundCaptureCreateProc)    (const GUID* pcGuidDevice, mal_IDirectSoundCapture** ppDSC8, LPUNKNOWN pUnkOuter);
typedef HRESULT (WINAPI   * mal_DirectSoundCaptureEnumerateAProc)(mal_DSEnumCallbackAProc pDSEnumCallback, LPVOID pContext);


// Retrieves the channel count and channel map for the given speaker configuration. If the speaker configuration is unknown,
// the channel count and channel map will be left unmodified.
void mal_get_channels_from_speaker_config__dsound(DWORD speakerConfig, WORD* pChannelsOut, DWORD* pChannelMapOut)
{
    WORD channels = 0;
    if (pChannelsOut != NULL) {
        channels = *pChannelsOut;
    }

    DWORD channelMap = 0;
    if (pChannelMapOut != NULL) {
        channelMap = *pChannelMapOut;
    }

    // The speaker configuration is a combination of speaker config and speaker geometry. The lower 8 bits is what we care about. The upper
    // 16 bits is for the geometry.
    switch ((BYTE)(speakerConfig)) {
        case 1 /*DSSPEAKER_HEADPHONE*/:                          channels = 2; channelMap = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT; break;
        case 2 /*DSSPEAKER_MONO*/:                               channels = 1; channelMap = SPEAKER_FRONT_CENTER; break;
        case 3 /*DSSPEAKER_QUAD*/:                               channels = 4; channelMap = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT; break;
        case 4 /*DSSPEAKER_STEREO*/:                             channels = 2; channelMap = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT; break;
        case 5 /*DSSPEAKER_SURROUND*/:                           channels = 4; channelMap = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_BACK_CENTER; break;
        case 6 /*DSSPEAKER_5POINT1_BACK*/ /*DSSPEAKER_5POINT1*/: channels = 6; channelMap = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT; break;
        case 7 /*DSSPEAKER_7POINT1_WIDE*/ /*DSSPEAKER_7POINT1*/: channels = 8; channelMap = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT | SPEAKER_FRONT_LEFT_OF_CENTER | SPEAKER_FRONT_RIGHT_OF_CENTER; break;
        case 8 /*DSSPEAKER_7POINT1_SURROUND*/:                   channels = 8; channelMap = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT | SPEAKER_SIDE_LEFT | SPEAKER_SIDE_RIGHT; break;
        case 9 /*DSSPEAKER_5POINT1_SURROUND*/:                   channels = 6; channelMap = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | SPEAKER_SIDE_LEFT | SPEAKER_SIDE_RIGHT; break;
        default: break;
    }

    if (pChannelsOut != NULL) {
        *pChannelsOut = channels;
    }

    if (pChannelMapOut != NULL) {
        *pChannelMapOut = channelMap;
    }
}


mal_result mal_context_create_IDirectSound__dsound(mal_context* pContext, mal_share_mode shareMode, const mal_device_id* pDeviceID, mal_IDirectSound** ppDirectSound)
{
    mal_assert(pContext != NULL);
    mal_assert(ppDirectSound != NULL);

    *ppDirectSound = NULL;
    mal_IDirectSound* pDirectSound = NULL;

    if (FAILED(((mal_DirectSoundCreateProc)pContext->dsound.DirectSoundCreate)((pDeviceID == NULL) ? NULL : (const GUID*)pDeviceID->dsound, &pDirectSound, NULL))) {
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[DirectSound] DirectSoundCreate() failed for playback device.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
    }

    // The cooperative level must be set before doing anything else.
    HWND hWnd = ((MAL_PFN_GetForegroundWindow)pContext->win32.GetForegroundWindow)();
    if (hWnd == NULL) {
        hWnd = ((MAL_PFN_GetDesktopWindow)pContext->win32.GetDesktopWindow)();
    }
    if (FAILED(mal_IDirectSound_SetCooperativeLevel(pDirectSound, hWnd, (shareMode == mal_share_mode_exclusive) ? MAL_DSSCL_EXCLUSIVE : MAL_DSSCL_PRIORITY))) {
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[DirectSound] IDirectSound_SetCooperateiveLevel() failed for playback device.", MAL_SHARE_MODE_NOT_SUPPORTED);
    }

    *ppDirectSound = pDirectSound;
    return MAL_SUCCESS;
}

mal_result mal_context_create_IDirectSoundCapture__dsound(mal_context* pContext, mal_share_mode shareMode, const mal_device_id* pDeviceID, mal_IDirectSoundCapture** ppDirectSoundCapture)
{
    mal_assert(pContext != NULL);
    mal_assert(ppDirectSoundCapture != NULL);

    /* DirectSound does not support exclusive mode for capture. */
    if (shareMode == mal_share_mode_exclusive) {
        return MAL_SHARE_MODE_NOT_SUPPORTED;
    }

    *ppDirectSoundCapture = NULL;
    mal_IDirectSoundCapture* pDirectSoundCapture = NULL;

    if (FAILED(((mal_DirectSoundCaptureCreateProc)pContext->dsound.DirectSoundCaptureCreate)((pDeviceID == NULL) ? NULL : (const GUID*)pDeviceID->dsound, &pDirectSoundCapture, NULL))) {
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[DirectSound] DirectSoundCaptureCreate() failed for capture device.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
    }

    *ppDirectSoundCapture = pDirectSoundCapture;
    return MAL_SUCCESS;
}

mal_result mal_context_get_format_info_for_IDirectSoundCapture__dsound(mal_context* pContext, mal_IDirectSoundCapture* pDirectSoundCapture, WORD* pChannels, WORD* pBitsPerSample, DWORD* pSampleRate)
{
    mal_assert(pContext != NULL);
    mal_assert(pDirectSoundCapture != NULL);

    if (pChannels) {
        *pChannels = 0;
    }
    if (pBitsPerSample) {
        *pBitsPerSample = 0;
    }
    if (pSampleRate) {
        *pSampleRate = 0;
    }

    MAL_DSCCAPS caps;
    mal_zero_object(&caps);
    caps.dwSize = sizeof(caps);
    if (FAILED(mal_IDirectSoundCapture_GetCaps(pDirectSoundCapture, &caps))) {
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundCapture_GetCaps() failed for capture device.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
    }

    if (pChannels) {
        *pChannels = (WORD)caps.dwChannels;
    }

    // The device can support multiple formats. We just go through the different formats in order of priority and
    // pick the first one. This the same type of system as the WinMM backend.
    WORD bitsPerSample = 16;
    DWORD sampleRate = 48000;

    if (caps.dwChannels == 1) {
        if ((caps.dwFormats & WAVE_FORMAT_48M16) != 0) {
            sampleRate = 48000;
        } else if ((caps.dwFormats & WAVE_FORMAT_44M16) != 0) {
            sampleRate = 44100;
        } else if ((caps.dwFormats & WAVE_FORMAT_2M16) != 0) {
            sampleRate = 22050;
        } else if ((caps.dwFormats & WAVE_FORMAT_1M16) != 0) {
            sampleRate = 11025;
        } else if ((caps.dwFormats & WAVE_FORMAT_96M16) != 0) {
            sampleRate = 96000;
        } else {
            bitsPerSample = 8;
            if ((caps.dwFormats & WAVE_FORMAT_48M08) != 0) {
                sampleRate = 48000;
            } else if ((caps.dwFormats & WAVE_FORMAT_44M08) != 0) {
                sampleRate = 44100;
            } else if ((caps.dwFormats & WAVE_FORMAT_2M08) != 0) {
                sampleRate = 22050;
            } else if ((caps.dwFormats & WAVE_FORMAT_1M08) != 0) {
                sampleRate = 11025;
            } else if ((caps.dwFormats & WAVE_FORMAT_96M08) != 0) {
                sampleRate = 96000;
            } else {
                bitsPerSample = 16;  // Didn't find it. Just fall back to 16-bit.
            }
        }
    } else if (caps.dwChannels == 2) {
        if ((caps.dwFormats & WAVE_FORMAT_48S16) != 0) {
            sampleRate = 48000;
        } else if ((caps.dwFormats & WAVE_FORMAT_44S16) != 0) {
            sampleRate = 44100;
        } else if ((caps.dwFormats & WAVE_FORMAT_2S16) != 0) {
            sampleRate = 22050;
        } else if ((caps.dwFormats & WAVE_FORMAT_1S16) != 0) {
            sampleRate = 11025;
        } else if ((caps.dwFormats & WAVE_FORMAT_96S16) != 0) {
            sampleRate = 96000;
        } else {
            bitsPerSample = 8;
            if ((caps.dwFormats & WAVE_FORMAT_48S08) != 0) {
                sampleRate = 48000;
            } else if ((caps.dwFormats & WAVE_FORMAT_44S08) != 0) {
                sampleRate = 44100;
            } else if ((caps.dwFormats & WAVE_FORMAT_2S08) != 0) {
                sampleRate = 22050;
            } else if ((caps.dwFormats & WAVE_FORMAT_1S08) != 0) {
                sampleRate = 11025;
            } else if ((caps.dwFormats & WAVE_FORMAT_96S08) != 0) {
                sampleRate = 96000;
            } else {
                bitsPerSample = 16;  // Didn't find it. Just fall back to 16-bit.
            }
        }
    }

    if (pBitsPerSample) {
        *pBitsPerSample = bitsPerSample;
    }
    if (pSampleRate) {
        *pSampleRate = sampleRate;
    }

    return MAL_SUCCESS;
}

mal_bool32 mal_context_is_device_id_equal__dsound(mal_context* pContext, const mal_device_id* pID0, const mal_device_id* pID1)
{
    mal_assert(pContext != NULL);
    mal_assert(pID0 != NULL);
    mal_assert(pID1 != NULL);
    (void)pContext;

    return memcmp(pID0->dsound, pID1->dsound, sizeof(pID0->dsound)) == 0;
}


typedef struct
{
    mal_context* pContext;
    mal_device_type deviceType;
    mal_enum_devices_callback_proc callback;
    void* pUserData;
    mal_bool32 terminated;
} mal_context_enumerate_devices_callback_data__dsound;

BOOL CALLBACK mal_context_enumerate_devices_callback__dsound(LPGUID lpGuid, LPCSTR lpcstrDescription, LPCSTR lpcstrModule, LPVOID lpContext)
{
    (void)lpcstrModule;

    mal_context_enumerate_devices_callback_data__dsound* pData = (mal_context_enumerate_devices_callback_data__dsound*)lpContext;
    mal_assert(pData != NULL);

    mal_device_info deviceInfo;
    mal_zero_object(&deviceInfo);

    // ID.
    if (lpGuid != NULL) {
        mal_copy_memory(deviceInfo.id.dsound, lpGuid, 16);
    } else {
        mal_zero_memory(deviceInfo.id.dsound, 16);
    }

    // Name / Description
    mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), lpcstrDescription, (size_t)-1);


    // Call the callback function, but make sure we stop enumerating if the callee requested so.
    pData->terminated = !pData->callback(pData->pContext, pData->deviceType, &deviceInfo, pData->pUserData);
    if (pData->terminated) {
        return FALSE;   // Stop enumeration.
    } else {
        return TRUE;    // Continue enumeration.
    }
}

mal_result mal_context_enumerate_devices__dsound(mal_context* pContext, mal_enum_devices_callback_proc callback, void* pUserData)
{
    mal_assert(pContext != NULL);
    mal_assert(callback != NULL);

    mal_context_enumerate_devices_callback_data__dsound data;
    data.pContext = pContext;
    data.callback = callback;
    data.pUserData = pUserData;
    data.terminated = MAL_FALSE;

    // Playback.
    if (!data.terminated) {
        data.deviceType = mal_device_type_playback;
        ((mal_DirectSoundEnumerateAProc)pContext->dsound.DirectSoundEnumerateA)(mal_context_enumerate_devices_callback__dsound, &data);
    }

    // Capture.
    if (!data.terminated) {
        data.deviceType = mal_device_type_capture;
        ((mal_DirectSoundCaptureEnumerateAProc)pContext->dsound.DirectSoundCaptureEnumerateA)(mal_context_enumerate_devices_callback__dsound, &data);
    }

    return MAL_SUCCESS;
}


typedef struct
{
    const mal_device_id* pDeviceID;
    mal_device_info* pDeviceInfo;
    mal_bool32 found;
} mal_context_get_device_info_callback_data__dsound;

BOOL CALLBACK mal_context_get_device_info_callback__dsound(LPGUID lpGuid, LPCSTR lpcstrDescription, LPCSTR lpcstrModule, LPVOID lpContext)
{
    (void)lpcstrModule;

    mal_context_get_device_info_callback_data__dsound* pData = (mal_context_get_device_info_callback_data__dsound*)lpContext;
    mal_assert(pData != NULL);

    if ((pData->pDeviceID == NULL || mal_is_guid_equal(pData->pDeviceID->dsound, &MAL_GUID_NULL)) && (lpGuid == NULL || mal_is_guid_equal(lpGuid, &MAL_GUID_NULL))) {
        // Default device.
        mal_strncpy_s(pData->pDeviceInfo->name, sizeof(pData->pDeviceInfo->name), lpcstrDescription, (size_t)-1);
        pData->found = MAL_TRUE;
        return FALSE;   // Stop enumeration.
    } else {
        // Not the default device.
        if (lpGuid != NULL) {
            if (memcmp(pData->pDeviceID->dsound, lpGuid, sizeof(pData->pDeviceID->dsound)) == 0) {
                mal_strncpy_s(pData->pDeviceInfo->name, sizeof(pData->pDeviceInfo->name), lpcstrDescription, (size_t)-1);
                pData->found = MAL_TRUE;
                return FALSE;   // Stop enumeration.
            }
        }
    }

    return TRUE;
}

mal_result mal_context_get_device_info__dsound(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, mal_device_info* pDeviceInfo)
{
    /* Exclusive mode and capture not supported with DirectSound. */
    if (deviceType == mal_device_type_capture && shareMode == mal_share_mode_exclusive) {
        return MAL_SHARE_MODE_NOT_SUPPORTED;
    }

    if (pDeviceID != NULL) {
        // ID.
        mal_copy_memory(pDeviceInfo->id.dsound, pDeviceID->dsound, 16);

        // Name / Description. This is retrieved by enumerating over each device until we find that one that matches the input ID.
        mal_context_get_device_info_callback_data__dsound data;
        data.pDeviceID = pDeviceID;
        data.pDeviceInfo = pDeviceInfo;
        data.found = MAL_FALSE;
        if (deviceType == mal_device_type_playback) {
            ((mal_DirectSoundEnumerateAProc)pContext->dsound.DirectSoundEnumerateA)(mal_context_get_device_info_callback__dsound, &data);
        } else {
            ((mal_DirectSoundCaptureEnumerateAProc)pContext->dsound.DirectSoundCaptureEnumerateA)(mal_context_get_device_info_callback__dsound, &data);
        }

        if (!data.found) {
            return MAL_NO_DEVICE;
        }
    } else {
        // I don't think there's a way to get the name of the default device with DirectSound. In this case we just need to use defaults.

        // ID
        mal_zero_memory(pDeviceInfo->id.dsound, 16);

        // Name / Description/
        if (deviceType == mal_device_type_playback) {
            mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MAL_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
        } else {
            mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MAL_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
        }
    }

    // Retrieving detailed information is slightly different depending on the device type.
    if (deviceType == mal_device_type_playback) {
        // Playback.
        mal_IDirectSound* pDirectSound;
        mal_result result = mal_context_create_IDirectSound__dsound(pContext, shareMode, pDeviceID, &pDirectSound);
        if (result != MAL_SUCCESS) {
            return result;
        }

        MAL_DSCAPS caps;
        mal_zero_object(&caps);
        caps.dwSize = sizeof(caps);
        if (FAILED(mal_IDirectSound_GetCaps(pDirectSound, &caps))) {
            return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[DirectSound] IDirectSound_GetCaps() failed for playback device.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        if ((caps.dwFlags & MAL_DSCAPS_PRIMARYSTEREO) != 0) {
            // It supports at least stereo, but could support more.
            WORD channels = 2;

            // Look at the speaker configuration to get a better idea on the channel count.
            DWORD speakerConfig;
            if (SUCCEEDED(mal_IDirectSound_GetSpeakerConfig(pDirectSound, &speakerConfig))) {
                mal_get_channels_from_speaker_config__dsound(speakerConfig, &channels, NULL);
            }

            pDeviceInfo->minChannels = channels;
            pDeviceInfo->maxChannels = channels;
        } else {
            // It does not support stereo, which means we are stuck with mono.
            pDeviceInfo->minChannels = 1;
            pDeviceInfo->maxChannels = 1;
        }

        // Sample rate.
        if ((caps.dwFlags & MAL_DSCAPS_CONTINUOUSRATE) != 0) {
            pDeviceInfo->minSampleRate = caps.dwMinSecondarySampleRate;
            pDeviceInfo->maxSampleRate = caps.dwMaxSecondarySampleRate;

            // On my machine the min and max sample rates can return 100 and 200000 respectively. I'd rather these be within
            // the range of our standard sample rates so I'm clamping.
            if (caps.dwMinSecondarySampleRate < MAL_MIN_SAMPLE_RATE && caps.dwMaxSecondarySampleRate >= MAL_MIN_SAMPLE_RATE) {
                pDeviceInfo->minSampleRate = MAL_MIN_SAMPLE_RATE;
            }
            if (caps.dwMaxSecondarySampleRate > MAL_MAX_SAMPLE_RATE && caps.dwMinSecondarySampleRate <= MAL_MAX_SAMPLE_RATE) {
                pDeviceInfo->maxSampleRate = MAL_MAX_SAMPLE_RATE;
            }
        } else {
            // Only supports a single sample rate. Set both min an max to the same thing. Do not clamp within the standard rates.
            pDeviceInfo->minSampleRate = caps.dwMaxSecondarySampleRate;
            pDeviceInfo->maxSampleRate = caps.dwMaxSecondarySampleRate;
        }

        // DirectSound can support all formats.
        pDeviceInfo->formatCount = mal_format_count - 1;    // Minus one because we don't want to include mal_format_unknown.
        for (mal_uint32 iFormat = 0; iFormat < pDeviceInfo->formatCount; ++iFormat) {
            pDeviceInfo->formats[iFormat] = (mal_format)(iFormat + 1);  // +1 to skip over mal_format_unknown.
        }

        mal_IDirectSound_Release(pDirectSound);
    } else {
        // Capture. This is a little different to playback due to the say the supported formats are reported. Technically capture
        // devices can support a number of different formats, but for simplicity and consistency with mal_device_init() I'm just
        // reporting the best format.
        mal_IDirectSoundCapture* pDirectSoundCapture;
        mal_result result = mal_context_create_IDirectSoundCapture__dsound(pContext, shareMode, pDeviceID, &pDirectSoundCapture);
        if (result != MAL_SUCCESS) {
            return result;
        }

        WORD channels;
        WORD bitsPerSample;
        DWORD sampleRate;
        result = mal_context_get_format_info_for_IDirectSoundCapture__dsound(pContext, pDirectSoundCapture, &channels, &bitsPerSample, &sampleRate);
        if (result != MAL_SUCCESS) {
            mal_IDirectSoundCapture_Release(pDirectSoundCapture);
            return result;
        }

        pDeviceInfo->minChannels = channels;
        pDeviceInfo->maxChannels = channels;
        pDeviceInfo->minSampleRate = sampleRate;
        pDeviceInfo->maxSampleRate = sampleRate;
        pDeviceInfo->formatCount = 1;
        if (bitsPerSample == 8) {
            pDeviceInfo->formats[0] = mal_format_u8;
        } else if (bitsPerSample == 16) {
            pDeviceInfo->formats[0] = mal_format_s16;
        } else if (bitsPerSample == 24) {
            pDeviceInfo->formats[0] = mal_format_s24;
        } else if (bitsPerSample == 32) {
            pDeviceInfo->formats[0] = mal_format_s32;
        } else {
            mal_IDirectSoundCapture_Release(pDirectSoundCapture);
            return MAL_FORMAT_NOT_SUPPORTED;
        }

        mal_IDirectSoundCapture_Release(pDirectSoundCapture);
    }

    return MAL_SUCCESS;
}


typedef struct
{
    mal_uint32 deviceCount;
    mal_uint32 infoCount;
    mal_device_info* pInfo;
} mal_device_enum_data__dsound;

BOOL CALLBACK mal_enum_devices_callback__dsound(LPGUID lpGuid, LPCSTR lpcstrDescription, LPCSTR lpcstrModule, LPVOID lpContext)
{
    (void)lpcstrModule;

    mal_device_enum_data__dsound* pData = (mal_device_enum_data__dsound*)lpContext;
    mal_assert(pData != NULL);

    if (pData->pInfo != NULL) {
        if (pData->infoCount > 0) {
            mal_zero_object(pData->pInfo);
            mal_strncpy_s(pData->pInfo->name, sizeof(pData->pInfo->name), lpcstrDescription, (size_t)-1);

            if (lpGuid != NULL) {
                mal_copy_memory(pData->pInfo->id.dsound, lpGuid, 16);
            } else {
                mal_zero_memory(pData->pInfo->id.dsound, 16);
            }

            pData->pInfo += 1;
            pData->infoCount -= 1;
            pData->deviceCount += 1;
        }
    } else {
        pData->deviceCount += 1;
    }

    return TRUE;
}

void mal_device_uninit__dsound(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (pDevice->dsound.pCaptureBuffer != NULL) {
        mal_IDirectSoundCaptureBuffer_Release((mal_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer);
    }
    if (pDevice->dsound.pCapture != NULL) {
        mal_IDirectSoundCapture_Release((mal_IDirectSoundCapture*)pDevice->dsound.pCapture);
    }

    if (pDevice->dsound.pPlaybackBuffer != NULL) {
        mal_IDirectSoundBuffer_Release((mal_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer);
    }
    if (pDevice->dsound.pPlaybackPrimaryBuffer != NULL) {
        mal_IDirectSoundBuffer_Release((mal_IDirectSoundBuffer*)pDevice->dsound.pPlaybackPrimaryBuffer);
    }
    if (pDevice->dsound.pPlayback != NULL) {
        mal_IDirectSound_Release((mal_IDirectSound*)pDevice->dsound.pPlayback);
    }
}

mal_result mal_config_to_WAVEFORMATEXTENSIBLE(mal_format format, mal_uint32 channels, mal_uint32 sampleRate, const mal_channel* pChannelMap, WAVEFORMATEXTENSIBLE* pWF)
{
    GUID subformat;
    switch (format)
    {
        case mal_format_u8:
        case mal_format_s16:
        case mal_format_s24:
        //case mal_format_s24_32:
        case mal_format_s32:
        {
            subformat = MAL_GUID_KSDATAFORMAT_SUBTYPE_PCM;
        } break;

        case mal_format_f32:
        {
            subformat = MAL_GUID_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
        } break;

        default:
        return MAL_FORMAT_NOT_SUPPORTED;
    }

    mal_zero_object(pWF);
    pWF->Format.cbSize               = sizeof(*pWF);
    pWF->Format.wFormatTag           = WAVE_FORMAT_EXTENSIBLE;
    pWF->Format.nChannels            = (WORD)channels;
    pWF->Format.nSamplesPerSec       = (DWORD)sampleRate;
    pWF->Format.wBitsPerSample       = (WORD)mal_get_bytes_per_sample(format)*8;
    pWF->Format.nBlockAlign          = (pWF->Format.nChannels * pWF->Format.wBitsPerSample) / 8;
    pWF->Format.nAvgBytesPerSec      = pWF->Format.nBlockAlign * pWF->Format.nSamplesPerSec;
    pWF->Samples.wValidBitsPerSample = pWF->Format.wBitsPerSample;
    pWF->dwChannelMask               = mal_channel_map_to_channel_mask__win32(pChannelMap, channels);
    pWF->SubFormat                   = subformat;

    return MAL_SUCCESS;
}

mal_result mal_device_init__dsound(mal_context* pContext, const mal_device_config* pConfig, mal_device* pDevice)
{
    mal_result result;

    (void)pContext;

    mal_assert(pDevice != NULL);
    mal_zero_object(&pDevice->dsound);

    mal_uint32 bufferSizeInMilliseconds = pConfig->bufferSizeInMilliseconds;
    if (bufferSizeInMilliseconds == 0) {
        bufferSizeInMilliseconds = mal_calculate_buffer_size_in_milliseconds_from_frames(pConfig->bufferSizeInFrames, pConfig->sampleRate);
    }
    
    /* DirectSound should use a latency of about 20ms per period for low latency mode. */
    if (pDevice->usingDefaultBufferSize) {
        if (pConfig->performanceProfile == mal_performance_profile_low_latency) {
            bufferSizeInMilliseconds =  20 * pConfig->periods;
        } else {
            bufferSizeInMilliseconds = 200 * pConfig->periods;
        }
    }


    // Unfortunately DirectSound uses different APIs and data structures for playback and catpure devices. We need to initialize
    // the capture device first because we'll want to match it's buffer size and period count on the playback side if we're using
    // full-duplex mode.
    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        WAVEFORMATEXTENSIBLE wf;
        result = mal_config_to_WAVEFORMATEXTENSIBLE(pConfig->capture.format, pConfig->capture.channels, pConfig->sampleRate, pConfig->capture.channelMap, &wf);
        if (result != MAL_SUCCESS) {
            return result;
        }

        result = mal_context_create_IDirectSoundCapture__dsound(pContext, pConfig->capture.shareMode, pConfig->capture.pDeviceID, (mal_IDirectSoundCapture**)&pDevice->dsound.pCapture);
        if (result != MAL_SUCCESS) {
            mal_device_uninit__dsound(pDevice);
            return result;
        }

        result = mal_context_get_format_info_for_IDirectSoundCapture__dsound(pContext, (mal_IDirectSoundCapture*)pDevice->dsound.pCapture, &wf.Format.nChannels, &wf.Format.wBitsPerSample, &wf.Format.nSamplesPerSec);
        if (result != MAL_SUCCESS) {
            mal_device_uninit__dsound(pDevice);
            return result;
        }

        wf.Format.nBlockAlign          = (wf.Format.nChannels * wf.Format.wBitsPerSample) / 8;
        wf.Format.nAvgBytesPerSec      = wf.Format.nBlockAlign * wf.Format.nSamplesPerSec;
        wf.Samples.wValidBitsPerSample = wf.Format.wBitsPerSample;
        wf.SubFormat                   = MAL_GUID_KSDATAFORMAT_SUBTYPE_PCM;

        /* The size of the buffer must be a clean multiple of the period count. */
        mal_uint32 bufferSizeInFrames = (mal_calculate_buffer_size_in_frames_from_milliseconds(bufferSizeInMilliseconds, wf.Format.nSamplesPerSec) / pConfig->periods) * pConfig->periods;

        MAL_DSCBUFFERDESC descDS;
        mal_zero_object(&descDS);
        descDS.dwSize = sizeof(descDS);
        descDS.dwFlags = 0;
        descDS.dwBufferBytes = bufferSizeInFrames * mal_get_bytes_per_frame(pDevice->capture.internalFormat, wf.Format.nChannels);
        descDS.lpwfxFormat = (WAVEFORMATEX*)&wf;
        if (FAILED(mal_IDirectSoundCapture_CreateCaptureBuffer((mal_IDirectSoundCapture*)pDevice->dsound.pCapture, &descDS, (mal_IDirectSoundCaptureBuffer**)&pDevice->dsound.pCaptureBuffer, NULL))) {
            mal_device_uninit__dsound(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundCapture_CreateCaptureBuffer() failed for capture device.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        // Get the _actual_ properties of the buffer.
        char rawdata[1024];
        WAVEFORMATEXTENSIBLE* pActualFormat = (WAVEFORMATEXTENSIBLE*)rawdata;
        if (FAILED(mal_IDirectSoundCaptureBuffer_GetFormat((mal_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, (WAVEFORMATEX*)pActualFormat, sizeof(rawdata), NULL))) {
            mal_device_uninit__dsound(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Failed to retrieve the actual format of the capture device's buffer.", MAL_FORMAT_NOT_SUPPORTED);
        }

        pDevice->capture.internalFormat = mal_format_from_WAVEFORMATEX((WAVEFORMATEX*)pActualFormat);
        pDevice->capture.internalChannels = pActualFormat->Format.nChannels;
        pDevice->capture.internalSampleRate = pActualFormat->Format.nSamplesPerSec;

        // Get the internal channel map based on the channel mask.
        if (pActualFormat->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
            mal_channel_mask_to_channel_map__win32(pActualFormat->dwChannelMask, pDevice->capture.internalChannels, pDevice->capture.internalChannelMap);
        } else {
            mal_channel_mask_to_channel_map__win32(wf.dwChannelMask, pDevice->capture.internalChannels, pDevice->capture.internalChannelMap);
        }

        /*
        After getting the actual format the size of the buffer in frames may have actually changed. However, we want this to be as close to what the
        user has asked for as possible, so let's go ahead and release the old capture buffer and create a new one in this case.
        */
        if (bufferSizeInFrames != (descDS.dwBufferBytes / mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels))) {
            descDS.dwBufferBytes = bufferSizeInFrames * mal_get_bytes_per_frame(pDevice->capture.internalFormat, wf.Format.nChannels);
            mal_IDirectSoundCaptureBuffer_Release((mal_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer);

            if (FAILED(mal_IDirectSoundCapture_CreateCaptureBuffer((mal_IDirectSoundCapture*)pDevice->dsound.pCapture, &descDS, (mal_IDirectSoundCaptureBuffer**)&pDevice->dsound.pCaptureBuffer, NULL))) {
                mal_device_uninit__dsound(pDevice);
                return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Second attempt at IDirectSoundCapture_CreateCaptureBuffer() failed for capture device.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
            }
        }

        /* DirectSound should give us a buffer exactly the size we asked for. */
        pDevice->capture.internalBufferSizeInFrames = bufferSizeInFrames;
        pDevice->capture.internalPeriods            = pConfig->periods;
    }

    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        WAVEFORMATEXTENSIBLE wf;
        result = mal_config_to_WAVEFORMATEXTENSIBLE(pConfig->playback.format, pConfig->playback.channels, pConfig->sampleRate, pConfig->playback.channelMap, &wf);
        if (result != MAL_SUCCESS) {
            return result;
        }

        result = mal_context_create_IDirectSound__dsound(pContext, pConfig->playback.shareMode, pConfig->playback.pDeviceID, (mal_IDirectSound**)&pDevice->dsound.pPlayback);
        if (result != MAL_SUCCESS) {
            mal_device_uninit__dsound(pDevice);
            return result;
        }

        MAL_DSBUFFERDESC descDSPrimary;
        mal_zero_object(&descDSPrimary);
        descDSPrimary.dwSize  = sizeof(MAL_DSBUFFERDESC);
        descDSPrimary.dwFlags = MAL_DSBCAPS_PRIMARYBUFFER | MAL_DSBCAPS_CTRLVOLUME;
        if (FAILED(mal_IDirectSound_CreateSoundBuffer((mal_IDirectSound*)pDevice->dsound.pPlayback, &descDSPrimary, (mal_IDirectSoundBuffer**)&pDevice->dsound.pPlaybackPrimaryBuffer, NULL))) {
            mal_device_uninit__dsound(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] IDirectSound_CreateSoundBuffer() failed for playback device's primary buffer.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }


        // We may want to make some adjustments to the format if we are using defaults.
        MAL_DSCAPS caps;
        mal_zero_object(&caps);
        caps.dwSize = sizeof(caps);
        if (FAILED(mal_IDirectSound_GetCaps((mal_IDirectSound*)pDevice->dsound.pPlayback, &caps))) {
            mal_device_uninit__dsound(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] IDirectSound_GetCaps() failed for playback device.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        if (pDevice->playback.usingDefaultChannels) {
            if ((caps.dwFlags & MAL_DSCAPS_PRIMARYSTEREO) != 0) {
                // It supports at least stereo, but could support more.
                wf.Format.nChannels = 2;

                // Look at the speaker configuration to get a better idea on the channel count.
                DWORD speakerConfig;
                if (SUCCEEDED(mal_IDirectSound_GetSpeakerConfig((mal_IDirectSound*)pDevice->dsound.pPlayback, &speakerConfig))) {
                    mal_get_channels_from_speaker_config__dsound(speakerConfig, &wf.Format.nChannels, &wf.dwChannelMask);
                }
            } else {
                // It does not support stereo, which means we are stuck with mono.
                wf.Format.nChannels = 1;
            }
        }

        if (pDevice->usingDefaultSampleRate) {
            // We base the sample rate on the values returned by GetCaps().
            if ((caps.dwFlags & MAL_DSCAPS_CONTINUOUSRATE) != 0) {
                wf.Format.nSamplesPerSec = mal_get_best_sample_rate_within_range(caps.dwMinSecondarySampleRate, caps.dwMaxSecondarySampleRate);
            } else {
                wf.Format.nSamplesPerSec = caps.dwMaxSecondarySampleRate;
            }
        }

        wf.Format.nBlockAlign     = (wf.Format.nChannels * wf.Format.wBitsPerSample) / 8;
        wf.Format.nAvgBytesPerSec = wf.Format.nBlockAlign * wf.Format.nSamplesPerSec;

        // From MSDN:
        //
        // The method succeeds even if the hardware does not support the requested format; DirectSound sets the buffer to the closest
        // supported format. To determine whether this has happened, an application can call the GetFormat method for the primary buffer
        // and compare the result with the format that was requested with the SetFormat method.
        if (FAILED(mal_IDirectSoundBuffer_SetFormat((mal_IDirectSoundBuffer*)pDevice->dsound.pPlaybackPrimaryBuffer, (WAVEFORMATEX*)&wf))) {
            mal_device_uninit__dsound(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Failed to set format of playback device's primary buffer.", MAL_FORMAT_NOT_SUPPORTED);
        }

        // Get the _actual_ properties of the buffer.
        char rawdata[1024];
        WAVEFORMATEXTENSIBLE* pActualFormat = (WAVEFORMATEXTENSIBLE*)rawdata;
        if (FAILED(mal_IDirectSoundBuffer_GetFormat((mal_IDirectSoundBuffer*)pDevice->dsound.pPlaybackPrimaryBuffer, (WAVEFORMATEX*)pActualFormat, sizeof(rawdata), NULL))) {
            mal_device_uninit__dsound(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Failed to retrieve the actual format of the playback device's primary buffer.", MAL_FORMAT_NOT_SUPPORTED);
        }

        pDevice->playback.internalFormat = mal_format_from_WAVEFORMATEX((WAVEFORMATEX*)pActualFormat);
        pDevice->playback.internalChannels = pActualFormat->Format.nChannels;
        pDevice->playback.internalSampleRate = pActualFormat->Format.nSamplesPerSec;

        // Get the internal channel map based on the channel mask.
        if (pActualFormat->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
            mal_channel_mask_to_channel_map__win32(pActualFormat->dwChannelMask, pDevice->playback.internalChannels, pDevice->playback.internalChannelMap);
        } else {
            mal_channel_mask_to_channel_map__win32(wf.dwChannelMask, pDevice->playback.internalChannels, pDevice->playback.internalChannelMap);
        }

        /* The size of the buffer must be a clean multiple of the period count. */
        mal_uint32 bufferSizeInFrames = (mal_calculate_buffer_size_in_frames_from_milliseconds(bufferSizeInMilliseconds, pDevice->playback.internalSampleRate) / pConfig->periods) * pConfig->periods;

        // Meaning of dwFlags (from MSDN):
        //
        // DSBCAPS_CTRLPOSITIONNOTIFY
        //   The buffer has position notification capability.
        //
        // DSBCAPS_GLOBALFOCUS
        //   With this flag set, an application using DirectSound can continue to play its buffers if the user switches focus to
        //   another application, even if the new application uses DirectSound.
        //
        // DSBCAPS_GETCURRENTPOSITION2
        //   In the first version of DirectSound, the play cursor was significantly ahead of the actual playing sound on emulated
        //   sound cards; it was directly behind the write cursor. Now, if the DSBCAPS_GETCURRENTPOSITION2 flag is specified, the
        //   application can get a more accurate play cursor.
        MAL_DSBUFFERDESC descDS;
        mal_zero_object(&descDS);
        descDS.dwSize = sizeof(descDS);
        descDS.dwFlags = MAL_DSBCAPS_CTRLPOSITIONNOTIFY | MAL_DSBCAPS_GLOBALFOCUS | MAL_DSBCAPS_GETCURRENTPOSITION2;
        descDS.dwBufferBytes = bufferSizeInFrames * mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
        descDS.lpwfxFormat = (WAVEFORMATEX*)&wf;
        if (FAILED(mal_IDirectSound_CreateSoundBuffer((mal_IDirectSound*)pDevice->dsound.pPlayback, &descDS, (mal_IDirectSoundBuffer**)&pDevice->dsound.pPlaybackBuffer, NULL))) {
            mal_device_uninit__dsound(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] IDirectSound_CreateSoundBuffer() failed for playback device's secondary buffer.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        /* DirectSound should give us a buffer exactly the size we asked for. */
        pDevice->playback.internalBufferSizeInFrames = bufferSizeInFrames;
        pDevice->playback.internalPeriods            = pConfig->periods;
    }

    return MAL_SUCCESS;
}


mal_result mal_device_start__dsound(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        if (FAILED(mal_IDirectSoundCaptureBuffer_Start((mal_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, MAL_DSCBSTART_LOOPING))) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundCaptureBuffer_Start() failed.", MAL_FAILED_TO_START_BACKEND_DEVICE);
        }
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        if (FAILED(mal_IDirectSoundBuffer_Play((mal_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, 0, 0, MAL_DSBPLAY_LOOPING))) {
            mal_IDirectSoundCaptureBuffer_Stop((mal_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundBuffer_Play() failed.", MAL_FAILED_TO_START_BACKEND_DEVICE);
        }
    }

    mal_atomic_exchange_32(&pDevice->dsound.isStarted, MAL_TRUE);
    return MAL_SUCCESS;
}

mal_result mal_device_stop__dsound(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (!pDevice->dsound.isStarted) {
        return MAL_DEVICE_NOT_STARTED;
    }

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        if (FAILED(mal_IDirectSoundCaptureBuffer_Stop((mal_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer))) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundCaptureBuffer_Stop() failed.", MAL_FAILED_TO_STOP_BACKEND_DEVICE);
        }
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        if (FAILED(mal_IDirectSoundBuffer_Stop((mal_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer))) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundBuffer_Stop() failed.", MAL_FAILED_TO_STOP_BACKEND_DEVICE);
        }
    }

    mal_atomic_exchange_32(&pDevice->dsound.isStarted, MAL_FALSE);
    return MAL_SUCCESS;
}

mal_result mal_device_get_current_frame__dsound(mal_device* pDevice, mal_device_type deviceType, mal_uint32* pCurrentPos)
{
    mal_assert(pDevice != NULL);
    mal_assert(pCurrentPos != NULL);
    mal_assert(deviceType != mal_device_type_duplex);   /* This function should never be called with a duplex device type. */

    *pCurrentPos = 0;

    DWORD dwCurrentPosition;
    if (deviceType == mal_device_type_playback) {
        if (FAILED(mal_IDirectSoundBuffer_GetCurrentPosition((mal_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, NULL, &dwCurrentPosition))) {
            return MAL_ERROR;
        }
        *pCurrentPos = (mal_uint32)dwCurrentPosition / mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
    } else {
        if (FAILED(mal_IDirectSoundCaptureBuffer_GetCurrentPosition((mal_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, NULL, &dwCurrentPosition))) {
            return MAL_ERROR;
        }
        *pCurrentPos = (mal_uint32)dwCurrentPosition / mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
    }
    
    return MAL_SUCCESS;
}

mal_result mal_device_map_next_playback_buffer__dsound(mal_device* pDevice)
{
    DWORD periodSizeInBytes = (pDevice->playback.internalBufferSizeInFrames / pDevice->playback.internalPeriods) * mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
    DWORD lockOffset = (pDevice->dsound.iNextPeriodPlayback * periodSizeInBytes);
    DWORD lockSizeInBytes = periodSizeInBytes;
    DWORD mappedSizeInBytes;
    HRESULT hr = mal_IDirectSoundBuffer_Lock((mal_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, lockOffset, lockSizeInBytes, &pDevice->dsound.pMappedBufferPlayback, &mappedSizeInBytes, NULL, NULL, 0);
    if (FAILED(hr)) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Failed to map buffer from playback device in preparation for writing to the device.", MAL_FAILED_TO_MAP_DEVICE_BUFFER);
    }

    pDevice->dsound.mappedBufferFramesCapacityPlayback  = (mal_uint32)mappedSizeInBytes / mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
    pDevice->dsound.mappedBufferFramesRemainingPlayback = (mal_uint32)mappedSizeInBytes / mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);

    //printf("TRACE 1: Playback: iNextPeriod=%d, internalBufferSizeInFrames=%d, periodSizeInBytes=%d, mappedSizeInBytes=%d\n", pDevice->dsound.iNextPeriodPlayback, pDevice->playback.internalBufferSizeInFrames, periodSizeInBytes, mappedSizeInBytes);

    return MAL_SUCCESS;
}

mal_result mal_device_write__dsound(mal_device* pDevice, const void* pPCMFrames, mal_uint32 frameCount)
{
    mal_result result = MAL_SUCCESS;
    mal_bool32 wasStartedOnEntry;
    mal_uint32 totalFramesWritten;
    HRESULT hr;

    mal_assert(pDevice != NULL);
    mal_assert(pPCMFrames != NULL);

    wasStartedOnEntry = pDevice->dsound.isStarted;

    /* If the device is not started we do not have a mapped buffer, we'll need to map the first period so we can fill it. */
    if (!pDevice->dsound.isStarted && pDevice->dsound.pMappedBufferPlayback == NULL) {
        result = mal_device_map_next_playback_buffer__dsound(pDevice);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    totalFramesWritten = 0;
    while (totalFramesWritten < frameCount) {
        /* If a buffer is mapped we need to write to that first. Once it's consumed we reset the event and unmap it. */
        if (pDevice->dsound.pMappedBufferPlayback != NULL && pDevice->dsound.mappedBufferFramesRemainingPlayback > 0) {
            mal_uint32 bpf = mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
            mal_uint32 mappedBufferFramesConsumed = pDevice->dsound.mappedBufferFramesCapacityPlayback - pDevice->dsound.mappedBufferFramesRemainingPlayback;

            void* pDst = (mal_uint8*)pDevice->dsound.pMappedBufferPlayback + (mappedBufferFramesConsumed * bpf);
            const void* pSrc = (const mal_uint8*)pPCMFrames + (totalFramesWritten * bpf);
            mal_uint32  framesToCopy = mal_min(pDevice->dsound.mappedBufferFramesRemainingPlayback, (frameCount - totalFramesWritten));
            mal_copy_memory(pDst, pSrc, framesToCopy * bpf);

            pDevice->dsound.mappedBufferFramesRemainingPlayback -= framesToCopy;
            totalFramesWritten += framesToCopy;
        }

        /* Getting here means we've consumed the device buffer and need to wait for more to become available. */
        if (pDevice->dsound.mappedBufferFramesCapacityPlayback > 0 && pDevice->dsound.mappedBufferFramesRemainingPlayback == 0) {
            hr = mal_IDirectSoundBuffer_Unlock((mal_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, pDevice->dsound.pMappedBufferPlayback, pDevice->dsound.mappedBufferFramesCapacityPlayback, NULL, 0);
            pDevice->dsound.pMappedBufferPlayback = NULL;
            pDevice->dsound.mappedBufferFramesRemainingPlayback = 0;
            pDevice->dsound.mappedBufferFramesCapacityPlayback = 0;
            pDevice->dsound.iNextPeriodPlayback = (pDevice->dsound.iNextPeriodPlayback + 1) % pDevice->playback.internalPeriods;

            if (FAILED(hr)) {
                result = MAL_FAILED_TO_UNMAP_DEVICE_BUFFER;
                mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Failed to unlock internal buffer from playback device after writing to the device.", result);
                break;
            }

            if (!pDevice->dsound.isStarted && !wasStartedOnEntry) {
                result = mal_device_start__dsound(pDevice);
                if (result != MAL_SUCCESS) {
                    break;
                }
            }
        }

        mal_assert(totalFramesWritten <= frameCount);
        if (totalFramesWritten == frameCount) {
            break;
        }

        /*
        Relying exclusively on the notification events turns out to be horribly slow. It looks like by the time the event is signaled, the cursor
        has already progressed way beyond the notification point. It's better to instead poll the position, only returning when a whole period is
        available.

        This loop just crudely sleeps for a bit and then queries the current position. If there's enough room for a whole period, we will fill it
        with data from the client. Otherwise we just wait a bit longer. It's crude, but it's simple and it works _much_ better than the notification
        system.
        */
        for (;;) {
            DWORD timeoutInMilliseconds = 1;
            mal_sleep((mal_uint32)timeoutInMilliseconds);

            /* We've woken up, so now we need to poll the current position. If there are enough frames for a whole period we can be done with the wait. */
            mal_uint32 currentPos;
            result = mal_device_get_current_frame__dsound(pDevice, mal_device_type_playback, &currentPos);
            if (result != MAL_SUCCESS) {
                break;  /* Failed to get the current frame. */
            }

            mal_uint32 periodSizeInFrames = pDevice->playback.internalBufferSizeInFrames / pDevice->playback.internalPeriods;
            if ((currentPos - (pDevice->dsound.iNextPeriodPlayback * periodSizeInFrames)) >= periodSizeInFrames) {
                break;  /* There's enough room. */
            }

            /* Don't keep waiting if the device has stopped. */
            if (!pDevice->dsound.isStarted && wasStartedOnEntry) {
                break;
            }
        }
        
        if (result != MAL_SUCCESS) {
            break;
        }

        /* If the device has been stopped don't continue. */
        if (!pDevice->dsound.isStarted && wasStartedOnEntry) {
            break;
        }

        /* Getting here means we can map the next period. */
        result = mal_device_map_next_playback_buffer__dsound(pDevice);
        if (result != MAL_SUCCESS) {
            mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Failed to map buffer from playback device in preparation for writing to the device.", result);
            break;
        }
    }

    return result;
}

mal_result mal_device_map_next_capture_buffer__dsound(mal_device* pDevice)
{
    DWORD periodSizeInBytes = (pDevice->capture.internalBufferSizeInFrames / pDevice->capture.internalPeriods) * mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
    DWORD lockOffset = (pDevice->dsound.iNextPeriodCapture * periodSizeInBytes);
    DWORD lockSizeInBytes = periodSizeInBytes;
    DWORD mappedSizeInBytes;
    HRESULT hr = mal_IDirectSoundCaptureBuffer_Lock((mal_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, lockOffset, lockSizeInBytes, &pDevice->dsound.pMappedBufferCapture, &mappedSizeInBytes, NULL, NULL, 0);
    if (FAILED(hr)) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Failed to map buffer from capture device in preparation for writing to the device.", MAL_FAILED_TO_MAP_DEVICE_BUFFER);
    }

    pDevice->dsound.mappedBufferFramesCapacityCapture  = (mal_uint32)mappedSizeInBytes / mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
    pDevice->dsound.mappedBufferFramesRemainingCapture = (mal_uint32)mappedSizeInBytes / mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);

    //printf("TRACE 1: Capture: internalBufferSizeInFrames=%d, periodSizeInBytes=%d, mappedSizeInBytes=%d\n", pDevice->capture.internalBufferSizeInFrames, periodSizeInBytes, mappedSizeInBytes);

    return MAL_SUCCESS;
}

mal_result mal_device_read__dsound(mal_device* pDevice, void* pPCMFrames, mal_uint32 frameCount)
{
    mal_result result = MAL_SUCCESS;
    mal_uint32 totalFramesRead;
    HRESULT hr;

    mal_assert(pDevice != NULL);
    mal_assert(pPCMFrames != NULL);

    /* The device needs to be started immediately if it's not already. */
    if (!pDevice->dsound.isStarted) {
        result = mal_device_start__dsound(pDevice);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    totalFramesRead = 0;
    while (totalFramesRead < frameCount) {
        /* If a buffer is mapped we need to write to that first. Once it's consumed we reset the event and unmap it. */
        if (pDevice->dsound.pMappedBufferCapture != NULL && pDevice->dsound.mappedBufferFramesRemainingCapture > 0) {
            mal_uint32 bpf = mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
            mal_uint32 mappedBufferFramesConsumed = pDevice->dsound.mappedBufferFramesCapacityCapture - pDevice->dsound.mappedBufferFramesRemainingCapture;

            void* pDst = (mal_uint8*)pPCMFrames + (totalFramesRead * bpf);
            const void* pSrc = (const mal_uint8*)pDevice->dsound.pMappedBufferCapture + (mappedBufferFramesConsumed * bpf);
            mal_uint32  framesToCopy = mal_min(pDevice->dsound.mappedBufferFramesRemainingCapture, (frameCount - totalFramesRead));
            mal_copy_memory(pDst, pSrc, framesToCopy * bpf);

            pDevice->dsound.mappedBufferFramesRemainingCapture -= framesToCopy;
            totalFramesRead += framesToCopy;
        }

        /* Getting here means we've consumed the device buffer and need to wait for more to become available. */
        if (pDevice->dsound.mappedBufferFramesCapacityCapture > 0 && pDevice->dsound.mappedBufferFramesRemainingCapture == 0) {
            hr = mal_IDirectSoundCaptureBuffer_Unlock((mal_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, pDevice->dsound.pMappedBufferCapture, pDevice->dsound.mappedBufferFramesCapacityCapture, NULL, 0);
            pDevice->dsound.pMappedBufferCapture = NULL;
            pDevice->dsound.mappedBufferFramesRemainingCapture = 0;
            pDevice->dsound.mappedBufferFramesCapacityCapture = 0;
            pDevice->dsound.iNextPeriodCapture = (pDevice->dsound.iNextPeriodCapture + 1) % pDevice->capture.internalPeriods;

            if (FAILED(hr)) {
                result = MAL_FAILED_TO_UNMAP_DEVICE_BUFFER;
                mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Failed to unlock internal buffer from capture device after reading from the device.", result);
                break;
            }
        }

        mal_assert(totalFramesRead <= frameCount);
        if (totalFramesRead == frameCount) {
            break;
        }

        /* Just like in the playback case we just use a simple wait-and-poll to know when a chunk of data is available. */
        for (;;) {
            DWORD timeoutInMilliseconds = 1;
            mal_sleep((mal_uint32)timeoutInMilliseconds);

            /* We've woken up, so now we need to poll the current position. If there are enough frames for a whole period we can be done with the wait. */
            mal_uint32 currentPos;
            result = mal_device_get_current_frame__dsound(pDevice, mal_device_type_capture, &currentPos);
            if (result != MAL_SUCCESS) {
                break;  /* Failed to get the current frame. */
            }

            //printf("TRACE: Capture Position: %d\n", (int)currentPos);

            mal_uint32 periodSizeInFrames = pDevice->capture.internalBufferSizeInFrames / pDevice->capture.internalPeriods;
            if ((currentPos - (pDevice->dsound.iNextPeriodCapture * periodSizeInFrames)) >= periodSizeInFrames) {
                break;  /* There's enough room. */
            }

            /* Don't keep waiting if the device has stopped. */
            if (!pDevice->dsound.isStarted) {
                break;
            }
        }

        if (result != MAL_SUCCESS) {
            break;
        }

        /* Don't keep waiting if the device has stopped. */
        if (!pDevice->dsound.isStarted) {
            break;
        }

        result = mal_device_map_next_capture_buffer__dsound(pDevice);
        if (result != MAL_SUCCESS) {
            mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Failed to map buffer from capture device in preparation for writing to the device.", result);
            break;
        }
    }

    return result;
}


mal_result mal_device_main_loop__dsound(mal_device* pDevice)
{
    mal_result result = MAL_SUCCESS;
    mal_uint32 currentFramePosCapture;
    //mal_uint32 currentFramePosPlayback;
    mal_uint32 prevFramePosCapture = 0;
    //mal_uint32 prevFramePosPlayback = 0;
    mal_uint32 bpfCapture  = mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
    mal_uint32 bpfPlayback = mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
    HRESULT hr;
    DWORD lockOffsetInBytesCapture;
    DWORD lockSizeInBytesCapture;
    DWORD mappedSizeInBytesCapture;
    void* pMappedBufferCapture;
    DWORD lockOffsetInBytesPlayback;
    DWORD lockSizeInBytesPlayback;
    DWORD mappedSizeInBytesPlayback;
    void* pMappedBufferPlayback;
    mal_bool32 isPlaybackDeviceStarted = MAL_FALSE;
    mal_uint32 framesWrittenToPlaybackDevice = 0;   /* For knowing whether or not the playback device needs to be started. */
    mal_uint32 waitTimeInMilliseconds = 1;

    DWORD prevPlayCursorInBytesPlayback = 0;
    //DWORD prevWriteCursorInBytesPlayback = 0;
    mal_bool32 physicalPlayCursorLoopFlagPlayback = 0;
    //mal_bool32 physicalWriteCursorLoopFlagPlayback = 0;
    
    //DWORD virtualPlayCursorInBytesPlayback = 0;
    DWORD virtualWriteCursorInBytesPlayback = 0;
    //mal_bool32 virtualPlayCursorLoopFlagPlayback = 0;
    mal_bool32 virtualWriteCursorLoopFlagPlayback = 0;

    DWORD prevReadCursorInBytesCapture = 0;

    mal_assert(pDevice != NULL);

    /* The first thing to do is start the capture device. The playback device is only started after the first period is written. */
    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        if (FAILED(mal_IDirectSoundCaptureBuffer_Start((mal_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, MAL_DSCBSTART_LOOPING))) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundCaptureBuffer_Start() failed.", MAL_FAILED_TO_START_BACKEND_DEVICE);
        }
    }
    
    while (mal_device__get_state(pDevice) == MAL_STATE_STARTED) {
        switch (pDevice->type)
        {
            case mal_device_type_duplex:
            {
                result = mal_device_get_current_frame__dsound(pDevice, mal_device_type_capture, &currentFramePosCapture);
                if (result != MAL_SUCCESS) {
                    return result;
                }

                /* If nothing is available we just sleep for a bit and return from this iteration. */
                if (currentFramePosCapture == prevFramePosCapture) {
                    mal_sleep(waitTimeInMilliseconds);
                    continue; /* Nothing is available in the capture buffer. */
                }

                /*
                The current position has moved. We need to map all of the captured samples and write them to the playback device, making sure
                we don't return until every frame has been copied over.
                */
                if (prevFramePosCapture < currentFramePosCapture) {
                    /* The capture position has not looped. This is the simple case. */
                    lockOffsetInBytesCapture = prevFramePosCapture * bpfCapture;
                    lockSizeInBytesCapture   = (currentFramePosCapture - prevFramePosCapture) * bpfCapture;
                } else {
                    /*
                    The capture position has looped. This is the more complex case. Map to the end of the buffer. If this does not return anything,
                    do it again from the start.
                    */
                    if (prevFramePosCapture < pDevice->capture.internalBufferSizeInFrames) {
                        /* Lock up to the end of the buffer. */
                        lockOffsetInBytesCapture = prevFramePosCapture * bpfCapture;
                        lockSizeInBytesCapture   = (pDevice->capture.internalBufferSizeInFrames - prevFramePosCapture) * bpfCapture;
                    } else {
                        /* Lock starting from the start of the buffer. */
                        lockOffsetInBytesCapture = 0;
                        lockSizeInBytesCapture   = currentFramePosCapture * bpfCapture;
                    }
                }

                if (lockSizeInBytesCapture == 0) {
                    mal_sleep(waitTimeInMilliseconds);
                    continue; /* Nothing is available in the capture buffer. */
                }

                hr = mal_IDirectSoundCaptureBuffer_Lock((mal_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, lockOffsetInBytesCapture, lockSizeInBytesCapture, &pMappedBufferCapture, &mappedSizeInBytesCapture, NULL, NULL, 0);
                if (FAILED(hr)) {
                    return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Failed to map buffer from capture device in preparation for writing to the device.", MAL_FAILED_TO_MAP_DEVICE_BUFFER);
                }


                /* At this point we have some input data that we need to output. We do not return until every mapped frame of the input data is written to the playback device. */
                pDevice->capture._dspFrameCount = mappedSizeInBytesCapture / bpfCapture;
                pDevice->capture._dspFrames     = (const mal_uint8*)pMappedBufferCapture;
                for (;;) {  /* Keep writing to the playback device. */
                    mal_uint8  inputFramesInExternalFormat[4096];
                    mal_uint32 inputFramesInExternalFormatCap = sizeof(inputFramesInExternalFormat) / mal_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels);
                    mal_uint32 inputFramesInExternalFormatCount;
                    mal_uint8  outputFramesInExternalFormat[4096];
                    mal_uint32 outputFramesInExternalFormatCap = sizeof(outputFramesInExternalFormat) / mal_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels);

                    inputFramesInExternalFormatCount = (mal_uint32)mal_pcm_converter_read(&pDevice->capture.converter, inputFramesInExternalFormat, mal_min(inputFramesInExternalFormatCap, outputFramesInExternalFormatCap));
                    if (inputFramesInExternalFormatCount == 0) {
                        break;  /* No more input data. */
                    }

                    pDevice->onData(pDevice, outputFramesInExternalFormat, inputFramesInExternalFormat, inputFramesInExternalFormatCount);

                    /* At this point we have input and output data in external format. All we need to do now is convert it to the output format. This may take a few passes. */
                    pDevice->playback._dspFrameCount = inputFramesInExternalFormatCount;
                    pDevice->playback._dspFrames     = (const mal_uint8*)outputFramesInExternalFormat;
                    for (;;) {
                        mal_uint32 framesWrittenThisIteration;
                        DWORD physicalPlayCursorInBytes;
                        DWORD physicalWriteCursorInBytes;
                        DWORD availableBytesPlayback;

                        /* We need the physical play and write cursors. */
                        if (FAILED(mal_IDirectSoundBuffer_GetCurrentPosition((mal_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, &physicalPlayCursorInBytes, &physicalWriteCursorInBytes))) {
                            break;
                        }

                        if (physicalPlayCursorInBytes < prevPlayCursorInBytesPlayback) {
                            physicalPlayCursorLoopFlagPlayback = !physicalPlayCursorLoopFlagPlayback;
                        }
                        //if (physicalWriteCursorInBytes < prevWriteCursorInBytesPlayback) {
                        //    physicalWriteCursorLoopFlagPlayback = !physicalWriteCursorLoopFlagPlayback;
                        //}

                        prevPlayCursorInBytesPlayback  = physicalPlayCursorInBytes;
                        //prevWriteCursorInBytesPlayback = physicalWriteCursorInBytes;

                        /* If there's any bytes available for writing we can do that now. The space between the virtual cursor position and play cursor. */
                        if (physicalPlayCursorLoopFlagPlayback == virtualWriteCursorLoopFlagPlayback) {
                            /* Same loop iteration. The available bytes wraps all the way around from the virtual write cursor to the physical play cursor. */
                            if (physicalPlayCursorInBytes <= virtualWriteCursorInBytesPlayback) {
                                availableBytesPlayback  = (pDevice->playback.internalBufferSizeInFrames*bpfPlayback) - virtualWriteCursorInBytesPlayback;
                                availableBytesPlayback += physicalPlayCursorInBytes;    /* Wrap around. */
                            } else {
                                /* This is an error. */
                            #ifdef MAL_DEBUG_OUTPUT
                                printf("[DirectSound] (Duplex/Playback) WARNING: Play cursor has moved in front of the write cursor (same loop iterations). physicalPlayCursorInBytes=%d, virtualWriteCursorInBytes=%d.\n", physicalPlayCursorInBytes, virtualWriteCursorInBytesPlayback);
                            #endif
                                availableBytesPlayback = 0;
                            }
                        } else {
                            /* Different loop iterations. The available bytes only goes from the virtual write cursor to the physical play cursor. */
                            if (physicalPlayCursorInBytes >= virtualWriteCursorInBytesPlayback) {
                                availableBytesPlayback = physicalPlayCursorInBytes - virtualWriteCursorInBytesPlayback;
                            } else {
                                /* This is an error. */
                            #ifdef MAL_DEBUG_OUTPUT
                                printf("[DirectSound] (Duplex/Playback) WARNING: Write cursor has moved behind the play cursor (different loop iterations). physicalPlayCursorInBytes=%d, virtualWriteCursorInBytes=%d.\n", physicalPlayCursorInBytes, virtualWriteCursorInBytesPlayback);
                            #endif
                                availableBytesPlayback = 0;
                            }
                        }

                    #ifdef MAL_DEBUG_OUTPUT
                        printf("[DirectSound] (Duplex/Playback) physicalPlayCursorInBytes=%d, availableBytesPlayback=%d\n", physicalPlayCursorInBytes, availableBytesPlayback);
                    #endif

                        /* If there's no room available for writing we need to wait for more. */
                        if (availableBytesPlayback < ((pDevice->playback.internalBufferSizeInFrames/pDevice->playback.internalPeriods)*bpfPlayback)) {
                            mal_sleep(waitTimeInMilliseconds);
                            continue;
                        }

                    #ifdef MAL_DEBUG_OUTPUT
                        if (isPlaybackDeviceStarted) {
                            if (availableBytesPlayback > (((pDevice->playback.internalBufferSizeInFrames/pDevice->playback.internalPeriods)*(pDevice->playback.internalPeriods-1)) * bpfPlayback)) {
                                printf("[DirectSound] (Duplex/Playback) Playback buffer starved. availableBytesPlayback=%d\n", availableBytesPlayback);
                            }
                        }
                    #endif


                        /* Getting here means there room available somewhere. We limit this to either the end of the buffer or the physical play cursor, whichever is closest. */
                        lockOffsetInBytesPlayback = virtualWriteCursorInBytesPlayback;
                        if (physicalPlayCursorLoopFlagPlayback == virtualWriteCursorLoopFlagPlayback) {
                            /* Same loop iteration. Go up to the end of the buffer. */
                            lockSizeInBytesPlayback = (pDevice->playback.internalBufferSizeInFrames*bpfPlayback) - virtualWriteCursorInBytesPlayback;
                        } else {
                            /* Different loop iterations. Go up to the physical play cursor. */
                            lockSizeInBytesPlayback = physicalPlayCursorInBytes - virtualWriteCursorInBytesPlayback;
                        }

                        hr = mal_IDirectSoundBuffer_Lock((mal_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, lockOffsetInBytesPlayback, lockSizeInBytesPlayback, &pMappedBufferPlayback, &mappedSizeInBytesPlayback, NULL, NULL, 0);
                        if (FAILED(hr)) {
                            result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Failed to map buffer from playback device in preparation for writing to the device.", MAL_FAILED_TO_MAP_DEVICE_BUFFER);
                            break;
                        }


                        /* At this point we have a buffer for output. */
                        framesWrittenThisIteration = (mal_uint32)mal_pcm_converter_read(&pDevice->playback.converter, pMappedBufferPlayback, mappedSizeInBytesPlayback/bpfPlayback);

                        hr = mal_IDirectSoundBuffer_Unlock((mal_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, pMappedBufferPlayback, framesWrittenThisIteration*bpfPlayback, NULL, 0);
                        if (FAILED(hr)) {
                            result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Failed to unlock internal buffer from playback device after writing to the device.", MAL_FAILED_TO_UNMAP_DEVICE_BUFFER);
                            break;
                        }

                        virtualWriteCursorInBytesPlayback += framesWrittenThisIteration*bpfPlayback;
                        if ((virtualWriteCursorInBytesPlayback/bpfPlayback) == pDevice->playback.internalBufferSizeInFrames) {
                            virtualWriteCursorInBytesPlayback  = 0;
                            virtualWriteCursorLoopFlagPlayback = !virtualWriteCursorLoopFlagPlayback;
                        }
                        
                        /*
                        We may need to start the device. We want two full periods to be written before starting the playback device. Having an extra period adds
                        a bit of a buffer to prevent the playback buffer from getting starved.
                        */
                        framesWrittenToPlaybackDevice += framesWrittenThisIteration;
                        if (!isPlaybackDeviceStarted && framesWrittenToPlaybackDevice >= ((pDevice->playback.internalBufferSizeInFrames/pDevice->playback.internalPeriods)*(pDevice->playback.internalPeriods-1))) {
                            if (FAILED(mal_IDirectSoundBuffer_Play((mal_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, 0, 0, MAL_DSBPLAY_LOOPING))) {
                                mal_IDirectSoundCaptureBuffer_Stop((mal_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer);
                                return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundBuffer_Play() failed.", MAL_FAILED_TO_START_BACKEND_DEVICE);
                            }
                            isPlaybackDeviceStarted = MAL_TRUE;
                        }

                        if (framesWrittenThisIteration < mappedSizeInBytesPlayback/bpfPlayback) {
                            break;  /* We're finished with the output data.*/
                        }
                    }

                    if (inputFramesInExternalFormatCount < inputFramesInExternalFormatCap) {
                        break;  /* We just consumed every input sample. */
                    }
                }


                /* At this point we're done with the mapped portion of the capture buffer. */
                hr = mal_IDirectSoundCaptureBuffer_Unlock((mal_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, pMappedBufferCapture, mappedSizeInBytesCapture, NULL, 0);
                if (FAILED(hr)) {
                    return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Failed to unlock internal buffer from capture device after reading from the device.", MAL_FAILED_TO_UNMAP_DEVICE_BUFFER);
                }
                prevFramePosCapture = (lockOffsetInBytesCapture + mappedSizeInBytesCapture) / bpfCapture;
            } break;



            case mal_device_type_capture:
            {
                DWORD physicalCaptureCursorInBytes;
                DWORD physicalReadCursorInBytes;
                if (FAILED(mal_IDirectSoundCaptureBuffer_GetCurrentPosition((mal_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, &physicalCaptureCursorInBytes, &physicalReadCursorInBytes))) {
                    return MAL_ERROR;
                }

                /* If the previous capture position is the same as the current position we need to wait a bit longer. */
                if (prevReadCursorInBytesCapture == physicalReadCursorInBytes) {
                    mal_sleep(waitTimeInMilliseconds);
                    continue;
                }

                /* Getting here means we have capture data available. */
                if (prevReadCursorInBytesCapture < physicalReadCursorInBytes) {
                    /* The capture position has not looped. This is the simple case. */
                    lockOffsetInBytesCapture = prevReadCursorInBytesCapture;
                    lockSizeInBytesCapture   = (physicalReadCursorInBytes - prevReadCursorInBytesCapture);
                } else {
                    /*
                    The capture position has looped. This is the more complex case. Map to the end of the buffer. If this does not return anything,
                    do it again from the start.
                    */
                    if (prevReadCursorInBytesCapture < pDevice->capture.internalBufferSizeInFrames*bpfCapture) {
                        /* Lock up to the end of the buffer. */
                        lockOffsetInBytesCapture = prevReadCursorInBytesCapture;
                        lockSizeInBytesCapture   = (pDevice->capture.internalBufferSizeInFrames*bpfCapture) - prevReadCursorInBytesCapture;
                    } else {
                        /* Lock starting from the start of the buffer. */
                        lockOffsetInBytesCapture = 0;
                        lockSizeInBytesCapture   = physicalReadCursorInBytes;
                    }
                }

            #ifdef MAL_DEBUG_OUTPUT
                //printf("[DirectSound] (Capture) physicalCaptureCursorInBytes=%d, physicalReadCursorInBytes=%d\n", physicalCaptureCursorInBytes, physicalReadCursorInBytes);
                //printf("[DirectSound] (Capture) lockOffsetInBytesCapture=%d, lockSizeInBytesCapture=%d\n", lockOffsetInBytesCapture, lockSizeInBytesCapture);
            #endif

                if (lockSizeInBytesCapture == 0) {
                    mal_sleep(waitTimeInMilliseconds);
                    continue; /* Nothing is available in the capture buffer. */
                }

                hr = mal_IDirectSoundCaptureBuffer_Lock((mal_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, lockOffsetInBytesCapture, lockSizeInBytesCapture, &pMappedBufferCapture, &mappedSizeInBytesCapture, NULL, NULL, 0);
                if (FAILED(hr)) {
                    return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Failed to map buffer from capture device in preparation for writing to the device.", MAL_FAILED_TO_MAP_DEVICE_BUFFER);
                }

            #ifdef MAL_DEBUG_OUTPUT
                if (lockSizeInBytesCapture != mappedSizeInBytesCapture) {
                    printf("[DirectSound] (Capture) lockSizeInBytesCapture=%d != mappedSizeInBytesCapture=%d\n", lockSizeInBytesCapture, mappedSizeInBytesCapture);
                }
            #endif

                /* Optimization: If we are running as a passthrough we can pass the mapped pointer to the callback directly. */
                if (pDevice->capture.converter.isPassthrough) {
                    /* Passthrough. */
                    pDevice->onData(pDevice, NULL, pMappedBufferCapture, mappedSizeInBytesCapture/bpfCapture);
                } else {
                    /* Not a passthrough. */
                    mal_device__send_frames_to_client(pDevice, mappedSizeInBytesCapture/bpfCapture, pMappedBufferCapture);
                }

                hr = mal_IDirectSoundCaptureBuffer_Unlock((mal_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, pMappedBufferCapture, mappedSizeInBytesCapture, NULL, 0);
                if (FAILED(hr)) {
                    return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Failed to unlock internal buffer from capture device after reading from the device.", MAL_FAILED_TO_UNMAP_DEVICE_BUFFER);
                }
                prevReadCursorInBytesCapture = lockOffsetInBytesCapture + mappedSizeInBytesCapture;

                if (prevReadCursorInBytesCapture == (pDevice->capture.internalBufferSizeInFrames*bpfCapture)) {
                    prevReadCursorInBytesCapture = 0;
                }
            } break;



            case mal_device_type_playback:
            {
                DWORD availableBytesPlayback;
                DWORD physicalPlayCursorInBytes;
                DWORD physicalWriteCursorInBytes;
                if (FAILED(mal_IDirectSoundBuffer_GetCurrentPosition((mal_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, &physicalPlayCursorInBytes, &physicalWriteCursorInBytes))) {
                    break;
                }

                if (physicalPlayCursorInBytes < prevPlayCursorInBytesPlayback) {
                    physicalPlayCursorLoopFlagPlayback = !physicalPlayCursorLoopFlagPlayback;
                }
                prevPlayCursorInBytesPlayback  = physicalPlayCursorInBytes;

                /* If there's any bytes available for writing we can do that now. The space between the virtual cursor position and play cursor. */
                if (physicalPlayCursorLoopFlagPlayback == virtualWriteCursorLoopFlagPlayback) {
                    /* Same loop iteration. The available bytes wraps all the way around from the virtual write cursor to the physical play cursor. */
                    if (physicalPlayCursorInBytes <= virtualWriteCursorInBytesPlayback) {
                        availableBytesPlayback  = (pDevice->playback.internalBufferSizeInFrames*bpfPlayback) - virtualWriteCursorInBytesPlayback;
                        availableBytesPlayback += physicalPlayCursorInBytes;    /* Wrap around. */
                    } else {
                        /* This is an error. */
                    #ifdef MAL_DEBUG_OUTPUT
                        printf("[DirectSound] (Playback) WARNING: Play cursor has moved in front of the write cursor (same loop iterations). physicalPlayCursorInBytes=%d, virtualWriteCursorInBytes=%d.\n", physicalPlayCursorInBytes, virtualWriteCursorInBytesPlayback);
                    #endif
                        availableBytesPlayback = 0;
                    }
                } else {
                    /* Different loop iterations. The available bytes only goes from the virtual write cursor to the physical play cursor. */
                    if (physicalPlayCursorInBytes >= virtualWriteCursorInBytesPlayback) {
                        availableBytesPlayback = physicalPlayCursorInBytes - virtualWriteCursorInBytesPlayback;
                    } else {
                        /* This is an error. */
                    #ifdef MAL_DEBUG_OUTPUT
                        printf("[DirectSound] (Playback) WARNING: Write cursor has moved behind the play cursor (different loop iterations). physicalPlayCursorInBytes=%d, virtualWriteCursorInBytes=%d.\n", physicalPlayCursorInBytes, virtualWriteCursorInBytesPlayback);
                    #endif
                        availableBytesPlayback = 0;
                    }
                }

            #ifdef MAL_DEBUG_OUTPUT
                printf("[DirectSound] (Playback) physicalPlayCursorInBytes=%d, availableBytesPlayback=%d\n", physicalPlayCursorInBytes, availableBytesPlayback);
            #endif

                /* If there's no room available for writing we need to wait for more. */
                if (availableBytesPlayback == 0) {
                    mal_sleep(waitTimeInMilliseconds);
                    continue;
                }

                /* Getting here means there room available somewhere. We limit this to either the end of the buffer or the physical play cursor, whichever is closest. */
                lockOffsetInBytesPlayback = virtualWriteCursorInBytesPlayback;
                if (physicalPlayCursorLoopFlagPlayback == virtualWriteCursorLoopFlagPlayback) {
                    /* Same loop iteration. Go up to the end of the buffer. */
                    lockSizeInBytesPlayback = (pDevice->playback.internalBufferSizeInFrames*bpfPlayback) - virtualWriteCursorInBytesPlayback;
                } else {
                    /* Different loop iterations. Go up to the physical play cursor. */
                    lockSizeInBytesPlayback = physicalPlayCursorInBytes - virtualWriteCursorInBytesPlayback;
                }

                hr = mal_IDirectSoundBuffer_Lock((mal_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, lockOffsetInBytesPlayback, lockSizeInBytesPlayback, &pMappedBufferPlayback, &mappedSizeInBytesPlayback, NULL, NULL, 0);
                if (FAILED(hr)) {
                    result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Failed to map buffer from playback device in preparation for writing to the device.", MAL_FAILED_TO_MAP_DEVICE_BUFFER);
                    break;
                }

                /*
                At this point we have a buffer for output. If we don't need to do any data conversion we can pass the mapped pointer to the buffer directly. Otherwise
                we need to convert the data.
                */
                if (pDevice->playback.converter.isPassthrough) {
                    /* Passthrough. */
                    pDevice->onData(pDevice, pMappedBufferPlayback, NULL, (mappedSizeInBytesPlayback/bpfPlayback));
                } else {
                    /* Conversion. */
                    mal_device__read_frames_from_client(pDevice, (mappedSizeInBytesPlayback/bpfPlayback), pMappedBufferPlayback);
                }

                hr = mal_IDirectSoundBuffer_Unlock((mal_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, pMappedBufferPlayback, mappedSizeInBytesPlayback, NULL, 0);
                if (FAILED(hr)) {
                    result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] Failed to unlock internal buffer from playback device after writing to the device.", MAL_FAILED_TO_UNMAP_DEVICE_BUFFER);
                    break;
                }

                virtualWriteCursorInBytesPlayback += mappedSizeInBytesPlayback;
                if (virtualWriteCursorInBytesPlayback == pDevice->playback.internalBufferSizeInFrames*bpfPlayback) {
                    virtualWriteCursorInBytesPlayback  = 0;
                    virtualWriteCursorLoopFlagPlayback = !virtualWriteCursorLoopFlagPlayback;
                }
                        
                /*
                We may need to start the device. We want two full periods to be written before starting the playback device. Having an extra period adds
                a bit of a buffer to prevent the playback buffer from getting starved.
                */
                framesWrittenToPlaybackDevice += mappedSizeInBytesPlayback/bpfPlayback;
                if (!isPlaybackDeviceStarted && framesWrittenToPlaybackDevice >= (pDevice->playback.internalBufferSizeInFrames/pDevice->playback.internalPeriods)) {
                    if (FAILED(mal_IDirectSoundBuffer_Play((mal_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, 0, 0, MAL_DSBPLAY_LOOPING))) {
                        mal_IDirectSoundCaptureBuffer_Stop((mal_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer);
                        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundBuffer_Play() failed.", MAL_FAILED_TO_START_BACKEND_DEVICE);
                    }
                    isPlaybackDeviceStarted = MAL_TRUE;
                }
            } break;


            default: return MAL_INVALID_ARGS;   /* Invalid device type. */
        }

        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    /* Getting here means the device is being stopped. */

    /* The playback device should be drained before stopping. */
    if (isPlaybackDeviceStarted) {
        /* TODO: Drain the playback device. */
    }

    return MAL_SUCCESS;
}

mal_result mal_context_uninit__dsound(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    mal_assert(pContext->backend == mal_backend_dsound);

    mal_dlclose(pContext->dsound.hDSoundDLL);

    return MAL_SUCCESS;
}

mal_result mal_context_init__dsound(mal_context* pContext)
{
    mal_assert(pContext != NULL);

    pContext->dsound.hDSoundDLL = mal_dlopen("dsound.dll");
    if (pContext->dsound.hDSoundDLL == NULL) {
        return MAL_API_NOT_FOUND;
    }

    pContext->dsound.DirectSoundCreate            = mal_dlsym(pContext->dsound.hDSoundDLL, "DirectSoundCreate");
    pContext->dsound.DirectSoundEnumerateA        = mal_dlsym(pContext->dsound.hDSoundDLL, "DirectSoundEnumerateA");
    pContext->dsound.DirectSoundCaptureCreate     = mal_dlsym(pContext->dsound.hDSoundDLL, "DirectSoundCaptureCreate");
    pContext->dsound.DirectSoundCaptureEnumerateA = mal_dlsym(pContext->dsound.hDSoundDLL, "DirectSoundCaptureEnumerateA");

    pContext->onUninit         = mal_context_uninit__dsound;
    pContext->onDeviceIDEqual  = mal_context_is_device_id_equal__dsound;
    pContext->onEnumDevices    = mal_context_enumerate_devices__dsound;
    pContext->onGetDeviceInfo  = mal_context_get_device_info__dsound;
    pContext->onDeviceInit     = mal_device_init__dsound;
    pContext->onDeviceUninit   = mal_device_uninit__dsound;
    pContext->onDeviceStart    = NULL; /* Not used. Started in onDeviceWrite/onDeviceRead. */
    pContext->onDeviceStop     = mal_device_stop__dsound;
    pContext->onDeviceWrite    = mal_device_write__dsound;
    pContext->onDeviceRead     = mal_device_read__dsound;
    pContext->onDeviceMainLoop = mal_device_main_loop__dsound;

    return MAL_SUCCESS;
}
#endif



///////////////////////////////////////////////////////////////////////////////
//
// WinMM Backend
//
///////////////////////////////////////////////////////////////////////////////
#ifdef MAL_HAS_WINMM

// Some older compilers don't have WAVEOUTCAPS2A and WAVEINCAPS2A, so we'll need to write this ourselves. These structures
// are exactly the same as the older ones but they have a few GUIDs for manufacturer/product/name identification. I'm keeping
// the names the same as the Win32 library for consistency, but namespaced to avoid naming conflicts with the Win32 version.
typedef struct
{
    WORD wMid;
    WORD wPid;
    MMVERSION vDriverVersion;
    CHAR szPname[MAXPNAMELEN];
    DWORD dwFormats;
    WORD wChannels;
    WORD wReserved1;
    DWORD dwSupport;
    GUID ManufacturerGuid;
    GUID ProductGuid;
    GUID NameGuid;
} MAL_WAVEOUTCAPS2A;
typedef struct
{
    WORD wMid;
    WORD wPid;
    MMVERSION vDriverVersion;
    CHAR szPname[MAXPNAMELEN];
    DWORD dwFormats;
    WORD wChannels;
    WORD wReserved1;
    GUID ManufacturerGuid;
    GUID ProductGuid;
    GUID NameGuid;
} MAL_WAVEINCAPS2A;

typedef UINT     (WINAPI * MAL_PFN_waveOutGetNumDevs)(void);
typedef MMRESULT (WINAPI * MAL_PFN_waveOutGetDevCapsA)(mal_uintptr uDeviceID, LPWAVEOUTCAPSA pwoc, UINT cbwoc);
typedef MMRESULT (WINAPI * MAL_PFN_waveOutOpen)(LPHWAVEOUT phwo, UINT uDeviceID, LPCWAVEFORMATEX pwfx, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen);
typedef MMRESULT (WINAPI * MAL_PFN_waveOutClose)(HWAVEOUT hwo);
typedef MMRESULT (WINAPI * MAL_PFN_waveOutPrepareHeader)(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
typedef MMRESULT (WINAPI * MAL_PFN_waveOutUnprepareHeader)(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
typedef MMRESULT (WINAPI * MAL_PFN_waveOutWrite)(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
typedef MMRESULT (WINAPI * MAL_PFN_waveOutReset)(HWAVEOUT hwo);
typedef UINT     (WINAPI * MAL_PFN_waveInGetNumDevs)(void);
typedef MMRESULT (WINAPI * MAL_PFN_waveInGetDevCapsA)(mal_uintptr uDeviceID, LPWAVEINCAPSA pwic, UINT cbwic);
typedef MMRESULT (WINAPI * MAL_PFN_waveInOpen)(LPHWAVEIN phwi, UINT uDeviceID, LPCWAVEFORMATEX pwfx, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen);
typedef MMRESULT (WINAPI * MAL_PFN_waveInClose)(HWAVEIN hwi);
typedef MMRESULT (WINAPI * MAL_PFN_waveInPrepareHeader)(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
typedef MMRESULT (WINAPI * MAL_PFN_waveInUnprepareHeader)(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
typedef MMRESULT (WINAPI * MAL_PFN_waveInAddBuffer)(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
typedef MMRESULT (WINAPI * MAL_PFN_waveInStart)(HWAVEIN hwi);
typedef MMRESULT (WINAPI * MAL_PFN_waveInReset)(HWAVEIN hwi);

mal_result mal_result_from_MMRESULT(MMRESULT resultMM)
{
    switch (resultMM) {
        case MMSYSERR_NOERROR:      return MAL_SUCCESS;
        case MMSYSERR_BADDEVICEID:  return MAL_INVALID_ARGS;
        case MMSYSERR_INVALHANDLE:  return MAL_INVALID_ARGS;
        case MMSYSERR_NOMEM:        return MAL_OUT_OF_MEMORY;
        case MMSYSERR_INVALFLAG:    return MAL_INVALID_ARGS;
        case MMSYSERR_INVALPARAM:   return MAL_INVALID_ARGS;
        case MMSYSERR_HANDLEBUSY:   return MAL_DEVICE_BUSY;
        case MMSYSERR_ERROR:        return MAL_ERROR;
        default:                    return MAL_ERROR;
    }
}

char* mal_find_last_character(char* str, char ch)
{
    if (str == NULL) {
        return NULL;
    }

    char* last = NULL;
    while (*str != '\0') {
        if (*str == ch) {
            last = str;
        }

        str += 1;
    }

    return last;
}


// Our own "WAVECAPS" structure that contains generic information shared between WAVEOUTCAPS2 and WAVEINCAPS2 so
// we can do things generically and typesafely. Names are being kept the same for consistency.
typedef struct
{
    CHAR szPname[MAXPNAMELEN];
    DWORD dwFormats;
    WORD wChannels;
    GUID NameGuid;
} MAL_WAVECAPSA;

mal_result mal_get_best_info_from_formats_flags__winmm(DWORD dwFormats, WORD channels, WORD* pBitsPerSample, DWORD* pSampleRate)
{
    if (pBitsPerSample) {
        *pBitsPerSample = 0;
    }
    if (pSampleRate) {
        *pSampleRate = 0;
    }

    WORD bitsPerSample = 0;
    DWORD sampleRate = 0;

    if (channels == 1) {
        bitsPerSample = 16;
        if ((dwFormats & WAVE_FORMAT_48M16) != 0) {
            sampleRate = 48000;
        } else if ((dwFormats & WAVE_FORMAT_44M16) != 0) {
            sampleRate = 44100;
        } else if ((dwFormats & WAVE_FORMAT_2M16) != 0) {
            sampleRate = 22050;
        } else if ((dwFormats & WAVE_FORMAT_1M16) != 0) {
            sampleRate = 11025;
        } else if ((dwFormats & WAVE_FORMAT_96M16) != 0) {
            sampleRate = 96000;
        } else {
            bitsPerSample = 8;
            if ((dwFormats & WAVE_FORMAT_48M08) != 0) {
                sampleRate = 48000;
            } else if ((dwFormats & WAVE_FORMAT_44M08) != 0) {
                sampleRate = 44100;
            } else if ((dwFormats & WAVE_FORMAT_2M08) != 0) {
                sampleRate = 22050;
            } else if ((dwFormats & WAVE_FORMAT_1M08) != 0) {
                sampleRate = 11025;
            } else if ((dwFormats & WAVE_FORMAT_96M08) != 0) {
                sampleRate = 96000;
            } else {
                return MAL_FORMAT_NOT_SUPPORTED;
            }
        }
    } else {
        bitsPerSample = 16;
        if ((dwFormats & WAVE_FORMAT_48S16) != 0) {
            sampleRate = 48000;
        } else if ((dwFormats & WAVE_FORMAT_44S16) != 0) {
            sampleRate = 44100;
        } else if ((dwFormats & WAVE_FORMAT_2S16) != 0) {
            sampleRate = 22050;
        } else if ((dwFormats & WAVE_FORMAT_1S16) != 0) {
            sampleRate = 11025;
        } else if ((dwFormats & WAVE_FORMAT_96S16) != 0) {
            sampleRate = 96000;
        } else {
            bitsPerSample = 8;
            if ((dwFormats & WAVE_FORMAT_48S08) != 0) {
                sampleRate = 48000;
            } else if ((dwFormats & WAVE_FORMAT_44S08) != 0) {
                sampleRate = 44100;
            } else if ((dwFormats & WAVE_FORMAT_2S08) != 0) {
                sampleRate = 22050;
            } else if ((dwFormats & WAVE_FORMAT_1S08) != 0) {
                sampleRate = 11025;
            } else if ((dwFormats & WAVE_FORMAT_96S08) != 0) {
                sampleRate = 96000;
            } else {
                return MAL_FORMAT_NOT_SUPPORTED;
            }
        }
    }

    if (pBitsPerSample) {
        *pBitsPerSample = bitsPerSample;
    }
    if (pSampleRate) {
        *pSampleRate = sampleRate;
    }

    return MAL_SUCCESS;
}

mal_result mal_formats_flags_to_WAVEFORMATEX__winmm(DWORD dwFormats, WORD channels, WAVEFORMATEX* pWF)
{
    mal_assert(pWF != NULL);

    mal_zero_object(pWF);
    pWF->cbSize     = sizeof(*pWF);
    pWF->wFormatTag = WAVE_FORMAT_PCM;
    pWF->nChannels  = (WORD)channels;
    if (pWF->nChannels > 2) {
        pWF->nChannels = 2;
    }

    if (channels == 1) {
        pWF->wBitsPerSample = 16;
        if ((dwFormats & WAVE_FORMAT_48M16) != 0) {
            pWF->nSamplesPerSec = 48000;
        } else if ((dwFormats & WAVE_FORMAT_44M16) != 0) {
            pWF->nSamplesPerSec = 44100;
        } else if ((dwFormats & WAVE_FORMAT_2M16) != 0) {
            pWF->nSamplesPerSec = 22050;
        } else if ((dwFormats & WAVE_FORMAT_1M16) != 0) {
            pWF->nSamplesPerSec = 11025;
        } else if ((dwFormats & WAVE_FORMAT_96M16) != 0) {
            pWF->nSamplesPerSec = 96000;
        } else {
            pWF->wBitsPerSample = 8;
            if ((dwFormats & WAVE_FORMAT_48M08) != 0) {
                pWF->nSamplesPerSec = 48000;
            } else if ((dwFormats & WAVE_FORMAT_44M08) != 0) {
                pWF->nSamplesPerSec = 44100;
            } else if ((dwFormats & WAVE_FORMAT_2M08) != 0) {
                pWF->nSamplesPerSec = 22050;
            } else if ((dwFormats & WAVE_FORMAT_1M08) != 0) {
                pWF->nSamplesPerSec = 11025;
            } else if ((dwFormats & WAVE_FORMAT_96M08) != 0) {
                pWF->nSamplesPerSec = 96000;
            } else {
                return MAL_FORMAT_NOT_SUPPORTED;
            }
        }
    } else {
        pWF->wBitsPerSample = 16;
        if ((dwFormats & WAVE_FORMAT_48S16) != 0) {
            pWF->nSamplesPerSec = 48000;
        } else if ((dwFormats & WAVE_FORMAT_44S16) != 0) {
            pWF->nSamplesPerSec = 44100;
        } else if ((dwFormats & WAVE_FORMAT_2S16) != 0) {
            pWF->nSamplesPerSec = 22050;
        } else if ((dwFormats & WAVE_FORMAT_1S16) != 0) {
            pWF->nSamplesPerSec = 11025;
        } else if ((dwFormats & WAVE_FORMAT_96S16) != 0) {
            pWF->nSamplesPerSec = 96000;
        } else {
            pWF->wBitsPerSample = 8;
            if ((dwFormats & WAVE_FORMAT_48S08) != 0) {
                pWF->nSamplesPerSec = 48000;
            } else if ((dwFormats & WAVE_FORMAT_44S08) != 0) {
                pWF->nSamplesPerSec = 44100;
            } else if ((dwFormats & WAVE_FORMAT_2S08) != 0) {
                pWF->nSamplesPerSec = 22050;
            } else if ((dwFormats & WAVE_FORMAT_1S08) != 0) {
                pWF->nSamplesPerSec = 11025;
            } else if ((dwFormats & WAVE_FORMAT_96S08) != 0) {
                pWF->nSamplesPerSec = 96000;
            } else {
                return MAL_FORMAT_NOT_SUPPORTED;
            }
        }
    }

    pWF->nBlockAlign     = (pWF->nChannels * pWF->wBitsPerSample) / 8;
    pWF->nAvgBytesPerSec = pWF->nBlockAlign * pWF->nSamplesPerSec;

    return MAL_SUCCESS;
}

mal_result mal_context_get_device_info_from_WAVECAPS(mal_context* pContext, MAL_WAVECAPSA* pCaps, mal_device_info* pDeviceInfo)
{
    mal_assert(pContext != NULL);
    mal_assert(pCaps != NULL);
    mal_assert(pDeviceInfo != NULL);

    // Name / Description
    //
    // Unfortunately the name specified in WAVE(OUT/IN)CAPS2 is limited to 31 characters. This results in an unprofessional looking
    // situation where the names of the devices are truncated. To help work around this, we need to look at the name GUID and try
    // looking in the registry for the full name. If we can't find it there, we need to just fall back to the default name.

    // Set the default to begin with.
    mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), pCaps->szPname, (size_t)-1);

    // Now try the registry. There's a few things to consider here:
    // - The name GUID can be null, in which we case we just need to stick to the original 31 characters.
    // - If the name GUID is not present in the registry we'll also need to stick to the original 31 characters.
    // - I like consistency, so I want the returned device names to be consistent with those returned by WASAPI and DirectSound. The
    //   problem, however is that WASAPI and DirectSound use "<component> (<name>)" format (such as "Speakers (High Definition Audio)"),
    //   but WinMM does not specificy the component name. From my admittedly limited testing, I've notice the component name seems to
    //   usually fit within the 31 characters of the fixed sized buffer, so what I'm going to do is parse that string for the component
    //   name, and then concatenate the name from the registry.
    if (!mal_is_guid_equal(&pCaps->NameGuid, &MAL_GUID_NULL)) {
        wchar_t guidStrW[256];
        if (((MAL_PFN_StringFromGUID2)pContext->win32.StringFromGUID2)(&pCaps->NameGuid, guidStrW, mal_countof(guidStrW)) > 0) {
            char guidStr[256];
            WideCharToMultiByte(CP_UTF8, 0, guidStrW, -1, guidStr, sizeof(guidStr), 0, FALSE);

            char keyStr[1024];
            mal_strcpy_s(keyStr, sizeof(keyStr), "SYSTEM\\CurrentControlSet\\Control\\MediaCategories\\");
            mal_strcat_s(keyStr, sizeof(keyStr), guidStr);

            HKEY hKey;
            LONG result = ((MAL_PFN_RegOpenKeyExA)pContext->win32.RegOpenKeyExA)(HKEY_LOCAL_MACHINE, keyStr, 0, KEY_READ, &hKey);
            if (result == ERROR_SUCCESS) {
                BYTE nameFromReg[512];
                DWORD nameFromRegSize = sizeof(nameFromReg);
                result = ((MAL_PFN_RegQueryValueExA)pContext->win32.RegQueryValueExA)(hKey, "Name", 0, NULL, (LPBYTE)nameFromReg, (LPDWORD)&nameFromRegSize);
                ((MAL_PFN_RegCloseKey)pContext->win32.RegCloseKey)(hKey);

                if (result == ERROR_SUCCESS) {
                    // We have the value from the registry, so now we need to construct the name string.
                    char name[1024];
                    if (mal_strcpy_s(name, sizeof(name), pDeviceInfo->name) == 0) {
                        char* nameBeg = mal_find_last_character(name, '(');
                        if (nameBeg != NULL) {
                            size_t leadingLen = (nameBeg - name);
                            mal_strncpy_s(nameBeg + 1, sizeof(name) - leadingLen, (const char*)nameFromReg, (size_t)-1);

                            // The closing ")", if it can fit.
                            if (leadingLen + nameFromRegSize < sizeof(name)-1) {
                                mal_strcat_s(name, sizeof(name), ")");
                            }

                            mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), name, (size_t)-1);
                        }
                    }
                }
            }
        }
    }

    
    WORD bitsPerSample;
    DWORD sampleRate;
    mal_result result = mal_get_best_info_from_formats_flags__winmm(pCaps->dwFormats, pCaps->wChannels, &bitsPerSample, &sampleRate);
    if (result != MAL_SUCCESS) {
        return result;
    }

    pDeviceInfo->minChannels = pCaps->wChannels;
    pDeviceInfo->maxChannels = pCaps->wChannels;
    pDeviceInfo->minSampleRate = sampleRate;
    pDeviceInfo->maxSampleRate = sampleRate;
    pDeviceInfo->formatCount = 1;
    if (bitsPerSample == 8) {
        pDeviceInfo->formats[0] = mal_format_u8;
    } else if (bitsPerSample == 16) {
        pDeviceInfo->formats[0] = mal_format_s16;
    } else if (bitsPerSample == 24) {
        pDeviceInfo->formats[0] = mal_format_s24;
    } else if (bitsPerSample == 32) {
        pDeviceInfo->formats[0] = mal_format_s32;
    } else {
        return MAL_FORMAT_NOT_SUPPORTED;
    }

    return MAL_SUCCESS;
}

mal_result mal_context_get_device_info_from_WAVEOUTCAPS2(mal_context* pContext, MAL_WAVEOUTCAPS2A* pCaps, mal_device_info* pDeviceInfo)
{
    mal_assert(pContext != NULL);
    mal_assert(pCaps != NULL);
    mal_assert(pDeviceInfo != NULL);

    MAL_WAVECAPSA caps;
    mal_copy_memory(caps.szPname, pCaps->szPname, sizeof(caps.szPname));
    caps.dwFormats = pCaps->dwFormats;
    caps.wChannels = pCaps->wChannels;
    caps.NameGuid = pCaps->NameGuid;
    return mal_context_get_device_info_from_WAVECAPS(pContext, &caps, pDeviceInfo);
}

mal_result mal_context_get_device_info_from_WAVEINCAPS2(mal_context* pContext, MAL_WAVEINCAPS2A* pCaps, mal_device_info* pDeviceInfo)
{
    mal_assert(pContext != NULL);
    mal_assert(pCaps != NULL);
    mal_assert(pDeviceInfo != NULL);

    MAL_WAVECAPSA caps;
    mal_copy_memory(caps.szPname, pCaps->szPname, sizeof(caps.szPname));
    caps.dwFormats = pCaps->dwFormats;
    caps.wChannels = pCaps->wChannels;
    caps.NameGuid = pCaps->NameGuid;
    return mal_context_get_device_info_from_WAVECAPS(pContext, &caps, pDeviceInfo);
}


mal_bool32 mal_context_is_device_id_equal__winmm(mal_context* pContext, const mal_device_id* pID0, const mal_device_id* pID1)
{
    mal_assert(pContext != NULL);
    mal_assert(pID0 != NULL);
    mal_assert(pID1 != NULL);
    (void)pContext;

    return pID0->winmm == pID1->winmm;
}

mal_result mal_context_enumerate_devices__winmm(mal_context* pContext, mal_enum_devices_callback_proc callback, void* pUserData)
{
    mal_assert(pContext != NULL);
    mal_assert(callback != NULL);

    // Playback.
    UINT playbackDeviceCount = ((MAL_PFN_waveOutGetNumDevs)pContext->winmm.waveOutGetNumDevs)();
    for (UINT iPlaybackDevice = 0; iPlaybackDevice < playbackDeviceCount; ++iPlaybackDevice) {
        MAL_WAVEOUTCAPS2A caps;
        mal_zero_object(&caps);
        MMRESULT result = ((MAL_PFN_waveOutGetDevCapsA)pContext->winmm.waveOutGetDevCapsA)(iPlaybackDevice, (WAVEOUTCAPSA*)&caps, sizeof(caps));
        if (result == MMSYSERR_NOERROR) {
            mal_device_info deviceInfo;
            mal_zero_object(&deviceInfo);
            deviceInfo.id.winmm = iPlaybackDevice;

            if (mal_context_get_device_info_from_WAVEOUTCAPS2(pContext, &caps, &deviceInfo) == MAL_SUCCESS) {
                mal_bool32 cbResult = callback(pContext, mal_device_type_playback, &deviceInfo, pUserData);
                if (cbResult == MAL_FALSE) {
                    return MAL_SUCCESS; // Enumeration was stopped.
                }
            }
        }
    }

    // Capture.
    UINT captureDeviceCount = ((MAL_PFN_waveInGetNumDevs)pContext->winmm.waveInGetNumDevs)();
    for (UINT iCaptureDevice = 0; iCaptureDevice < captureDeviceCount; ++iCaptureDevice) {
        MAL_WAVEINCAPS2A caps;
        mal_zero_object(&caps);
        MMRESULT result = ((MAL_PFN_waveInGetDevCapsA)pContext->winmm.waveInGetDevCapsA)(iCaptureDevice, (WAVEINCAPSA*)&caps, sizeof(caps));
        if (result == MMSYSERR_NOERROR) {
            mal_device_info deviceInfo;
            mal_zero_object(&deviceInfo);
            deviceInfo.id.winmm = iCaptureDevice;

            if (mal_context_get_device_info_from_WAVEINCAPS2(pContext, &caps, &deviceInfo) == MAL_SUCCESS) {
                mal_bool32 cbResult = callback(pContext, mal_device_type_capture, &deviceInfo, pUserData);
                if (cbResult == MAL_FALSE) {
                    return MAL_SUCCESS; // Enumeration was stopped.
                }
            }
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_context_get_device_info__winmm(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, mal_device_info* pDeviceInfo)
{
    mal_assert(pContext != NULL);

    if (shareMode == mal_share_mode_exclusive) {
        return MAL_SHARE_MODE_NOT_SUPPORTED;
    }

    UINT winMMDeviceID = 0;
    if (pDeviceID != NULL) {
        winMMDeviceID = (UINT)pDeviceID->winmm;
    }

    pDeviceInfo->id.winmm = winMMDeviceID;

    if (deviceType == mal_device_type_playback) {
        MAL_WAVEOUTCAPS2A caps;
        mal_zero_object(&caps);
        MMRESULT result = ((MAL_PFN_waveOutGetDevCapsA)pContext->winmm.waveOutGetDevCapsA)(winMMDeviceID, (WAVEOUTCAPSA*)&caps, sizeof(caps));
        if (result == MMSYSERR_NOERROR) {
            return mal_context_get_device_info_from_WAVEOUTCAPS2(pContext, &caps, pDeviceInfo);
        }
    } else {
        MAL_WAVEINCAPS2A caps;
        mal_zero_object(&caps);
        MMRESULT result = ((MAL_PFN_waveInGetDevCapsA)pContext->winmm.waveInGetDevCapsA)(winMMDeviceID, (WAVEINCAPSA*)&caps, sizeof(caps));
        if (result == MMSYSERR_NOERROR) {
            return mal_context_get_device_info_from_WAVEINCAPS2(pContext, &caps, pDeviceInfo);
        }
    }

    return MAL_NO_DEVICE;
}


void mal_device_uninit__winmm(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    ((MAL_PFN_waveOutReset)pDevice->pContext->winmm.waveOutReset);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        ((MAL_PFN_waveInClose)pDevice->pContext->winmm.waveInClose)((HWAVEIN)pDevice->winmm.hDeviceCapture);
        CloseHandle((HANDLE)pDevice->winmm.hEventCapture);
    }

    if (pDevice->type == mal_device_type_playback) {
        ((MAL_PFN_waveOutClose)pDevice->pContext->winmm.waveOutClose)((HWAVEOUT)pDevice->winmm.hDevicePlayback);
        CloseHandle((HANDLE)pDevice->winmm.hEventPlayback);
    }

    mal_free(pDevice->winmm._pHeapData);

    mal_zero_object(&pDevice->winmm);   // Safety.
}

mal_result mal_device_init__winmm(mal_context* pContext, const mal_device_config* pConfig, mal_device* pDevice)
{
    const char* errorMsg = "";
    mal_result errorCode = MAL_ERROR;
    mal_result result = MAL_SUCCESS;
    mal_uint32 heapSize;
    UINT winMMDeviceIDPlayback = 0;
    UINT winMMDeviceIDCapture  = 0;

    mal_assert(pDevice != NULL);
    mal_zero_object(&pDevice->winmm);

    /* No exlusive mode with WinMM. */
    if (((pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) && pConfig->playback.shareMode == mal_share_mode_exclusive) ||
        ((pConfig->deviceType == mal_device_type_capture  || pConfig->deviceType == mal_device_type_duplex) && pConfig->capture.shareMode  == mal_share_mode_exclusive)) {
        return MAL_SHARE_MODE_NOT_SUPPORTED;
    }

    mal_uint32 bufferSizeInMilliseconds = pConfig->bufferSizeInMilliseconds;
    if (bufferSizeInMilliseconds == 0) {
        bufferSizeInMilliseconds = mal_calculate_buffer_size_in_milliseconds_from_frames(pConfig->bufferSizeInFrames, pConfig->sampleRate);
    }
    
    /* WinMM has horrible latency. */
    if (pDevice->usingDefaultBufferSize) {
        if (pConfig->performanceProfile == mal_performance_profile_low_latency) {
            bufferSizeInMilliseconds =  40 * pConfig->periods;
        } else {
            bufferSizeInMilliseconds = 400 * pConfig->periods;
        }
    }


    if (pConfig->playback.pDeviceID != NULL) {
        winMMDeviceIDPlayback = (UINT)pConfig->playback.pDeviceID->winmm;
    }
    if (pConfig->capture.pDeviceID != NULL) {
        winMMDeviceIDCapture = (UINT)pConfig->capture.pDeviceID->winmm;
    }

    // The capture device needs to be initialized first.
    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        WAVEINCAPSA caps;
        WAVEFORMATEX wf;
        MMRESULT resultMM;

        // We use an event to know when a new fragment needs to be enqueued.
        pDevice->winmm.hEventCapture = (mal_handle)CreateEvent(NULL, TRUE, TRUE, NULL);
        if (pDevice->winmm.hEventCapture == NULL) {
            errorMsg = "[WinMM] Failed to create event for fragment enqueing for the capture device.", errorCode = MAL_FAILED_TO_CREATE_EVENT;
            goto on_error;
        }

        // The format should be based on the device's actual format.
        if (((MAL_PFN_waveInGetDevCapsA)pContext->winmm.waveInGetDevCapsA)(winMMDeviceIDCapture, &caps, sizeof(caps)) != MMSYSERR_NOERROR) {
            errorMsg = "[WinMM] Failed to retrieve internal device caps.", errorCode = MAL_FORMAT_NOT_SUPPORTED;
            goto on_error;
        }

        result = mal_formats_flags_to_WAVEFORMATEX__winmm(caps.dwFormats, caps.wChannels, &wf);
        if (result != MAL_SUCCESS) {
            errorMsg = "[WinMM] Could not find appropriate format for internal device.", errorCode = result;
            goto on_error;
        }

        resultMM = ((MAL_PFN_waveInOpen)pDevice->pContext->winmm.waveInOpen)((LPHWAVEIN)&pDevice->winmm.hDeviceCapture, winMMDeviceIDCapture, &wf, (DWORD_PTR)pDevice->winmm.hEventCapture, (DWORD_PTR)pDevice, CALLBACK_EVENT | WAVE_ALLOWSYNC);
        if (resultMM != MMSYSERR_NOERROR) {
            errorMsg = "[WinMM] Failed to open capture device.", errorCode = MAL_FAILED_TO_OPEN_BACKEND_DEVICE;
            goto on_error;
        }

        pDevice->capture.internalFormat     = mal_format_from_WAVEFORMATEX(&wf);
        pDevice->capture.internalChannels   = wf.nChannels;
        pDevice->capture.internalSampleRate = wf.nSamplesPerSec;
        mal_get_standard_channel_map(mal_standard_channel_map_microsoft, pDevice->capture.internalChannels, pDevice->capture.internalChannelMap);
        pDevice->capture.internalPeriods = pConfig->periods;
        pDevice->capture.internalBufferSizeInFrames = mal_calculate_buffer_size_in_frames_from_milliseconds(bufferSizeInMilliseconds, pDevice->capture.internalSampleRate);
    }

    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        WAVEOUTCAPSA caps;
        WAVEFORMATEX wf;
        MMRESULT resultMM;

        // We use an event to know when a new fragment needs to be enqueued.
        pDevice->winmm.hEventPlayback = (mal_handle)CreateEvent(NULL, TRUE, TRUE, NULL);
        if (pDevice->winmm.hEventPlayback == NULL) {
            errorMsg = "[WinMM] Failed to create event for fragment enqueing for the playback device.", errorCode = MAL_FAILED_TO_CREATE_EVENT;
            goto on_error;
        }

        // The format should be based on the device's actual format.
        if (((MAL_PFN_waveOutGetDevCapsA)pContext->winmm.waveOutGetDevCapsA)(winMMDeviceIDPlayback, &caps, sizeof(caps)) != MMSYSERR_NOERROR) {
            errorMsg = "[WinMM] Failed to retrieve internal device caps.", errorCode = MAL_FORMAT_NOT_SUPPORTED;
            goto on_error;
        }

        result = mal_formats_flags_to_WAVEFORMATEX__winmm(caps.dwFormats, caps.wChannels, &wf);
        if (result != MAL_SUCCESS) {
            errorMsg = "[WinMM] Could not find appropriate format for internal device.", errorCode = result;
            goto on_error;
        }

        resultMM = ((MAL_PFN_waveOutOpen)pContext->winmm.waveOutOpen)((LPHWAVEOUT)&pDevice->winmm.hDevicePlayback, winMMDeviceIDPlayback, &wf, (DWORD_PTR)pDevice->winmm.hEventPlayback, (DWORD_PTR)pDevice, CALLBACK_EVENT | WAVE_ALLOWSYNC);
        if (resultMM != MMSYSERR_NOERROR) {
            errorMsg = "[WinMM] Failed to open playback device.", errorCode = MAL_FAILED_TO_OPEN_BACKEND_DEVICE;
            goto on_error;
        }

        pDevice->playback.internalFormat     = mal_format_from_WAVEFORMATEX(&wf);
        pDevice->playback.internalChannels   = wf.nChannels;
        pDevice->playback.internalSampleRate = wf.nSamplesPerSec;
        mal_get_standard_channel_map(mal_standard_channel_map_microsoft, pDevice->playback.internalChannels, pDevice->playback.internalChannelMap);
        pDevice->playback.internalPeriods = pConfig->periods;
        pDevice->playback.internalBufferSizeInFrames = mal_calculate_buffer_size_in_frames_from_milliseconds(bufferSizeInMilliseconds, pDevice->playback.internalSampleRate);
    }

    // The heap allocated data is allocated like so:
    //
    // [Capture WAVEHDRs][Playback WAVEHDRs][Capture Intermediary Buffer][Playback Intermediary Buffer]
    heapSize = 0;
    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        heapSize += sizeof(WAVEHDR)*pDevice->capture.internalPeriods + (pDevice->capture.internalBufferSizeInFrames*mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));
    }
    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        heapSize += sizeof(WAVEHDR)*pDevice->playback.internalPeriods + (pDevice->playback.internalBufferSizeInFrames*mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels));
    }

    pDevice->winmm._pHeapData = (mal_uint8*)mal_malloc(heapSize);
    if (pDevice->winmm._pHeapData == NULL) {
        errorMsg = "[WinMM] Failed to allocate memory for the intermediary buffer.", errorCode = MAL_OUT_OF_MEMORY;
        goto on_error;
    }

    mal_zero_memory(pDevice->winmm._pHeapData, heapSize);

    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        if (pConfig->deviceType == mal_device_type_capture) {
            pDevice->winmm.pWAVEHDRCapture            = pDevice->winmm._pHeapData;
            pDevice->winmm.pIntermediaryBufferCapture = pDevice->winmm._pHeapData + (sizeof(WAVEHDR)*(pDevice->capture.internalPeriods));
        } else {
            pDevice->winmm.pWAVEHDRCapture            = pDevice->winmm._pHeapData;
            pDevice->winmm.pIntermediaryBufferCapture = pDevice->winmm._pHeapData + (sizeof(WAVEHDR)*(pDevice->capture.internalPeriods + pDevice->playback.internalPeriods));
        }

        /* Prepare headers. */
        for (mal_uint32 iPeriod = 0; iPeriod < pDevice->capture.internalPeriods; ++iPeriod) {
            mal_uint32 fragmentSizeInBytes = mal_get_fragment_size_in_bytes(pDevice->capture.internalBufferSizeInFrames, pDevice->capture.internalPeriods, pDevice->capture.internalFormat, pDevice->capture.internalChannels);

            ((WAVEHDR*)pDevice->winmm.pWAVEHDRCapture)[iPeriod].lpData         = (LPSTR)(pDevice->winmm.pIntermediaryBufferCapture + (fragmentSizeInBytes*iPeriod));
            ((WAVEHDR*)pDevice->winmm.pWAVEHDRCapture)[iPeriod].dwBufferLength = fragmentSizeInBytes;
            ((WAVEHDR*)pDevice->winmm.pWAVEHDRCapture)[iPeriod].dwFlags        = 0L;
            ((WAVEHDR*)pDevice->winmm.pWAVEHDRCapture)[iPeriod].dwLoops        = 0L;
            ((MAL_PFN_waveInPrepareHeader)pContext->winmm.waveInPrepareHeader)((HWAVEIN)pDevice->winmm.hDeviceCapture, &((WAVEHDR*)pDevice->winmm.pWAVEHDRCapture)[iPeriod], sizeof(WAVEHDR));

            /*
            The user data of the WAVEHDR structure is a single flag the controls whether or not it is ready for writing. Consider it to be named "isLocked". A value of 0 means
            it's unlocked and available for writing. A value of 1 means it's locked.
            */
            ((WAVEHDR*)pDevice->winmm.pWAVEHDRCapture)[iPeriod].dwUser = 0;
        }
    }
    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        if (pConfig->deviceType == mal_device_type_playback) {
            pDevice->winmm.pWAVEHDRPlayback            = pDevice->winmm._pHeapData;
            pDevice->winmm.pIntermediaryBufferPlayback = pDevice->winmm._pHeapData + (sizeof(WAVEHDR)*pDevice->playback.internalPeriods);
        } else {
            pDevice->winmm.pWAVEHDRPlayback            = pDevice->winmm._pHeapData + (sizeof(WAVEHDR)*(pDevice->capture.internalPeriods));
            pDevice->winmm.pIntermediaryBufferPlayback = pDevice->winmm._pHeapData + (sizeof(WAVEHDR)*(pDevice->capture.internalPeriods + pDevice->playback.internalPeriods)) + (pDevice->playback.internalBufferSizeInFrames*mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels));
        }

        /* Prepare headers. */
        for (mal_uint32 iPeriod = 0; iPeriod < pDevice->playback.internalPeriods; ++iPeriod) {
            mal_uint32 fragmentSizeInBytes = mal_get_fragment_size_in_bytes(pDevice->playback.internalBufferSizeInFrames, pDevice->playback.internalPeriods, pDevice->playback.internalFormat, pDevice->playback.internalChannels);

            ((WAVEHDR*)pDevice->winmm.pWAVEHDRPlayback)[iPeriod].lpData         = (LPSTR)(pDevice->winmm.pIntermediaryBufferPlayback + (fragmentSizeInBytes*iPeriod));
            ((WAVEHDR*)pDevice->winmm.pWAVEHDRPlayback)[iPeriod].dwBufferLength = fragmentSizeInBytes;
            ((WAVEHDR*)pDevice->winmm.pWAVEHDRPlayback)[iPeriod].dwFlags        = 0L;
            ((WAVEHDR*)pDevice->winmm.pWAVEHDRPlayback)[iPeriod].dwLoops        = 0L;
            ((MAL_PFN_waveOutPrepareHeader)pContext->winmm.waveOutPrepareHeader)((HWAVEOUT)pDevice->winmm.hDevicePlayback, &((WAVEHDR*)pDevice->winmm.pWAVEHDRPlayback)[iPeriod], sizeof(WAVEHDR));

            /*
            The user data of the WAVEHDR structure is a single flag the controls whether or not it is ready for writing. Consider it to be named "isLocked". A value of 0 means
            it's unlocked and available for writing. A value of 1 means it's locked.
            */
            ((WAVEHDR*)pDevice->winmm.pWAVEHDRPlayback)[iPeriod].dwUser = 0;
        }
    }

    return MAL_SUCCESS;

on_error:
    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        if (pDevice->winmm.pWAVEHDRCapture != NULL) {
            for (mal_uint32 iPeriod = 0; iPeriod < pDevice->capture.internalPeriods; ++iPeriod) {
                ((MAL_PFN_waveInUnprepareHeader)pContext->winmm.waveInUnprepareHeader)((HWAVEIN)pDevice->winmm.hDeviceCapture, &((WAVEHDR*)pDevice->winmm.pWAVEHDRCapture)[iPeriod], sizeof(WAVEHDR));
            }
        }

        ((MAL_PFN_waveInClose)pContext->winmm.waveInClose)((HWAVEIN)pDevice->winmm.hDeviceCapture);
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        if (pDevice->winmm.pWAVEHDRCapture != NULL) {
            for (mal_uint32 iPeriod = 0; iPeriod < pDevice->playback.internalPeriods; ++iPeriod) {
                ((MAL_PFN_waveOutUnprepareHeader)pContext->winmm.waveOutUnprepareHeader)((HWAVEOUT)pDevice->winmm.hDevicePlayback, &((WAVEHDR*)pDevice->winmm.pWAVEHDRPlayback)[iPeriod], sizeof(WAVEHDR));
            }
        }

        ((MAL_PFN_waveOutClose)pContext->winmm.waveOutClose)((HWAVEOUT)pDevice->winmm.hDevicePlayback);
    }

    mal_free(pDevice->winmm._pHeapData);
    return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, errorMsg, errorCode);
}

mal_result mal_device_stop__winmm(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        if (pDevice->winmm.hDeviceCapture == NULL) {
            return MAL_INVALID_ARGS;
        }

        MMRESULT resultMM = ((MAL_PFN_waveInReset)pDevice->pContext->winmm.waveInReset)((HWAVEIN)pDevice->winmm.hDeviceCapture);
        if (resultMM != MMSYSERR_NOERROR) {
            mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WinMM] WARNING: Failed to reset capture device.", mal_result_from_MMRESULT(resultMM));
        }
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        if (pDevice->winmm.hDevicePlayback == NULL) {
            return MAL_INVALID_ARGS;
        }

        MMRESULT resultMM = ((MAL_PFN_waveOutReset)pDevice->pContext->winmm.waveOutReset)((HWAVEOUT)pDevice->winmm.hDevicePlayback);
        if (resultMM != MMSYSERR_NOERROR) {
            mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WinMM] WARNING: Failed to reset playback device.", mal_result_from_MMRESULT(resultMM));
        }
    }

    mal_atomic_exchange_32(&pDevice->winmm.isStarted, MAL_FALSE);
    return MAL_SUCCESS;
}

mal_result mal_device_write__winmm(mal_device* pDevice, const void* pPCMFrames, mal_uint32 frameCount)
{
    mal_result result = MAL_SUCCESS;
    MMRESULT resultMM;
    mal_uint32 totalFramesWritten;
    WAVEHDR* pWAVEHDR = (WAVEHDR*)pDevice->winmm.pWAVEHDRPlayback;

    mal_assert(pDevice != NULL);
    mal_assert(pPCMFrames != NULL);

    /* Keep processing as much data as possible. */
    totalFramesWritten = 0;
    while (totalFramesWritten < frameCount) {
        /* If the current header has some space available we need to write part of it. */
        if (pWAVEHDR[pDevice->winmm.iNextHeaderPlayback].dwUser == 0) { /* 0 = unlocked. */
            /*
            This header has room in it. We copy as much of it as we can. If we end up fully consuming the buffer we need to
            write it out and move on to the next iteration.
            */
            mal_uint32 bpf = mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
            mal_uint32 framesRemainingInHeader = (pWAVEHDR[pDevice->winmm.iNextHeaderPlayback].dwBufferLength/bpf) - pDevice->winmm.headerFramesConsumedPlayback;

            mal_uint32 framesToCopy = mal_min(framesRemainingInHeader, (frameCount - totalFramesWritten));
            const void* pSrc = mal_offset_ptr(pPCMFrames, totalFramesWritten*bpf);
            void* pDst = mal_offset_ptr(pWAVEHDR[pDevice->winmm.iNextHeaderPlayback].lpData, pDevice->winmm.headerFramesConsumedPlayback*bpf);
            mal_copy_memory(pDst, pSrc, framesToCopy*bpf);

            pDevice->winmm.headerFramesConsumedPlayback += framesToCopy;
            totalFramesWritten += framesToCopy;

            /* If we've consumed the buffer entirely we need to write it out to the device. */
            if (pDevice->winmm.headerFramesConsumedPlayback == (pWAVEHDR[pDevice->winmm.iNextHeaderPlayback].dwBufferLength/bpf)) {
                pWAVEHDR[pDevice->winmm.iNextHeaderPlayback].dwUser = 1;            /* 1 = locked. */
                pWAVEHDR[pDevice->winmm.iNextHeaderPlayback].dwFlags &= ~WHDR_DONE; /* <-- Need to make sure the WHDR_DONE flag is unset. */

                /* Make sure the event is reset to a non-signaled state to ensure we don't prematurely return from WaitForSingleObject(). */
                ResetEvent((HANDLE)pDevice->winmm.hEventPlayback);

                /* The device will be started here. */
                resultMM = ((MAL_PFN_waveOutWrite)pDevice->pContext->winmm.waveOutWrite)((HWAVEOUT)pDevice->winmm.hDevicePlayback, &pWAVEHDR[pDevice->winmm.iNextHeaderPlayback], sizeof(WAVEHDR));
                if (resultMM != MMSYSERR_NOERROR) {
                    result = mal_result_from_MMRESULT(resultMM);
                    mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WinMM] waveOutWrite() failed.", result);
                    break;
                }
                mal_atomic_exchange_32(&pDevice->winmm.isStarted, MAL_TRUE);

                /* Make sure we move to the next header. */
                pDevice->winmm.iNextHeaderPlayback = (pDevice->winmm.iNextHeaderPlayback + 1) % pDevice->playback.internalPeriods;
                pDevice->winmm.headerFramesConsumedPlayback = 0;
            }

            /* If at this point we have consumed the entire input buffer we can return. */
            mal_assert(totalFramesWritten <= frameCount);
            if (totalFramesWritten == frameCount) {
                break;
            }

            /* Getting here means there's more to process. */
            continue;
        }

        /* Getting here means there isn't enough room in the buffer and we need to wait for one to become available. */
        if (WaitForSingleObject((HANDLE)pDevice->winmm.hEventPlayback, INFINITE) != WAIT_OBJECT_0) {
            result = MAL_ERROR;
            break;
        }

        /* Something happened. If the next buffer has been marked as done we need to reset a bit of state. */
        if ((pWAVEHDR[pDevice->winmm.iNextHeaderPlayback].dwFlags & WHDR_DONE) != 0) {
            pWAVEHDR[pDevice->winmm.iNextHeaderPlayback].dwUser = 0;    /* 0 = unlocked (make it available for writing). */
            pDevice->winmm.headerFramesConsumedPlayback = 0;
        }

        /* If the device has been stopped we need to break. */
        if (!pDevice->winmm.isStarted) {
            break;
        }
    }

    return result;
}

mal_result mal_device_read__winmm(mal_device* pDevice, void* pPCMFrames, mal_uint32 frameCount)
{
    mal_assert(pDevice != NULL);
    mal_assert(pPCMFrames != NULL);

    mal_result result = MAL_SUCCESS;
    MMRESULT resultMM;
    mal_uint32 totalFramesRead;
    WAVEHDR* pWAVEHDR = (WAVEHDR*)pDevice->winmm.pWAVEHDRCapture;

    /* We want to start the device immediately. */
    if (!pDevice->winmm.isStarted) {
        /* Make sure the event is reset to a non-signaled state to ensure we don't prematurely return from WaitForSingleObject(). */
        ResetEvent((HANDLE)pDevice->winmm.hEventCapture);

        /* To start the device we attach all of the buffers and then start it. As the buffers are filled with data we will get notifications. */
        for (mal_uint32 iPeriod = 0; iPeriod < pDevice->capture.internalPeriods; ++iPeriod) {
            resultMM = ((MAL_PFN_waveInAddBuffer)pDevice->pContext->winmm.waveInAddBuffer)((HWAVEIN)pDevice->winmm.hDeviceCapture, &((LPWAVEHDR)pDevice->winmm.pWAVEHDRCapture)[iPeriod], sizeof(WAVEHDR));
            if (resultMM != MMSYSERR_NOERROR) {
                return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WinMM] Failed to attach input buffers to capture device in preparation for capture.", mal_result_from_MMRESULT(resultMM));
            }

            /* Make sure all of the buffers start out locked. We don't want to access them until the backend tells us we can. */
            pWAVEHDR[iPeriod].dwUser = 1;   /* 1 = locked. */
        }

        /* Capture devices need to be explicitly started, unlike playback devices. */
        resultMM = ((MAL_PFN_waveInStart)pDevice->pContext->winmm.waveInStart)((HWAVEIN)pDevice->winmm.hDeviceCapture);
        if (resultMM != MMSYSERR_NOERROR) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WinMM] Failed to start backend device.", mal_result_from_MMRESULT(resultMM));
        }

        mal_atomic_exchange_32(&pDevice->winmm.isStarted, MAL_TRUE);
    }

    /* Keep processing as much data as possible. */
    totalFramesRead = 0;
    while (totalFramesRead < frameCount) {
        /* If the current header has some space available we need to write part of it. */
        if (pWAVEHDR[pDevice->winmm.iNextHeaderCapture].dwUser == 0) { /* 0 = unlocked. */
            /* The buffer is available for reading. If we fully consume it we need to add it back to the buffer. */
            mal_uint32 bpf = mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
            mal_uint32 framesRemainingInHeader = (pWAVEHDR[pDevice->winmm.iNextHeaderCapture].dwBufferLength/bpf) - pDevice->winmm.headerFramesConsumedCapture;

            mal_uint32 framesToCopy = mal_min(framesRemainingInHeader, (frameCount - totalFramesRead));
            const void* pSrc = mal_offset_ptr(pWAVEHDR[pDevice->winmm.iNextHeaderCapture].lpData, pDevice->winmm.headerFramesConsumedCapture*bpf);
            void* pDst = mal_offset_ptr(pPCMFrames, totalFramesRead*bpf);
            mal_copy_memory(pDst, pSrc, framesToCopy*bpf);

            pDevice->winmm.headerFramesConsumedCapture += framesToCopy;
            totalFramesRead += framesToCopy;

            /* If we've consumed the buffer entirely we need to add it back to the device. */
            if (pDevice->winmm.headerFramesConsumedCapture == (pWAVEHDR[pDevice->winmm.iNextHeaderCapture].dwBufferLength/bpf)) {
                pWAVEHDR[pDevice->winmm.iNextHeaderCapture].dwUser = 1;            /* 1 = locked. */
                pWAVEHDR[pDevice->winmm.iNextHeaderCapture].dwFlags &= ~WHDR_DONE; /* <-- Need to make sure the WHDR_DONE flag is unset. */

                /* Make sure the event is reset to a non-signaled state to ensure we don't prematurely return from WaitForSingleObject(). */
                ResetEvent((HANDLE)pDevice->winmm.hEventCapture);

                /* The device will be started here. */
                resultMM = ((MAL_PFN_waveInAddBuffer)pDevice->pContext->winmm.waveInAddBuffer)((HWAVEIN)pDevice->winmm.hDeviceCapture, &((LPWAVEHDR)pDevice->winmm.pWAVEHDRCapture)[pDevice->winmm.iNextHeaderCapture], sizeof(WAVEHDR));
                if (resultMM != MMSYSERR_NOERROR) {
                    result = mal_result_from_MMRESULT(resultMM);
                    mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[WinMM] waveInAddBuffer() failed.", result);
                    break;
                }

                /* Make sure we move to the next header. */
                pDevice->winmm.iNextHeaderCapture = (pDevice->winmm.iNextHeaderCapture + 1) % pDevice->capture.internalPeriods;
                pDevice->winmm.headerFramesConsumedCapture = 0;
            }

            /* If at this point we have filled the entire input buffer we can return. */
            mal_assert(totalFramesRead <= frameCount);
            if (totalFramesRead == frameCount) {
                break;
            }

            /* Getting here means there's more to process. */
            continue;
        }

        /* Getting here means there isn't enough any data left to send to the client which means we need to wait for more. */
        if (WaitForSingleObject((HANDLE)pDevice->winmm.hEventCapture, INFINITE) != WAIT_OBJECT_0) {
            result = MAL_ERROR;
            break;
        }

        /* Something happened. If the next buffer has been marked as done we need to reset a bit of state. */
        if ((pWAVEHDR[pDevice->winmm.iNextHeaderCapture].dwFlags & WHDR_DONE) != 0) {
            pWAVEHDR[pDevice->winmm.iNextHeaderCapture].dwUser = 0;    /* 0 = unlocked (make it available for reading). */
            pDevice->winmm.headerFramesConsumedCapture = 0;
        }

        /* If the device has been stopped we need to break. */
        if (!pDevice->winmm.isStarted) {
            break;
        }
    }

    return result;
}

mal_result mal_context_uninit__winmm(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    mal_assert(pContext->backend == mal_backend_winmm);

    mal_dlclose(pContext->winmm.hWinMM);
    return MAL_SUCCESS;
}

mal_result mal_context_init__winmm(mal_context* pContext)
{
    mal_assert(pContext != NULL);

    pContext->winmm.hWinMM = mal_dlopen("winmm.dll");
    if (pContext->winmm.hWinMM == NULL) {
        return MAL_NO_BACKEND;
    }

    pContext->winmm.waveOutGetNumDevs      = mal_dlsym(pContext->winmm.hWinMM, "waveOutGetNumDevs");
    pContext->winmm.waveOutGetDevCapsA     = mal_dlsym(pContext->winmm.hWinMM, "waveOutGetDevCapsA");
    pContext->winmm.waveOutOpen            = mal_dlsym(pContext->winmm.hWinMM, "waveOutOpen");
    pContext->winmm.waveOutClose           = mal_dlsym(pContext->winmm.hWinMM, "waveOutClose");
    pContext->winmm.waveOutPrepareHeader   = mal_dlsym(pContext->winmm.hWinMM, "waveOutPrepareHeader");
    pContext->winmm.waveOutUnprepareHeader = mal_dlsym(pContext->winmm.hWinMM, "waveOutUnprepareHeader");
    pContext->winmm.waveOutWrite           = mal_dlsym(pContext->winmm.hWinMM, "waveOutWrite");
    pContext->winmm.waveOutReset           = mal_dlsym(pContext->winmm.hWinMM, "waveOutReset");
    pContext->winmm.waveInGetNumDevs       = mal_dlsym(pContext->winmm.hWinMM, "waveInGetNumDevs");
    pContext->winmm.waveInGetDevCapsA      = mal_dlsym(pContext->winmm.hWinMM, "waveInGetDevCapsA");
    pContext->winmm.waveInOpen             = mal_dlsym(pContext->winmm.hWinMM, "waveInOpen");
    pContext->winmm.waveInClose            = mal_dlsym(pContext->winmm.hWinMM, "waveInClose");
    pContext->winmm.waveInPrepareHeader    = mal_dlsym(pContext->winmm.hWinMM, "waveInPrepareHeader");
    pContext->winmm.waveInUnprepareHeader  = mal_dlsym(pContext->winmm.hWinMM, "waveInUnprepareHeader");
    pContext->winmm.waveInAddBuffer        = mal_dlsym(pContext->winmm.hWinMM, "waveInAddBuffer");
    pContext->winmm.waveInStart            = mal_dlsym(pContext->winmm.hWinMM, "waveInStart");
    pContext->winmm.waveInReset            = mal_dlsym(pContext->winmm.hWinMM, "waveInReset");

    pContext->onUninit              = mal_context_uninit__winmm;
    pContext->onDeviceIDEqual       = mal_context_is_device_id_equal__winmm;
    pContext->onEnumDevices         = mal_context_enumerate_devices__winmm;
    pContext->onGetDeviceInfo       = mal_context_get_device_info__winmm;
    pContext->onDeviceInit          = mal_device_init__winmm;
    pContext->onDeviceUninit        = mal_device_uninit__winmm;
    pContext->onDeviceStart         = NULL; /* Not used. Started in onDeviceWrite/onDeviceRead. */
    pContext->onDeviceStop          = mal_device_stop__winmm;
    pContext->onDeviceWrite         = mal_device_write__winmm;
    pContext->onDeviceRead          = mal_device_read__winmm;

    return MAL_SUCCESS;
}
#endif




///////////////////////////////////////////////////////////////////////////////
//
// ALSA Backend
//
///////////////////////////////////////////////////////////////////////////////
#ifdef MAL_HAS_ALSA

#ifdef MAL_NO_RUNTIME_LINKING
#include <alsa/asoundlib.h>
typedef snd_pcm_uframes_t                       mal_snd_pcm_uframes_t;
typedef snd_pcm_sframes_t                       mal_snd_pcm_sframes_t;
typedef snd_pcm_stream_t                        mal_snd_pcm_stream_t;
typedef snd_pcm_format_t                        mal_snd_pcm_format_t;
typedef snd_pcm_access_t                        mal_snd_pcm_access_t;
typedef snd_pcm_t                               mal_snd_pcm_t;
typedef snd_pcm_hw_params_t                     mal_snd_pcm_hw_params_t;
typedef snd_pcm_sw_params_t                     mal_snd_pcm_sw_params_t;
typedef snd_pcm_format_mask_t                   mal_snd_pcm_format_mask_t;
typedef snd_pcm_info_t                          mal_snd_pcm_info_t;
typedef snd_pcm_channel_area_t                  mal_snd_pcm_channel_area_t;
typedef snd_pcm_chmap_t                         mal_snd_pcm_chmap_t;

// snd_pcm_stream_t
#define MAL_SND_PCM_STREAM_PLAYBACK             SND_PCM_STREAM_PLAYBACK
#define MAL_SND_PCM_STREAM_CAPTURE              SND_PCM_STREAM_CAPTURE

// snd_pcm_format_t
#define MAL_SND_PCM_FORMAT_UNKNOWN              SND_PCM_FORMAT_UNKNOWN
#define MAL_SND_PCM_FORMAT_U8                   SND_PCM_FORMAT_U8
#define MAL_SND_PCM_FORMAT_S16_LE               SND_PCM_FORMAT_S16_LE
#define MAL_SND_PCM_FORMAT_S16_BE               SND_PCM_FORMAT_S16_BE
#define MAL_SND_PCM_FORMAT_S24_LE               SND_PCM_FORMAT_S24_LE
#define MAL_SND_PCM_FORMAT_S24_BE               SND_PCM_FORMAT_S24_BE
#define MAL_SND_PCM_FORMAT_S32_LE               SND_PCM_FORMAT_S32_LE
#define MAL_SND_PCM_FORMAT_S32_BE               SND_PCM_FORMAT_S32_BE
#define MAL_SND_PCM_FORMAT_FLOAT_LE             SND_PCM_FORMAT_FLOAT_LE
#define MAL_SND_PCM_FORMAT_FLOAT_BE             SND_PCM_FORMAT_FLOAT_BE
#define MAL_SND_PCM_FORMAT_FLOAT64_LE           SND_PCM_FORMAT_FLOAT64_LE
#define MAL_SND_PCM_FORMAT_FLOAT64_BE           SND_PCM_FORMAT_FLOAT64_BE
#define MAL_SND_PCM_FORMAT_MU_LAW               SND_PCM_FORMAT_MU_LAW
#define MAL_SND_PCM_FORMAT_A_LAW                SND_PCM_FORMAT_A_LAW
#define MAL_SND_PCM_FORMAT_S24_3LE              SND_PCM_FORMAT_S24_3LE
#define MAL_SND_PCM_FORMAT_S24_3BE              SND_PCM_FORMAT_S24_3BE

// mal_snd_pcm_access_t
#define MAL_SND_PCM_ACCESS_MMAP_INTERLEAVED     SND_PCM_ACCESS_MMAP_INTERLEAVED
#define MAL_SND_PCM_ACCESS_MMAP_NONINTERLEAVED  SND_PCM_ACCESS_MMAP_NONINTERLEAVED
#define MAL_SND_PCM_ACCESS_MMAP_COMPLEX         SND_PCM_ACCESS_MMAP_COMPLEX
#define MAL_SND_PCM_ACCESS_RW_INTERLEAVED       SND_PCM_ACCESS_RW_INTERLEAVED
#define MAL_SND_PCM_ACCESS_RW_NONINTERLEAVED    SND_PCM_ACCESS_RW_NONINTERLEAVED

// Channel positions.
#define MAL_SND_CHMAP_UNKNOWN                   SND_CHMAP_UNKNOWN
#define MAL_SND_CHMAP_NA                        SND_CHMAP_NA
#define MAL_SND_CHMAP_MONO                      SND_CHMAP_MONO
#define MAL_SND_CHMAP_FL                        SND_CHMAP_FL
#define MAL_SND_CHMAP_FR                        SND_CHMAP_FR
#define MAL_SND_CHMAP_RL                        SND_CHMAP_RL
#define MAL_SND_CHMAP_RR                        SND_CHMAP_RR
#define MAL_SND_CHMAP_FC                        SND_CHMAP_FC
#define MAL_SND_CHMAP_LFE                       SND_CHMAP_LFE
#define MAL_SND_CHMAP_SL                        SND_CHMAP_SL
#define MAL_SND_CHMAP_SR                        SND_CHMAP_SR
#define MAL_SND_CHMAP_RC                        SND_CHMAP_RC
#define MAL_SND_CHMAP_FLC                       SND_CHMAP_FLC
#define MAL_SND_CHMAP_FRC                       SND_CHMAP_FRC
#define MAL_SND_CHMAP_RLC                       SND_CHMAP_RLC
#define MAL_SND_CHMAP_RRC                       SND_CHMAP_RRC
#define MAL_SND_CHMAP_FLW                       SND_CHMAP_FLW
#define MAL_SND_CHMAP_FRW                       SND_CHMAP_FRW
#define MAL_SND_CHMAP_FLH                       SND_CHMAP_FLH
#define MAL_SND_CHMAP_FCH                       SND_CHMAP_FCH
#define MAL_SND_CHMAP_FRH                       SND_CHMAP_FRH
#define MAL_SND_CHMAP_TC                        SND_CHMAP_TC
#define MAL_SND_CHMAP_TFL                       SND_CHMAP_TFL
#define MAL_SND_CHMAP_TFR                       SND_CHMAP_TFR
#define MAL_SND_CHMAP_TFC                       SND_CHMAP_TFC
#define MAL_SND_CHMAP_TRL                       SND_CHMAP_TRL
#define MAL_SND_CHMAP_TRR                       SND_CHMAP_TRR
#define MAL_SND_CHMAP_TRC                       SND_CHMAP_TRC
#define MAL_SND_CHMAP_TFLC                      SND_CHMAP_TFLC
#define MAL_SND_CHMAP_TFRC                      SND_CHMAP_TFRC
#define MAL_SND_CHMAP_TSL                       SND_CHMAP_TSL
#define MAL_SND_CHMAP_TSR                       SND_CHMAP_TSR
#define MAL_SND_CHMAP_LLFE                      SND_CHMAP_LLFE
#define MAL_SND_CHMAP_RLFE                      SND_CHMAP_RLFE
#define MAL_SND_CHMAP_BC                        SND_CHMAP_BC
#define MAL_SND_CHMAP_BLC                       SND_CHMAP_BLC
#define MAL_SND_CHMAP_BRC                       SND_CHMAP_BRC

// Open mode flags.
#define MAL_SND_PCM_NO_AUTO_RESAMPLE            SND_PCM_NO_AUTO_RESAMPLE
#define MAL_SND_PCM_NO_AUTO_CHANNELS            SND_PCM_NO_AUTO_CHANNELS
#define MAL_SND_PCM_NO_AUTO_FORMAT              SND_PCM_NO_AUTO_FORMAT
#else
#include <errno.h>  // For EPIPE, etc.
typedef unsigned long                           mal_snd_pcm_uframes_t;
typedef long                                    mal_snd_pcm_sframes_t;
typedef int                                     mal_snd_pcm_stream_t;
typedef int                                     mal_snd_pcm_format_t;
typedef int                                     mal_snd_pcm_access_t;
typedef struct mal_snd_pcm_t                    mal_snd_pcm_t;
typedef struct mal_snd_pcm_hw_params_t          mal_snd_pcm_hw_params_t;
typedef struct mal_snd_pcm_sw_params_t          mal_snd_pcm_sw_params_t;
typedef struct mal_snd_pcm_format_mask_t        mal_snd_pcm_format_mask_t;
typedef struct mal_snd_pcm_info_t               mal_snd_pcm_info_t;
typedef struct
{
    void* addr;
    unsigned int first;
    unsigned int step;
} mal_snd_pcm_channel_area_t;
typedef struct
{
    unsigned int channels;
    unsigned int pos[0];
} mal_snd_pcm_chmap_t;

// snd_pcm_state_t
#define MAL_SND_PCM_STATE_OPEN                  0
#define MAL_SND_PCM_STATE_SETUP                 1
#define MAL_SND_PCM_STATE_PREPARED              2
#define MAL_SND_PCM_STATE_RUNNING               3
#define MAL_SND_PCM_STATE_XRUN                  4
#define MAL_SND_PCM_STATE_DRAINING              5
#define MAL_SND_PCM_STATE_PAUSED                6
#define MAL_SND_PCM_STATE_SUSPENDED             7
#define MAL_SND_PCM_STATE_DISCONNECTED          8

// snd_pcm_stream_t
#define MAL_SND_PCM_STREAM_PLAYBACK             0
#define MAL_SND_PCM_STREAM_CAPTURE              1

// snd_pcm_format_t
#define MAL_SND_PCM_FORMAT_UNKNOWN              -1
#define MAL_SND_PCM_FORMAT_U8                   1
#define MAL_SND_PCM_FORMAT_S16_LE               2
#define MAL_SND_PCM_FORMAT_S16_BE               3
#define MAL_SND_PCM_FORMAT_S24_LE               6
#define MAL_SND_PCM_FORMAT_S24_BE               7
#define MAL_SND_PCM_FORMAT_S32_LE               10
#define MAL_SND_PCM_FORMAT_S32_BE               11
#define MAL_SND_PCM_FORMAT_FLOAT_LE             14
#define MAL_SND_PCM_FORMAT_FLOAT_BE             15
#define MAL_SND_PCM_FORMAT_FLOAT64_LE           16
#define MAL_SND_PCM_FORMAT_FLOAT64_BE           17
#define MAL_SND_PCM_FORMAT_MU_LAW               20
#define MAL_SND_PCM_FORMAT_A_LAW                21
#define MAL_SND_PCM_FORMAT_S24_3LE              32
#define MAL_SND_PCM_FORMAT_S24_3BE              33

// snd_pcm_access_t
#define MAL_SND_PCM_ACCESS_MMAP_INTERLEAVED     0
#define MAL_SND_PCM_ACCESS_MMAP_NONINTERLEAVED  1
#define MAL_SND_PCM_ACCESS_MMAP_COMPLEX         2
#define MAL_SND_PCM_ACCESS_RW_INTERLEAVED       3
#define MAL_SND_PCM_ACCESS_RW_NONINTERLEAVED    4

// Channel positions.
#define MAL_SND_CHMAP_UNKNOWN                   0
#define MAL_SND_CHMAP_NA                        1
#define MAL_SND_CHMAP_MONO                      2
#define MAL_SND_CHMAP_FL                        3
#define MAL_SND_CHMAP_FR                        4
#define MAL_SND_CHMAP_RL                        5
#define MAL_SND_CHMAP_RR                        6
#define MAL_SND_CHMAP_FC                        7
#define MAL_SND_CHMAP_LFE                       8
#define MAL_SND_CHMAP_SL                        9
#define MAL_SND_CHMAP_SR                        10
#define MAL_SND_CHMAP_RC                        11
#define MAL_SND_CHMAP_FLC                       12
#define MAL_SND_CHMAP_FRC                       13
#define MAL_SND_CHMAP_RLC                       14
#define MAL_SND_CHMAP_RRC                       15
#define MAL_SND_CHMAP_FLW                       16
#define MAL_SND_CHMAP_FRW                       17
#define MAL_SND_CHMAP_FLH                       18
#define MAL_SND_CHMAP_FCH                       19
#define MAL_SND_CHMAP_FRH                       20
#define MAL_SND_CHMAP_TC                        21
#define MAL_SND_CHMAP_TFL                       22
#define MAL_SND_CHMAP_TFR                       23
#define MAL_SND_CHMAP_TFC                       24
#define MAL_SND_CHMAP_TRL                       25
#define MAL_SND_CHMAP_TRR                       26
#define MAL_SND_CHMAP_TRC                       27
#define MAL_SND_CHMAP_TFLC                      28
#define MAL_SND_CHMAP_TFRC                      29
#define MAL_SND_CHMAP_TSL                       30
#define MAL_SND_CHMAP_TSR                       31
#define MAL_SND_CHMAP_LLFE                      32
#define MAL_SND_CHMAP_RLFE                      33
#define MAL_SND_CHMAP_BC                        34
#define MAL_SND_CHMAP_BLC                       35
#define MAL_SND_CHMAP_BRC                       36

// Open mode flags.
#define MAL_SND_PCM_NO_AUTO_RESAMPLE            0x00010000
#define MAL_SND_PCM_NO_AUTO_CHANNELS            0x00020000
#define MAL_SND_PCM_NO_AUTO_FORMAT              0x00040000
#endif

typedef int                   (* mal_snd_pcm_open_proc)                          (mal_snd_pcm_t **pcm, const char *name, mal_snd_pcm_stream_t stream, int mode);
typedef int                   (* mal_snd_pcm_close_proc)                         (mal_snd_pcm_t *pcm);
typedef size_t                (* mal_snd_pcm_hw_params_sizeof_proc)              (void);
typedef int                   (* mal_snd_pcm_hw_params_any_proc)                 (mal_snd_pcm_t *pcm, mal_snd_pcm_hw_params_t *params);
typedef int                   (* mal_snd_pcm_hw_params_set_format_proc)          (mal_snd_pcm_t *pcm, mal_snd_pcm_hw_params_t *params, mal_snd_pcm_format_t val);
typedef int                   (* mal_snd_pcm_hw_params_set_format_first_proc)    (mal_snd_pcm_t *pcm, mal_snd_pcm_hw_params_t *params, mal_snd_pcm_format_t *format);
typedef void                  (* mal_snd_pcm_hw_params_get_format_mask_proc)     (mal_snd_pcm_hw_params_t *params, mal_snd_pcm_format_mask_t *mask);
typedef int                   (* mal_snd_pcm_hw_params_set_channels_near_proc)   (mal_snd_pcm_t *pcm, mal_snd_pcm_hw_params_t *params, unsigned int *val);
typedef int                   (* mal_snd_pcm_hw_params_set_rate_resample_proc)   (mal_snd_pcm_t *pcm, mal_snd_pcm_hw_params_t *params, unsigned int val);
typedef int                   (* mal_snd_pcm_hw_params_set_rate_near_proc)       (mal_snd_pcm_t *pcm, mal_snd_pcm_hw_params_t *params, unsigned int *val, int *dir);
typedef int                   (* mal_snd_pcm_hw_params_set_buffer_size_near_proc)(mal_snd_pcm_t *pcm, mal_snd_pcm_hw_params_t *params, mal_snd_pcm_uframes_t *val);
typedef int                   (* mal_snd_pcm_hw_params_set_periods_near_proc)    (mal_snd_pcm_t *pcm, mal_snd_pcm_hw_params_t *params, unsigned int *val, int *dir);
typedef int                   (* mal_snd_pcm_hw_params_set_access_proc)          (mal_snd_pcm_t *pcm, mal_snd_pcm_hw_params_t *params, mal_snd_pcm_access_t _access);
typedef int                   (* mal_snd_pcm_hw_params_get_format_proc)          (const mal_snd_pcm_hw_params_t *params, mal_snd_pcm_format_t *format);
typedef int                   (* mal_snd_pcm_hw_params_get_channels_proc)        (const mal_snd_pcm_hw_params_t *params, unsigned int *val);
typedef int                   (* mal_snd_pcm_hw_params_get_channels_min_proc)    (const mal_snd_pcm_hw_params_t *params, unsigned int *val);
typedef int                   (* mal_snd_pcm_hw_params_get_channels_max_proc)    (const mal_snd_pcm_hw_params_t *params, unsigned int *val);
typedef int                   (* mal_snd_pcm_hw_params_get_rate_proc)            (const mal_snd_pcm_hw_params_t *params, unsigned int *rate, int *dir);
typedef int                   (* mal_snd_pcm_hw_params_get_rate_min_proc)        (const mal_snd_pcm_hw_params_t *params, unsigned int *rate, int *dir);
typedef int                   (* mal_snd_pcm_hw_params_get_rate_max_proc)        (const mal_snd_pcm_hw_params_t *params, unsigned int *rate, int *dir);
typedef int                   (* mal_snd_pcm_hw_params_get_buffer_size_proc)     (const mal_snd_pcm_hw_params_t *params, mal_snd_pcm_uframes_t *val);
typedef int                   (* mal_snd_pcm_hw_params_get_periods_proc)         (const mal_snd_pcm_hw_params_t *params, unsigned int *val, int *dir);
typedef int                   (* mal_snd_pcm_hw_params_get_access_proc)          (const mal_snd_pcm_hw_params_t *params, mal_snd_pcm_access_t *_access);
typedef int                   (* mal_snd_pcm_hw_params_proc)                     (mal_snd_pcm_t *pcm, mal_snd_pcm_hw_params_t *params);
typedef size_t                (* mal_snd_pcm_sw_params_sizeof_proc)              (void);
typedef int                   (* mal_snd_pcm_sw_params_current_proc)             (mal_snd_pcm_t *pcm, mal_snd_pcm_sw_params_t *params);
typedef int                   (* mal_snd_pcm_sw_params_get_boundary_proc)        (mal_snd_pcm_sw_params_t *params, mal_snd_pcm_uframes_t* val);
typedef int                   (* mal_snd_pcm_sw_params_set_avail_min_proc)       (mal_snd_pcm_t *pcm, mal_snd_pcm_sw_params_t *params, mal_snd_pcm_uframes_t val);
typedef int                   (* mal_snd_pcm_sw_params_set_start_threshold_proc) (mal_snd_pcm_t *pcm, mal_snd_pcm_sw_params_t *params, mal_snd_pcm_uframes_t val);
typedef int                   (* mal_snd_pcm_sw_params_set_stop_threshold_proc)  (mal_snd_pcm_t *pcm, mal_snd_pcm_sw_params_t *params, mal_snd_pcm_uframes_t val);
typedef int                   (* mal_snd_pcm_sw_params_proc)                     (mal_snd_pcm_t *pcm, mal_snd_pcm_sw_params_t *params);
typedef size_t                (* mal_snd_pcm_format_mask_sizeof_proc)            (void);
typedef int                   (* mal_snd_pcm_format_mask_test_proc)              (const mal_snd_pcm_format_mask_t *mask, mal_snd_pcm_format_t val);
typedef mal_snd_pcm_chmap_t * (* mal_snd_pcm_get_chmap_proc)                     (mal_snd_pcm_t *pcm);
typedef int                   (* mal_snd_pcm_state_proc)                         (mal_snd_pcm_t *pcm);
typedef int                   (* mal_snd_pcm_prepare_proc)                       (mal_snd_pcm_t *pcm);
typedef int                   (* mal_snd_pcm_start_proc)                         (mal_snd_pcm_t *pcm);
typedef int                   (* mal_snd_pcm_drop_proc)                          (mal_snd_pcm_t *pcm);
typedef int                   (* mal_snd_pcm_drain_proc)                         (mal_snd_pcm_t *pcm);
typedef int                   (* mal_snd_device_name_hint_proc)                  (int card, const char *iface, void ***hints);
typedef char *                (* mal_snd_device_name_get_hint_proc)              (const void *hint, const char *id);
typedef int                   (* mal_snd_card_get_index_proc)                    (const char *name);
typedef int                   (* mal_snd_device_name_free_hint_proc)             (void **hints);
typedef int                   (* mal_snd_pcm_mmap_begin_proc)                    (mal_snd_pcm_t *pcm, const mal_snd_pcm_channel_area_t **areas, mal_snd_pcm_uframes_t *offset, mal_snd_pcm_uframes_t *frames);
typedef mal_snd_pcm_sframes_t (* mal_snd_pcm_mmap_commit_proc)                   (mal_snd_pcm_t *pcm, mal_snd_pcm_uframes_t offset, mal_snd_pcm_uframes_t frames);
typedef int                   (* mal_snd_pcm_recover_proc)                       (mal_snd_pcm_t *pcm, int err, int silent);
typedef mal_snd_pcm_sframes_t (* mal_snd_pcm_readi_proc)                         (mal_snd_pcm_t *pcm, void *buffer, mal_snd_pcm_uframes_t size);
typedef mal_snd_pcm_sframes_t (* mal_snd_pcm_writei_proc)                        (mal_snd_pcm_t *pcm, const void *buffer, mal_snd_pcm_uframes_t size);
typedef mal_snd_pcm_sframes_t (* mal_snd_pcm_avail_proc)                         (mal_snd_pcm_t *pcm);
typedef mal_snd_pcm_sframes_t (* mal_snd_pcm_avail_update_proc)                  (mal_snd_pcm_t *pcm);
typedef int                   (* mal_snd_pcm_wait_proc)                          (mal_snd_pcm_t *pcm, int timeout);
typedef int                   (* mal_snd_pcm_info_proc)                          (mal_snd_pcm_t *pcm, mal_snd_pcm_info_t* info);
typedef size_t                (* mal_snd_pcm_info_sizeof_proc)                   ();
typedef const char*           (* mal_snd_pcm_info_get_name_proc)                 (const mal_snd_pcm_info_t* info);
typedef int                   (* mal_snd_config_update_free_global_proc)         ();

// This array specifies each of the common devices that can be used for both playback and capture.
const char* g_malCommonDeviceNamesALSA[] = {
    "default",
    "null",
    "pulse",
    "jack"
};

// This array allows us to blacklist specific playback devices.
const char* g_malBlacklistedPlaybackDeviceNamesALSA[] = {
    ""
};

// This array allows us to blacklist specific capture devices.
const char* g_malBlacklistedCaptureDeviceNamesALSA[] = {
    ""
};


// This array allows mini_al to control device-specific default buffer sizes. This uses a scaling factor. Order is important. If
// any part of the string is present in the device's name, the associated scale will be used.
static struct
{
    const char* name;
    float scale;
} g_malDefaultBufferSizeScalesALSA[] = {
    {"bcm2835 IEC958/HDMI", 2.0f},
    {"bcm2835 ALSA",        2.0f}
};

float mal_find_default_buffer_size_scale__alsa(const char* deviceName)
{
    if (deviceName == NULL) {
        return 1;
    }

    for (size_t i = 0; i < mal_countof(g_malDefaultBufferSizeScalesALSA); ++i) {
        if (strstr(g_malDefaultBufferSizeScalesALSA[i].name, deviceName) != NULL) {
            return g_malDefaultBufferSizeScalesALSA[i].scale;
        }
    }

    return 1;
}

mal_snd_pcm_format_t mal_convert_mal_format_to_alsa_format(mal_format format)
{
    mal_snd_pcm_format_t ALSAFormats[] = {
        MAL_SND_PCM_FORMAT_UNKNOWN,     // mal_format_unknown
        MAL_SND_PCM_FORMAT_U8,          // mal_format_u8
        MAL_SND_PCM_FORMAT_S16_LE,      // mal_format_s16
        MAL_SND_PCM_FORMAT_S24_3LE,     // mal_format_s24
        MAL_SND_PCM_FORMAT_S32_LE,      // mal_format_s32
        MAL_SND_PCM_FORMAT_FLOAT_LE     // mal_format_f32
    };

    if (mal_is_big_endian()) {
        ALSAFormats[0] = MAL_SND_PCM_FORMAT_UNKNOWN;
        ALSAFormats[1] = MAL_SND_PCM_FORMAT_U8;
        ALSAFormats[2] = MAL_SND_PCM_FORMAT_S16_BE;
        ALSAFormats[3] = MAL_SND_PCM_FORMAT_S24_3BE;
        ALSAFormats[4] = MAL_SND_PCM_FORMAT_S32_BE;
        ALSAFormats[5] = MAL_SND_PCM_FORMAT_FLOAT_BE;
    }


    return ALSAFormats[format];
}

mal_format mal_convert_alsa_format_to_mal_format(mal_snd_pcm_format_t formatALSA)
{
    if (mal_is_little_endian()) {
        switch (formatALSA) {
            case MAL_SND_PCM_FORMAT_S16_LE:   return mal_format_s16;
            case MAL_SND_PCM_FORMAT_S24_3LE:  return mal_format_s24;
            case MAL_SND_PCM_FORMAT_S32_LE:   return mal_format_s32;
            case MAL_SND_PCM_FORMAT_FLOAT_LE: return mal_format_f32;
            default: break;
        }
    } else {
        switch (formatALSA) {
            case MAL_SND_PCM_FORMAT_S16_BE:   return mal_format_s16;
            case MAL_SND_PCM_FORMAT_S24_3BE:  return mal_format_s24;
            case MAL_SND_PCM_FORMAT_S32_BE:   return mal_format_s32;
            case MAL_SND_PCM_FORMAT_FLOAT_BE: return mal_format_f32;
            default: break;
        }
    }

    // Endian agnostic.
    switch (formatALSA) {
        case MAL_SND_PCM_FORMAT_U8: return mal_format_u8;
        default: return mal_format_unknown;
    }
}

mal_channel mal_convert_alsa_channel_position_to_mal_channel(unsigned int alsaChannelPos)
{
    switch (alsaChannelPos)
    {
        case MAL_SND_CHMAP_MONO: return MAL_CHANNEL_MONO;
        case MAL_SND_CHMAP_FL:   return MAL_CHANNEL_FRONT_LEFT;
        case MAL_SND_CHMAP_FR:   return MAL_CHANNEL_FRONT_RIGHT;
        case MAL_SND_CHMAP_RL:   return MAL_CHANNEL_BACK_LEFT;
        case MAL_SND_CHMAP_RR:   return MAL_CHANNEL_BACK_RIGHT;
        case MAL_SND_CHMAP_FC:   return MAL_CHANNEL_FRONT_CENTER;
        case MAL_SND_CHMAP_LFE:  return MAL_CHANNEL_LFE;
        case MAL_SND_CHMAP_SL:   return MAL_CHANNEL_SIDE_LEFT;
        case MAL_SND_CHMAP_SR:   return MAL_CHANNEL_SIDE_RIGHT;
        case MAL_SND_CHMAP_RC:   return MAL_CHANNEL_BACK_CENTER;
        case MAL_SND_CHMAP_FLC:  return MAL_CHANNEL_FRONT_LEFT_CENTER;
        case MAL_SND_CHMAP_FRC:  return MAL_CHANNEL_FRONT_RIGHT_CENTER;
        case MAL_SND_CHMAP_RLC:  return 0;
        case MAL_SND_CHMAP_RRC:  return 0;
        case MAL_SND_CHMAP_FLW:  return 0;
        case MAL_SND_CHMAP_FRW:  return 0;
        case MAL_SND_CHMAP_FLH:  return 0;
        case MAL_SND_CHMAP_FCH:  return 0;
        case MAL_SND_CHMAP_FRH:  return 0;
        case MAL_SND_CHMAP_TC:   return MAL_CHANNEL_TOP_CENTER;
        case MAL_SND_CHMAP_TFL:  return MAL_CHANNEL_TOP_FRONT_LEFT;
        case MAL_SND_CHMAP_TFR:  return MAL_CHANNEL_TOP_FRONT_RIGHT;
        case MAL_SND_CHMAP_TFC:  return MAL_CHANNEL_TOP_FRONT_CENTER;
        case MAL_SND_CHMAP_TRL:  return MAL_CHANNEL_TOP_BACK_LEFT;
        case MAL_SND_CHMAP_TRR:  return MAL_CHANNEL_TOP_BACK_RIGHT;
        case MAL_SND_CHMAP_TRC:  return MAL_CHANNEL_TOP_BACK_CENTER;
        default: break;
    }

    return 0;
}

mal_bool32 mal_is_common_device_name__alsa(const char* name)
{
    for (size_t iName = 0; iName < mal_countof(g_malCommonDeviceNamesALSA); ++iName) {
        if (mal_strcmp(name, g_malCommonDeviceNamesALSA[iName]) == 0) {
            return MAL_TRUE;
        }
    }

    return MAL_FALSE;
}


mal_bool32 mal_is_playback_device_blacklisted__alsa(const char* name)
{
    for (size_t iName = 0; iName < mal_countof(g_malBlacklistedPlaybackDeviceNamesALSA); ++iName) {
        if (mal_strcmp(name, g_malBlacklistedPlaybackDeviceNamesALSA[iName]) == 0) {
            return MAL_TRUE;
        }
    }

    return MAL_FALSE;
}

mal_bool32 mal_is_capture_device_blacklisted__alsa(const char* name)
{
    for (size_t iName = 0; iName < mal_countof(g_malBlacklistedCaptureDeviceNamesALSA); ++iName) {
        if (mal_strcmp(name, g_malBlacklistedCaptureDeviceNamesALSA[iName]) == 0) {
            return MAL_TRUE;
        }
    }

    return MAL_FALSE;
}

mal_bool32 mal_is_device_blacklisted__alsa(mal_device_type deviceType, const char* name)
{
    if (deviceType == mal_device_type_playback) {
        return mal_is_playback_device_blacklisted__alsa(name);
    } else {
        return mal_is_capture_device_blacklisted__alsa(name);
    }
}


const char* mal_find_char(const char* str, char c, int* index)
{
    int i = 0;
    for (;;) {
        if (str[i] == '\0') {
            if (index) *index = -1;
            return NULL;
        }

        if (str[i] == c) {
            if (index) *index = i;
            return str + i;
        }

        i += 1;
    }

    // Should never get here, but treat it as though the character was not found to make me feel
    // better inside.
    if (index) *index = -1;
    return NULL;
}

mal_bool32 mal_is_device_name_in_hw_format__alsa(const char* hwid)
{
    // This function is just checking whether or not hwid is in "hw:%d,%d" format.

    if (hwid == NULL) {
        return MAL_FALSE;
    }

    if (hwid[0] != 'h' || hwid[1] != 'w' || hwid[2] != ':') {
        return MAL_FALSE;
    }

    hwid += 3;

    int commaPos;
    const char* dev = mal_find_char(hwid, ',', &commaPos);
    if (dev == NULL) {
        return MAL_FALSE;
    } else {
        dev += 1;   // Skip past the ",".
    }

    // Check if the part between the ":" and the "," contains only numbers. If not, return false.
    for (int i = 0; i < commaPos; ++i) {
        if (hwid[i] < '0' || hwid[i] > '9') {
            return MAL_FALSE;
        }
    }

    // Check if everything after the "," is numeric. If not, return false.
    int i = 0;
    while (dev[i] != '\0') {
        if (dev[i] < '0' || dev[i] > '9') {
            return MAL_FALSE;
        }
        i += 1;
    }

    return MAL_TRUE;
}

int mal_convert_device_name_to_hw_format__alsa(mal_context* pContext, char* dst, size_t dstSize, const char* src)  // Returns 0 on success, non-0 on error.
{
    // src should look something like this: "hw:CARD=I82801AAICH,DEV=0"

    if (dst == NULL) return -1;
    if (dstSize < 7) return -1;     // Absolute minimum size of the output buffer is 7 bytes.

    *dst = '\0';    // Safety.
    if (src == NULL) return -1;

    // If the input name is already in "hw:%d,%d" format, just return that verbatim.
    if (mal_is_device_name_in_hw_format__alsa(src)) {
        return mal_strcpy_s(dst, dstSize, src);
    }


    int colonPos;
    src = mal_find_char(src, ':', &colonPos);
    if (src == NULL) {
        return -1;  // Couldn't find a colon
    }

    char card[256];

    int commaPos;
    const char* dev = mal_find_char(src, ',', &commaPos);
    if (dev == NULL) {
        dev = "0";
        mal_strncpy_s(card, sizeof(card), src+6, (size_t)-1);   // +6 = ":CARD="
    } else {
        dev = dev + 5;  // +5 = ",DEV="
        mal_strncpy_s(card, sizeof(card), src+6, commaPos-6);   // +6 = ":CARD="
    }

    int cardIndex = ((mal_snd_card_get_index_proc)pContext->alsa.snd_card_get_index)(card);
    if (cardIndex < 0) {
        return -2;  // Failed to retrieve the card index.
    }

    //printf("TESTING: CARD=%s,DEV=%s\n", card, dev);


    // Construction.
    dst[0] = 'h'; dst[1] = 'w'; dst[2] = ':';
    if (mal_itoa_s(cardIndex, dst+3, dstSize-3, 10) != 0) {
        return -3;
    }
    if (mal_strcat_s(dst, dstSize, ",") != 0) {
        return -3;
    }
    if (mal_strcat_s(dst, dstSize, dev) != 0) {
        return -3;
    }

    return 0;
}

mal_bool32 mal_does_id_exist_in_list__alsa(mal_device_id* pUniqueIDs, mal_uint32 count, const char* pHWID)
{
    mal_assert(pHWID != NULL);

    for (mal_uint32 i = 0; i < count; ++i) {
        if (mal_strcmp(pUniqueIDs[i].alsa, pHWID) == 0) {
            return MAL_TRUE;
        }
    }

    return MAL_FALSE;
}


mal_result mal_context_open_pcm__alsa(mal_context* pContext, mal_share_mode shareMode, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_snd_pcm_t** ppPCM)
{
    mal_assert(pContext != NULL);
    mal_assert(ppPCM != NULL);

    *ppPCM = NULL;

    mal_snd_pcm_t* pPCM = NULL;

    mal_snd_pcm_stream_t stream = (deviceType == mal_device_type_playback) ? MAL_SND_PCM_STREAM_PLAYBACK : MAL_SND_PCM_STREAM_CAPTURE;
    int openMode = MAL_SND_PCM_NO_AUTO_RESAMPLE | MAL_SND_PCM_NO_AUTO_CHANNELS | MAL_SND_PCM_NO_AUTO_FORMAT;

    if (pDeviceID == NULL) {
        // We're opening the default device. I don't know if trying anything other than "default" is necessary, but it makes
        // me feel better to try as hard as we can get to get _something_ working.
        const char* defaultDeviceNames[] = {
            "default",
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL
        };

        if (shareMode == mal_share_mode_exclusive) {
            defaultDeviceNames[1] = "hw";
            defaultDeviceNames[2] = "hw:0";
            defaultDeviceNames[3] = "hw:0,0";
        } else {
            if (deviceType == mal_device_type_playback) {
                defaultDeviceNames[1] = "dmix";
                defaultDeviceNames[2] = "dmix:0";
                defaultDeviceNames[3] = "dmix:0,0";
            } else {
                defaultDeviceNames[1] = "dsnoop";
                defaultDeviceNames[2] = "dsnoop:0";
                defaultDeviceNames[3] = "dsnoop:0,0";
            }
            defaultDeviceNames[4] = "hw";
            defaultDeviceNames[5] = "hw:0";
            defaultDeviceNames[6] = "hw:0,0";
        }

        mal_bool32 isDeviceOpen = MAL_FALSE;
        for (size_t i = 0; i < mal_countof(defaultDeviceNames); ++i) {  // TODO: i = 1 is temporary for testing purposes. Needs to be i = 0.
            if (defaultDeviceNames[i] != NULL && defaultDeviceNames[i][0] != '\0') {
                if (((mal_snd_pcm_open_proc)pContext->alsa.snd_pcm_open)(&pPCM, defaultDeviceNames[i], stream, openMode) == 0) {
                    isDeviceOpen = MAL_TRUE;
                    break;
                }
            }
        }

        if (!isDeviceOpen) {
            return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[ALSA] snd_pcm_open() failed when trying to open an appropriate default device.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }
    } else {
        // We're trying to open a specific device. There's a few things to consider here:
        //
        // mini_al recongnizes a special format of device id that excludes the "hw", "dmix", etc. prefix. It looks like this: ":0,0", ":0,1", etc. When
        // an ID of this format is specified, it indicates to mini_al that it can try different combinations of plugins ("hw", "dmix", etc.) until it
        // finds an appropriate one that works. This comes in very handy when trying to open a device in shared mode ("dmix"), vs exclusive mode ("hw").

        // May end up needing to make small adjustments to the ID, so make a copy.
        mal_device_id deviceID = *pDeviceID;

        mal_bool32 isDeviceOpen = MAL_FALSE;
        if (deviceID.alsa[0] != ':') {
            // The ID is not in ":0,0" format. Use the ID exactly as-is.
            if (((mal_snd_pcm_open_proc)pContext->alsa.snd_pcm_open)(&pPCM, deviceID.alsa, stream, openMode) == 0) {
                isDeviceOpen = MAL_TRUE;
            }
        } else {
            // The ID is in ":0,0" format. Try different plugins depending on the shared mode.
            if (deviceID.alsa[1] == '\0') {
                deviceID.alsa[0] = '\0';  // An ID of ":" should be converted to "".
            }

            char hwid[256];
            if (shareMode == mal_share_mode_shared) {
                if (deviceType == mal_device_type_playback) {
                    mal_strcpy_s(hwid, sizeof(hwid), "dmix");
                } else {
                    mal_strcpy_s(hwid, sizeof(hwid), "dsnoop");
                }

                if (mal_strcat_s(hwid, sizeof(hwid), deviceID.alsa) == 0) {
                    if (((mal_snd_pcm_open_proc)pContext->alsa.snd_pcm_open)(&pPCM, hwid, stream, openMode) == 0) {
                        isDeviceOpen = MAL_TRUE;
                    }
                }
            }

            // If at this point we still don't have an open device it means we're either preferencing exclusive mode or opening with "dmix"/"dsnoop" failed.
            if (!isDeviceOpen) {
                mal_strcpy_s(hwid, sizeof(hwid), "hw");
                if (mal_strcat_s(hwid, sizeof(hwid), deviceID.alsa) == 0) {
                    if (((mal_snd_pcm_open_proc)pContext->alsa.snd_pcm_open)(&pPCM, hwid, stream, openMode) == 0) {
                        isDeviceOpen = MAL_TRUE;
                    }
                }
            }
        }

        if (!isDeviceOpen) {
            return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[ALSA] snd_pcm_open() failed.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }
    }

    *ppPCM = pPCM;
    return MAL_SUCCESS;
}


mal_bool32 mal_context_is_device_id_equal__alsa(mal_context* pContext, const mal_device_id* pID0, const mal_device_id* pID1)
{
    mal_assert(pContext != NULL);
    mal_assert(pID0 != NULL);
    mal_assert(pID1 != NULL);
    (void)pContext;

    return mal_strcmp(pID0->alsa, pID1->alsa) == 0;
}

mal_result mal_context_enumerate_devices__alsa(mal_context* pContext, mal_enum_devices_callback_proc callback, void* pUserData)
{
    mal_assert(pContext != NULL);
    mal_assert(callback != NULL);

    mal_bool32 cbResult = MAL_TRUE;

    mal_mutex_lock(&pContext->alsa.internalDeviceEnumLock);

    char** ppDeviceHints;
    if (((mal_snd_device_name_hint_proc)pContext->alsa.snd_device_name_hint)(-1, "pcm", (void***)&ppDeviceHints) < 0) {
        mal_mutex_unlock(&pContext->alsa.internalDeviceEnumLock);
        return MAL_NO_BACKEND;
    }

    mal_device_id* pUniqueIDs = NULL;
    mal_uint32 uniqueIDCount = 0;

    char** ppNextDeviceHint = ppDeviceHints;
    while (*ppNextDeviceHint != NULL) {
        char* NAME = ((mal_snd_device_name_get_hint_proc)pContext->alsa.snd_device_name_get_hint)(*ppNextDeviceHint, "NAME");
        char* DESC = ((mal_snd_device_name_get_hint_proc)pContext->alsa.snd_device_name_get_hint)(*ppNextDeviceHint, "DESC");
        char* IOID = ((mal_snd_device_name_get_hint_proc)pContext->alsa.snd_device_name_get_hint)(*ppNextDeviceHint, "IOID");

        mal_device_type deviceType = mal_device_type_playback;
        if ((IOID == NULL || mal_strcmp(IOID, "Output") == 0)) {
            deviceType = mal_device_type_playback;
        }
        if ((IOID != NULL && mal_strcmp(IOID, "Input" ) == 0)) {
            deviceType = mal_device_type_capture;
        }

        mal_bool32 stopEnumeration = MAL_FALSE;
#if 0
        printf("NAME: %s\n", NAME);
        printf("DESC: %s\n", DESC);
        printf("IOID: %s\n", IOID);

        char hwid2[256];
        mal_convert_device_name_to_hw_format__alsa(pContext, hwid2, sizeof(hwid2), NAME);
        printf("DEVICE ID: %s\n\n", hwid2);
#endif

        char hwid[sizeof(pUniqueIDs->alsa)];
        if (NAME != NULL) {
            if (pContext->config.alsa.useVerboseDeviceEnumeration) {
                // Verbose mode. Use the name exactly as-is.
                mal_strncpy_s(hwid, sizeof(hwid), NAME, (size_t)-1);
            } else {
                // Simplified mode. Use ":%d,%d" format.
                if (mal_convert_device_name_to_hw_format__alsa(pContext, hwid, sizeof(hwid), NAME) == 0) {
                    // At this point, hwid looks like "hw:0,0". In simplified enumeration mode, we actually want to strip off the
                    // plugin name so it looks like ":0,0". The reason for this is that this special format is detected at device
                    // initialization time and is used as an indicator to try and use the most appropriate plugin depending on the
                    // device type and sharing mode.
                    char* dst = hwid;
                    char* src = hwid+2;
                    while ((*dst++ = *src++));
                } else {
                    // Conversion to "hw:%d,%d" failed. Just use the name as-is.
                    mal_strncpy_s(hwid, sizeof(hwid), NAME, (size_t)-1);
                }

                if (mal_does_id_exist_in_list__alsa(pUniqueIDs, uniqueIDCount, hwid)) {
                    goto next_device;   // The device has already been enumerated. Move on to the next one.
                } else {
                    // The device has not yet been enumerated. Make sure it's added to our list so that it's not enumerated again.
                    mal_device_id* pNewUniqueIDs = (mal_device_id*)mal_realloc(pUniqueIDs, sizeof(*pUniqueIDs) * (uniqueIDCount + 1));
                    if (pNewUniqueIDs == NULL) {
                        goto next_device;   // Failed to allocate memory.
                    }

                    pUniqueIDs = pNewUniqueIDs;
                    mal_copy_memory(pUniqueIDs[uniqueIDCount].alsa, hwid, sizeof(hwid));
                    uniqueIDCount += 1;
                }
            }
        } else {
            mal_zero_memory(hwid, sizeof(hwid));
        }

        mal_device_info deviceInfo;
        mal_zero_object(&deviceInfo);
        mal_strncpy_s(deviceInfo.id.alsa, sizeof(deviceInfo.id.alsa), hwid, (size_t)-1);

        // DESC is the friendly name. We treat this slightly differently depending on whether or not we are using verbose
        // device enumeration. In verbose mode we want to take the entire description so that the end-user can distinguish
        // between the subdevices of each card/dev pair. In simplified mode, however, we only want the first part of the
        // description.
        //
        // The value in DESC seems to be split into two lines, with the first line being the name of the device and the
        // second line being a description of the device. I don't like having the description be across two lines because
        // it makes formatting ugly and annoying. I'm therefore deciding to put it all on a single line with the second line
        // being put into parentheses. In simplified mode I'm just stripping the second line entirely.
        if (DESC != NULL) {
            int lfPos;
            const char* line2 = mal_find_char(DESC, '\n', &lfPos);
            if (line2 != NULL) {
                line2 += 1; // Skip past the new-line character.

                if (pContext->config.alsa.useVerboseDeviceEnumeration) {
                    // Verbose mode. Put the second line in brackets.
                    mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), DESC, lfPos);
                    mal_strcat_s (deviceInfo.name, sizeof(deviceInfo.name), " (");
                    mal_strcat_s (deviceInfo.name, sizeof(deviceInfo.name), line2);
                    mal_strcat_s (deviceInfo.name, sizeof(deviceInfo.name), ")");
                } else {
                    // Simplified mode. Strip the second line entirely.
                    mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), DESC, lfPos);
                }
            } else {
                // There's no second line. Just copy the whole description.
                mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), DESC, (size_t)-1);
            }
        }

        if (!mal_is_device_blacklisted__alsa(deviceType, NAME)) {
            cbResult = callback(pContext, deviceType, &deviceInfo, pUserData);
        }

        // Some devices are both playback and capture, but they are only enumerated by ALSA once. We need to fire the callback
        // again for the other device type in this case. We do this for known devices.
        if (cbResult) {
            if (mal_is_common_device_name__alsa(NAME)) {
                if (deviceType == mal_device_type_playback) {
                    if (!mal_is_capture_device_blacklisted__alsa(NAME)) {
                        cbResult = callback(pContext, mal_device_type_capture, &deviceInfo, pUserData);
                    }
                } else {
                    if (!mal_is_playback_device_blacklisted__alsa(NAME)) {
                        cbResult = callback(pContext, mal_device_type_playback, &deviceInfo, pUserData);
                    }
                }
            }
        }

        if (cbResult == MAL_FALSE) {
            stopEnumeration = MAL_TRUE;
        }

    next_device:
        free(NAME);
        free(DESC);
        free(IOID);
        ppNextDeviceHint += 1;

        // We need to stop enumeration if the callback returned false.
        if (stopEnumeration) {
            break;
        }
    }

    mal_free(pUniqueIDs);
    ((mal_snd_device_name_free_hint_proc)pContext->alsa.snd_device_name_free_hint)((void**)ppDeviceHints);

    mal_mutex_unlock(&pContext->alsa.internalDeviceEnumLock);

    return MAL_SUCCESS;
}


typedef struct
{
    mal_device_type deviceType;
    const mal_device_id* pDeviceID;
    mal_share_mode shareMode;
    mal_device_info* pDeviceInfo;
    mal_bool32 foundDevice;
} mal_context_get_device_info_enum_callback_data__alsa;

mal_bool32 mal_context_get_device_info_enum_callback__alsa(mal_context* pContext, mal_device_type deviceType, const mal_device_info* pDeviceInfo, void* pUserData)
{
    mal_context_get_device_info_enum_callback_data__alsa* pData = (mal_context_get_device_info_enum_callback_data__alsa*)pUserData;
    mal_assert(pData != NULL);

    if (pData->pDeviceID == NULL && mal_strcmp(pDeviceInfo->id.alsa, "default") == 0) {
        mal_strncpy_s(pData->pDeviceInfo->name, sizeof(pData->pDeviceInfo->name), pDeviceInfo->name, (size_t)-1);
        pData->foundDevice = MAL_TRUE;
    } else {
        if (pData->deviceType == deviceType && mal_context_is_device_id_equal__alsa(pContext, pData->pDeviceID, &pDeviceInfo->id)) {
            mal_strncpy_s(pData->pDeviceInfo->name, sizeof(pData->pDeviceInfo->name), pDeviceInfo->name, (size_t)-1);
            pData->foundDevice = MAL_TRUE;
        }
    }

    // Keep enumerating until we have found the device.
    return !pData->foundDevice;
}

mal_result mal_context_get_device_info__alsa(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, mal_device_info* pDeviceInfo)
{
    mal_assert(pContext != NULL);

    // We just enumerate to find basic information about the device.
    mal_context_get_device_info_enum_callback_data__alsa data;
    data.deviceType = deviceType;
    data.pDeviceID = pDeviceID;
    data.shareMode = shareMode;
    data.pDeviceInfo = pDeviceInfo;
    data.foundDevice = MAL_FALSE;
    mal_result result = mal_context_enumerate_devices__alsa(pContext, mal_context_get_device_info_enum_callback__alsa, &data);
    if (result != MAL_SUCCESS) {
        return result;
    }

    if (!data.foundDevice) {
        return MAL_NO_DEVICE;
    }


    // For detailed info we need to open the device.
    mal_snd_pcm_t* pPCM;
    result = mal_context_open_pcm__alsa(pContext, shareMode, deviceType, pDeviceID, &pPCM);
    if (result != MAL_SUCCESS) {
        return result;
    }

    // We need to initialize a HW parameters object in order to know what formats are supported.
    mal_snd_pcm_hw_params_t* pHWParams = (mal_snd_pcm_hw_params_t*)alloca(((mal_snd_pcm_hw_params_sizeof_proc)pContext->alsa.snd_pcm_hw_params_sizeof)());
    mal_zero_memory(pHWParams, ((mal_snd_pcm_hw_params_sizeof_proc)pContext->alsa.snd_pcm_hw_params_sizeof)());

    if (((mal_snd_pcm_hw_params_any_proc)pContext->alsa.snd_pcm_hw_params_any)(pPCM, pHWParams) < 0) {
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to initialize hardware parameters. snd_pcm_hw_params_any() failed.", MAL_FAILED_TO_CONFIGURE_BACKEND_DEVICE);
    }

    int sampleRateDir = 0;

    ((mal_snd_pcm_hw_params_get_channels_min_proc)pContext->alsa.snd_pcm_hw_params_get_channels_min)(pHWParams, &pDeviceInfo->minChannels);
    ((mal_snd_pcm_hw_params_get_channels_max_proc)pContext->alsa.snd_pcm_hw_params_get_channels_max)(pHWParams, &pDeviceInfo->maxChannels);
    ((mal_snd_pcm_hw_params_get_rate_min_proc)pContext->alsa.snd_pcm_hw_params_get_rate_min)(pHWParams, &pDeviceInfo->minSampleRate, &sampleRateDir);
    ((mal_snd_pcm_hw_params_get_rate_max_proc)pContext->alsa.snd_pcm_hw_params_get_rate_max)(pHWParams, &pDeviceInfo->maxSampleRate, &sampleRateDir);

    // Formats.
    mal_snd_pcm_format_mask_t* pFormatMask = (mal_snd_pcm_format_mask_t*)alloca(((mal_snd_pcm_format_mask_sizeof_proc)pContext->alsa.snd_pcm_format_mask_sizeof)());
    mal_zero_memory(pFormatMask, ((mal_snd_pcm_format_mask_sizeof_proc)pContext->alsa.snd_pcm_format_mask_sizeof)());
    ((mal_snd_pcm_hw_params_get_format_mask_proc)pContext->alsa.snd_pcm_hw_params_get_format_mask)(pHWParams, pFormatMask);

    pDeviceInfo->formatCount = 0;
    if (((mal_snd_pcm_format_mask_test_proc)pContext->alsa.snd_pcm_format_mask_test)(pFormatMask, MAL_SND_PCM_FORMAT_U8)) {
        pDeviceInfo->formats[pDeviceInfo->formatCount++] = mal_format_u8;
    }
    if (((mal_snd_pcm_format_mask_test_proc)pContext->alsa.snd_pcm_format_mask_test)(pFormatMask, MAL_SND_PCM_FORMAT_S16_LE)) {
        pDeviceInfo->formats[pDeviceInfo->formatCount++] = mal_format_s16;
    }
    if (((mal_snd_pcm_format_mask_test_proc)pContext->alsa.snd_pcm_format_mask_test)(pFormatMask, MAL_SND_PCM_FORMAT_S24_3LE)) {
        pDeviceInfo->formats[pDeviceInfo->formatCount++] = mal_format_s24;
    }
    if (((mal_snd_pcm_format_mask_test_proc)pContext->alsa.snd_pcm_format_mask_test)(pFormatMask, MAL_SND_PCM_FORMAT_S32_LE)) {
        pDeviceInfo->formats[pDeviceInfo->formatCount++] = mal_format_s32;
    }
    if (((mal_snd_pcm_format_mask_test_proc)pContext->alsa.snd_pcm_format_mask_test)(pFormatMask, MAL_SND_PCM_FORMAT_FLOAT_LE)) {
        pDeviceInfo->formats[pDeviceInfo->formatCount++] = mal_format_f32;
    }

    ((mal_snd_pcm_close_proc)pContext->alsa.snd_pcm_close)(pPCM);
    return MAL_SUCCESS;
}


#if 0
// Waits for a number of frames to become available for either capture or playback. The return
// value is the number of frames available.
//
// This will return early if the main loop is broken with mal_device__break_main_loop().
mal_uint32 mal_device__wait_for_frames__alsa(mal_device* pDevice, mal_bool32* pRequiresRestart)
{
    mal_assert(pDevice != NULL);

    if (pRequiresRestart) *pRequiresRestart = MAL_FALSE;

    // I want it so that this function returns the period size in frames. We just wait until that number of frames are available and then return.
    mal_uint32 periodSizeInFrames = pDevice->bufferSizeInFrames / pDevice->periods;
    while (!pDevice->alsa.breakFromMainLoop) {
        mal_snd_pcm_sframes_t framesAvailable = ((mal_snd_pcm_avail_update_proc)pDevice->pContext->alsa.snd_pcm_avail_update)((mal_snd_pcm_t*)pDevice->alsa.pPCM);
        if (framesAvailable < 0) {
            if (framesAvailable == -EPIPE) {
                if (((mal_snd_pcm_recover_proc)pDevice->pContext->alsa.snd_pcm_recover)((mal_snd_pcm_t*)pDevice->alsa.pPCM, framesAvailable, MAL_TRUE) < 0) {
                    return 0;
                }

                // A device recovery means a restart for mmap mode.
                if (pRequiresRestart) {
                    *pRequiresRestart = MAL_TRUE;
                }

                // Try again, but if it fails this time just return an error.
                framesAvailable = ((mal_snd_pcm_avail_update_proc)pDevice->pContext->alsa.snd_pcm_avail_update)((mal_snd_pcm_t*)pDevice->alsa.pPCM);
                if (framesAvailable < 0) {
                    return 0;
                }
            }
        }

        if (framesAvailable >= periodSizeInFrames) {
            return periodSizeInFrames;
        }

        if (framesAvailable < periodSizeInFrames) {
            // Less than a whole period is available so keep waiting.
            int waitResult = ((mal_snd_pcm_wait_proc)pDevice->pContext->alsa.snd_pcm_wait)((mal_snd_pcm_t*)pDevice->alsa.pPCM, -1);
            if (waitResult < 0) {
                if (waitResult == -EPIPE) {
                    if (((mal_snd_pcm_recover_proc)pDevice->pContext->alsa.snd_pcm_recover)((mal_snd_pcm_t*)pDevice->alsa.pPCM, waitResult, MAL_TRUE) < 0) {
                        return 0;
                    }

                    // A device recovery means a restart for mmap mode.
                    if (pRequiresRestart) {
                        *pRequiresRestart = MAL_TRUE;
                    }
                }
            }
        }
    }

    // We'll get here if the loop was terminated. Just return whatever's available.
    mal_snd_pcm_sframes_t framesAvailable = ((mal_snd_pcm_avail_update_proc)pDevice->pContext->alsa.snd_pcm_avail_update)((mal_snd_pcm_t*)pDevice->alsa.pPCM);
    if (framesAvailable < 0) {
        return 0;
    }

    return framesAvailable;
}

mal_bool32 mal_device_read_from_client_and_write__alsa(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);
    if (!mal_device_is_started(pDevice) && mal_device__get_state(pDevice) != MAL_STATE_STARTING) {
        return MAL_FALSE;
    }
    if (pDevice->alsa.breakFromMainLoop) {
        return MAL_FALSE;
    }

    if (pDevice->alsa.isUsingMMap) {
        // mmap.
        mal_bool32 requiresRestart;
        mal_uint32 framesAvailable = mal_device__wait_for_frames__alsa(pDevice, &requiresRestart);
        if (framesAvailable == 0) {
            return MAL_FALSE;
        }

        // Don't bother asking the client for more audio data if we're just stopping the device anyway.
        if (pDevice->alsa.breakFromMainLoop) {
            return MAL_FALSE;
        }

        const mal_snd_pcm_channel_area_t* pAreas;
        mal_snd_pcm_uframes_t mappedOffset;
        mal_snd_pcm_uframes_t mappedFrames = framesAvailable;
        while (framesAvailable > 0) {
            int result = ((mal_snd_pcm_mmap_begin_proc)pDevice->pContext->alsa.snd_pcm_mmap_begin)((mal_snd_pcm_t*)pDevice->alsa.pPCM, &pAreas, &mappedOffset, &mappedFrames);
            if (result < 0) {
                return MAL_FALSE;
            }

            if (mappedFrames > 0) {
                void* pBuffer = (mal_uint8*)pAreas[0].addr + ((pAreas[0].first + (mappedOffset * pAreas[0].step)) / 8);
                mal_device__read_frames_from_client(pDevice, mappedFrames, pBuffer);
            }

            result = ((mal_snd_pcm_mmap_commit_proc)pDevice->pContext->alsa.snd_pcm_mmap_commit)((mal_snd_pcm_t*)pDevice->alsa.pPCM, mappedOffset, mappedFrames);
            if (result < 0 || (mal_snd_pcm_uframes_t)result != mappedFrames) {
                ((mal_snd_pcm_recover_proc)pDevice->pContext->alsa.snd_pcm_recover)((mal_snd_pcm_t*)pDevice->alsa.pPCM, result, MAL_TRUE);
                return MAL_FALSE;
            }

            if (requiresRestart) {
                if (((mal_snd_pcm_start_proc)pDevice->pContext->alsa.snd_pcm_start)((mal_snd_pcm_t*)pDevice->alsa.pPCM) < 0) {
                    return MAL_FALSE;
                }
            }

            if (framesAvailable >= mappedFrames) {
                framesAvailable -= mappedFrames;
            } else {
                framesAvailable = 0;
            }
        }
    } else {
        // readi/writei.
        while (!pDevice->alsa.breakFromMainLoop) {
            mal_uint32 framesAvailable = mal_device__wait_for_frames__alsa(pDevice, NULL);
            if (framesAvailable == 0) {
                continue;
            }

            // Don't bother asking the client for more audio data if we're just stopping the device anyway.
            if (pDevice->alsa.breakFromMainLoop) {
                return MAL_FALSE;
            }

            mal_device__read_frames_from_client(pDevice, framesAvailable, pDevice->alsa.pIntermediaryBuffer);

            mal_snd_pcm_sframes_t framesWritten = ((mal_snd_pcm_writei_proc)pDevice->pContext->alsa.snd_pcm_writei)((mal_snd_pcm_t*)pDevice->alsa.pPCM, pDevice->alsa.pIntermediaryBuffer, framesAvailable);
            if (framesWritten < 0) {
                if (framesWritten == -EAGAIN) {
                    continue;   // Just keep trying...
                } else if (framesWritten == -EPIPE) {
                    // Underrun. Just recover and try writing again.
                    if (((mal_snd_pcm_recover_proc)pDevice->pContext->alsa.snd_pcm_recover)((mal_snd_pcm_t*)pDevice->alsa.pPCM, framesWritten, MAL_TRUE) < 0) {
                        mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to recover device after underrun.", MAL_FAILED_TO_START_BACKEND_DEVICE);
                        return MAL_FALSE;
                    }

                    framesWritten = ((mal_snd_pcm_writei_proc)pDevice->pContext->alsa.snd_pcm_writei)((mal_snd_pcm_t*)pDevice->alsa.pPCM, pDevice->alsa.pIntermediaryBuffer, framesAvailable);
                    if (framesWritten < 0) {
                        mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to write data to the internal device.", MAL_FAILED_TO_SEND_DATA_TO_DEVICE);
                        return MAL_FALSE;
                    }

                    break;  // Success.
                } else {
                    mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] snd_pcm_writei() failed when writing initial data.", MAL_FAILED_TO_SEND_DATA_TO_DEVICE);
                    return MAL_FALSE;
                }
            } else {
                break;  // Success.
            }
        }
    }

    return MAL_TRUE;
}

mal_bool32 mal_device_read_and_send_to_client__alsa(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);
    if (!mal_device_is_started(pDevice)) {
        return MAL_FALSE;
    }
    if (pDevice->alsa.breakFromMainLoop) {
        return MAL_FALSE;
    }

    mal_uint32 framesToSend = 0;
    void* pBuffer = NULL;
    if (pDevice->alsa.pIntermediaryBuffer == NULL) {
        // mmap.
        mal_bool32 requiresRestart;
        mal_uint32 framesAvailable = mal_device__wait_for_frames__alsa(pDevice, &requiresRestart);
        if (framesAvailable == 0) {
            return MAL_FALSE;
        }

        const mal_snd_pcm_channel_area_t* pAreas;
        mal_snd_pcm_uframes_t mappedOffset;
        mal_snd_pcm_uframes_t mappedFrames = framesAvailable;
        while (framesAvailable > 0) {
            int result = ((mal_snd_pcm_mmap_begin_proc)pDevice->pContext->alsa.snd_pcm_mmap_begin)((mal_snd_pcm_t*)pDevice->alsa.pPCM, &pAreas, &mappedOffset, &mappedFrames);
            if (result < 0) {
                return MAL_FALSE;
            }

            if (mappedFrames > 0) {
                void* pBuffer = (mal_uint8*)pAreas[0].addr + ((pAreas[0].first + (mappedOffset * pAreas[0].step)) / 8);
                mal_device__send_frames_to_client(pDevice, mappedFrames, pBuffer);
            }

            result = ((mal_snd_pcm_mmap_commit_proc)pDevice->pContext->alsa.snd_pcm_mmap_commit)((mal_snd_pcm_t*)pDevice->alsa.pPCM, mappedOffset, mappedFrames);
            if (result < 0 || (mal_snd_pcm_uframes_t)result != mappedFrames) {
                ((mal_snd_pcm_recover_proc)pDevice->pContext->alsa.snd_pcm_recover)((mal_snd_pcm_t*)pDevice->alsa.pPCM, result, MAL_TRUE);
                return MAL_FALSE;
            }

            if (requiresRestart) {
                if (((mal_snd_pcm_start_proc)pDevice->pContext->alsa.snd_pcm_start)((mal_snd_pcm_t*)pDevice->alsa.pPCM) < 0) {
                    return MAL_FALSE;
                }
            }

            if (framesAvailable >= mappedFrames) {
                framesAvailable -= mappedFrames;
            } else {
                framesAvailable = 0;
            }
        }
    } else {
        // readi/writei.
        mal_snd_pcm_sframes_t framesRead = 0;
        while (!pDevice->alsa.breakFromMainLoop) {
            mal_uint32 framesAvailable = mal_device__wait_for_frames__alsa(pDevice, NULL);
            if (framesAvailable == 0) {
                continue;
            }

            framesRead = ((mal_snd_pcm_readi_proc)pDevice->pContext->alsa.snd_pcm_readi)((mal_snd_pcm_t*)pDevice->alsa.pPCM, pDevice->alsa.pIntermediaryBuffer, framesAvailable);
            if (framesRead < 0) {
                if (framesRead == -EAGAIN) {
                    continue;   // Just keep trying...
                } else if (framesRead == -EPIPE) {
                    // Overrun. Just recover and try reading again.
                    if (((mal_snd_pcm_recover_proc)pDevice->pContext->alsa.snd_pcm_recover)((mal_snd_pcm_t*)pDevice->alsa.pPCM, framesRead, MAL_TRUE) < 0) {
                        mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to recover device after overrun.", MAL_FAILED_TO_START_BACKEND_DEVICE);
                        return MAL_FALSE;
                    }

                    framesRead = ((mal_snd_pcm_readi_proc)pDevice->pContext->alsa.snd_pcm_readi)((mal_snd_pcm_t*)pDevice->alsa.pPCM, pDevice->alsa.pIntermediaryBuffer, framesAvailable);
                    if (framesRead < 0) {
                        mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to read data from the internal device.", MAL_FAILED_TO_READ_DATA_FROM_DEVICE);
                        return MAL_FALSE;
                    }

                    break;  // Success.
                } else {
                    return MAL_FALSE;
                }
            } else {
                break;  // Success.
            }
        }

        framesToSend = framesRead;
        pBuffer = pDevice->alsa.pIntermediaryBuffer;
    }

    if (framesToSend > 0) {
        mal_device__send_frames_to_client(pDevice, framesToSend, pBuffer);
    }

    return MAL_TRUE;
}
#endif

void mal_device_uninit__alsa(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if ((mal_snd_pcm_t*)pDevice->alsa.pPCMCapture) {
        ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)((mal_snd_pcm_t*)pDevice->alsa.pPCMCapture);
    }

    if ((mal_snd_pcm_t*)pDevice->alsa.pPCMPlayback) {
        ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)((mal_snd_pcm_t*)pDevice->alsa.pPCMPlayback);
    }
}

mal_result mal_device_init_by_type__alsa(mal_context* pContext, const mal_device_config* pConfig, mal_device_type deviceType, mal_device* pDevice)
{
    mal_result result;
    mal_snd_pcm_t* pPCM;
    mal_bool32 isUsingMMap;
    mal_snd_pcm_format_t formatALSA;
    mal_share_mode shareMode;
    mal_device_id* pDeviceID;
    mal_format internalFormat;
    mal_uint32 internalChannels;
    mal_uint32 internalSampleRate;
    mal_channel internalChannelMap[MAL_MAX_CHANNELS];
    mal_uint32 internalBufferSizeInFrames;
    mal_uint32 internalPeriods;
    mal_snd_pcm_hw_params_t* pHWParams;
    mal_snd_pcm_sw_params_t* pSWParams;
    mal_snd_pcm_uframes_t bufferBoundary;

    mal_assert(pContext != NULL);
    mal_assert(pConfig != NULL);
    mal_assert(deviceType != mal_device_type_duplex); /* This function should only be called for playback _or_ capture, never duplex. */
    mal_assert(pDevice != NULL);

    formatALSA = mal_convert_mal_format_to_alsa_format((deviceType == mal_device_type_capture) ? pConfig->capture.format : pConfig->playback.format);
    shareMode  = (deviceType == mal_device_type_capture) ? pConfig->capture.shareMode : pConfig->playback.shareMode;
    pDeviceID  = (deviceType == mal_device_type_capture) ? pConfig->capture.pDeviceID : pConfig->playback.pDeviceID;

    result = mal_context_open_pcm__alsa(pContext, shareMode, deviceType, pDeviceID, &pPCM);
    if (result != MAL_SUCCESS) {
        return result;
    }

    /* If using the default buffer size we may want to apply some device-specific scaling for known devices that have peculiar latency characteristics */
    float bufferSizeScaleFactor = 1;
    if (pDevice->usingDefaultBufferSize) {
        mal_snd_pcm_info_t* pInfo = (mal_snd_pcm_info_t*)alloca(((mal_snd_pcm_info_sizeof_proc)pContext->alsa.snd_pcm_info_sizeof)());
        mal_zero_memory(pInfo, ((mal_snd_pcm_info_sizeof_proc)pContext->alsa.snd_pcm_info_sizeof)());

        /* We may need to scale the size of the buffer depending on the device. */
        if (((mal_snd_pcm_info_proc)pContext->alsa.snd_pcm_info)(pPCM, pInfo) == 0) {
            const char* deviceName = ((mal_snd_pcm_info_get_name_proc)pContext->alsa.snd_pcm_info_get_name)(pInfo);
            if (deviceName != NULL) {
                if (mal_strcmp(deviceName, "default") == 0) {
                    char** ppDeviceHints;
                    char** ppNextDeviceHint;

                    /* It's the default device. We need to use DESC from snd_device_name_hint(). */
                    if (((mal_snd_device_name_hint_proc)pContext->alsa.snd_device_name_hint)(-1, "pcm", (void***)&ppDeviceHints) < 0) {
                        return MAL_NO_BACKEND;
                    }

                    ppNextDeviceHint = ppDeviceHints;
                    while (*ppNextDeviceHint != NULL) {
                        char* NAME = ((mal_snd_device_name_get_hint_proc)pContext->alsa.snd_device_name_get_hint)(*ppNextDeviceHint, "NAME");
                        char* DESC = ((mal_snd_device_name_get_hint_proc)pContext->alsa.snd_device_name_get_hint)(*ppNextDeviceHint, "DESC");
                        char* IOID = ((mal_snd_device_name_get_hint_proc)pContext->alsa.snd_device_name_get_hint)(*ppNextDeviceHint, "IOID");

                        mal_bool32 foundDevice = MAL_FALSE;
                        if ((deviceType == mal_device_type_playback && (IOID == NULL || mal_strcmp(IOID, "Output") == 0)) ||
                            (deviceType == mal_device_type_capture  && (IOID != NULL && mal_strcmp(IOID, "Input" ) == 0))) {
                            if (mal_strcmp(NAME, deviceName) == 0) {
                                bufferSizeScaleFactor = mal_find_default_buffer_size_scale__alsa(DESC);
                                foundDevice = MAL_TRUE;
                            }
                        }

                        free(NAME);
                        free(DESC);
                        free(IOID);
                        ppNextDeviceHint += 1;

                        if (foundDevice) {
                            break;
                        }
                    }

                    ((mal_snd_device_name_free_hint_proc)pContext->alsa.snd_device_name_free_hint)((void**)ppDeviceHints);
                } else {
                    bufferSizeScaleFactor = mal_find_default_buffer_size_scale__alsa(deviceName);
                }
            }
        }
    }


    /* Hardware parameters. */
    pHWParams = (mal_snd_pcm_hw_params_t*)alloca(((mal_snd_pcm_hw_params_sizeof_proc)pContext->alsa.snd_pcm_hw_params_sizeof)());
    mal_zero_memory(pHWParams, ((mal_snd_pcm_hw_params_sizeof_proc)pContext->alsa.snd_pcm_hw_params_sizeof)());

    if (((mal_snd_pcm_hw_params_any_proc)pContext->alsa.snd_pcm_hw_params_any)(pPCM, pHWParams) < 0) {
        ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to initialize hardware parameters. snd_pcm_hw_params_any() failed.", MAL_FAILED_TO_CONFIGURE_BACKEND_DEVICE);
    }

    /* MMAP Mode. Try using interleaved MMAP access. If this fails, fall back to standard readi/writei. */
    isUsingMMap = MAL_FALSE;
#if 0   /* NOTE: MMAP mode temporarily disabled. */
    if (deviceType != mal_device_type_capture) {    /* <-- Disabling MMAP mode for capture devices because I apparently do not have a device that supports it which means I can't test it... Contributions welcome. */
        if (!pConfig->alsa.noMMap && mal_device__is_async(pDevice)) {
            if (((mal_snd_pcm_hw_params_set_access_proc)pContext->alsa.snd_pcm_hw_params_set_access)(pPCM, pHWParams, MAL_SND_PCM_ACCESS_MMAP_INTERLEAVED) == 0) {
                pDevice->alsa.isUsingMMap = MAL_TRUE;
            }
        }
    }
#endif

    if (!isUsingMMap) {
        if (((mal_snd_pcm_hw_params_set_access_proc)pContext->alsa.snd_pcm_hw_params_set_access)(pPCM, pHWParams, MAL_SND_PCM_ACCESS_RW_INTERLEAVED) < 0) {;
            ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to set access mode to neither SND_PCM_ACCESS_MMAP_INTERLEAVED nor SND_PCM_ACCESS_RW_INTERLEAVED. snd_pcm_hw_params_set_access() failed.", MAL_FORMAT_NOT_SUPPORTED);
        }
    }

    /*
    Most important properties first. The documentation for OSS (yes, I know this is ALSA!) recommends format, channels, then sample rate. I can't
    find any documentation for ALSA specifically, so I'm going to copy the recommendation for OSS.
    */

    /* Format. */
    {
        mal_snd_pcm_format_mask_t* pFormatMask;

        /* Try getting every supported format first. */
        pFormatMask = (mal_snd_pcm_format_mask_t*)alloca(((mal_snd_pcm_format_mask_sizeof_proc)pContext->alsa.snd_pcm_format_mask_sizeof)());
        mal_zero_memory(pFormatMask, ((mal_snd_pcm_format_mask_sizeof_proc)pContext->alsa.snd_pcm_format_mask_sizeof)());

        ((mal_snd_pcm_hw_params_get_format_mask_proc)pContext->alsa.snd_pcm_hw_params_get_format_mask)(pHWParams, pFormatMask);

        /*
        At this point we should have a list of supported formats, so now we need to find the best one. We first check if the requested format is
        supported, and if so, use that one. If it's not supported, we just run though a list of formats and try to find the best one.
        */
        if (!((mal_snd_pcm_format_mask_test_proc)pContext->alsa.snd_pcm_format_mask_test)(pFormatMask, formatALSA)) {
            /* The requested format is not supported so now try running through the list of formats and return the best one. */
            mal_snd_pcm_format_t preferredFormatsALSA[] = {
                MAL_SND_PCM_FORMAT_S16_LE,      /* mal_format_s16 */
                MAL_SND_PCM_FORMAT_FLOAT_LE,    /* mal_format_f32 */
                MAL_SND_PCM_FORMAT_S32_LE,      /* mal_format_s32 */
                MAL_SND_PCM_FORMAT_S24_3LE,     /* mal_format_s24 */
                MAL_SND_PCM_FORMAT_U8           /* mal_format_u8 */
            };

            if (mal_is_big_endian()) {
                preferredFormatsALSA[0] = MAL_SND_PCM_FORMAT_S16_BE;
                preferredFormatsALSA[1] = MAL_SND_PCM_FORMAT_FLOAT_BE;
                preferredFormatsALSA[2] = MAL_SND_PCM_FORMAT_S32_BE;
                preferredFormatsALSA[3] = MAL_SND_PCM_FORMAT_S24_3BE;
                preferredFormatsALSA[4] = MAL_SND_PCM_FORMAT_U8;
            }

            formatALSA = MAL_SND_PCM_FORMAT_UNKNOWN;
            for (size_t i = 0; i < (sizeof(preferredFormatsALSA) / sizeof(preferredFormatsALSA[0])); ++i) {
                if (((mal_snd_pcm_format_mask_test_proc)pContext->alsa.snd_pcm_format_mask_test)(pFormatMask, preferredFormatsALSA[i])) {
                    formatALSA = preferredFormatsALSA[i];
                    break;
                }
            }

            if (formatALSA == MAL_SND_PCM_FORMAT_UNKNOWN) {
                ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
                return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Format not supported. The device does not support any mini_al formats.", MAL_FORMAT_NOT_SUPPORTED);
            }
        }

        if (((mal_snd_pcm_hw_params_set_format_proc)pContext->alsa.snd_pcm_hw_params_set_format)(pPCM, pHWParams, formatALSA) < 0) {
            ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Format not supported. snd_pcm_hw_params_set_format() failed.", MAL_FORMAT_NOT_SUPPORTED);
        }
        
        internalFormat = mal_convert_alsa_format_to_mal_format(formatALSA);
        if (internalFormat == mal_format_unknown) {
            ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] The chosen format is not supported by mini_al.", MAL_FORMAT_NOT_SUPPORTED);
        }
    }

    /* Channels. */
    {
        unsigned int channels = (deviceType == mal_device_type_capture) ? pConfig->capture.channels : pConfig->playback.channels;
        if (((mal_snd_pcm_hw_params_set_channels_near_proc)pContext->alsa.snd_pcm_hw_params_set_channels_near)(pPCM, pHWParams, &channels) < 0) {
            ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to set channel count. snd_pcm_hw_params_set_channels_near() failed.", MAL_FORMAT_NOT_SUPPORTED);
        }
        internalChannels = (mal_uint32)channels;
    }

    /* Sample Rate */
    {
        unsigned int sampleRate;

        /*
        It appears there's either a bug in ALSA, a bug in some drivers, or I'm doing something silly; but having resampling enabled causes
        problems with some device configurations when used in conjunction with MMAP access mode. To fix this problem we need to disable
        resampling.
        
        To reproduce this problem, open the "plug:dmix" device, and set the sample rate to 44100. Internally, it looks like dmix uses a
        sample rate of 48000. The hardware parameters will get set correctly with no errors, but it looks like the 44100 -> 48000 resampling
        doesn't work properly - but only with MMAP access mode. You will notice skipping/crackling in the audio, and it'll run at a slightly
        faster rate.
        
        mini_al has built-in support for sample rate conversion (albeit low quality at the moment), so disabling resampling should be fine
        for us. The only problem is that it won't be taking advantage of any kind of hardware-accelerated resampling and it won't be very
        good quality until I get a chance to improve the quality of mini_al's software sample rate conversion.
        
        I don't currently know if the dmix plugin is the only one with this error. Indeed, this is the only one I've been able to reproduce
        this error with. In the future, we may want to restrict the disabling of resampling to only known bad plugins.
        */
        ((mal_snd_pcm_hw_params_set_rate_resample_proc)pContext->alsa.snd_pcm_hw_params_set_rate_resample)(pPCM, pHWParams, 0);

        sampleRate = pConfig->sampleRate;
        if (((mal_snd_pcm_hw_params_set_rate_near_proc)pContext->alsa.snd_pcm_hw_params_set_rate_near)(pPCM, pHWParams, &sampleRate, 0) < 0) {
            ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Sample rate not supported. snd_pcm_hw_params_set_rate_near() failed.", MAL_FORMAT_NOT_SUPPORTED);
        }
        internalSampleRate = (mal_uint32)sampleRate;
    }

    /* Buffer Size */
    {
        mal_snd_pcm_uframes_t actualBufferSizeInFrames = pConfig->bufferSizeInFrames;
        if (actualBufferSizeInFrames == 0) {
            actualBufferSizeInFrames = mal_scale_buffer_size(mal_calculate_buffer_size_in_frames_from_milliseconds(pConfig->bufferSizeInMilliseconds, internalSampleRate), bufferSizeScaleFactor);
        }

        if (((mal_snd_pcm_hw_params_set_buffer_size_near_proc)pContext->alsa.snd_pcm_hw_params_set_buffer_size_near)(pPCM, pHWParams, &actualBufferSizeInFrames) < 0) {
            ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to set buffer size for device. snd_pcm_hw_params_set_buffer_size() failed.", MAL_FORMAT_NOT_SUPPORTED);
        }
        internalBufferSizeInFrames = actualBufferSizeInFrames;
    }

    /* Periods. */
    {
        mal_uint32 periods = pConfig->periods;
        if (((mal_snd_pcm_hw_params_set_periods_near_proc)pContext->alsa.snd_pcm_hw_params_set_periods_near)(pPCM, pHWParams, &periods, NULL) < 0) {
            ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to set period count. snd_pcm_hw_params_set_periods_near() failed.", MAL_FORMAT_NOT_SUPPORTED);
        }
        internalPeriods = periods;
    }

    /* Apply hardware parameters. */
    if (((mal_snd_pcm_hw_params_proc)pContext->alsa.snd_pcm_hw_params)(pPCM, pHWParams) < 0) {
        ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to set hardware parameters. snd_pcm_hw_params() failed.", MAL_FAILED_TO_CONFIGURE_BACKEND_DEVICE);
    }


    /* Software parameters. */
    pSWParams = (mal_snd_pcm_sw_params_t*)alloca(((mal_snd_pcm_sw_params_sizeof_proc)pContext->alsa.snd_pcm_sw_params_sizeof)());
    mal_zero_memory(pSWParams, ((mal_snd_pcm_sw_params_sizeof_proc)pContext->alsa.snd_pcm_sw_params_sizeof)());

    if (((mal_snd_pcm_sw_params_current_proc)pContext->alsa.snd_pcm_sw_params_current)(pPCM, pSWParams) != 0) {
        ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to initialize software parameters. snd_pcm_sw_params_current() failed.", MAL_FAILED_TO_CONFIGURE_BACKEND_DEVICE);
    }

    if (deviceType == mal_device_type_capture) {
        if (((mal_snd_pcm_sw_params_set_avail_min_proc)pContext->alsa.snd_pcm_sw_params_set_avail_min)(pPCM, pSWParams, 1) != 0) {
            ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] snd_pcm_sw_params_set_avail_min() failed.", MAL_FORMAT_NOT_SUPPORTED);
        }
    } else {
        if (((mal_snd_pcm_sw_params_set_avail_min_proc)pContext->alsa.snd_pcm_sw_params_set_avail_min)(pPCM, pSWParams, 1) != 0) {
            ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] snd_pcm_sw_params_set_avail_min() failed.", MAL_FORMAT_NOT_SUPPORTED);
        }
    }
    

    if (((mal_snd_pcm_sw_params_get_boundary_proc)pContext->alsa.snd_pcm_sw_params_get_boundary)(pSWParams, &bufferBoundary) < 0) {
        bufferBoundary = internalBufferSizeInFrames;
    }

    //printf("TRACE: bufferBoundary=%ld\n", bufferBoundary);

    if (deviceType == mal_device_type_playback && !isUsingMMap) {   /* Only playback devices in writei/readi mode need a start threshold. */
        /*
        Subtle detail here with the start threshold. When in playback-only mode (no full-duplex) we can set the start threshold to
        the size of a period. But for full-duplex we need to set it such that it is at least two periods.
        */
        if (((mal_snd_pcm_sw_params_set_start_threshold_proc)pContext->alsa.snd_pcm_sw_params_set_start_threshold)(pPCM, pSWParams, internalBufferSizeInFrames) != 0) {
            ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to set start threshold for playback device. snd_pcm_sw_params_set_start_threshold() failed.", MAL_FAILED_TO_CONFIGURE_BACKEND_DEVICE);
        }
        if (((mal_snd_pcm_sw_params_set_stop_threshold_proc)pContext->alsa.snd_pcm_sw_params_set_stop_threshold)(pPCM, pSWParams, bufferBoundary) != 0) { /* Set to boundary to loop instead of stop in the event of an xrun. */
            ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to set stop threshold for playback device. snd_pcm_sw_params_set_stop_threshold() failed.", MAL_FAILED_TO_CONFIGURE_BACKEND_DEVICE);
        }
    }

    if (((mal_snd_pcm_sw_params_proc)pContext->alsa.snd_pcm_sw_params)(pPCM, pSWParams) != 0) {
        ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to set software parameters. snd_pcm_sw_params() failed.", MAL_FAILED_TO_CONFIGURE_BACKEND_DEVICE);
    }


    /* Grab the internal channel map. For now we're not going to bother trying to change the channel map and instead just do it ourselves. */
    {
        mal_snd_pcm_chmap_t* pChmap = ((mal_snd_pcm_get_chmap_proc)pContext->alsa.snd_pcm_get_chmap)(pPCM);
        if (pChmap != NULL) {
            /* There are cases where the returned channel map can have a different channel count than was returned by snd_pcm_hw_params_set_channels_near(). */
            if (pChmap->channels >= internalChannels) {
                /* Drop excess channels. */
                for (mal_uint32 iChannel = 0; iChannel < internalChannels; ++iChannel) {
                    internalChannelMap[iChannel] = mal_convert_alsa_channel_position_to_mal_channel(pChmap->pos[iChannel]);
                }
            } else {
                /*
                Excess channels use defaults. Do an initial fill with defaults, overwrite the first pChmap->channels, validate to ensure there are no duplicate
                channels. If validation fails, fall back to defaults.
                */
                mal_bool32 isValid = MAL_TRUE;

                /* Fill with defaults. */
                mal_get_standard_channel_map(mal_standard_channel_map_alsa, internalChannels, internalChannelMap);

                /* Overwrite first pChmap->channels channels. */
                for (mal_uint32 iChannel = 0; iChannel < pChmap->channels; ++iChannel) {
                    internalChannelMap[iChannel] = mal_convert_alsa_channel_position_to_mal_channel(pChmap->pos[iChannel]);
                }

                /* Validate. */
                for (mal_uint32 i = 0; i < internalChannels && isValid; ++i) {
                    for (mal_uint32 j = i+1; j < internalChannels; ++j) {
                        if (internalChannelMap[i] == internalChannelMap[j]) {
                            isValid = MAL_FALSE;
                            break;
                        }
                    }
                }

                /* If our channel map is invalid, fall back to defaults. */
                if (!isValid) {
                    mal_get_standard_channel_map(mal_standard_channel_map_alsa, internalChannels, internalChannelMap);
                }
            }

            free(pChmap);
            pChmap = NULL;
        } else {
            /* Could not retrieve the channel map. Fall back to a hard-coded assumption. */
            mal_get_standard_channel_map(mal_standard_channel_map_alsa, internalChannels, internalChannelMap);
        }
    }


    /* We're done. Prepare the device. */
    if (((mal_snd_pcm_prepare_proc)pDevice->pContext->alsa.snd_pcm_prepare)(pPCM) < 0) {
        ((mal_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to prepare device.", MAL_FAILED_TO_START_BACKEND_DEVICE);
    }


    if (deviceType == mal_device_type_capture) {
        pDevice->alsa.pPCMCapture                    = (mal_ptr)pPCM;
        pDevice->alsa.isUsingMMapCapture             = isUsingMMap;
        pDevice->capture.internalFormat              = internalFormat;
        pDevice->capture.internalChannels            = internalChannels;
        pDevice->capture.internalSampleRate          = internalSampleRate;
        mal_channel_map_copy(pDevice->capture.internalChannelMap, internalChannelMap, internalChannels);
        pDevice->capture.internalBufferSizeInFrames  = internalBufferSizeInFrames;
        pDevice->capture.internalPeriods             = internalPeriods;
    } else {
        pDevice->alsa.pPCMPlayback                   = (mal_ptr)pPCM;
        pDevice->alsa.isUsingMMapPlayback            = isUsingMMap;
        pDevice->playback.internalFormat             = internalFormat;
        pDevice->playback.internalChannels           = internalChannels;
        pDevice->playback.internalSampleRate         = internalSampleRate;
        mal_channel_map_copy(pDevice->playback.internalChannelMap, internalChannelMap, internalChannels);
        pDevice->playback.internalBufferSizeInFrames = internalBufferSizeInFrames;
        pDevice->playback.internalPeriods            = internalPeriods;
    }

    return MAL_SUCCESS;
}

mal_result mal_device_init__alsa(mal_context* pContext, const mal_device_config* pConfig, mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    mal_zero_object(&pDevice->alsa);

    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        mal_result result = mal_device_init_by_type__alsa(pContext, pConfig, mal_device_type_capture, pDevice);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        mal_result result = mal_device_init_by_type__alsa(pContext, pConfig, mal_device_type_playback, pDevice);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    return MAL_SUCCESS;
}

#if 0
mal_result mal_device_start__alsa(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    // Prepare the device first...
    if (((mal_snd_pcm_prepare_proc)pDevice->pContext->alsa.snd_pcm_prepare)((mal_snd_pcm_t*)pDevice->alsa.pPCM) < 0) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to prepare device.", MAL_FAILED_TO_START_BACKEND_DEVICE);
    }

    // ... and then grab an initial chunk from the client. After this is done, the device should
    // automatically start playing, since that's how we configured the software parameters.
    if (pDevice->type == mal_device_type_playback) {
        if (!mal_device_read_from_client_and_write__alsa(pDevice)) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to write initial chunk of data to the playback device.", MAL_FAILED_TO_SEND_DATA_TO_DEVICE);
        }

        // mmap mode requires an explicit start.
        if (pDevice->alsa.isUsingMMap) {
            if (((mal_snd_pcm_start_proc)pDevice->pContext->alsa.snd_pcm_start)((mal_snd_pcm_t*)pDevice->alsa.pPCM) < 0) {
                return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to start capture device.", MAL_FAILED_TO_START_BACKEND_DEVICE);
            }
        }
    } else {
        if (((mal_snd_pcm_start_proc)pDevice->pContext->alsa.snd_pcm_start)((mal_snd_pcm_t*)pDevice->alsa.pPCM) < 0) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to start capture device.", MAL_FAILED_TO_START_BACKEND_DEVICE);
        }
    }

    return MAL_SUCCESS;
}
#endif

mal_result mal_device_stop__alsa(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        ((mal_snd_pcm_drain_proc)pDevice->pContext->alsa.snd_pcm_drain)((mal_snd_pcm_t*)pDevice->alsa.pPCMCapture);
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        /* Using drain instead of drop because mal_device_stop() is defined such that pending frames are processed before returning. */
        ((mal_snd_pcm_drain_proc)pDevice->pContext->alsa.snd_pcm_drain)((mal_snd_pcm_t*)pDevice->alsa.pPCMPlayback);
    }

    
    return MAL_SUCCESS;
}

mal_result mal_device_write__alsa(mal_device* pDevice, const void* pPCMFrames, mal_uint32 frameCount)
{
    mal_snd_pcm_sframes_t resultALSA;
    mal_uint32 totalPCMFramesProcessed;

    mal_assert(pDevice != NULL);
    mal_assert(pPCMFrames != NULL);

    //printf("TRACE: Enter write()\n");

    totalPCMFramesProcessed = 0;
    while (totalPCMFramesProcessed < frameCount) {
        const void* pSrc = mal_offset_ptr(pPCMFrames, totalPCMFramesProcessed * mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels));
        mal_uint32 framesRemaining = (frameCount - totalPCMFramesProcessed);

        //printf("TRACE: Writing %d frames (frameCount=%d)\n", framesRemaining, frameCount);

        resultALSA = ((mal_snd_pcm_writei_proc)pDevice->pContext->alsa.snd_pcm_writei)((mal_snd_pcm_t*)pDevice->alsa.pPCMPlayback, pSrc, framesRemaining);
        if (resultALSA < 0) {
            if (resultALSA == -EAGAIN) {
                //printf("TRACE: EGAIN (write)\n");
                continue;   /* Try again. */
            } else if (resultALSA == -EPIPE) {
                //printf("TRACE: EPIPE (write)\n");

                /* Underrun. Recover and try again. If this fails we need to return an error. */
                if (((mal_snd_pcm_recover_proc)pDevice->pContext->alsa.snd_pcm_recover)((mal_snd_pcm_t*)pDevice->alsa.pPCMPlayback, resultALSA, MAL_TRUE) < 0) { /* MAL_TRUE=silent (don't print anything on error). */
                    return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to recover device after underrun.", MAL_FAILED_TO_START_BACKEND_DEVICE);
                }

                /*
                In my testing I have had a situation where writei() does not automatically restart the device even though I've set it
                up as such in the software parameters. What will happen is writei() will block indefinitely even though the number of
                frames is well beyond the auto-start threshold. To work around this I've needed to add an explicit start here. Not sure
                if this is me just being stupid and not recovering the device properly, but this definitely feels like something isn't
                quite right here.
                */
                if (((mal_snd_pcm_start_proc)pDevice->pContext->alsa.snd_pcm_start)((mal_snd_pcm_t*)pDevice->alsa.pPCMPlayback) < 0) {
                    return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to start device after underrun.", MAL_FAILED_TO_START_BACKEND_DEVICE);
                }

                resultALSA = ((mal_snd_pcm_writei_proc)pDevice->pContext->alsa.snd_pcm_writei)((mal_snd_pcm_t*)pDevice->alsa.pPCMPlayback, pSrc, framesRemaining);
                if (resultALSA < 0) {
                    return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to write data to device after underrun.", MAL_FAILED_TO_START_BACKEND_DEVICE);
                }
            }
        }

        totalPCMFramesProcessed += resultALSA;
    }

    return MAL_SUCCESS;
}

mal_result mal_device_read__alsa(mal_device* pDevice, void* pPCMFrames, mal_uint32 frameCount)
{
    mal_snd_pcm_sframes_t resultALSA;
    mal_uint32 totalPCMFramesProcessed;

    mal_assert(pDevice != NULL);
    mal_assert(pPCMFrames != NULL);

    /* We need to explicitly start the device if it isn't already. */
    if (((mal_snd_pcm_state_proc)pDevice->pContext->alsa.snd_pcm_state)((mal_snd_pcm_t*)pDevice->alsa.pPCMCapture) != MAL_SND_PCM_STATE_RUNNING) {
        if (((mal_snd_pcm_start_proc)pDevice->pContext->alsa.snd_pcm_start)((mal_snd_pcm_t*)pDevice->alsa.pPCMCapture) < 0) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to start device in preparation for reading.", MAL_FAILED_TO_START_BACKEND_DEVICE);
        }
    }

    totalPCMFramesProcessed = 0;
    while (totalPCMFramesProcessed < frameCount) {
        void* pDst = mal_offset_ptr(pPCMFrames, totalPCMFramesProcessed * mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));
        mal_uint32 framesRemaining = (frameCount - totalPCMFramesProcessed);

        //printf("TRACE: snd_pcm_readi(framesRemaining=%d)\n", framesRemaining);

        resultALSA = ((mal_snd_pcm_readi_proc)pDevice->pContext->alsa.snd_pcm_readi)((mal_snd_pcm_t*)pDevice->alsa.pPCMCapture, pDst, framesRemaining);
        if (resultALSA < 0) {
            if (resultALSA == -EAGAIN) {
                //printf("TRACE: EGAIN (read)\n");
                continue;
            } else if (resultALSA == -EPIPE) {
                //printf("TRACE: EPIPE (read)\n");

                /* Overrun. Recover and try again. If this fails we need to return an error. */
                if (((mal_snd_pcm_recover_proc)pDevice->pContext->alsa.snd_pcm_recover)((mal_snd_pcm_t*)pDevice->alsa.pPCMCapture, resultALSA, MAL_TRUE) < 0) {
                    return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to recover device after overrun.", MAL_FAILED_TO_START_BACKEND_DEVICE);
                }

                if (((mal_snd_pcm_start_proc)pDevice->pContext->alsa.snd_pcm_start)((mal_snd_pcm_t*)pDevice->alsa.pPCMCapture) < 0) {
                    return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to start device after underrun.", MAL_FAILED_TO_START_BACKEND_DEVICE);
                }

                resultALSA = ((mal_snd_pcm_readi_proc)pDevice->pContext->alsa.snd_pcm_readi)((mal_snd_pcm_t*)pDevice->alsa.pPCMCapture, pDst, framesRemaining);
                if (resultALSA < 0) {
                    return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[ALSA] Failed to read data from the internal device.", MAL_FAILED_TO_READ_DATA_FROM_DEVICE);
                }
            }
        }

        totalPCMFramesProcessed += resultALSA;
    }

    return MAL_SUCCESS;
}

#if 0
mal_result mal_device_break_main_loop__alsa(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    pDevice->alsa.breakFromMainLoop = MAL_TRUE;
    return MAL_SUCCESS;
}

mal_result mal_device_main_loop__alsa(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    pDevice->alsa.breakFromMainLoop = MAL_FALSE;
    if (pDevice->type == mal_device_type_playback) {
        // Playback. Read from client, write to device.
        while (!pDevice->alsa.breakFromMainLoop && mal_device_read_from_client_and_write__alsa(pDevice)) {
        }
    } else {
        // Capture. Read from device, write to client.
        while (!pDevice->alsa.breakFromMainLoop && mal_device_read_and_send_to_client__alsa(pDevice)) {
        }
    }

    return MAL_SUCCESS;
}
#endif

mal_result mal_context_uninit__alsa(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    mal_assert(pContext->backend == mal_backend_alsa);

    // Clean up memory for memory leak checkers.
    ((mal_snd_config_update_free_global_proc)pContext->alsa.snd_config_update_free_global)();

#ifndef MAL_NO_RUNTIME_LINKING
    mal_dlclose(pContext->alsa.asoundSO);
#endif

    mal_mutex_uninit(&pContext->alsa.internalDeviceEnumLock);

    return MAL_SUCCESS;
}

mal_result mal_context_init__alsa(mal_context* pContext)
{
    mal_assert(pContext != NULL);

#ifndef MAL_NO_RUNTIME_LINKING
    const char* libasoundNames[] = {
        "libasound.so.2",
        "libasound.so"
    };

    for (size_t i = 0; i < mal_countof(libasoundNames); ++i) {
        pContext->alsa.asoundSO = mal_dlopen(libasoundNames[i]);
        if (pContext->alsa.asoundSO != NULL) {
            break;
        }
    }

    if (pContext->alsa.asoundSO == NULL) {
#ifdef MAL_DEBUG_OUTPUT
        printf("[ALSA] Failed to open shared object.\n");
#endif
        return MAL_NO_BACKEND;
    }

    pContext->alsa.snd_pcm_open                           = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_open");
    pContext->alsa.snd_pcm_close                          = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_close");
    pContext->alsa.snd_pcm_hw_params_sizeof               = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_sizeof");
    pContext->alsa.snd_pcm_hw_params_any                  = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_any");
    pContext->alsa.snd_pcm_hw_params_set_format           = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_set_format");
    pContext->alsa.snd_pcm_hw_params_set_format_first     = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_set_format_first");
    pContext->alsa.snd_pcm_hw_params_get_format_mask      = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_get_format_mask");
    pContext->alsa.snd_pcm_hw_params_set_channels_near    = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_set_channels_near");
    pContext->alsa.snd_pcm_hw_params_set_rate_resample    = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_set_rate_resample");
    pContext->alsa.snd_pcm_hw_params_set_rate_near        = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_set_rate_near");
    pContext->alsa.snd_pcm_hw_params_set_buffer_size_near = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_set_buffer_size_near");
    pContext->alsa.snd_pcm_hw_params_set_periods_near     = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_set_periods_near");
    pContext->alsa.snd_pcm_hw_params_set_access           = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_set_access");
    pContext->alsa.snd_pcm_hw_params_get_format           = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_get_format");
    pContext->alsa.snd_pcm_hw_params_get_channels         = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_get_channels");
    pContext->alsa.snd_pcm_hw_params_get_channels_min     = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_get_channels_min");
    pContext->alsa.snd_pcm_hw_params_get_channels_max     = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_get_channels_max");
    pContext->alsa.snd_pcm_hw_params_get_rate             = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_get_rate");
    pContext->alsa.snd_pcm_hw_params_get_rate_min         = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_get_rate_min");
    pContext->alsa.snd_pcm_hw_params_get_rate_max         = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_get_rate_max");
    pContext->alsa.snd_pcm_hw_params_get_buffer_size      = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_get_buffer_size");
    pContext->alsa.snd_pcm_hw_params_get_periods          = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_get_periods");
    pContext->alsa.snd_pcm_hw_params_get_access           = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params_get_access");
    pContext->alsa.snd_pcm_hw_params                      = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_hw_params");
    pContext->alsa.snd_pcm_sw_params_sizeof               = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_sw_params_sizeof");
    pContext->alsa.snd_pcm_sw_params_current              = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_sw_params_current");
    pContext->alsa.snd_pcm_sw_params_get_boundary         = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_sw_params_get_boundary");
    pContext->alsa.snd_pcm_sw_params_set_avail_min        = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_sw_params_set_avail_min");
    pContext->alsa.snd_pcm_sw_params_set_start_threshold  = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_sw_params_set_start_threshold");
    pContext->alsa.snd_pcm_sw_params_set_stop_threshold   = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_sw_params_set_stop_threshold");
    pContext->alsa.snd_pcm_sw_params                      = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_sw_params");
    pContext->alsa.snd_pcm_format_mask_sizeof             = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_format_mask_sizeof");
    pContext->alsa.snd_pcm_format_mask_test               = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_format_mask_test");
    pContext->alsa.snd_pcm_get_chmap                      = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_get_chmap");
    pContext->alsa.snd_pcm_state                          = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_state");
    pContext->alsa.snd_pcm_prepare                        = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_prepare");
    pContext->alsa.snd_pcm_start                          = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_start");
    pContext->alsa.snd_pcm_drop                           = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_drop");
    pContext->alsa.snd_pcm_drain                          = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_drain");
    pContext->alsa.snd_device_name_hint                   = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_device_name_hint");
    pContext->alsa.snd_device_name_get_hint               = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_device_name_get_hint");
    pContext->alsa.snd_card_get_index                     = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_card_get_index");
    pContext->alsa.snd_device_name_free_hint              = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_device_name_free_hint");
    pContext->alsa.snd_pcm_mmap_begin                     = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_mmap_begin");
    pContext->alsa.snd_pcm_mmap_commit                    = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_mmap_commit");
    pContext->alsa.snd_pcm_recover                        = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_recover");
    pContext->alsa.snd_pcm_readi                          = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_readi");
    pContext->alsa.snd_pcm_writei                         = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_writei");
    pContext->alsa.snd_pcm_avail                          = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_avail");
    pContext->alsa.snd_pcm_avail_update                   = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_avail_update");
    pContext->alsa.snd_pcm_wait                           = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_wait");
    pContext->alsa.snd_pcm_info                           = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_info");
    pContext->alsa.snd_pcm_info_sizeof                    = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_info_sizeof");
    pContext->alsa.snd_pcm_info_get_name                  = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_pcm_info_get_name");
    pContext->alsa.snd_config_update_free_global          = (mal_proc)mal_dlsym(pContext->alsa.asoundSO, "snd_config_update_free_global");
#else
    // The system below is just for type safety.
    mal_snd_pcm_open_proc                           _snd_pcm_open                           = snd_pcm_open;
    mal_snd_pcm_close_proc                          _snd_pcm_close                          = snd_pcm_close;
    mal_snd_pcm_hw_params_sizeof_proc               _snd_pcm_hw_params_sizeof               = snd_pcm_hw_params_sizeof;
    mal_snd_pcm_hw_params_any_proc                  _snd_pcm_hw_params_any                  = snd_pcm_hw_params_any;
    mal_snd_pcm_hw_params_set_format_proc           _snd_pcm_hw_params_set_format           = snd_pcm_hw_params_set_format;
    mal_snd_pcm_hw_params_set_format_first_proc     _snd_pcm_hw_params_set_format_first     = snd_pcm_hw_params_set_format_first;
    mal_snd_pcm_hw_params_get_format_mask_proc      _snd_pcm_hw_params_get_format_mask      = snd_pcm_hw_params_get_format_mask;
    mal_snd_pcm_hw_params_set_channels_near_proc    _snd_pcm_hw_params_set_channels_near    = snd_pcm_hw_params_set_channels_near;
    mal_snd_pcm_hw_params_set_rate_resample_proc    _snd_pcm_hw_params_set_rate_resample    = snd_pcm_hw_params_set_rate_resample;
    mal_snd_pcm_hw_params_set_rate_near_proc        _snd_pcm_hw_params_set_rate_near        = snd_pcm_hw_params_set_rate_near;
    mal_snd_pcm_hw_params_set_buffer_size_near_proc _snd_pcm_hw_params_set_buffer_size_near = snd_pcm_hw_params_set_buffer_size_near;
    mal_snd_pcm_hw_params_set_periods_near_proc     _snd_pcm_hw_params_set_periods_near     = snd_pcm_hw_params_set_periods_near;
    mal_snd_pcm_hw_params_set_access_proc           _snd_pcm_hw_params_set_access           = snd_pcm_hw_params_set_access;
    mal_snd_pcm_hw_params_get_format_proc           _snd_pcm_hw_params_get_format           = snd_pcm_hw_params_get_format;
    mal_snd_pcm_hw_params_get_channels_proc         _snd_pcm_hw_params_get_channels         = snd_pcm_hw_params_get_channels;
    mal_snd_pcm_hw_params_get_channels_min_proc     _snd_pcm_hw_params_get_channels_min     = snd_pcm_hw_params_get_channels_min;
    mal_snd_pcm_hw_params_get_channels_max_proc     _snd_pcm_hw_params_get_channels_max     = snd_pcm_hw_params_get_channels_max;
    mal_snd_pcm_hw_params_get_rate_proc             _snd_pcm_hw_params_get_rate             = snd_pcm_hw_params_get_rate;
    mal_snd_pcm_hw_params_get_rate_min_proc         _snd_pcm_hw_params_get_rate_min         = snd_pcm_hw_params_get_rate_min;
    mal_snd_pcm_hw_params_get_rate_max_proc         _snd_pcm_hw_params_get_rate_max         = snd_pcm_hw_params_get_rate_max;
    mal_snd_pcm_hw_params_get_buffer_size_proc      _snd_pcm_hw_params_get_buffer_size      = snd_pcm_hw_params_get_buffer_size;
    mal_snd_pcm_hw_params_get_periods_proc          _snd_pcm_hw_params_get_periods          = snd_pcm_hw_params_get_periods;
    mal_snd_pcm_hw_params_get_access_proc           _snd_pcm_hw_params_get_access           = snd_pcm_hw_params_get_access;
    mal_snd_pcm_hw_params_proc                      _snd_pcm_hw_params                      = snd_pcm_hw_params;
    mal_snd_pcm_sw_params_sizeof_proc               _snd_pcm_sw_params_sizeof               = snd_pcm_sw_params_sizeof;
    mal_snd_pcm_sw_params_current_proc              _snd_pcm_sw_params_current              = snd_pcm_sw_params_current;
    mal_snd_pcm_sw_params_get_boundary_proc         _snd_pcm_sw_params_get_boundary         = snd_pcm_sw_params_get_boundary;
    mal_snd_pcm_sw_params_set_avail_min_proc        _snd_pcm_sw_params_set_avail_min        = snd_pcm_sw_params_set_avail_min;
    mal_snd_pcm_sw_params_set_start_threshold_proc  _snd_pcm_sw_params_set_start_threshold  = snd_pcm_sw_params_set_start_threshold;
    mal_snd_pcm_sw_params_set_stop_threshold_proc   _snd_pcm_sw_params_set_stop_threshold   = snd_pcm_sw_params_set_stop_threshold;
    mal_snd_pcm_sw_params_proc                      _snd_pcm_sw_params                      = snd_pcm_sw_params;
    mal_snd_pcm_format_mask_sizeof_proc             _snd_pcm_format_mask_sizeof             = snd_pcm_format_mask_sizeof;
    mal_snd_pcm_format_mask_test_proc               _snd_pcm_format_mask_test               = snd_pcm_format_mask_test;
    mal_snd_pcm_get_chmap_proc                      _snd_pcm_get_chmap                      = snd_pcm_get_chmap;
    mal_snd_pcm_state_proc                          _snd_pcm_state                          = snd_pcm_state;
    mal_snd_pcm_prepare_proc                        _snd_pcm_prepare                        = snd_pcm_prepare;
    mal_snd_pcm_start_proc                          _snd_pcm_start                          = snd_pcm_start;
    mal_snd_pcm_drop_proc                           _snd_pcm_drop                           = snd_pcm_drop;
    mal_snd_pcm_drain_proc                          _snd_pcm_drain                          = snd_pcm_drain;
    mal_snd_device_name_hint_proc                   _snd_device_name_hint                   = snd_device_name_hint;
    mal_snd_device_name_get_hint_proc               _snd_device_name_get_hint               = snd_device_name_get_hint;
    mal_snd_card_get_index_proc                     _snd_card_get_index                     = snd_card_get_index;
    mal_snd_device_name_free_hint_proc              _snd_device_name_free_hint              = snd_device_name_free_hint;
    mal_snd_pcm_mmap_begin_proc                     _snd_pcm_mmap_begin                     = snd_pcm_mmap_begin;
    mal_snd_pcm_mmap_commit_proc                    _snd_pcm_mmap_commit                    = snd_pcm_mmap_commit;
    mal_snd_pcm_recover_proc                        _snd_pcm_recover                        = snd_pcm_recover;
    mal_snd_pcm_readi_proc                          _snd_pcm_readi                          = snd_pcm_readi;
    mal_snd_pcm_writei_proc                         _snd_pcm_writei                         = snd_pcm_writei;
    mal_snd_pcm_avail_proc                          _snd_pcm_avail                          = snd_pcm_avail;
    mal_snd_pcm_avail_update_proc                   _snd_pcm_avail_update                   = snd_pcm_avail_update;
    mal_snd_pcm_wait_proc                           _snd_pcm_wait                           = snd_pcm_wait;
    mal_snd_pcm_info_proc                           _snd_pcm_info                           = snd_pcm_info;
    mal_snd_pcm_info_sizeof_proc                    _snd_pcm_info_sizeof                    = snd_pcm_info_sizeof;
    mal_snd_pcm_info_get_name_proc                  _snd_pcm_info_get_name                  = snd_pcm_info_get_name;
    mal_snd_config_update_free_global_proc          _snd_config_update_free_global          = snd_config_update_free_global;

    pContext->alsa.snd_pcm_open                           = (mal_proc)_snd_pcm_open;
    pContext->alsa.snd_pcm_close                          = (mal_proc)_snd_pcm_close;
    pContext->alsa.snd_pcm_hw_params_sizeof               = (mal_proc)_snd_pcm_hw_params_sizeof;
    pContext->alsa.snd_pcm_hw_params_any                  = (mal_proc)_snd_pcm_hw_params_any;
    pContext->alsa.snd_pcm_hw_params_set_format           = (mal_proc)_snd_pcm_hw_params_set_format;
    pContext->alsa.snd_pcm_hw_params_set_format_first     = (mal_proc)_snd_pcm_hw_params_set_format_first;
    pContext->alsa.snd_pcm_hw_params_get_format_mask      = (mal_proc)_snd_pcm_hw_params_get_format_mask;
    pContext->alsa.snd_pcm_hw_params_set_channels_near    = (mal_proc)_snd_pcm_hw_params_set_channels_near;
    pContext->alsa.snd_pcm_hw_params_set_rate_resample    = (mal_proc)_snd_pcm_hw_params_set_rate_resample;
    pContext->alsa.snd_pcm_hw_params_set_rate_near        = (mal_proc)_snd_pcm_hw_params_set_rate_near;
    pContext->alsa.snd_pcm_hw_params_set_buffer_size_near = (mal_proc)_snd_pcm_hw_params_set_buffer_size_near;
    pContext->alsa.snd_pcm_hw_params_set_periods_near     = (mal_proc)_snd_pcm_hw_params_set_periods_near;
    pContext->alsa.snd_pcm_hw_params_set_access           = (mal_proc)_snd_pcm_hw_params_set_access;
    pContext->alsa.snd_pcm_hw_params_get_format           = (mal_proc)_snd_pcm_hw_params_get_format;
    pContext->alsa.snd_pcm_hw_params_get_channels         = (mal_proc)_snd_pcm_hw_params_get_channels;
    pContext->alsa.snd_pcm_hw_params_get_channels_min     = (mal_proc)_snd_pcm_hw_params_get_channels_min;
    pContext->alsa.snd_pcm_hw_params_get_channels_max     = (mal_proc)_snd_pcm_hw_params_get_channels_max;
    pContext->alsa.snd_pcm_hw_params_get_rate             = (mal_proc)_snd_pcm_hw_params_get_rate;
    pContext->alsa.snd_pcm_hw_params_get_buffer_size      = (mal_proc)_snd_pcm_hw_params_get_buffer_size;
    pContext->alsa.snd_pcm_hw_params_get_periods          = (mal_proc)_snd_pcm_hw_params_get_periods;
    pContext->alsa.snd_pcm_hw_params_get_access           = (mal_proc)_snd_pcm_hw_params_get_access;
    pContext->alsa.snd_pcm_hw_params                      = (mal_proc)_snd_pcm_hw_params;
    pContext->alsa.snd_pcm_sw_params_sizeof               = (mal_proc)_snd_pcm_sw_params_sizeof;
    pContext->alsa.snd_pcm_sw_params_current              = (mal_proc)_snd_pcm_sw_params_current;
    pContext->alsa.snd_pcm_sw_params_get_boundary         = (mal_proc)_snd_pcm_sw_params_get_boundary;
    pContext->alsa.snd_pcm_sw_params_set_avail_min        = (mal_proc)_snd_pcm_sw_params_set_avail_min;
    pContext->alsa.snd_pcm_sw_params_set_start_threshold  = (mal_proc)_snd_pcm_sw_params_set_start_threshold;
    pContext->alsa.snd_pcm_sw_params_set_stop_threshold   = (mal_proc)_snd_pcm_sw_params_set_stop_threshold;
    pContext->alsa.snd_pcm_sw_params                      = (mal_proc)_snd_pcm_sw_params;
    pContext->alsa.snd_pcm_format_mask_sizeof             = (mal_proc)_snd_pcm_format_mask_sizeof;
    pContext->alsa.snd_pcm_format_mask_test               = (mal_proc)_snd_pcm_format_mask_test;
    pContext->alsa.snd_pcm_get_chmap                      = (mal_proc)_snd_pcm_get_chmap;
    pContext->alsa.snd_pcm_state                          = (mal_proc)_snd_pcm_state;
    pContext->alsa.snd_pcm_prepare                        = (mal_proc)_snd_pcm_prepare;
    pContext->alsa.snd_pcm_start                          = (mal_proc)_snd_pcm_start;
    pContext->alsa.snd_pcm_drop                           = (mal_proc)_snd_pcm_drop;
    pContext->alsa.snd_pcm_drain                          = (mal_proc)_snd_pcm_drain;
    pContext->alsa.snd_device_name_hint                   = (mal_proc)_snd_device_name_hint;
    pContext->alsa.snd_device_name_get_hint               = (mal_proc)_snd_device_name_get_hint;
    pContext->alsa.snd_card_get_index                     = (mal_proc)_snd_card_get_index;
    pContext->alsa.snd_device_name_free_hint              = (mal_proc)_snd_device_name_free_hint;
    pContext->alsa.snd_pcm_mmap_begin                     = (mal_proc)_snd_pcm_mmap_begin;
    pContext->alsa.snd_pcm_mmap_commit                    = (mal_proc)_snd_pcm_mmap_commit;
    pContext->alsa.snd_pcm_recover                        = (mal_proc)_snd_pcm_recover;
    pContext->alsa.snd_pcm_readi                          = (mal_proc)_snd_pcm_readi;
    pContext->alsa.snd_pcm_writei                         = (mal_proc)_snd_pcm_writei;
    pContext->alsa.snd_pcm_avail                          = (mal_proc)_snd_pcm_avail;
    pContext->alsa.snd_pcm_avail_update                   = (mal_proc)_snd_pcm_avail_update;
    pContext->alsa.snd_pcm_wait                           = (mal_proc)_snd_pcm_wait;
    pContext->alsa.snd_pcm_info                           = (mal_proc)_snd_pcm_info;
    pContext->alsa.snd_pcm_info_sizeof                    = (mal_proc)_snd_pcm_info_sizeof;
    pContext->alsa.snd_pcm_info_get_name                  = (mal_proc)_snd_pcm_info_get_name;
    pContext->alsa.snd_config_update_free_global          = (mal_proc)_snd_config_update_free_global;
#endif

    if (mal_mutex_init(pContext, &pContext->alsa.internalDeviceEnumLock) != MAL_SUCCESS) {
        mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[ALSA] WARNING: Failed to initialize mutex for internal device enumeration.", MAL_ERROR);
    }

    pContext->onUninit              = mal_context_uninit__alsa;
    pContext->onDeviceIDEqual       = mal_context_is_device_id_equal__alsa;
    pContext->onEnumDevices         = mal_context_enumerate_devices__alsa;
    pContext->onGetDeviceInfo       = mal_context_get_device_info__alsa;
    pContext->onDeviceInit          = mal_device_init__alsa;
    pContext->onDeviceUninit        = mal_device_uninit__alsa;
    pContext->onDeviceStart         = NULL; /*mal_device_start__alsa;*/
    pContext->onDeviceStop          = mal_device_stop__alsa;
    pContext->onDeviceWrite         = mal_device_write__alsa;
    pContext->onDeviceRead          = mal_device_read__alsa;

    return MAL_SUCCESS;
}
#endif  // ALSA



///////////////////////////////////////////////////////////////////////////////
//
// PulseAudio Backend
//
///////////////////////////////////////////////////////////////////////////////
#ifdef MAL_HAS_PULSEAUDIO

// It is assumed pulseaudio.h is available when compile-time linking is being used. We use this for type safety when using
// compile time linking (we don't have this luxury when using runtime linking without headers).
//
// When using compile time linking, each of our mal_* equivalents should use the sames types as defined by the header. The
// reason for this is that it allow us to take advantage of proper type safety.
#ifdef MAL_NO_RUNTIME_LINKING
#include <pulse/pulseaudio.h>

#define MAL_PA_OK                                       PA_OK
#define MAL_PA_ERR_ACCESS                               PA_ERR_ACCESS
#define MAL_PA_ERR_INVALID                              PA_ERR_INVALID
#define MAL_PA_ERR_NOENTITY                             PA_ERR_NOENTITY

#define MAL_PA_CHANNELS_MAX                             PA_CHANNELS_MAX
#define MAL_PA_RATE_MAX                                 PA_RATE_MAX

typedef pa_context_flags_t mal_pa_context_flags_t;
#define MAL_PA_CONTEXT_NOFLAGS                          PA_CONTEXT_NOFLAGS
#define MAL_PA_CONTEXT_NOAUTOSPAWN                      PA_CONTEXT_NOAUTOSPAWN
#define MAL_PA_CONTEXT_NOFAIL                           PA_CONTEXT_NOFAIL

typedef pa_stream_flags_t mal_pa_stream_flags_t;
#define MAL_PA_STREAM_NOFLAGS                           PA_STREAM_NOFLAGS
#define MAL_PA_STREAM_START_CORKED                      PA_STREAM_START_CORKED
#define MAL_PA_STREAM_INTERPOLATE_TIMING                PA_STREAM_INTERPOLATE_TIMING
#define MAL_PA_STREAM_NOT_MONOTONIC                     PA_STREAM_NOT_MONOTONIC
#define MAL_PA_STREAM_AUTO_TIMING_UPDATE                PA_STREAM_AUTO_TIMING_UPDATE
#define MAL_PA_STREAM_NO_REMAP_CHANNELS                 PA_STREAM_NO_REMAP_CHANNELS
#define MAL_PA_STREAM_NO_REMIX_CHANNELS                 PA_STREAM_NO_REMIX_CHANNELS
#define MAL_PA_STREAM_FIX_FORMAT                        PA_STREAM_FIX_FORMAT
#define MAL_PA_STREAM_FIX_RATE                          PA_STREAM_FIX_RATE
#define MAL_PA_STREAM_FIX_CHANNELS                      PA_STREAM_FIX_CHANNELS
#define MAL_PA_STREAM_DONT_MOVE                         PA_STREAM_DONT_MOVE
#define MAL_PA_STREAM_VARIABLE_RATE                     PA_STREAM_VARIABLE_RATE
#define MAL_PA_STREAM_PEAK_DETECT                       PA_STREAM_PEAK_DETECT
#define MAL_PA_STREAM_START_MUTED                       PA_STREAM_START_MUTED
#define MAL_PA_STREAM_ADJUST_LATENCY                    PA_STREAM_ADJUST_LATENCY
#define MAL_PA_STREAM_EARLY_REQUESTS                    PA_STREAM_EARLY_REQUESTS
#define MAL_PA_STREAM_DONT_INHIBIT_AUTO_SUSPEND         PA_STREAM_DONT_INHIBIT_AUTO_SUSPEND
#define MAL_PA_STREAM_START_UNMUTED                     PA_STREAM_START_UNMUTED
#define MAL_PA_STREAM_FAIL_ON_SUSPEND                   PA_STREAM_FAIL_ON_SUSPEND
#define MAL_PA_STREAM_RELATIVE_VOLUME                   PA_STREAM_RELATIVE_VOLUME
#define MAL_PA_STREAM_PASSTHROUGH                       PA_STREAM_PASSTHROUGH

typedef pa_sink_flags_t mal_pa_sink_flags_t;
#define MAL_PA_SINK_NOFLAGS                             PA_SINK_NOFLAGS
#define MAL_PA_SINK_HW_VOLUME_CTRL                      PA_SINK_HW_VOLUME_CTRL
#define MAL_PA_SINK_LATENCY                             PA_SINK_LATENCY
#define MAL_PA_SINK_HARDWARE                            PA_SINK_HARDWARE
#define MAL_PA_SINK_NETWORK                             PA_SINK_NETWORK
#define MAL_PA_SINK_HW_MUTE_CTRL                        PA_SINK_HW_MUTE_CTRL
#define MAL_PA_SINK_DECIBEL_VOLUME                      PA_SINK_DECIBEL_VOLUME
#define MAL_PA_SINK_FLAT_VOLUME                         PA_SINK_FLAT_VOLUME
#define MAL_PA_SINK_DYNAMIC_LATENCY                     PA_SINK_DYNAMIC_LATENCY
#define MAL_PA_SINK_SET_FORMATS                         PA_SINK_SET_FORMATS

typedef pa_source_flags_t mal_pa_source_flags_t;
#define MAL_PA_SOURCE_NOFLAGS                           PA_SOURCE_NOFLAGS
#define MAL_PA_SOURCE_HW_VOLUME_CTRL                    PA_SOURCE_HW_VOLUME_CTRL
#define MAL_PA_SOURCE_LATENCY                           PA_SOURCE_LATENCY
#define MAL_PA_SOURCE_HARDWARE                          PA_SOURCE_HARDWARE
#define MAL_PA_SOURCE_NETWORK                           PA_SOURCE_NETWORK
#define MAL_PA_SOURCE_HW_MUTE_CTRL                      PA_SOURCE_HW_MUTE_CTRL
#define MAL_PA_SOURCE_DECIBEL_VOLUME                    PA_SOURCE_DECIBEL_VOLUME
#define MAL_PA_SOURCE_DYNAMIC_LATENCY                   PA_SOURCE_DYNAMIC_LATENCY
#define MAL_PA_SOURCE_FLAT_VOLUME                       PA_SOURCE_FLAT_VOLUME

typedef pa_context_state_t mal_pa_context_state_t;
#define MAL_PA_CONTEXT_UNCONNECTED                      PA_CONTEXT_UNCONNECTED
#define MAL_PA_CONTEXT_CONNECTING                       PA_CONTEXT_CONNECTING
#define MAL_PA_CONTEXT_AUTHORIZING                      PA_CONTEXT_AUTHORIZING
#define MAL_PA_CONTEXT_SETTING_NAME                     PA_CONTEXT_SETTING_NAME
#define MAL_PA_CONTEXT_READY                            PA_CONTEXT_READY
#define MAL_PA_CONTEXT_FAILED                           PA_CONTEXT_FAILED
#define MAL_PA_CONTEXT_TERMINATED                       PA_CONTEXT_TERMINATED

typedef pa_stream_state_t mal_pa_stream_state_t;
#define MAL_PA_STREAM_UNCONNECTED                       PA_STREAM_UNCONNECTED
#define MAL_PA_STREAM_CREATING                          PA_STREAM_CREATING
#define MAL_PA_STREAM_READY                             PA_STREAM_READY
#define MAL_PA_STREAM_FAILED                            PA_STREAM_FAILED
#define MAL_PA_STREAM_TERMINATED                        PA_STREAM_TERMINATED

typedef pa_operation_state_t mal_pa_operation_state_t;
#define MAL_PA_OPERATION_RUNNING                        PA_OPERATION_RUNNING
#define MAL_PA_OPERATION_DONE                           PA_OPERATION_DONE
#define MAL_PA_OPERATION_CANCELLED                      PA_OPERATION_CANCELLED

typedef pa_sink_state_t mal_pa_sink_state_t;
#define MAL_PA_SINK_INVALID_STATE                       PA_SINK_INVALID_STATE
#define MAL_PA_SINK_RUNNING                             PA_SINK_RUNNING
#define MAL_PA_SINK_IDLE                                PA_SINK_IDLE
#define MAL_PA_SINK_SUSPENDED                           PA_SINK_SUSPENDED

typedef pa_source_state_t mal_pa_source_state_t;
#define MAL_PA_SOURCE_INVALID_STATE                     PA_SOURCE_INVALID_STATE
#define MAL_PA_SOURCE_RUNNING                           PA_SOURCE_RUNNING
#define MAL_PA_SOURCE_IDLE                              PA_SOURCE_IDLE
#define MAL_PA_SOURCE_SUSPENDED                         PA_SOURCE_SUSPENDED

typedef pa_seek_mode_t mal_pa_seek_mode_t;
#define MAL_PA_SEEK_RELATIVE                            PA_SEEK_RELATIVE
#define MAL_PA_SEEK_ABSOLUTE                            PA_SEEK_ABSOLUTE
#define MAL_PA_SEEK_RELATIVE_ON_READ                    PA_SEEK_RELATIVE_ON_READ
#define MAL_PA_SEEK_RELATIVE_END                        PA_SEEK_RELATIVE_END

typedef pa_channel_position_t mal_pa_channel_position_t;
#define MAL_PA_CHANNEL_POSITION_INVALID                 PA_CHANNEL_POSITION_INVALID
#define MAL_PA_CHANNEL_POSITION_MONO                    PA_CHANNEL_POSITION_MONO
#define MAL_PA_CHANNEL_POSITION_FRONT_LEFT              PA_CHANNEL_POSITION_FRONT_LEFT
#define MAL_PA_CHANNEL_POSITION_FRONT_RIGHT             PA_CHANNEL_POSITION_FRONT_RIGHT
#define MAL_PA_CHANNEL_POSITION_FRONT_CENTER            PA_CHANNEL_POSITION_FRONT_CENTER
#define MAL_PA_CHANNEL_POSITION_REAR_CENTER             PA_CHANNEL_POSITION_REAR_CENTER
#define MAL_PA_CHANNEL_POSITION_REAR_LEFT               PA_CHANNEL_POSITION_REAR_LEFT
#define MAL_PA_CHANNEL_POSITION_REAR_RIGHT              PA_CHANNEL_POSITION_REAR_RIGHT
#define MAL_PA_CHANNEL_POSITION_LFE                     PA_CHANNEL_POSITION_LFE
#define MAL_PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER    PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER
#define MAL_PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER   PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER
#define MAL_PA_CHANNEL_POSITION_SIDE_LEFT               PA_CHANNEL_POSITION_SIDE_LEFT
#define MAL_PA_CHANNEL_POSITION_SIDE_RIGHT              PA_CHANNEL_POSITION_SIDE_RIGHT
#define MAL_PA_CHANNEL_POSITION_AUX0                    PA_CHANNEL_POSITION_AUX0
#define MAL_PA_CHANNEL_POSITION_AUX1                    PA_CHANNEL_POSITION_AUX1
#define MAL_PA_CHANNEL_POSITION_AUX2                    PA_CHANNEL_POSITION_AUX2
#define MAL_PA_CHANNEL_POSITION_AUX3                    PA_CHANNEL_POSITION_AUX3
#define MAL_PA_CHANNEL_POSITION_AUX4                    PA_CHANNEL_POSITION_AUX4
#define MAL_PA_CHANNEL_POSITION_AUX5                    PA_CHANNEL_POSITION_AUX5
#define MAL_PA_CHANNEL_POSITION_AUX6                    PA_CHANNEL_POSITION_AUX6
#define MAL_PA_CHANNEL_POSITION_AUX7                    PA_CHANNEL_POSITION_AUX7
#define MAL_PA_CHANNEL_POSITION_AUX8                    PA_CHANNEL_POSITION_AUX8
#define MAL_PA_CHANNEL_POSITION_AUX9                    PA_CHANNEL_POSITION_AUX9
#define MAL_PA_CHANNEL_POSITION_AUX10                   PA_CHANNEL_POSITION_AUX10
#define MAL_PA_CHANNEL_POSITION_AUX11                   PA_CHANNEL_POSITION_AUX11
#define MAL_PA_CHANNEL_POSITION_AUX12                   PA_CHANNEL_POSITION_AUX12
#define MAL_PA_CHANNEL_POSITION_AUX13                   PA_CHANNEL_POSITION_AUX13
#define MAL_PA_CHANNEL_POSITION_AUX14                   PA_CHANNEL_POSITION_AUX14
#define MAL_PA_CHANNEL_POSITION_AUX15                   PA_CHANNEL_POSITION_AUX15
#define MAL_PA_CHANNEL_POSITION_AUX16                   PA_CHANNEL_POSITION_AUX16
#define MAL_PA_CHANNEL_POSITION_AUX17                   PA_CHANNEL_POSITION_AUX17
#define MAL_PA_CHANNEL_POSITION_AUX18                   PA_CHANNEL_POSITION_AUX18
#define MAL_PA_CHANNEL_POSITION_AUX19                   PA_CHANNEL_POSITION_AUX19
#define MAL_PA_CHANNEL_POSITION_AUX20                   PA_CHANNEL_POSITION_AUX20
#define MAL_PA_CHANNEL_POSITION_AUX21                   PA_CHANNEL_POSITION_AUX21
#define MAL_PA_CHANNEL_POSITION_AUX22                   PA_CHANNEL_POSITION_AUX22
#define MAL_PA_CHANNEL_POSITION_AUX23                   PA_CHANNEL_POSITION_AUX23
#define MAL_PA_CHANNEL_POSITION_AUX24                   PA_CHANNEL_POSITION_AUX24
#define MAL_PA_CHANNEL_POSITION_AUX25                   PA_CHANNEL_POSITION_AUX25
#define MAL_PA_CHANNEL_POSITION_AUX26                   PA_CHANNEL_POSITION_AUX26
#define MAL_PA_CHANNEL_POSITION_AUX27                   PA_CHANNEL_POSITION_AUX27
#define MAL_PA_CHANNEL_POSITION_AUX28                   PA_CHANNEL_POSITION_AUX28
#define MAL_PA_CHANNEL_POSITION_AUX29                   PA_CHANNEL_POSITION_AUX29
#define MAL_PA_CHANNEL_POSITION_AUX30                   PA_CHANNEL_POSITION_AUX30
#define MAL_PA_CHANNEL_POSITION_AUX31                   PA_CHANNEL_POSITION_AUX31
#define MAL_PA_CHANNEL_POSITION_TOP_CENTER              PA_CHANNEL_POSITION_TOP_CENTER
#define MAL_PA_CHANNEL_POSITION_TOP_FRONT_LEFT          PA_CHANNEL_POSITION_TOP_FRONT_LEFT
#define MAL_PA_CHANNEL_POSITION_TOP_FRONT_RIGHT         PA_CHANNEL_POSITION_TOP_FRONT_RIGHT
#define MAL_PA_CHANNEL_POSITION_TOP_FRONT_CENTER        PA_CHANNEL_POSITION_TOP_FRONT_CENTER
#define MAL_PA_CHANNEL_POSITION_TOP_REAR_LEFT           PA_CHANNEL_POSITION_TOP_REAR_LEFT
#define MAL_PA_CHANNEL_POSITION_TOP_REAR_RIGHT          PA_CHANNEL_POSITION_TOP_REAR_RIGHT
#define MAL_PA_CHANNEL_POSITION_TOP_REAR_CENTER         PA_CHANNEL_POSITION_TOP_REAR_CENTER
#define MAL_PA_CHANNEL_POSITION_LEFT                    PA_CHANNEL_POSITION_LEFT
#define MAL_PA_CHANNEL_POSITION_RIGHT                   PA_CHANNEL_POSITION_RIGHT
#define MAL_PA_CHANNEL_POSITION_CENTER                  PA_CHANNEL_POSITION_CENTER
#define MAL_PA_CHANNEL_POSITION_SUBWOOFER               PA_CHANNEL_POSITION_SUBWOOFER

typedef pa_channel_map_def_t mal_pa_channel_map_def_t;
#define MAL_PA_CHANNEL_MAP_AIFF                         PA_CHANNEL_MAP_AIFF
#define MAL_PA_CHANNEL_MAP_ALSA                         PA_CHANNEL_MAP_ALSA
#define MAL_PA_CHANNEL_MAP_AUX                          PA_CHANNEL_MAP_AUX
#define MAL_PA_CHANNEL_MAP_WAVEEX                       PA_CHANNEL_MAP_WAVEEX
#define MAL_PA_CHANNEL_MAP_OSS                          PA_CHANNEL_MAP_OSS
#define MAL_PA_CHANNEL_MAP_DEFAULT                      PA_CHANNEL_MAP_DEFAULT

typedef pa_sample_format_t mal_pa_sample_format_t;
#define MAL_PA_SAMPLE_INVALID                           PA_SAMPLE_INVALID
#define MAL_PA_SAMPLE_U8                                PA_SAMPLE_U8
#define MAL_PA_SAMPLE_ALAW                              PA_SAMPLE_ALAW
#define MAL_PA_SAMPLE_ULAW                              PA_SAMPLE_ULAW
#define MAL_PA_SAMPLE_S16LE                             PA_SAMPLE_S16LE
#define MAL_PA_SAMPLE_S16BE                             PA_SAMPLE_S16BE
#define MAL_PA_SAMPLE_FLOAT32LE                         PA_SAMPLE_FLOAT32LE
#define MAL_PA_SAMPLE_FLOAT32BE                         PA_SAMPLE_FLOAT32BE
#define MAL_PA_SAMPLE_S32LE                             PA_SAMPLE_S32LE
#define MAL_PA_SAMPLE_S32BE                             PA_SAMPLE_S32BE
#define MAL_PA_SAMPLE_S24LE                             PA_SAMPLE_S24LE
#define MAL_PA_SAMPLE_S24BE                             PA_SAMPLE_S24BE
#define MAL_PA_SAMPLE_S24_32LE                          PA_SAMPLE_S24_32LE
#define MAL_PA_SAMPLE_S24_32BE                          PA_SAMPLE_S24_32BE

typedef pa_mainloop     mal_pa_mainloop;
typedef pa_mainloop_api mal_pa_mainloop_api;
typedef pa_context      mal_pa_context;
typedef pa_operation    mal_pa_operation;
typedef pa_stream       mal_pa_stream;
typedef pa_spawn_api    mal_pa_spawn_api;
typedef pa_buffer_attr  mal_pa_buffer_attr;
typedef pa_channel_map  mal_pa_channel_map;
typedef pa_cvolume      mal_pa_cvolume;
typedef pa_sample_spec  mal_pa_sample_spec;
typedef pa_sink_info    mal_pa_sink_info;
typedef pa_source_info  mal_pa_source_info;

typedef pa_context_notify_cb_t mal_pa_context_notify_cb_t;
typedef pa_sink_info_cb_t mal_pa_sink_info_cb_t;
typedef pa_source_info_cb_t mal_pa_source_info_cb_t;
typedef pa_stream_success_cb_t mal_pa_stream_success_cb_t;
typedef pa_stream_request_cb_t mal_pa_stream_request_cb_t;
typedef pa_free_cb_t mal_pa_free_cb_t;
#else
#define MAL_PA_OK                                       0
#define MAL_PA_ERR_ACCESS                               1
#define MAL_PA_ERR_INVALID                              2
#define MAL_PA_ERR_NOENTITY                             5

#define MAL_PA_CHANNELS_MAX                             32
#define MAL_PA_RATE_MAX                                 384000

typedef int mal_pa_context_flags_t;
#define MAL_PA_CONTEXT_NOFLAGS                          0x00000000
#define MAL_PA_CONTEXT_NOAUTOSPAWN                      0x00000001
#define MAL_PA_CONTEXT_NOFAIL                           0x00000002

typedef int mal_pa_stream_flags_t;
#define MAL_PA_STREAM_NOFLAGS                           0x00000000
#define MAL_PA_STREAM_START_CORKED                      0x00000001
#define MAL_PA_STREAM_INTERPOLATE_TIMING                0x00000002
#define MAL_PA_STREAM_NOT_MONOTONIC                     0x00000004
#define MAL_PA_STREAM_AUTO_TIMING_UPDATE                0x00000008
#define MAL_PA_STREAM_NO_REMAP_CHANNELS                 0x00000010
#define MAL_PA_STREAM_NO_REMIX_CHANNELS                 0x00000020
#define MAL_PA_STREAM_FIX_FORMAT                        0x00000040
#define MAL_PA_STREAM_FIX_RATE                          0x00000080
#define MAL_PA_STREAM_FIX_CHANNELS                      0x00000100
#define MAL_PA_STREAM_DONT_MOVE                         0x00000200
#define MAL_PA_STREAM_VARIABLE_RATE                     0x00000400
#define MAL_PA_STREAM_PEAK_DETECT                       0x00000800
#define MAL_PA_STREAM_START_MUTED                       0x00001000
#define MAL_PA_STREAM_ADJUST_LATENCY                    0x00002000
#define MAL_PA_STREAM_EARLY_REQUESTS                    0x00004000
#define MAL_PA_STREAM_DONT_INHIBIT_AUTO_SUSPEND         0x00008000
#define MAL_PA_STREAM_START_UNMUTED                     0x00010000
#define MAL_PA_STREAM_FAIL_ON_SUSPEND                   0x00020000
#define MAL_PA_STREAM_RELATIVE_VOLUME                   0x00040000
#define MAL_PA_STREAM_PASSTHROUGH                       0x00080000

typedef int mal_pa_sink_flags_t;
#define MAL_PA_SINK_NOFLAGS                             0x00000000
#define MAL_PA_SINK_HW_VOLUME_CTRL                      0x00000001
#define MAL_PA_SINK_LATENCY                             0x00000002
#define MAL_PA_SINK_HARDWARE                            0x00000004
#define MAL_PA_SINK_NETWORK                             0x00000008
#define MAL_PA_SINK_HW_MUTE_CTRL                        0x00000010
#define MAL_PA_SINK_DECIBEL_VOLUME                      0x00000020
#define MAL_PA_SINK_FLAT_VOLUME                         0x00000040
#define MAL_PA_SINK_DYNAMIC_LATENCY                     0x00000080
#define MAL_PA_SINK_SET_FORMATS                         0x00000100

typedef int mal_pa_source_flags_t;
#define MAL_PA_SOURCE_NOFLAGS                           0x00000000
#define MAL_PA_SOURCE_HW_VOLUME_CTRL                    0x00000001
#define MAL_PA_SOURCE_LATENCY                           0x00000002
#define MAL_PA_SOURCE_HARDWARE                          0x00000004
#define MAL_PA_SOURCE_NETWORK                           0x00000008
#define MAL_PA_SOURCE_HW_MUTE_CTRL                      0x00000010
#define MAL_PA_SOURCE_DECIBEL_VOLUME                    0x00000020
#define MAL_PA_SOURCE_DYNAMIC_LATENCY                   0x00000040
#define MAL_PA_SOURCE_FLAT_VOLUME                       0x00000080

typedef int mal_pa_context_state_t;
#define MAL_PA_CONTEXT_UNCONNECTED                      0
#define MAL_PA_CONTEXT_CONNECTING                       1
#define MAL_PA_CONTEXT_AUTHORIZING                      2
#define MAL_PA_CONTEXT_SETTING_NAME                     3
#define MAL_PA_CONTEXT_READY                            4
#define MAL_PA_CONTEXT_FAILED                           5
#define MAL_PA_CONTEXT_TERMINATED                       6

typedef int mal_pa_stream_state_t;
#define MAL_PA_STREAM_UNCONNECTED                       0
#define MAL_PA_STREAM_CREATING                          1
#define MAL_PA_STREAM_READY                             2
#define MAL_PA_STREAM_FAILED                            3
#define MAL_PA_STREAM_TERMINATED                        4

typedef int mal_pa_operation_state_t;
#define MAL_PA_OPERATION_RUNNING                        0
#define MAL_PA_OPERATION_DONE                           1
#define MAL_PA_OPERATION_CANCELLED                      2

typedef int mal_pa_sink_state_t;
#define MAL_PA_SINK_INVALID_STATE                       -1
#define MAL_PA_SINK_RUNNING                             0
#define MAL_PA_SINK_IDLE                                1
#define MAL_PA_SINK_SUSPENDED                           2

typedef int mal_pa_source_state_t;
#define MAL_PA_SOURCE_INVALID_STATE                     -1
#define MAL_PA_SOURCE_RUNNING                           0
#define MAL_PA_SOURCE_IDLE                              1
#define MAL_PA_SOURCE_SUSPENDED                         2

typedef int mal_pa_seek_mode_t;
#define MAL_PA_SEEK_RELATIVE                            0
#define MAL_PA_SEEK_ABSOLUTE                            1
#define MAL_PA_SEEK_RELATIVE_ON_READ                    2
#define MAL_PA_SEEK_RELATIVE_END                        3

typedef int mal_pa_channel_position_t;
#define MAL_PA_CHANNEL_POSITION_INVALID                 -1
#define MAL_PA_CHANNEL_POSITION_MONO                    0
#define MAL_PA_CHANNEL_POSITION_FRONT_LEFT              1
#define MAL_PA_CHANNEL_POSITION_FRONT_RIGHT             2
#define MAL_PA_CHANNEL_POSITION_FRONT_CENTER            3
#define MAL_PA_CHANNEL_POSITION_REAR_CENTER             4
#define MAL_PA_CHANNEL_POSITION_REAR_LEFT               5
#define MAL_PA_CHANNEL_POSITION_REAR_RIGHT              6
#define MAL_PA_CHANNEL_POSITION_LFE                     7
#define MAL_PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER    8
#define MAL_PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER   9
#define MAL_PA_CHANNEL_POSITION_SIDE_LEFT               10
#define MAL_PA_CHANNEL_POSITION_SIDE_RIGHT              11
#define MAL_PA_CHANNEL_POSITION_AUX0                    12
#define MAL_PA_CHANNEL_POSITION_AUX1                    13
#define MAL_PA_CHANNEL_POSITION_AUX2                    14
#define MAL_PA_CHANNEL_POSITION_AUX3                    15
#define MAL_PA_CHANNEL_POSITION_AUX4                    16
#define MAL_PA_CHANNEL_POSITION_AUX5                    17
#define MAL_PA_CHANNEL_POSITION_AUX6                    18
#define MAL_PA_CHANNEL_POSITION_AUX7                    19
#define MAL_PA_CHANNEL_POSITION_AUX8                    20
#define MAL_PA_CHANNEL_POSITION_AUX9                    21
#define MAL_PA_CHANNEL_POSITION_AUX10                   22
#define MAL_PA_CHANNEL_POSITION_AUX11                   23
#define MAL_PA_CHANNEL_POSITION_AUX12                   24
#define MAL_PA_CHANNEL_POSITION_AUX13                   25
#define MAL_PA_CHANNEL_POSITION_AUX14                   26
#define MAL_PA_CHANNEL_POSITION_AUX15                   27
#define MAL_PA_CHANNEL_POSITION_AUX16                   28
#define MAL_PA_CHANNEL_POSITION_AUX17                   29
#define MAL_PA_CHANNEL_POSITION_AUX18                   30
#define MAL_PA_CHANNEL_POSITION_AUX19                   31
#define MAL_PA_CHANNEL_POSITION_AUX20                   32
#define MAL_PA_CHANNEL_POSITION_AUX21                   33
#define MAL_PA_CHANNEL_POSITION_AUX22                   34
#define MAL_PA_CHANNEL_POSITION_AUX23                   35
#define MAL_PA_CHANNEL_POSITION_AUX24                   36
#define MAL_PA_CHANNEL_POSITION_AUX25                   37
#define MAL_PA_CHANNEL_POSITION_AUX26                   38
#define MAL_PA_CHANNEL_POSITION_AUX27                   39
#define MAL_PA_CHANNEL_POSITION_AUX28                   40
#define MAL_PA_CHANNEL_POSITION_AUX29                   41
#define MAL_PA_CHANNEL_POSITION_AUX30                   42
#define MAL_PA_CHANNEL_POSITION_AUX31                   43
#define MAL_PA_CHANNEL_POSITION_TOP_CENTER              44
#define MAL_PA_CHANNEL_POSITION_TOP_FRONT_LEFT          45
#define MAL_PA_CHANNEL_POSITION_TOP_FRONT_RIGHT         46
#define MAL_PA_CHANNEL_POSITION_TOP_FRONT_CENTER        47
#define MAL_PA_CHANNEL_POSITION_TOP_REAR_LEFT           48
#define MAL_PA_CHANNEL_POSITION_TOP_REAR_RIGHT          49
#define MAL_PA_CHANNEL_POSITION_TOP_REAR_CENTER         50
#define MAL_PA_CHANNEL_POSITION_LEFT                    MAL_PA_CHANNEL_POSITION_FRONT_LEFT
#define MAL_PA_CHANNEL_POSITION_RIGHT                   MAL_PA_CHANNEL_POSITION_FRONT_RIGHT
#define MAL_PA_CHANNEL_POSITION_CENTER                  MAL_PA_CHANNEL_POSITION_FRONT_CENTER
#define MAL_PA_CHANNEL_POSITION_SUBWOOFER               MAL_PA_CHANNEL_POSITION_LFE

typedef int mal_pa_channel_map_def_t;
#define MAL_PA_CHANNEL_MAP_AIFF                         0
#define MAL_PA_CHANNEL_MAP_ALSA                         1
#define MAL_PA_CHANNEL_MAP_AUX                          2
#define MAL_PA_CHANNEL_MAP_WAVEEX                       3
#define MAL_PA_CHANNEL_MAP_OSS                          4
#define MAL_PA_CHANNEL_MAP_DEFAULT                      MAL_PA_CHANNEL_MAP_AIFF

typedef int mal_pa_sample_format_t;
#define MAL_PA_SAMPLE_INVALID                           -1
#define MAL_PA_SAMPLE_U8                                0
#define MAL_PA_SAMPLE_ALAW                              1
#define MAL_PA_SAMPLE_ULAW                              2
#define MAL_PA_SAMPLE_S16LE                             3
#define MAL_PA_SAMPLE_S16BE                             4
#define MAL_PA_SAMPLE_FLOAT32LE                         5
#define MAL_PA_SAMPLE_FLOAT32BE                         6
#define MAL_PA_SAMPLE_S32LE                             7
#define MAL_PA_SAMPLE_S32BE                             8
#define MAL_PA_SAMPLE_S24LE                             9
#define MAL_PA_SAMPLE_S24BE                             10
#define MAL_PA_SAMPLE_S24_32LE                          11
#define MAL_PA_SAMPLE_S24_32BE                          12

typedef struct mal_pa_mainloop     mal_pa_mainloop;
typedef struct mal_pa_mainloop_api mal_pa_mainloop_api;
typedef struct mal_pa_context      mal_pa_context;
typedef struct mal_pa_operation    mal_pa_operation;
typedef struct mal_pa_stream       mal_pa_stream;
typedef struct mal_pa_spawn_api    mal_pa_spawn_api;

typedef struct
{
    mal_uint32 maxlength;
    mal_uint32 tlength;
    mal_uint32 prebuf;
    mal_uint32 minreq;
    mal_uint32 fragsize;
} mal_pa_buffer_attr;

typedef struct
{
    mal_uint8 channels;
    mal_pa_channel_position_t map[MAL_PA_CHANNELS_MAX];
} mal_pa_channel_map;

typedef struct
{
    mal_uint8 channels;
    mal_uint32 values[MAL_PA_CHANNELS_MAX];
} mal_pa_cvolume;

typedef struct
{
    mal_pa_sample_format_t format;
    mal_uint32 rate;
    mal_uint8 channels;
} mal_pa_sample_spec;

typedef struct
{
    const char* name;
    mal_uint32 index;
    const char* description;
    mal_pa_sample_spec sample_spec;
    mal_pa_channel_map channel_map;
    mal_uint32 owner_module;
    mal_pa_cvolume volume;
    int mute;
    mal_uint32 monitor_source;
    const char* monitor_source_name;
    mal_uint64 latency;
    const char* driver;
    mal_pa_sink_flags_t flags;
    void* proplist;
    mal_uint64 configured_latency;
    mal_uint32 base_volume;
    mal_pa_sink_state_t state;
    mal_uint32 n_volume_steps;
    mal_uint32 card;
    mal_uint32 n_ports;
    void** ports;
    void* active_port;
    mal_uint8 n_formats;
    void** formats;
} mal_pa_sink_info;

typedef struct
{
    const char *name;
    mal_uint32 index;
    const char *description;
    mal_pa_sample_spec sample_spec;
    mal_pa_channel_map channel_map;
    mal_uint32 owner_module;
    mal_pa_cvolume volume;
    int mute;
    mal_uint32 monitor_of_sink;
    const char *monitor_of_sink_name;
    mal_uint64 latency;
    const char *driver;
    mal_pa_source_flags_t flags;
    void* proplist;
    mal_uint64 configured_latency;
    mal_uint32 base_volume;
    mal_pa_source_state_t state;
    mal_uint32 n_volume_steps;
    mal_uint32 card;
    mal_uint32 n_ports;
    void** ports;
    void* active_port;
    mal_uint8 n_formats;
    void** formats;
} mal_pa_source_info;

typedef void (* mal_pa_context_notify_cb_t)(mal_pa_context* c, void* userdata);
typedef void (* mal_pa_sink_info_cb_t)     (mal_pa_context* c, const mal_pa_sink_info* i, int eol, void* userdata);
typedef void (* mal_pa_source_info_cb_t)   (mal_pa_context* c, const mal_pa_source_info* i, int eol, void* userdata);
typedef void (* mal_pa_stream_success_cb_t)(mal_pa_stream* s, int success, void* userdata);
typedef void (* mal_pa_stream_request_cb_t)(mal_pa_stream* s, size_t nbytes, void* userdata);
typedef void (* mal_pa_free_cb_t)          (void* p);
#endif


typedef mal_pa_mainloop*          (* mal_pa_mainloop_new_proc)                   ();
typedef void                      (* mal_pa_mainloop_free_proc)                  (mal_pa_mainloop* m);
typedef mal_pa_mainloop_api*      (* mal_pa_mainloop_get_api_proc)               (mal_pa_mainloop* m);
typedef int                       (* mal_pa_mainloop_iterate_proc)               (mal_pa_mainloop* m, int block, int* retval);
typedef void                      (* mal_pa_mainloop_wakeup_proc)                (mal_pa_mainloop* m);
typedef mal_pa_context*           (* mal_pa_context_new_proc)                    (mal_pa_mainloop_api* mainloop, const char* name);
typedef void                      (* mal_pa_context_unref_proc)                  (mal_pa_context* c);
typedef int                       (* mal_pa_context_connect_proc)                (mal_pa_context* c, const char* server, mal_pa_context_flags_t flags, const mal_pa_spawn_api* api);
typedef void                      (* mal_pa_context_disconnect_proc)             (mal_pa_context* c);
typedef void                      (* mal_pa_context_set_state_callback_proc)     (mal_pa_context* c, mal_pa_context_notify_cb_t cb, void* userdata);
typedef mal_pa_context_state_t    (* mal_pa_context_get_state_proc)              (mal_pa_context* c);
typedef mal_pa_operation*         (* mal_pa_context_get_sink_info_list_proc)     (mal_pa_context* c, mal_pa_sink_info_cb_t cb, void* userdata);
typedef mal_pa_operation*         (* mal_pa_context_get_source_info_list_proc)   (mal_pa_context* c, mal_pa_source_info_cb_t cb, void* userdata);
typedef mal_pa_operation*         (* mal_pa_context_get_sink_info_by_name_proc)  (mal_pa_context* c, const char* name, mal_pa_sink_info_cb_t cb, void* userdata);
typedef mal_pa_operation*         (* mal_pa_context_get_source_info_by_name_proc)(mal_pa_context* c, const char* name, mal_pa_source_info_cb_t cb, void* userdata);
typedef void                      (* mal_pa_operation_unref_proc)                (mal_pa_operation* o);
typedef mal_pa_operation_state_t  (* mal_pa_operation_get_state_proc)            (mal_pa_operation* o);
typedef mal_pa_channel_map*       (* mal_pa_channel_map_init_extend_proc)        (mal_pa_channel_map* m, unsigned channels, mal_pa_channel_map_def_t def);
typedef int                       (* mal_pa_channel_map_valid_proc)              (const mal_pa_channel_map* m);
typedef int                       (* mal_pa_channel_map_compatible_proc)         (const mal_pa_channel_map* m, const mal_pa_sample_spec* ss);
typedef mal_pa_stream*            (* mal_pa_stream_new_proc)                     (mal_pa_context* c, const char* name, const mal_pa_sample_spec* ss, const mal_pa_channel_map* map);
typedef void                      (* mal_pa_stream_unref_proc)                   (mal_pa_stream* s);
typedef int                       (* mal_pa_stream_connect_playback_proc)        (mal_pa_stream* s, const char* dev, const mal_pa_buffer_attr* attr, mal_pa_stream_flags_t flags, const mal_pa_cvolume* volume, mal_pa_stream* sync_stream);
typedef int                       (* mal_pa_stream_connect_record_proc)          (mal_pa_stream* s, const char* dev, const mal_pa_buffer_attr* attr, mal_pa_stream_flags_t flags);
typedef int                       (* mal_pa_stream_disconnect_proc)              (mal_pa_stream* s);
typedef mal_pa_stream_state_t     (* mal_pa_stream_get_state_proc)               (mal_pa_stream* s);
typedef const mal_pa_sample_spec* (* mal_pa_stream_get_sample_spec_proc)         (mal_pa_stream* s);
typedef const mal_pa_channel_map* (* mal_pa_stream_get_channel_map_proc)         (mal_pa_stream* s);
typedef const mal_pa_buffer_attr* (* mal_pa_stream_get_buffer_attr_proc)         (mal_pa_stream* s);
typedef mal_pa_operation*         (* mal_pa_stream_set_buffer_attr_proc)         (mal_pa_stream* s, const mal_pa_buffer_attr* attr, mal_pa_stream_success_cb_t cb, void* userdata);
typedef const char*               (* mal_pa_stream_get_device_name_proc)         (mal_pa_stream* s);
typedef void                      (* mal_pa_stream_set_write_callback_proc)      (mal_pa_stream* s, mal_pa_stream_request_cb_t cb, void* userdata);
typedef void                      (* mal_pa_stream_set_read_callback_proc)       (mal_pa_stream* s, mal_pa_stream_request_cb_t cb, void* userdata);
typedef mal_pa_operation*         (* mal_pa_stream_flush_proc)                   (mal_pa_stream* s, mal_pa_stream_success_cb_t cb, void* userdata);
typedef mal_pa_operation*         (* mal_pa_stream_drain_proc)                   (mal_pa_stream* s, mal_pa_stream_success_cb_t cb, void* userdata);
typedef int                       (* mal_pa_stream_is_corked_proc)               (mal_pa_stream* s);
typedef mal_pa_operation*         (* mal_pa_stream_cork_proc)                    (mal_pa_stream* s, int b, mal_pa_stream_success_cb_t cb, void* userdata);
typedef mal_pa_operation*         (* mal_pa_stream_trigger_proc)                 (mal_pa_stream* s, mal_pa_stream_success_cb_t cb, void* userdata);
typedef int                       (* mal_pa_stream_begin_write_proc)             (mal_pa_stream* s, void** data, size_t* nbytes);
typedef int                       (* mal_pa_stream_write_proc)                   (mal_pa_stream* s, const void* data, size_t nbytes, mal_pa_free_cb_t free_cb, int64_t offset, mal_pa_seek_mode_t seek);
typedef int                       (* mal_pa_stream_peek_proc)                    (mal_pa_stream* s, const void** data, size_t* nbytes);
typedef int                       (* mal_pa_stream_drop_proc)                    (mal_pa_stream* s);
typedef size_t                    (* mal_pa_stream_writable_size_proc)           (mal_pa_stream* s);
typedef size_t                    (* mal_pa_stream_readable_size_proc)           (mal_pa_stream* s);

typedef struct
{
    mal_uint32 count;
    mal_uint32 capacity;
    mal_device_info* pInfo;
} mal_pulse_device_enum_data;

mal_result mal_result_from_pulse(int result)
{
    switch (result) {
        case MAL_PA_OK:           return MAL_SUCCESS;
        case MAL_PA_ERR_ACCESS:   return MAL_ACCESS_DENIED;
        case MAL_PA_ERR_INVALID:  return MAL_INVALID_ARGS;
        case MAL_PA_ERR_NOENTITY: return MAL_NO_DEVICE;
        default:                  return MAL_ERROR;
    }
}

#if 0
mal_pa_sample_format_t mal_format_to_pulse(mal_format format)
{
    if (mal_is_little_endian()) {
        switch (format) {
            case mal_format_s16: return MAL_PA_SAMPLE_S16LE;
            case mal_format_s24: return MAL_PA_SAMPLE_S24LE;
            case mal_format_s32: return MAL_PA_SAMPLE_S32LE;
            case mal_format_f32: return MAL_PA_SAMPLE_FLOAT32LE;
            default: break;
        }
    } else {
        switch (format) {
            case mal_format_s16: return MAL_PA_SAMPLE_S16BE;
            case mal_format_s24: return MAL_PA_SAMPLE_S24BE;
            case mal_format_s32: return MAL_PA_SAMPLE_S32BE;
            case mal_format_f32: return MAL_PA_SAMPLE_FLOAT32BE;
            default: break;
        }
    }

    // Endian agnostic.
    switch (format) {
        case mal_format_u8: return MAL_PA_SAMPLE_U8;
        default: return MAL_PA_SAMPLE_INVALID;
    }
}
#endif

mal_format mal_format_from_pulse(mal_pa_sample_format_t format)
{
    if (mal_is_little_endian()) {
        switch (format) {
            case MAL_PA_SAMPLE_S16LE:     return mal_format_s16;
            case MAL_PA_SAMPLE_S24LE:     return mal_format_s24;
            case MAL_PA_SAMPLE_S32LE:     return mal_format_s32;
            case MAL_PA_SAMPLE_FLOAT32LE: return mal_format_f32;
            default: break;
        }
    } else {
        switch (format) {
            case MAL_PA_SAMPLE_S16BE:     return mal_format_s16;
            case MAL_PA_SAMPLE_S24BE:     return mal_format_s24;
            case MAL_PA_SAMPLE_S32BE:     return mal_format_s32;
            case MAL_PA_SAMPLE_FLOAT32BE: return mal_format_f32;
            default: break;
        }
    }

    // Endian agnostic.
    switch (format) {
        case MAL_PA_SAMPLE_U8: return mal_format_u8;
        default: return mal_format_unknown;
    }
}

mal_channel mal_channel_position_from_pulse(mal_pa_channel_position_t position)
{
    switch (position)
    {
        case MAL_PA_CHANNEL_POSITION_INVALID:               return MAL_CHANNEL_NONE;
        case MAL_PA_CHANNEL_POSITION_MONO:                  return MAL_CHANNEL_MONO;
        case MAL_PA_CHANNEL_POSITION_FRONT_LEFT:            return MAL_CHANNEL_FRONT_LEFT;
        case MAL_PA_CHANNEL_POSITION_FRONT_RIGHT:           return MAL_CHANNEL_FRONT_RIGHT;
        case MAL_PA_CHANNEL_POSITION_FRONT_CENTER:          return MAL_CHANNEL_FRONT_CENTER;
        case MAL_PA_CHANNEL_POSITION_REAR_CENTER:           return MAL_CHANNEL_BACK_CENTER;
        case MAL_PA_CHANNEL_POSITION_REAR_LEFT:             return MAL_CHANNEL_BACK_LEFT;
        case MAL_PA_CHANNEL_POSITION_REAR_RIGHT:            return MAL_CHANNEL_BACK_RIGHT;
        case MAL_PA_CHANNEL_POSITION_LFE:                   return MAL_CHANNEL_LFE;
        case MAL_PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER:  return MAL_CHANNEL_FRONT_LEFT_CENTER;
        case MAL_PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER: return MAL_CHANNEL_FRONT_RIGHT_CENTER;
        case MAL_PA_CHANNEL_POSITION_SIDE_LEFT:             return MAL_CHANNEL_SIDE_LEFT;
        case MAL_PA_CHANNEL_POSITION_SIDE_RIGHT:            return MAL_CHANNEL_SIDE_RIGHT;
        case MAL_PA_CHANNEL_POSITION_AUX0:                  return MAL_CHANNEL_AUX_0;
        case MAL_PA_CHANNEL_POSITION_AUX1:                  return MAL_CHANNEL_AUX_1;
        case MAL_PA_CHANNEL_POSITION_AUX2:                  return MAL_CHANNEL_AUX_2;
        case MAL_PA_CHANNEL_POSITION_AUX3:                  return MAL_CHANNEL_AUX_3;
        case MAL_PA_CHANNEL_POSITION_AUX4:                  return MAL_CHANNEL_AUX_4;
        case MAL_PA_CHANNEL_POSITION_AUX5:                  return MAL_CHANNEL_AUX_5;
        case MAL_PA_CHANNEL_POSITION_AUX6:                  return MAL_CHANNEL_AUX_6;
        case MAL_PA_CHANNEL_POSITION_AUX7:                  return MAL_CHANNEL_AUX_7;
        case MAL_PA_CHANNEL_POSITION_AUX8:                  return MAL_CHANNEL_AUX_8;
        case MAL_PA_CHANNEL_POSITION_AUX9:                  return MAL_CHANNEL_AUX_9;
        case MAL_PA_CHANNEL_POSITION_AUX10:                 return MAL_CHANNEL_AUX_10;
        case MAL_PA_CHANNEL_POSITION_AUX11:                 return MAL_CHANNEL_AUX_11;
        case MAL_PA_CHANNEL_POSITION_AUX12:                 return MAL_CHANNEL_AUX_12;
        case MAL_PA_CHANNEL_POSITION_AUX13:                 return MAL_CHANNEL_AUX_13;
        case MAL_PA_CHANNEL_POSITION_AUX14:                 return MAL_CHANNEL_AUX_14;
        case MAL_PA_CHANNEL_POSITION_AUX15:                 return MAL_CHANNEL_AUX_15;
        case MAL_PA_CHANNEL_POSITION_AUX16:                 return MAL_CHANNEL_AUX_16;
        case MAL_PA_CHANNEL_POSITION_AUX17:                 return MAL_CHANNEL_AUX_17;
        case MAL_PA_CHANNEL_POSITION_AUX18:                 return MAL_CHANNEL_AUX_18;
        case MAL_PA_CHANNEL_POSITION_AUX19:                 return MAL_CHANNEL_AUX_19;
        case MAL_PA_CHANNEL_POSITION_AUX20:                 return MAL_CHANNEL_AUX_20;
        case MAL_PA_CHANNEL_POSITION_AUX21:                 return MAL_CHANNEL_AUX_21;
        case MAL_PA_CHANNEL_POSITION_AUX22:                 return MAL_CHANNEL_AUX_22;
        case MAL_PA_CHANNEL_POSITION_AUX23:                 return MAL_CHANNEL_AUX_23;
        case MAL_PA_CHANNEL_POSITION_AUX24:                 return MAL_CHANNEL_AUX_24;
        case MAL_PA_CHANNEL_POSITION_AUX25:                 return MAL_CHANNEL_AUX_25;
        case MAL_PA_CHANNEL_POSITION_AUX26:                 return MAL_CHANNEL_AUX_26;
        case MAL_PA_CHANNEL_POSITION_AUX27:                 return MAL_CHANNEL_AUX_27;
        case MAL_PA_CHANNEL_POSITION_AUX28:                 return MAL_CHANNEL_AUX_28;
        case MAL_PA_CHANNEL_POSITION_AUX29:                 return MAL_CHANNEL_AUX_29;
        case MAL_PA_CHANNEL_POSITION_AUX30:                 return MAL_CHANNEL_AUX_30;
        case MAL_PA_CHANNEL_POSITION_AUX31:                 return MAL_CHANNEL_AUX_31;
        case MAL_PA_CHANNEL_POSITION_TOP_CENTER:            return MAL_CHANNEL_TOP_CENTER;
        case MAL_PA_CHANNEL_POSITION_TOP_FRONT_LEFT:        return MAL_CHANNEL_TOP_FRONT_LEFT;
        case MAL_PA_CHANNEL_POSITION_TOP_FRONT_RIGHT:       return MAL_CHANNEL_TOP_FRONT_RIGHT;
        case MAL_PA_CHANNEL_POSITION_TOP_FRONT_CENTER:      return MAL_CHANNEL_TOP_FRONT_CENTER;
        case MAL_PA_CHANNEL_POSITION_TOP_REAR_LEFT:         return MAL_CHANNEL_TOP_BACK_LEFT;
        case MAL_PA_CHANNEL_POSITION_TOP_REAR_RIGHT:        return MAL_CHANNEL_TOP_BACK_RIGHT;
        case MAL_PA_CHANNEL_POSITION_TOP_REAR_CENTER:       return MAL_CHANNEL_TOP_BACK_CENTER;
        default: return MAL_CHANNEL_NONE;
    }
}

#if 0
mal_pa_channel_position_t mal_channel_position_to_pulse(mal_channel position)
{
    switch (position)
    {
        case MAL_CHANNEL_NONE:               return MAL_PA_CHANNEL_POSITION_INVALID;
        case MAL_CHANNEL_FRONT_LEFT:         return MAL_PA_CHANNEL_POSITION_FRONT_LEFT;
        case MAL_CHANNEL_FRONT_RIGHT:        return MAL_PA_CHANNEL_POSITION_FRONT_RIGHT;
        case MAL_CHANNEL_FRONT_CENTER:       return MAL_PA_CHANNEL_POSITION_FRONT_CENTER;
        case MAL_CHANNEL_LFE:                return MAL_PA_CHANNEL_POSITION_LFE;
        case MAL_CHANNEL_BACK_LEFT:          return MAL_PA_CHANNEL_POSITION_REAR_LEFT;
        case MAL_CHANNEL_BACK_RIGHT:         return MAL_PA_CHANNEL_POSITION_REAR_RIGHT;
        case MAL_CHANNEL_FRONT_LEFT_CENTER:  return MAL_PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER;
        case MAL_CHANNEL_FRONT_RIGHT_CENTER: return MAL_PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER;
        case MAL_CHANNEL_BACK_CENTER:        return MAL_PA_CHANNEL_POSITION_REAR_CENTER;
        case MAL_CHANNEL_SIDE_LEFT:          return MAL_PA_CHANNEL_POSITION_SIDE_LEFT;
        case MAL_CHANNEL_SIDE_RIGHT:         return MAL_PA_CHANNEL_POSITION_SIDE_RIGHT;
        case MAL_CHANNEL_TOP_CENTER:         return MAL_PA_CHANNEL_POSITION_TOP_CENTER;
        case MAL_CHANNEL_TOP_FRONT_LEFT:     return MAL_PA_CHANNEL_POSITION_TOP_FRONT_LEFT;
        case MAL_CHANNEL_TOP_FRONT_CENTER:   return MAL_PA_CHANNEL_POSITION_TOP_FRONT_CENTER;
        case MAL_CHANNEL_TOP_FRONT_RIGHT:    return MAL_PA_CHANNEL_POSITION_TOP_FRONT_RIGHT;
        case MAL_CHANNEL_TOP_BACK_LEFT:      return MAL_PA_CHANNEL_POSITION_TOP_REAR_LEFT;
        case MAL_CHANNEL_TOP_BACK_CENTER:    return MAL_PA_CHANNEL_POSITION_TOP_REAR_CENTER;
        case MAL_CHANNEL_TOP_BACK_RIGHT:     return MAL_PA_CHANNEL_POSITION_TOP_REAR_RIGHT;
        case MAL_CHANNEL_19:                 return MAL_PA_CHANNEL_POSITION_AUX18;
        case MAL_CHANNEL_20:                 return MAL_PA_CHANNEL_POSITION_AUX19;
        case MAL_CHANNEL_21:                 return MAL_PA_CHANNEL_POSITION_AUX20;
        case MAL_CHANNEL_22:                 return MAL_PA_CHANNEL_POSITION_AUX21;
        case MAL_CHANNEL_23:                 return MAL_PA_CHANNEL_POSITION_AUX22;
        case MAL_CHANNEL_24:                 return MAL_PA_CHANNEL_POSITION_AUX23;
        case MAL_CHANNEL_25:                 return MAL_PA_CHANNEL_POSITION_AUX24;
        case MAL_CHANNEL_26:                 return MAL_PA_CHANNEL_POSITION_AUX25;
        case MAL_CHANNEL_27:                 return MAL_PA_CHANNEL_POSITION_AUX26;
        case MAL_CHANNEL_28:                 return MAL_PA_CHANNEL_POSITION_AUX27;
        case MAL_CHANNEL_29:                 return MAL_PA_CHANNEL_POSITION_AUX28;
        case MAL_CHANNEL_30:                 return MAL_PA_CHANNEL_POSITION_AUX29;
        case MAL_CHANNEL_31:                 return MAL_PA_CHANNEL_POSITION_AUX30;
        case MAL_CHANNEL_32:                 return MAL_PA_CHANNEL_POSITION_AUX31;
        default: return (mal_pa_channel_position_t)position;
    }
}
#endif

mal_result mal_wait_for_operation__pulse(mal_context* pContext, mal_pa_mainloop* pMainLoop, mal_pa_operation* pOP)
{
    mal_assert(pContext != NULL);
    mal_assert(pMainLoop != NULL);
    mal_assert(pOP != NULL);

    while (((mal_pa_operation_get_state_proc)pContext->pulse.pa_operation_get_state)(pOP) == MAL_PA_OPERATION_RUNNING) {
        int error = ((mal_pa_mainloop_iterate_proc)pContext->pulse.pa_mainloop_iterate)(pMainLoop, 1, NULL);
        if (error < 0) {
            return mal_result_from_pulse(error);
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_device__wait_for_operation__pulse(mal_device* pDevice, mal_pa_operation* pOP)
{
    mal_assert(pDevice != NULL);
    mal_assert(pOP != NULL);

    return mal_wait_for_operation__pulse(pDevice->pContext, (mal_pa_mainloop*)pDevice->pulse.pMainLoop, pOP);
}


mal_bool32 mal_context_is_device_id_equal__pulse(mal_context* pContext, const mal_device_id* pID0, const mal_device_id* pID1)
{
    mal_assert(pContext != NULL);
    mal_assert(pID0 != NULL);
    mal_assert(pID1 != NULL);
    (void)pContext;

    return mal_strcmp(pID0->pulse, pID1->pulse) == 0;
}


typedef struct
{
    mal_context* pContext;
    mal_enum_devices_callback_proc callback;
    void* pUserData;
    mal_bool32 isTerminated;
} mal_context_enumerate_devices_callback_data__pulse;

void mal_context_enumerate_devices_sink_callback__pulse(mal_pa_context* pPulseContext, const mal_pa_sink_info* pSinkInfo, int endOfList, void* pUserData)
{
    mal_context_enumerate_devices_callback_data__pulse* pData = (mal_context_enumerate_devices_callback_data__pulse*)pUserData;
    mal_assert(pData != NULL);

    if (endOfList || pData->isTerminated) {
        return;
    }

    mal_device_info deviceInfo;
    mal_zero_object(&deviceInfo);

    // The name from PulseAudio is the ID for mini_al.
    if (pSinkInfo->name != NULL) {
        mal_strncpy_s(deviceInfo.id.pulse, sizeof(deviceInfo.id.pulse), pSinkInfo->name, (size_t)-1);
    }

    // The description from PulseAudio is the name for mini_al.
    if (pSinkInfo->description != NULL) {
        mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), pSinkInfo->description, (size_t)-1);
    }

    pData->isTerminated = !pData->callback(pData->pContext, mal_device_type_playback, &deviceInfo, pData->pUserData);
}

void mal_context_enumerate_devices_source_callback__pulse(mal_pa_context* pPulseContext, const mal_pa_source_info* pSinkInfo, int endOfList, void* pUserData)
{
    mal_context_enumerate_devices_callback_data__pulse* pData = (mal_context_enumerate_devices_callback_data__pulse*)pUserData;
    mal_assert(pData != NULL);

    if (endOfList || pData->isTerminated) {
        return;
    }

    mal_device_info deviceInfo;
    mal_zero_object(&deviceInfo);

    // The name from PulseAudio is the ID for mini_al.
    if (pSinkInfo->name != NULL) {
        mal_strncpy_s(deviceInfo.id.pulse, sizeof(deviceInfo.id.pulse), pSinkInfo->name, (size_t)-1);
    }

    // The description from PulseAudio is the name for mini_al.
    if (pSinkInfo->description != NULL) {
        mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), pSinkInfo->description, (size_t)-1);
    }

    pData->isTerminated = !pData->callback(pData->pContext, mal_device_type_capture, &deviceInfo, pData->pUserData);
}

mal_result mal_context_enumerate_devices__pulse(mal_context* pContext, mal_enum_devices_callback_proc callback, void* pUserData)
{
    mal_assert(pContext != NULL);
    mal_assert(callback != NULL);

    mal_result result = MAL_SUCCESS;

    mal_context_enumerate_devices_callback_data__pulse callbackData;
    callbackData.pContext = pContext;
    callbackData.callback = callback;
    callbackData.pUserData = pUserData;
    callbackData.isTerminated = MAL_FALSE;

    mal_pa_operation* pOP = NULL;

    mal_pa_mainloop* pMainLoop = ((mal_pa_mainloop_new_proc)pContext->pulse.pa_mainloop_new)();
    if (pMainLoop == NULL) {
        return MAL_FAILED_TO_INIT_BACKEND;
    }

    mal_pa_mainloop_api* pAPI = ((mal_pa_mainloop_get_api_proc)pContext->pulse.pa_mainloop_get_api)(pMainLoop);
    if (pAPI == NULL) {
        ((mal_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
        return MAL_FAILED_TO_INIT_BACKEND;
    }

    mal_pa_context* pPulseContext = ((mal_pa_context_new_proc)pContext->pulse.pa_context_new)(pAPI, pContext->config.pulse.pApplicationName);
    if (pPulseContext == NULL) {
        ((mal_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
        return MAL_FAILED_TO_INIT_BACKEND;
    }

    int error = ((mal_pa_context_connect_proc)pContext->pulse.pa_context_connect)(pPulseContext, pContext->config.pulse.pServerName, 0, NULL);
    if (error != MAL_PA_OK) {
        ((mal_pa_context_unref_proc)pContext->pulse.pa_context_unref)(pPulseContext);
        ((mal_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
        return mal_result_from_pulse(error);
    }

    while (((mal_pa_context_get_state_proc)pContext->pulse.pa_context_get_state)(pPulseContext) != MAL_PA_CONTEXT_READY) {
        error = ((mal_pa_mainloop_iterate_proc)pContext->pulse.pa_mainloop_iterate)(pMainLoop, 1, NULL);
        if (error < 0) {
            result = mal_result_from_pulse(error);
            goto done;
        }
    }


    // Playback.
    if (!callbackData.isTerminated) {
        pOP = ((mal_pa_context_get_sink_info_list_proc)pContext->pulse.pa_context_get_sink_info_list)(pPulseContext, mal_context_enumerate_devices_sink_callback__pulse, &callbackData);
        if (pOP == NULL) {
            result = MAL_ERROR;
            goto done;
        }

        result = mal_wait_for_operation__pulse(pContext, pMainLoop, pOP);
        ((mal_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
        if (result != MAL_SUCCESS) {
            goto done;
        }
    }


    // Capture.
    if (!callbackData.isTerminated) {
        pOP = ((mal_pa_context_get_source_info_list_proc)pContext->pulse.pa_context_get_source_info_list)(pPulseContext, mal_context_enumerate_devices_source_callback__pulse, &callbackData);
        if (pOP == NULL) {
            result = MAL_ERROR;
            goto done;
        }

        result = mal_wait_for_operation__pulse(pContext, pMainLoop, pOP);
        ((mal_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
        if (result != MAL_SUCCESS) {
            goto done;
        }
    }

done:
    ((mal_pa_context_disconnect_proc)pContext->pulse.pa_context_disconnect)(pPulseContext);
    ((mal_pa_context_unref_proc)pContext->pulse.pa_context_unref)(pPulseContext);
    ((mal_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
    return result;
}


typedef struct
{
    mal_device_info* pDeviceInfo;
    mal_bool32 foundDevice;
} mal_context_get_device_info_callback_data__pulse;

void mal_context_get_device_info_sink_callback__pulse(mal_pa_context* pPulseContext, const mal_pa_sink_info* pInfo, int endOfList, void* pUserData)
{
    if (endOfList > 0) {
        return;
    }

    mal_context_get_device_info_callback_data__pulse* pData = (mal_context_get_device_info_callback_data__pulse*)pUserData;
    mal_assert(pData != NULL);
    pData->foundDevice = MAL_TRUE;

    if (pInfo->name != NULL) {
        mal_strncpy_s(pData->pDeviceInfo->id.pulse, sizeof(pData->pDeviceInfo->id.pulse), pInfo->name, (size_t)-1);
    }

    if (pInfo->description != NULL) {
        mal_strncpy_s(pData->pDeviceInfo->name, sizeof(pData->pDeviceInfo->name), pInfo->description, (size_t)-1);
    }

    pData->pDeviceInfo->minChannels   = pInfo->sample_spec.channels;
    pData->pDeviceInfo->maxChannels   = pInfo->sample_spec.channels;
    pData->pDeviceInfo->minSampleRate = pInfo->sample_spec.rate;
    pData->pDeviceInfo->maxSampleRate = pInfo->sample_spec.rate;
    pData->pDeviceInfo->formatCount = 1;
    pData->pDeviceInfo->formats[0] = mal_format_from_pulse(pInfo->sample_spec.format);
}

void mal_context_get_device_info_source_callback__pulse(mal_pa_context* pPulseContext, const mal_pa_source_info* pInfo, int endOfList, void* pUserData)
{
    if (endOfList > 0) {
        return;
    }

    mal_context_get_device_info_callback_data__pulse* pData = (mal_context_get_device_info_callback_data__pulse*)pUserData;
    mal_assert(pData != NULL);
    pData->foundDevice = MAL_TRUE;

    if (pInfo->name != NULL) {
        mal_strncpy_s(pData->pDeviceInfo->id.pulse, sizeof(pData->pDeviceInfo->id.pulse), pInfo->name, (size_t)-1);
    }

    if (pInfo->description != NULL) {
        mal_strncpy_s(pData->pDeviceInfo->name, sizeof(pData->pDeviceInfo->name), pInfo->description, (size_t)-1);
    }

    pData->pDeviceInfo->minChannels = pInfo->sample_spec.channels;
    pData->pDeviceInfo->maxChannels = pInfo->sample_spec.channels;
    pData->pDeviceInfo->minSampleRate = pInfo->sample_spec.rate;
    pData->pDeviceInfo->maxSampleRate = pInfo->sample_spec.rate;
    pData->pDeviceInfo->formatCount = 1;
    pData->pDeviceInfo->formats[0] = mal_format_from_pulse(pInfo->sample_spec.format);
}

mal_result mal_context_get_device_info__pulse(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, mal_device_info* pDeviceInfo)
{
    mal_assert(pContext != NULL);

    /* No exclusive mode with the PulseAudio backend. */
    if (shareMode == mal_share_mode_exclusive) {
        return MAL_SHARE_MODE_NOT_SUPPORTED;
    }

    mal_result result = MAL_SUCCESS;

    mal_context_get_device_info_callback_data__pulse callbackData;
    callbackData.pDeviceInfo = pDeviceInfo;
    callbackData.foundDevice = MAL_FALSE;

    mal_pa_operation* pOP = NULL;

    mal_pa_mainloop* pMainLoop = ((mal_pa_mainloop_new_proc)pContext->pulse.pa_mainloop_new)();
    if (pMainLoop == NULL) {
        return MAL_FAILED_TO_INIT_BACKEND;
    }

    mal_pa_mainloop_api* pAPI = ((mal_pa_mainloop_get_api_proc)pContext->pulse.pa_mainloop_get_api)(pMainLoop);
    if (pAPI == NULL) {
        ((mal_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
        return MAL_FAILED_TO_INIT_BACKEND;
    }

    mal_pa_context* pPulseContext = ((mal_pa_context_new_proc)pContext->pulse.pa_context_new)(pAPI, pContext->config.pulse.pApplicationName);
    if (pPulseContext == NULL) {
        ((mal_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
        return MAL_FAILED_TO_INIT_BACKEND;
    }

    int error = ((mal_pa_context_connect_proc)pContext->pulse.pa_context_connect)(pPulseContext, pContext->config.pulse.pServerName, 0, NULL);
    if (error != MAL_PA_OK) {
        ((mal_pa_context_unref_proc)pContext->pulse.pa_context_unref)(pPulseContext);
        ((mal_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
        return mal_result_from_pulse(error);
    }

    while (((mal_pa_context_get_state_proc)pContext->pulse.pa_context_get_state)(pPulseContext) != MAL_PA_CONTEXT_READY) {
        error = ((mal_pa_mainloop_iterate_proc)pContext->pulse.pa_mainloop_iterate)(pMainLoop, 1, NULL);
        if (error < 0) {
            result = mal_result_from_pulse(error);
            goto done;
        }
    }

    if (deviceType == mal_device_type_playback) {
        pOP = ((mal_pa_context_get_sink_info_by_name_proc)pContext->pulse.pa_context_get_sink_info_by_name)(pPulseContext, pDeviceID->pulse, mal_context_get_device_info_sink_callback__pulse, &callbackData);
    } else {
        pOP = ((mal_pa_context_get_source_info_by_name_proc)pContext->pulse.pa_context_get_source_info_by_name)(pPulseContext, pDeviceID->pulse, mal_context_get_device_info_source_callback__pulse, &callbackData);
    }

    if (pOP != NULL) {
        mal_wait_for_operation__pulse(pContext, pMainLoop, pOP);
        ((mal_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
    } else {
        result = MAL_ERROR;
        goto done;
    }

    if (!callbackData.foundDevice) {
        result = MAL_NO_DEVICE;
        goto done;
    }


done:
    ((mal_pa_context_disconnect_proc)pContext->pulse.pa_context_disconnect)(pPulseContext);
    ((mal_pa_context_unref_proc)pContext->pulse.pa_context_unref)(pPulseContext);
    ((mal_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
    return result;
}


void mal_pulse_device_state_callback(mal_pa_context* pPulseContext, void* pUserData)
{
    mal_device* pDevice = (mal_device*)pUserData;
    mal_assert(pDevice != NULL);

    mal_context* pContext = pDevice->pContext;
    mal_assert(pContext != NULL);

    pDevice->pulse.pulseContextState = ((mal_pa_context_get_state_proc)pContext->pulse.pa_context_get_state)(pPulseContext);
}

void mal_device_sink_info_callback(mal_pa_context* pPulseContext, const mal_pa_sink_info* pInfo, int endOfList, void* pUserData)
{
    if (endOfList > 0) {
        return;
    }

    mal_pa_sink_info* pInfoOut = (mal_pa_sink_info*)pUserData;
    mal_assert(pInfoOut != NULL);

    *pInfoOut = *pInfo;
}

void mal_device_source_info_callback(mal_pa_context* pPulseContext, const mal_pa_source_info* pInfo, int endOfList, void* pUserData)
{
    if (endOfList > 0) {
        return;
    }

    mal_pa_source_info* pInfoOut = (mal_pa_source_info*)pUserData;
    mal_assert(pInfoOut != NULL);

    *pInfoOut = *pInfo;
}

void mal_device_sink_name_callback(mal_pa_context* pPulseContext, const mal_pa_sink_info* pInfo, int endOfList, void* pUserData)
{
    if (endOfList > 0) {
        return;
    }

    mal_device* pDevice = (mal_device*)pUserData;
    mal_assert(pDevice != NULL);

    mal_strncpy_s(pDevice->playback.name, sizeof(pDevice->playback.name), pInfo->description, (size_t)-1);
}

void mal_device_source_name_callback(mal_pa_context* pPulseContext, const mal_pa_source_info* pInfo, int endOfList, void* pUserData)
{
    if (endOfList > 0) {
        return;
    }

    mal_device* pDevice = (mal_device*)pUserData;
    mal_assert(pDevice != NULL);

    mal_strncpy_s(pDevice->capture.name, sizeof(pDevice->capture.name), pInfo->description, (size_t)-1);
}

void mal_device_uninit__pulse(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    mal_context* pContext = pDevice->pContext;
    mal_assert(pContext != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        ((mal_pa_stream_disconnect_proc)pContext->pulse.pa_stream_disconnect)((mal_pa_stream*)pDevice->pulse.pStreamCapture);
        ((mal_pa_stream_unref_proc)pContext->pulse.pa_stream_unref)((mal_pa_stream*)pDevice->pulse.pStreamCapture);
    }
    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        ((mal_pa_stream_disconnect_proc)pContext->pulse.pa_stream_disconnect)((mal_pa_stream*)pDevice->pulse.pStreamPlayback);
        ((mal_pa_stream_unref_proc)pContext->pulse.pa_stream_unref)((mal_pa_stream*)pDevice->pulse.pStreamPlayback);
    }

    ((mal_pa_context_disconnect_proc)pContext->pulse.pa_context_disconnect)((mal_pa_context*)pDevice->pulse.pPulseContext);
    ((mal_pa_context_unref_proc)pContext->pulse.pa_context_unref)((mal_pa_context*)pDevice->pulse.pPulseContext);
    ((mal_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)((mal_pa_mainloop*)pDevice->pulse.pMainLoop);
}

mal_pa_buffer_attr mal_device__pa_buffer_attr_new(mal_uint32 bufferSizeInFrames, mal_uint32 periods, const mal_pa_sample_spec* ss)
{
    mal_pa_buffer_attr attr;
    attr.maxlength = bufferSizeInFrames * mal_get_bytes_per_sample(mal_format_from_pulse(ss->format)) * ss->channels;
    attr.tlength   = attr.maxlength / periods;
    attr.prebuf    = (mal_uint32)-1;
    attr.minreq    = attr.maxlength / periods;
    attr.fragsize  = attr.maxlength / periods;

    return attr;
}

mal_pa_stream* mal_device__pa_stream_new__pulse(mal_device* pDevice, const char* pStreamName, const mal_pa_sample_spec* ss, const mal_pa_channel_map* cmap)
{
    static int g_StreamCounter = 0;

    char actualStreamName[256];
    if (pStreamName != NULL) {
        mal_strncpy_s(actualStreamName, sizeof(actualStreamName), pStreamName, (size_t)-1);
    } else {
        mal_strcpy_s(actualStreamName, sizeof(actualStreamName), "mini_al:");
        mal_itoa_s(g_StreamCounter, actualStreamName + 8, sizeof(actualStreamName)-8, 10);  // 8 = strlen("mini_al:")
    }
    g_StreamCounter += 1;

    return ((mal_pa_stream_new_proc)pDevice->pContext->pulse.pa_stream_new)((mal_pa_context*)pDevice->pulse.pPulseContext, actualStreamName, ss, cmap);
}

mal_result mal_device_init__pulse(mal_context* pContext, const mal_device_config* pConfig, mal_device* pDevice)
{
    (void)pContext;

    mal_assert(pDevice != NULL);
    mal_zero_object(&pDevice->pulse);

    mal_result result = MAL_SUCCESS;
    int error = 0;
    const char* devPlayback = NULL;
    const char* devCapture  = NULL;

    /* No exclusive mode with the PulseAudio backend. */
    if (((pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) && pConfig->playback.shareMode == mal_share_mode_exclusive) ||
        ((pConfig->deviceType == mal_device_type_capture  || pConfig->deviceType == mal_device_type_duplex) && pConfig->capture.shareMode  == mal_share_mode_exclusive)) {
        return MAL_SHARE_MODE_NOT_SUPPORTED;
    }

    if ((pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) && pConfig->playback.pDeviceID != NULL) {
        devPlayback = pConfig->playback.pDeviceID->pulse;
    }
    if ((pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) && pConfig->capture.pDeviceID != NULL) {
        devCapture = pConfig->capture.pDeviceID->pulse;
    }

    mal_uint32 bufferSizeInMilliseconds = pConfig->bufferSizeInMilliseconds;
    if (bufferSizeInMilliseconds == 0) {
        bufferSizeInMilliseconds = mal_calculate_buffer_size_in_milliseconds_from_frames(pConfig->bufferSizeInFrames, pConfig->sampleRate);
    }

    mal_pa_sink_info sinkInfo;
    mal_pa_source_info sourceInfo;
    mal_pa_operation* pOP = NULL;

    mal_pa_sample_spec ss;
    mal_pa_channel_map cmap;
    mal_pa_buffer_attr attr;

    const mal_pa_sample_spec* pActualSS   = NULL;
    const mal_pa_channel_map* pActualCMap = NULL;
    const mal_pa_buffer_attr* pActualAttr = NULL;



    pDevice->pulse.pMainLoop = ((mal_pa_mainloop_new_proc)pContext->pulse.pa_mainloop_new)();
    if (pDevice->pulse.pMainLoop == NULL) {
        result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to create main loop for device.", MAL_FAILED_TO_INIT_BACKEND);
        goto on_error0;
    }

    pDevice->pulse.pAPI = ((mal_pa_mainloop_get_api_proc)pContext->pulse.pa_mainloop_get_api)((mal_pa_mainloop*)pDevice->pulse.pMainLoop);
    if (pDevice->pulse.pAPI == NULL) {
        result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to retrieve PulseAudio main loop.", MAL_FAILED_TO_INIT_BACKEND);
        goto on_error1;
    }

    pDevice->pulse.pPulseContext = ((mal_pa_context_new_proc)pContext->pulse.pa_context_new)((mal_pa_mainloop_api*)pDevice->pulse.pAPI, pContext->config.pulse.pApplicationName);
    if (pDevice->pulse.pPulseContext == NULL) {
        result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to create PulseAudio context for device.", MAL_FAILED_TO_INIT_BACKEND);
        goto on_error1;
    }

    error = ((mal_pa_context_connect_proc)pContext->pulse.pa_context_connect)((mal_pa_context*)pDevice->pulse.pPulseContext, pContext->config.pulse.pServerName, (pContext->config.pulse.tryAutoSpawn) ? 0 : MAL_PA_CONTEXT_NOAUTOSPAWN, NULL);
    if (error != MAL_PA_OK) {
        result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to connect PulseAudio context.", mal_result_from_pulse(error));
        goto on_error2;
    }


    pDevice->pulse.pulseContextState = MAL_PA_CONTEXT_UNCONNECTED;
    ((mal_pa_context_set_state_callback_proc)pContext->pulse.pa_context_set_state_callback)((mal_pa_context*)pDevice->pulse.pPulseContext, mal_pulse_device_state_callback, pDevice);

    // Wait for PulseAudio to get itself ready before returning.
    for (;;) {
        if (pDevice->pulse.pulseContextState == MAL_PA_CONTEXT_READY) {
            break;
        } else {
            error = ((mal_pa_mainloop_iterate_proc)pContext->pulse.pa_mainloop_iterate)((mal_pa_mainloop*)pDevice->pulse.pMainLoop, 1, NULL);    // 1 = block.
            if (error < 0) {
                result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] The PulseAudio main loop returned an error while connecting the PulseAudio context.", mal_result_from_pulse(error));
                goto on_error3;
            }
            continue;
        }

        // An error may have occurred.
        if (pDevice->pulse.pulseContextState == MAL_PA_CONTEXT_FAILED || pDevice->pulse.pulseContextState == MAL_PA_CONTEXT_TERMINATED) {
            result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] An error occurred while connecting the PulseAudio context.", MAL_ERROR);
            goto on_error3;
        }

        error = ((mal_pa_mainloop_iterate_proc)pContext->pulse.pa_mainloop_iterate)((mal_pa_mainloop*)pDevice->pulse.pMainLoop, 1, NULL);
        if (error < 0) {
            result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] The PulseAudio main loop returned an error while connecting the PulseAudio context.", mal_result_from_pulse(error));
            goto on_error3;
        }
    }

    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        pOP = ((mal_pa_context_get_source_info_by_name_proc)pContext->pulse.pa_context_get_source_info_by_name)((mal_pa_context*)pDevice->pulse.pPulseContext, devCapture, mal_device_source_info_callback, &sourceInfo);
        if (pOP != NULL) {
            mal_device__wait_for_operation__pulse(pDevice, pOP);
            ((mal_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
        } else {
            result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to retrieve source info for capture device.", mal_result_from_pulse(error));
            goto on_error3;
        }

        ss = sourceInfo.sample_spec;
        cmap = sourceInfo.channel_map;

        pDevice->capture.internalBufferSizeInFrames = mal_calculate_buffer_size_in_frames_from_milliseconds(bufferSizeInMilliseconds, ss.rate);
        pDevice->capture.internalPeriods            = pConfig->periods;

        attr = mal_device__pa_buffer_attr_new(pDevice->capture.internalBufferSizeInFrames, pConfig->periods, &ss);
    #ifdef MAL_DEBUG_OUTPUT
        printf("[PulseAudio] Capture attr: maxlength=%d, tlength=%d, prebuf=%d, minreq=%d, fragsize=%d; internalBufferSizeInFrames=%d\n", attr.maxlength, attr.tlength, attr.prebuf, attr.minreq, attr.fragsize, pDevice->capture.internalBufferSizeInFrames);
    #endif

        pDevice->pulse.pStreamCapture = mal_device__pa_stream_new__pulse(pDevice, pConfig->pulse.pStreamNameCapture, &ss, &cmap);
        if (pDevice->pulse.pStreamCapture == NULL) {
            result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to create PulseAudio capture stream.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
            goto on_error3;
        }

        mal_pa_stream_flags_t streamFlags = MAL_PA_STREAM_START_CORKED | MAL_PA_STREAM_FIX_FORMAT | MAL_PA_STREAM_FIX_RATE | MAL_PA_STREAM_FIX_CHANNELS;
        if (devCapture != NULL) {
            streamFlags |= MAL_PA_STREAM_DONT_MOVE;
        }

        error = ((mal_pa_stream_connect_record_proc)pContext->pulse.pa_stream_connect_record)((mal_pa_stream*)pDevice->pulse.pStreamCapture, devCapture, &attr, streamFlags);
        if (error != MAL_PA_OK) {
            result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to connect PulseAudio capture stream.", mal_result_from_pulse(error));
            goto on_error4;
        }

        while (((mal_pa_stream_get_state_proc)pContext->pulse.pa_stream_get_state)((mal_pa_stream*)pDevice->pulse.pStreamCapture) != MAL_PA_STREAM_READY) {
            error = ((mal_pa_mainloop_iterate_proc)pContext->pulse.pa_mainloop_iterate)((mal_pa_mainloop*)pDevice->pulse.pMainLoop, 1, NULL);
            if (error < 0) {
                result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] The PulseAudio main loop returned an error while connecting the PulseAudio capture stream.", mal_result_from_pulse(error));
                goto on_error5;
            }
        }

        /* Internal format. */
        pActualSS = ((mal_pa_stream_get_sample_spec_proc)pContext->pulse.pa_stream_get_sample_spec)((mal_pa_stream*)pDevice->pulse.pStreamCapture);
        if (pActualSS != NULL) {
            /* If anything has changed between the requested and the actual sample spec, we need to update the buffer. */
            if (ss.format != pActualSS->format || ss.channels != pActualSS->channels || ss.rate != pActualSS->rate) {
                attr = mal_device__pa_buffer_attr_new(pDevice->capture.internalBufferSizeInFrames, pConfig->periods, pActualSS);

                pOP = ((mal_pa_stream_set_buffer_attr_proc)pContext->pulse.pa_stream_set_buffer_attr)((mal_pa_stream*)pDevice->pulse.pStreamCapture, &attr, NULL, NULL);
                if (pOP != NULL) {
                    mal_device__wait_for_operation__pulse(pDevice, pOP);
                    ((mal_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
                }
            }

            ss = *pActualSS;
        }

        pDevice->capture.internalFormat     = mal_format_from_pulse(ss.format);
        pDevice->capture.internalChannels   = ss.channels;
        pDevice->capture.internalSampleRate = ss.rate;

        /* Internal channel map. */
        pActualCMap = ((mal_pa_stream_get_channel_map_proc)pContext->pulse.pa_stream_get_channel_map)((mal_pa_stream*)pDevice->pulse.pStreamCapture);
        if (pActualCMap != NULL) {
            cmap = *pActualCMap;
        }
        for (mal_uint32 iChannel = 0; iChannel < pDevice->capture.internalChannels; ++iChannel) {
            pDevice->capture.internalChannelMap[iChannel] = mal_channel_position_from_pulse(cmap.map[iChannel]);
        }

        /* Buffer. */
        pActualAttr = ((mal_pa_stream_get_buffer_attr_proc)pContext->pulse.pa_stream_get_buffer_attr)((mal_pa_stream*)pDevice->pulse.pStreamCapture);
        if (pActualAttr != NULL) {
            attr = *pActualAttr;
        }
        pDevice->capture.internalBufferSizeInFrames = attr.maxlength / (mal_get_bytes_per_sample(pDevice->capture.internalFormat) * pDevice->capture.internalChannels);
        pDevice->capture.internalPeriods            = attr.maxlength / attr.fragsize;
    #ifdef MAL_DEBUG_OUTPUT
        printf("[PulseAudio] Capture actual attr: maxlength=%d, tlength=%d, prebuf=%d, minreq=%d, fragsize=%d; internalBufferSizeInFrames=%d\n", attr.maxlength, attr.tlength, attr.prebuf, attr.minreq, attr.fragsize, pDevice->capture.internalBufferSizeInFrames);
    #endif

        /* Name. */
        devCapture = ((mal_pa_stream_get_device_name_proc)pContext->pulse.pa_stream_get_device_name)((mal_pa_stream*)pDevice->pulse.pStreamCapture);
        if (devCapture != NULL) {
            mal_pa_operation* pOP = ((mal_pa_context_get_source_info_by_name_proc)pContext->pulse.pa_context_get_source_info_by_name)((mal_pa_context*)pDevice->pulse.pPulseContext, devCapture, mal_device_source_name_callback, pDevice);
            if (pOP != NULL) {
                mal_device__wait_for_operation__pulse(pDevice, pOP);
                ((mal_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
            }
        }
    }

    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        pOP = ((mal_pa_context_get_sink_info_by_name_proc)pContext->pulse.pa_context_get_sink_info_by_name)((mal_pa_context*)pDevice->pulse.pPulseContext, devPlayback, mal_device_sink_info_callback, &sinkInfo);
        if (pOP != NULL) {
            mal_device__wait_for_operation__pulse(pDevice, pOP);
            ((mal_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
        } else {
            result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to retrieve sink info for playback device.", mal_result_from_pulse(error));
            goto on_error3;
        }

        ss = sinkInfo.sample_spec;
        cmap = sinkInfo.channel_map;

        pDevice->playback.internalBufferSizeInFrames = mal_calculate_buffer_size_in_frames_from_milliseconds(bufferSizeInMilliseconds, ss.rate);
        pDevice->playback.internalPeriods            = pConfig->periods;

        attr = mal_device__pa_buffer_attr_new(pDevice->playback.internalBufferSizeInFrames, pConfig->periods, &ss);
    #ifdef MAL_DEBUG_OUTPUT
        printf("[PulseAudio] Playback attr: maxlength=%d, tlength=%d, prebuf=%d, minreq=%d, fragsize=%d; internalBufferSizeInFrames=%d\n", attr.maxlength, attr.tlength, attr.prebuf, attr.minreq, attr.fragsize, pDevice->playback.internalBufferSizeInFrames);
    #endif

        pDevice->pulse.pStreamPlayback = mal_device__pa_stream_new__pulse(pDevice, pConfig->pulse.pStreamNamePlayback, &ss, &cmap);
        if (pDevice->pulse.pStreamPlayback == NULL) {
            result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to create PulseAudio playback stream.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
            goto on_error3;
        }

        mal_pa_stream_flags_t streamFlags = MAL_PA_STREAM_START_CORKED | MAL_PA_STREAM_FIX_FORMAT | MAL_PA_STREAM_FIX_RATE | MAL_PA_STREAM_FIX_CHANNELS;
        if (devPlayback != NULL) {
            streamFlags |= MAL_PA_STREAM_DONT_MOVE;
        }

        error = ((mal_pa_stream_connect_playback_proc)pContext->pulse.pa_stream_connect_playback)((mal_pa_stream*)pDevice->pulse.pStreamPlayback, devPlayback, &attr, streamFlags, NULL, NULL);
        if (error != MAL_PA_OK) {
            result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to connect PulseAudio playback stream.", mal_result_from_pulse(error));
            goto on_error6;
        }

        while (((mal_pa_stream_get_state_proc)pContext->pulse.pa_stream_get_state)((mal_pa_stream*)pDevice->pulse.pStreamPlayback) != MAL_PA_STREAM_READY) {
            error = ((mal_pa_mainloop_iterate_proc)pContext->pulse.pa_mainloop_iterate)((mal_pa_mainloop*)pDevice->pulse.pMainLoop, 1, NULL);
            if (error < 0) {
                result = mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] The PulseAudio main loop returned an error while connecting the PulseAudio playback stream.", mal_result_from_pulse(error));
                goto on_error7;
            }
        }

        /* Internal format. */
        pActualSS = ((mal_pa_stream_get_sample_spec_proc)pContext->pulse.pa_stream_get_sample_spec)((mal_pa_stream*)pDevice->pulse.pStreamPlayback);
        if (pActualSS != NULL) {
            /* If anything has changed between the requested and the actual sample spec, we need to update the buffer. */
            if (ss.format != pActualSS->format || ss.channels != pActualSS->channels || ss.rate != pActualSS->rate) {
                attr = mal_device__pa_buffer_attr_new(pDevice->playback.internalBufferSizeInFrames, pConfig->periods, pActualSS);

                pOP = ((mal_pa_stream_set_buffer_attr_proc)pContext->pulse.pa_stream_set_buffer_attr)((mal_pa_stream*)pDevice->pulse.pStreamPlayback, &attr, NULL, NULL);
                if (pOP != NULL) {
                    mal_device__wait_for_operation__pulse(pDevice, pOP);
                    ((mal_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
                }
            }

            ss = *pActualSS;
        }

        pDevice->playback.internalFormat     = mal_format_from_pulse(ss.format);
        pDevice->playback.internalChannels   = ss.channels;
        pDevice->playback.internalSampleRate = ss.rate;

        /* Internal channel map. */
        pActualCMap = ((mal_pa_stream_get_channel_map_proc)pContext->pulse.pa_stream_get_channel_map)((mal_pa_stream*)pDevice->pulse.pStreamPlayback);
        if (pActualCMap != NULL) {
            cmap = *pActualCMap;
        }
        for (mal_uint32 iChannel = 0; iChannel < pDevice->playback.internalChannels; ++iChannel) {
            pDevice->playback.internalChannelMap[iChannel] = mal_channel_position_from_pulse(cmap.map[iChannel]);
        }

        /* Buffer. */
        pActualAttr = ((mal_pa_stream_get_buffer_attr_proc)pContext->pulse.pa_stream_get_buffer_attr)((mal_pa_stream*)pDevice->pulse.pStreamPlayback);
        if (pActualAttr != NULL) {
            attr = *pActualAttr;
        }
        pDevice->playback.internalBufferSizeInFrames = attr.maxlength / (mal_get_bytes_per_sample(pDevice->playback.internalFormat) * pDevice->playback.internalChannels);
        pDevice->playback.internalPeriods            = /*pConfig->periods;*/attr.maxlength / attr.tlength;
    #ifdef MAL_DEBUG_OUTPUT
        printf("[PulseAudio] Playback actual attr: maxlength=%d, tlength=%d, prebuf=%d, minreq=%d, fragsize=%d; internalBufferSizeInFrames=%d\n", attr.maxlength, attr.tlength, attr.prebuf, attr.minreq, attr.fragsize, pDevice->playback.internalBufferSizeInFrames);
    #endif

        /* Name. */
        devPlayback = ((mal_pa_stream_get_device_name_proc)pContext->pulse.pa_stream_get_device_name)((mal_pa_stream*)pDevice->pulse.pStreamPlayback);
        if (devPlayback != NULL) {
            mal_pa_operation* pOP = ((mal_pa_context_get_sink_info_by_name_proc)pContext->pulse.pa_context_get_sink_info_by_name)((mal_pa_context*)pDevice->pulse.pPulseContext, devPlayback, mal_device_sink_name_callback, pDevice);
            if (pOP != NULL) {
                mal_device__wait_for_operation__pulse(pDevice, pOP);
                ((mal_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
            }
        }
    }

    return MAL_SUCCESS;


on_error7:
    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        ((mal_pa_stream_disconnect_proc)pContext->pulse.pa_stream_disconnect)((mal_pa_stream*)pDevice->pulse.pStreamPlayback);
    }
on_error6:
    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        ((mal_pa_stream_unref_proc)pContext->pulse.pa_stream_unref)((mal_pa_stream*)pDevice->pulse.pStreamPlayback);
    }
on_error5:
    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        ((mal_pa_stream_disconnect_proc)pContext->pulse.pa_stream_disconnect)((mal_pa_stream*)pDevice->pulse.pStreamCapture);
    }
on_error4:
    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        ((mal_pa_stream_unref_proc)pContext->pulse.pa_stream_unref)((mal_pa_stream*)pDevice->pulse.pStreamCapture);
    }
on_error3: ((mal_pa_context_disconnect_proc)pContext->pulse.pa_context_disconnect)((mal_pa_context*)pDevice->pulse.pPulseContext);
on_error2: ((mal_pa_context_unref_proc)pContext->pulse.pa_context_unref)((mal_pa_context*)pDevice->pulse.pPulseContext);
on_error1: ((mal_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)((mal_pa_mainloop*)pDevice->pulse.pMainLoop);
on_error0:
    return result;
}


void mal_pulse_operation_complete_callback(mal_pa_stream* pStream, int success, void* pUserData)
{
    mal_bool32* pIsSuccessful = (mal_bool32*)pUserData;
    mal_assert(pIsSuccessful != NULL);

    *pIsSuccessful = (mal_bool32)success;
}

mal_result mal_device__cork_stream__pulse(mal_device* pDevice, mal_device_type deviceType, int cork)
{
    mal_context* pContext = pDevice->pContext;
    mal_assert(pContext != NULL);

    /* This should not be called with a duplex device type. */
    if (deviceType == mal_device_type_duplex) {
        return MAL_INVALID_ARGS;
    }

    mal_bool32 wasSuccessful = MAL_FALSE;

    mal_pa_stream* pStream = (mal_pa_stream*)((deviceType == mal_device_type_capture) ? pDevice->pulse.pStreamCapture : pDevice->pulse.pStreamPlayback);
    mal_assert(pStream != NULL);

    mal_pa_operation* pOP = ((mal_pa_stream_cork_proc)pContext->pulse.pa_stream_cork)(pStream, cork, mal_pulse_operation_complete_callback, &wasSuccessful);
    if (pOP == NULL) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to cork PulseAudio stream.", (cork == 0) ? MAL_FAILED_TO_START_BACKEND_DEVICE : MAL_FAILED_TO_STOP_BACKEND_DEVICE);
    }

    mal_result result = mal_device__wait_for_operation__pulse(pDevice, pOP);
    ((mal_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);

    if (result != MAL_SUCCESS) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] An error occurred while waiting for the PulseAudio stream to cork.", result);
    }

    if (!wasSuccessful) {
        if (cork) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to stop PulseAudio stream.", MAL_FAILED_TO_STOP_BACKEND_DEVICE);
        } else {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to start PulseAudio stream.", MAL_FAILED_TO_START_BACKEND_DEVICE);
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_device_stop__pulse(mal_device* pDevice)
{
    mal_result result;
    mal_bool32 wasSuccessful;
    mal_pa_operation* pOP;

    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        result = mal_device__cork_stream__pulse(pDevice, mal_device_type_capture, 1);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        /* The stream needs to be drained if it's a playback device. */
        pOP = ((mal_pa_stream_drain_proc)pDevice->pContext->pulse.pa_stream_drain)((mal_pa_stream*)pDevice->pulse.pStreamPlayback, mal_pulse_operation_complete_callback, &wasSuccessful);
        if (pOP != NULL) {
            mal_device__wait_for_operation__pulse(pDevice, pOP);
            ((mal_pa_operation_unref_proc)pDevice->pContext->pulse.pa_operation_unref)(pOP);
        }

        result = mal_device__cork_stream__pulse(pDevice, mal_device_type_playback, 1);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_device_write__pulse(mal_device* pDevice, const void* pPCMFrames, mal_uint32 frameCount)
{
    mal_assert(pDevice != NULL);
    mal_assert(pPCMFrames != NULL);
    mal_assert(frameCount > 0);

    /* The stream needs to be uncorked first. */
    if (((mal_pa_stream_is_corked_proc)pDevice->pContext->pulse.pa_stream_is_corked)(pDevice->pulse.pStreamPlayback)) {
        mal_result result = mal_device__cork_stream__pulse(pDevice, mal_device_type_playback, 0);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    mal_uint32 totalFramesWritten = 0;
    while (totalFramesWritten < frameCount) {
        //printf("TRACE: Outer loop.\n");

        /* Place the data into the mapped buffer if we have one. */
        if (pDevice->pulse.pMappedBufferPlayback != NULL && pDevice->pulse.mappedBufferFramesRemainingPlayback > 0) {
            //printf("TRACE: Copying data.\n");

            mal_uint32 bpf = mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
            mal_uint32 mappedBufferFramesConsumed = pDevice->pulse.mappedBufferFramesCapacityPlayback - pDevice->pulse.mappedBufferFramesRemainingPlayback;

            void* pDst = (mal_uint8*)pDevice->pulse.pMappedBufferPlayback + (mappedBufferFramesConsumed * bpf);
            const void* pSrc = (const mal_uint8*)pPCMFrames + (totalFramesWritten * bpf);
            mal_uint32  framesToCopy = mal_min(pDevice->pulse.mappedBufferFramesRemainingPlayback, (frameCount - totalFramesWritten));
            mal_copy_memory(pDst, pSrc, framesToCopy * bpf);

            pDevice->pulse.mappedBufferFramesRemainingPlayback -= framesToCopy;
            totalFramesWritten += framesToCopy;
        }

        /*
        Getting here means we've run out of data in the currently mapped chunk. We need to write this to the device and then try
        mapping another chunk. If this fails we need to wait for space to become available.
        */
        if (pDevice->pulse.mappedBufferFramesCapacityPlayback > 0 && pDevice->pulse.mappedBufferFramesRemainingPlayback == 0) {
            size_t nbytes = pDevice->pulse.mappedBufferFramesCapacityPlayback * mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
            //printf("TRACE: Submitting data. %d\n", nbytes);

            int error = ((mal_pa_stream_write_proc)pDevice->pContext->pulse.pa_stream_write)((mal_pa_stream*)pDevice->pulse.pStreamPlayback, pDevice->pulse.pMappedBufferPlayback, nbytes, NULL, 0, MAL_PA_SEEK_RELATIVE);
            if (error < 0) {
                return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to write data to the PulseAudio stream.", mal_result_from_pulse(error));
            }

            pDevice->pulse.pMappedBufferPlayback = NULL;
            pDevice->pulse.mappedBufferFramesRemainingPlayback = 0;
            pDevice->pulse.mappedBufferFramesCapacityPlayback = 0;
        }

        mal_assert(totalFramesWritten <= frameCount);
        if (totalFramesWritten == frameCount) {
            break;
        }

        /* Getting here means we need to map a new buffer. If we don't have enough space we need to wait for more. */
        for (;;) {
            //printf("TRACE: Inner loop.\n");

            /* If the device has been corked, don't try to continue. */
            if (((mal_pa_stream_is_corked_proc)pDevice->pContext->pulse.pa_stream_is_corked)(pDevice->pulse.pStreamPlayback)) {
                break;
            }

            size_t writableSizeInBytes = ((mal_pa_stream_writable_size_proc)pDevice->pContext->pulse.pa_stream_writable_size)((mal_pa_stream*)pDevice->pulse.pStreamPlayback);
            if (writableSizeInBytes != (size_t)-1) {
                size_t periodSizeInBytes = (pDevice->playback.internalBufferSizeInFrames / pDevice->playback.internalPeriods) * mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
                if (writableSizeInBytes >= periodSizeInBytes) {
                    //printf("TRACE: Data available.\n");

                    /* Data is avaialable. */
                    size_t bytesToMap = periodSizeInBytes;
                    int error = ((mal_pa_stream_begin_write_proc)pDevice->pContext->pulse.pa_stream_begin_write)((mal_pa_stream*)pDevice->pulse.pStreamPlayback, &pDevice->pulse.pMappedBufferPlayback, &bytesToMap);
                    if (error < 0) {
                        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to map write buffer.", mal_result_from_pulse(error));
                    }

                    pDevice->pulse.mappedBufferFramesCapacityPlayback  = bytesToMap / mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
                    pDevice->pulse.mappedBufferFramesRemainingPlayback = pDevice->pulse.mappedBufferFramesCapacityPlayback;

                    break;
                } else {
                    /* No data available. Need to wait for more. */
                    //printf("TRACE: Playback: pa_mainloop_iterate(). writableSizeInBytes=%d, periodSizeInBytes=%d\n", writableSizeInBytes, periodSizeInBytes);

                    int error = ((mal_pa_mainloop_iterate_proc)pDevice->pContext->pulse.pa_mainloop_iterate)(pDevice->pulse.pMainLoop, 1, NULL);
                    if (error < 0) {
                        return mal_result_from_pulse(error);
                    }

                    continue;
                }
            } else {
                return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to query the stream's writable size.", MAL_ERROR);
            }
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_device_read__pulse(mal_device* pDevice, void* pPCMFrames, mal_uint32 frameCount)
{
    mal_assert(pDevice != NULL);
    mal_assert(pPCMFrames != NULL);
    mal_assert(frameCount > 0);

    /* The stream needs to be uncorked first. */
    if (((mal_pa_stream_is_corked_proc)pDevice->pContext->pulse.pa_stream_is_corked)(pDevice->pulse.pStreamCapture)) {
        mal_result result = mal_device__cork_stream__pulse(pDevice, mal_device_type_capture, 0);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    mal_uint32 totalFramesRead = 0;
    while (totalFramesRead < frameCount) {
        /* If a buffer is mapped we need to write to that first. Once it's consumed we reset the event and unmap it. */
        if (pDevice->pulse.pMappedBufferCapture != NULL && pDevice->pulse.mappedBufferFramesRemainingCapture > 0) {
            mal_uint32 bpf = mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
            mal_uint32 mappedBufferFramesConsumed = pDevice->pulse.mappedBufferFramesCapacityCapture - pDevice->pulse.mappedBufferFramesRemainingCapture;

            mal_uint32  framesToCopy = mal_min(pDevice->pulse.mappedBufferFramesRemainingCapture, (frameCount - totalFramesRead));
            void* pDst = (mal_uint8*)pPCMFrames + (totalFramesRead * bpf);

            /*
            This little bit of logic here is specifically for PulseAudio and it's hole management. The buffer pointer will be set to NULL
            when the current fragment is a hole. For a hole we just output silence.
            */
            if (pDevice->pulse.pMappedBufferCapture != NULL) {
                const void* pSrc = (const mal_uint8*)pDevice->pulse.pMappedBufferCapture + (mappedBufferFramesConsumed * bpf);
                mal_copy_memory(pDst, pSrc, framesToCopy * bpf);
            } else {
                mal_zero_memory(pDst, framesToCopy * bpf);
            }

            pDevice->pulse.mappedBufferFramesRemainingCapture -= framesToCopy;
            totalFramesRead += framesToCopy;
        }

        /*
        Getting here means we've run out of data in the currently mapped chunk. We need to drop this from the device and then try
        mapping another chunk. If this fails we need to wait for data to become available.
        */
        if (pDevice->pulse.mappedBufferFramesCapacityCapture > 0 && pDevice->pulse.mappedBufferFramesRemainingCapture == 0) {
            //printf("TRACE: Dropping fragment. %d\n", nbytes);

            int error = ((mal_pa_stream_drop_proc)pDevice->pContext->pulse.pa_stream_drop)((mal_pa_stream*)pDevice->pulse.pStreamCapture);
            if (error != 0) {
                return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to drop fragment.", mal_result_from_pulse(error));
            }

            pDevice->pulse.pMappedBufferCapture = NULL;
            pDevice->pulse.mappedBufferFramesRemainingCapture = 0;
            pDevice->pulse.mappedBufferFramesCapacityCapture = 0;
        }

        mal_assert(totalFramesRead <= frameCount);
        if (totalFramesRead == frameCount) {
            break;
        }

        /* Getting here means we need to map a new buffer. If we don't have enough data we wait for more. */
        for (;;) {
            //printf("TRACE: Inner loop.\n");

            /* If the device has been corked, don't try to continue. */
            if (((mal_pa_stream_is_corked_proc)pDevice->pContext->pulse.pa_stream_is_corked)(pDevice->pulse.pStreamCapture)) {
                break;
            }

            size_t readableSizeInBytes = ((mal_pa_stream_readable_size_proc)pDevice->pContext->pulse.pa_stream_readable_size)((mal_pa_stream*)pDevice->pulse.pStreamCapture);
            if (readableSizeInBytes != (size_t)-1) {
                size_t periodSizeInBytes = (pDevice->capture.internalBufferSizeInFrames / pDevice->capture.internalPeriods) * mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
                if (readableSizeInBytes >= periodSizeInBytes) {
                    /* Data is avaialable. */
                    size_t bytesMapped = (size_t)-1;
                    int error = ((mal_pa_stream_peek_proc)pDevice->pContext->pulse.pa_stream_peek)((mal_pa_stream*)pDevice->pulse.pStreamCapture, &pDevice->pulse.pMappedBufferCapture, &bytesMapped);
                    if (error < 0) {
                        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to peek capture buffer.", mal_result_from_pulse(error));
                    }

                    //printf("TRACE: Data available: bytesMapped=%d, readableSizeInBytes=%d, periodSizeInBytes=%d.\n", bytesMapped, readableSizeInBytes, periodSizeInBytes);

                    if (pDevice->pulse.pMappedBufferCapture == NULL && bytesMapped == 0) {
                        /* Nothing available. This shouldn't happen because we checked earlier with pa_stream_readable_size(). I'm going to throw an error in this case. */
                        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Nothing available after peeking capture buffer.", MAL_ERROR);
                    }

                    pDevice->pulse.mappedBufferFramesCapacityCapture  = bytesMapped / mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
                    pDevice->pulse.mappedBufferFramesRemainingCapture = pDevice->pulse.mappedBufferFramesCapacityCapture;

                    break;
                } else {
                    /* No data available. Need to wait for more. */
                    //printf("TRACE: Capture: pa_mainloop_iterate(). readableSizeInBytes=%d, periodSizeInBytes=%d\n", readableSizeInBytes, periodSizeInBytes);

                    int error = ((mal_pa_mainloop_iterate_proc)pDevice->pContext->pulse.pa_mainloop_iterate)(pDevice->pulse.pMainLoop, 1, NULL);
                    if (error < 0) {
                        return mal_result_from_pulse(error);
                    }

                    continue;
                }
            } else {
                return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[PulseAudio] Failed to query the stream's readable size.", MAL_ERROR);
            }
        }
    }

    return MAL_SUCCESS;
}


mal_result mal_context_uninit__pulse(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    mal_assert(pContext->backend == mal_backend_pulseaudio);

#ifndef MAL_NO_RUNTIME_LINKING
    mal_dlclose(pContext->pulse.pulseSO);
#endif

    return MAL_SUCCESS;
}

mal_result mal_context_init__pulse(mal_context* pContext)
{
    mal_assert(pContext != NULL);

#ifndef MAL_NO_RUNTIME_LINKING
    // libpulse.so
    const char* libpulseNames[] = {
        "libpulse.so",
        "libpulse.so.0"
    };

    for (size_t i = 0; i < mal_countof(libpulseNames); ++i) {
        pContext->pulse.pulseSO = mal_dlopen(libpulseNames[i]);
        if (pContext->pulse.pulseSO != NULL) {
            break;
        }
    }

    if (pContext->pulse.pulseSO == NULL) {
        return MAL_NO_BACKEND;
    }

    pContext->pulse.pa_mainloop_new                    = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_mainloop_new");
    pContext->pulse.pa_mainloop_free                   = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_mainloop_free");
    pContext->pulse.pa_mainloop_get_api                = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_mainloop_get_api");
    pContext->pulse.pa_mainloop_iterate                = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_mainloop_iterate");
    pContext->pulse.pa_mainloop_wakeup                 = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_mainloop_wakeup");
    pContext->pulse.pa_context_new                     = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_context_new");
    pContext->pulse.pa_context_unref                   = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_context_unref");
    pContext->pulse.pa_context_connect                 = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_context_connect");
    pContext->pulse.pa_context_disconnect              = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_context_disconnect");
    pContext->pulse.pa_context_set_state_callback      = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_context_set_state_callback");
    pContext->pulse.pa_context_get_state               = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_context_get_state");
    pContext->pulse.pa_context_get_sink_info_list      = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_context_get_sink_info_list");
    pContext->pulse.pa_context_get_source_info_list    = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_context_get_source_info_list");
    pContext->pulse.pa_context_get_sink_info_by_name   = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_context_get_sink_info_by_name");
    pContext->pulse.pa_context_get_source_info_by_name = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_context_get_source_info_by_name");
    pContext->pulse.pa_operation_unref                 = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_operation_unref");
    pContext->pulse.pa_operation_get_state             = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_operation_get_state");
    pContext->pulse.pa_channel_map_init_extend         = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_channel_map_init_extend");
    pContext->pulse.pa_channel_map_valid               = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_channel_map_valid");
    pContext->pulse.pa_channel_map_compatible          = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_channel_map_compatible");
    pContext->pulse.pa_stream_new                      = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_new");
    pContext->pulse.pa_stream_unref                    = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_unref");
    pContext->pulse.pa_stream_connect_playback         = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_connect_playback");
    pContext->pulse.pa_stream_connect_record           = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_connect_record");
    pContext->pulse.pa_stream_disconnect               = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_disconnect");
    pContext->pulse.pa_stream_get_state                = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_get_state");
    pContext->pulse.pa_stream_get_sample_spec          = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_get_sample_spec");
    pContext->pulse.pa_stream_get_channel_map          = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_get_channel_map");
    pContext->pulse.pa_stream_get_buffer_attr          = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_get_buffer_attr");
    pContext->pulse.pa_stream_set_buffer_attr          = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_set_buffer_attr");
    pContext->pulse.pa_stream_get_device_name          = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_get_device_name");
    pContext->pulse.pa_stream_set_write_callback       = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_set_write_callback");
    pContext->pulse.pa_stream_set_read_callback        = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_set_read_callback");
    pContext->pulse.pa_stream_flush                    = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_flush");
    pContext->pulse.pa_stream_drain                    = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_drain");
    pContext->pulse.pa_stream_is_corked                = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_is_corked");
    pContext->pulse.pa_stream_cork                     = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_cork");
    pContext->pulse.pa_stream_trigger                  = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_trigger");
    pContext->pulse.pa_stream_begin_write              = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_begin_write");
    pContext->pulse.pa_stream_write                    = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_write");
    pContext->pulse.pa_stream_peek                     = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_peek");
    pContext->pulse.pa_stream_drop                     = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_drop");
    pContext->pulse.pa_stream_writable_size            = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_writable_size");
    pContext->pulse.pa_stream_readable_size            = (mal_proc)mal_dlsym(pContext->pulse.pulseSO, "pa_stream_readable_size");
#else
    // This strange assignment system is just for type safety.
    mal_pa_mainloop_new_proc                    _pa_mainloop_new                   = pa_mainloop_new;
    mal_pa_mainloop_free_proc                   _pa_mainloop_free                  = pa_mainloop_free;
    mal_pa_mainloop_get_api_proc                _pa_mainloop_get_api               = pa_mainloop_get_api;
    mal_pa_mainloop_iterate_proc                _pa_mainloop_iterate               = pa_mainloop_iterate;
    mal_pa_mainloop_wakeup_proc                 _pa_mainloop_wakeup                = pa_mainloop_wakeup;
    mal_pa_context_new_proc                     _pa_context_new                    = pa_context_new;
    mal_pa_context_unref_proc                   _pa_context_unref                  = pa_context_unref;
    mal_pa_context_connect_proc                 _pa_context_connect                = pa_context_connect;
    mal_pa_context_disconnect_proc              _pa_context_disconnect             = pa_context_disconnect;
    mal_pa_context_set_state_callback_proc      _pa_context_set_state_callback     = pa_context_set_state_callback;
    mal_pa_context_get_state_proc               _pa_context_get_state              = pa_context_get_state;
    mal_pa_context_get_sink_info_list_proc      _pa_context_get_sink_info_list     = pa_context_get_sink_info_list;
    mal_pa_context_get_source_info_list_proc    _pa_context_get_source_info_list   = pa_context_get_source_info_list;
    mal_pa_context_get_sink_info_by_name_proc   _pa_context_get_sink_info_by_name  = pa_context_get_sink_info_by_name;
    mal_pa_context_get_source_info_by_name_proc _pa_context_get_source_info_by_name= pa_context_get_source_info_by_name;
    mal_pa_operation_unref_proc                 _pa_operation_unref                = pa_operation_unref;
    mal_pa_operation_get_state_proc             _pa_operation_get_state            = pa_operation_get_state;
    mal_pa_channel_map_init_extend_proc         _pa_channel_map_init_extend        = pa_channel_map_init_extend;
    mal_pa_channel_map_valid_proc               _pa_channel_map_valid              = pa_channel_map_valid;
    mal_pa_channel_map_compatible_proc          _pa_channel_map_compatible         = pa_channel_map_compatible;
    mal_pa_stream_new_proc                      _pa_stream_new                     = pa_stream_new;
    mal_pa_stream_unref_proc                    _pa_stream_unref                   = pa_stream_unref;
    mal_pa_stream_connect_playback_proc         _pa_stream_connect_playback        = pa_stream_connect_playback;
    mal_pa_stream_connect_record_proc           _pa_stream_connect_record          = pa_stream_connect_record;
    mal_pa_stream_disconnect_proc               _pa_stream_disconnect              = pa_stream_disconnect;
    mal_pa_stream_get_state_proc                _pa_stream_get_state               = pa_stream_get_state;
    mal_pa_stream_get_sample_spec_proc          _pa_stream_get_sample_spec         = pa_stream_get_sample_spec;
    mal_pa_stream_get_channel_map_proc          _pa_stream_get_channel_map         = pa_stream_get_channel_map;
    mal_pa_stream_get_buffer_attr_proc          _pa_stream_get_buffer_attr         = pa_stream_get_buffer_attr;
    mal_pa_stream_set_buffer_attr_proc          _pa_stream_set_buffer_attr         = pa_stream_set_buffer_attr;
    mal_pa_stream_get_device_name_proc          _pa_stream_get_device_name         = pa_stream_get_device_name;
    mal_pa_stream_set_write_callback_proc       _pa_stream_set_write_callback      = pa_stream_set_write_callback;
    mal_pa_stream_set_read_callback_proc        _pa_stream_set_read_callback       = pa_stream_set_read_callback;
    mal_pa_stream_flush_proc                    _pa_stream_flush                   = pa_stream_flush;
    mal_pa_stream_drain_proc                    _pa_stream_drain                   = pa_stream_drain;
    mal_pa_stream_ic_corked_proc                _pa_stream_is_corked               = pa_stream_is_corked;
    mal_pa_stream_cork_proc                     _pa_stream_cork                    = pa_stream_cork;
    mal_pa_stream_trigger_proc                  _pa_stream_trigger                 = pa_stream_trigger;
    mal_pa_stream_begin_write_proc              _pa_stream_begin_write             = pa_stream_begin_write;
    mal_pa_stream_write_proc                    _pa_stream_write                   = pa_stream_write;
    mal_pa_stream_peek_proc                     _pa_stream_peek                    = pa_stream_peek;
    mal_pa_stream_drop_proc                     _pa_stream_drop                    = pa_stream_drop;
    mal_pa_stream_writable_size_proc            _pa_stream_writable_size           = pa_stream_writable_size;
    mal_pa_stream_readable_size_proc            _pa_stream_readable_size           = pa_stream_readable_size;

    pContext->pulse.pa_mainloop_new                    = (mal_proc)_pa_mainloop_new;
    pContext->pulse.pa_mainloop_free                   = (mal_proc)_pa_mainloop_free;
    pContext->pulse.pa_mainloop_get_api                = (mal_proc)_pa_mainloop_get_api;
    pContext->pulse.pa_mainloop_iterate                = (mal_proc)_pa_mainloop_iterate;
    pContext->pulse.pa_mainloop_wakeup                 = (mal_proc)_pa_mainloop_wakeup;
    pContext->pulse.pa_context_new                     = (mal_proc)_pa_context_new;
    pContext->pulse.pa_context_unref                   = (mal_proc)_pa_context_unref;
    pContext->pulse.pa_context_connect                 = (mal_proc)_pa_context_connect;
    pContext->pulse.pa_context_disconnect              = (mal_proc)_pa_context_disconnect;
    pContext->pulse.pa_context_set_state_callback      = (mal_proc)_pa_context_set_state_callback;
    pContext->pulse.pa_context_get_state               = (mal_proc)_pa_context_get_state;
    pContext->pulse.pa_context_get_sink_info_list      = (mal_proc)_pa_context_get_sink_info_list;
    pContext->pulse.pa_context_get_source_info_list    = (mal_proc)_pa_context_get_source_info_list;
    pContext->pulse.pa_context_get_sink_info_by_name   = (mal_proc)_pa_context_get_sink_info_by_name;
    pContext->pulse.pa_context_get_source_info_by_name = (mal_proc)_pa_context_get_source_info_by_name;
    pContext->pulse.pa_operation_unref                 = (mal_proc)_pa_operation_unref;
    pContext->pulse.pa_operation_get_state             = (mal_proc)_pa_operation_get_state;
    pContext->pulse.pa_channel_map_init_extend         = (mal_proc)_pa_channel_map_init_extend;
    pContext->pulse.pa_channel_map_valid               = (mal_proc)_pa_channel_map_valid;
    pContext->pulse.pa_channel_map_compatible          = (mal_proc)_pa_channel_map_compatible;
    pContext->pulse.pa_stream_new                      = (mal_proc)_pa_stream_new;
    pContext->pulse.pa_stream_unref                    = (mal_proc)_pa_stream_unref;
    pContext->pulse.pa_stream_connect_playback         = (mal_proc)_pa_stream_connect_playback;
    pContext->pulse.pa_stream_connect_record           = (mal_proc)_pa_stream_connect_record;
    pContext->pulse.pa_stream_disconnect               = (mal_proc)_pa_stream_disconnect;
    pContext->pulse.pa_stream_get_state                = (mal_proc)_pa_stream_get_state;
    pContext->pulse.pa_stream_get_sample_spec          = (mal_proc)_pa_stream_get_sample_spec;
    pContext->pulse.pa_stream_get_channel_map          = (mal_proc)_pa_stream_get_channel_map;
    pContext->pulse.pa_stream_get_buffer_attr          = (mal_proc)_pa_stream_get_buffer_attr;
    pContext->pulse.pa_stream_set_buffer_attr          = (mal_proc)_pa_stream_set_buffer_attr;
    pContext->pulse.pa_stream_get_device_name          = (mal_proc)_pa_stream_get_device_name;
    pContext->pulse.pa_stream_set_write_callback       = (mal_proc)_pa_stream_set_write_callback;
    pContext->pulse.pa_stream_set_read_callback        = (mal_proc)_pa_stream_set_read_callback;
    pContext->pulse.pa_stream_flush                    = (mal_proc)_pa_stream_flush;
    pContext->pulse.pa_stream_drain                    = (mal_proc)_pa_stream_drain;
    pContext->pulse.pa_stream_is_corked                = (mal_proc)_pa_stream_is_corked;
    pContext->pulse.pa_stream_cork                     = (mal_proc)_pa_stream_cork;
    pContext->pulse.pa_stream_trigger                  = (mal_proc)_pa_stream_trigger;
    pContext->pulse.pa_stream_begin_write              = (mal_proc)_pa_stream_begin_write;
    pContext->pulse.pa_stream_write                    = (mal_proc)_pa_stream_write;
    pContext->pulse.pa_stream_peek                     = (mal_proc)_pa_stream_peek;
    pContext->pulse.pa_stream_drop                     = (mal_proc)_pa_stream_drop;
    pContext->pulse.pa_stream_writable_size            = (mal_proc)_pa_stream_writable_size;
    pContext->pulse.pa_stream_readable_size            = (mal_proc)_pa_stream_readable_size;
#endif

    pContext->onUninit         = mal_context_uninit__pulse;
    pContext->onDeviceIDEqual  = mal_context_is_device_id_equal__pulse;
    pContext->onEnumDevices    = mal_context_enumerate_devices__pulse;
    pContext->onGetDeviceInfo  = mal_context_get_device_info__pulse;
    pContext->onDeviceInit     = mal_device_init__pulse;
    pContext->onDeviceUninit   = mal_device_uninit__pulse;
    pContext->onDeviceStart    = NULL;
    pContext->onDeviceStop     = mal_device_stop__pulse;
    pContext->onDeviceWrite    = mal_device_write__pulse;
    pContext->onDeviceRead     = mal_device_read__pulse;

    
    // Although we have found the libpulse library, it doesn't necessarily mean PulseAudio is useable. We need to initialize
    // and connect a dummy PulseAudio context to test PulseAudio's usability.
    mal_pa_mainloop* pMainLoop = ((mal_pa_mainloop_new_proc)pContext->pulse.pa_mainloop_new)();
    if (pMainLoop == NULL) {
        return MAL_NO_BACKEND;
    }

    mal_pa_mainloop_api* pAPI = ((mal_pa_mainloop_get_api_proc)pContext->pulse.pa_mainloop_get_api)(pMainLoop);
    if (pAPI == NULL) {
        ((mal_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
        return MAL_NO_BACKEND;
    }

    mal_pa_context* pPulseContext = ((mal_pa_context_new_proc)pContext->pulse.pa_context_new)(pAPI, pContext->config.pulse.pApplicationName);
    if (pPulseContext == NULL) {
        ((mal_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
        return MAL_NO_BACKEND;
    }

    int error = ((mal_pa_context_connect_proc)pContext->pulse.pa_context_connect)(pPulseContext, pContext->config.pulse.pServerName, 0, NULL);
    if (error != MAL_PA_OK) {
        ((mal_pa_context_unref_proc)pContext->pulse.pa_context_unref)(pPulseContext);
        ((mal_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
        return MAL_NO_BACKEND;
    }

    ((mal_pa_context_disconnect_proc)pContext->pulse.pa_context_disconnect)(pPulseContext);
    ((mal_pa_context_unref_proc)pContext->pulse.pa_context_unref)(pPulseContext);
    ((mal_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
    return MAL_SUCCESS;
}
#endif


///////////////////////////////////////////////////////////////////////////////
//
// JACK Backend
//
///////////////////////////////////////////////////////////////////////////////
#ifdef MAL_HAS_JACK

// It is assumed jack.h is available when compile-time linking is being used.
#ifdef MAL_NO_RUNTIME_LINKING
#include <jack/jack.h>

typedef jack_nframes_t              mal_jack_nframes_t;
typedef jack_options_t              mal_jack_options_t;
typedef jack_status_t               mal_jack_status_t;
typedef jack_client_t               mal_jack_client_t;
typedef jack_port_t                 mal_jack_port_t;
typedef JackProcessCallback         mal_JackProcessCallback;
typedef JackBufferSizeCallback      mal_JackBufferSizeCallback;
typedef JackShutdownCallback        mal_JackShutdownCallback;
#define MAL_JACK_DEFAULT_AUDIO_TYPE JACK_DEFAULT_AUDIO_TYPE
#define mal_JackNoStartServer       JackNoStartServer
#define mal_JackPortIsInput         JackPortIsInput
#define mal_JackPortIsOutput        JackPortIsOutput
#define mal_JackPortIsPhysical      JackPortIsPhysical
#else
typedef mal_uint32               mal_jack_nframes_t;
typedef int                      mal_jack_options_t;
typedef int                      mal_jack_status_t;
typedef struct mal_jack_client_t mal_jack_client_t;
typedef struct mal_jack_port_t   mal_jack_port_t;
typedef int  (* mal_JackProcessCallback)   (mal_jack_nframes_t nframes, void* arg);
typedef int  (* mal_JackBufferSizeCallback)(mal_jack_nframes_t nframes, void* arg);
typedef void (* mal_JackShutdownCallback)  (void* arg);
#define MAL_JACK_DEFAULT_AUDIO_TYPE "32 bit float mono audio"
#define mal_JackNoStartServer       1
#define mal_JackPortIsInput         1
#define mal_JackPortIsOutput        2
#define mal_JackPortIsPhysical      4
#endif

typedef mal_jack_client_t* (* mal_jack_client_open_proc)             (const char* client_name, mal_jack_options_t options, mal_jack_status_t* status, ...);
typedef int                (* mal_jack_client_close_proc)            (mal_jack_client_t* client);
typedef int                (* mal_jack_client_name_size_proc)        ();
typedef int                (* mal_jack_set_process_callback_proc)    (mal_jack_client_t* client, mal_JackProcessCallback process_callback, void* arg);
typedef int                (* mal_jack_set_buffer_size_callback_proc)(mal_jack_client_t* client, mal_JackBufferSizeCallback bufsize_callback, void* arg);
typedef void               (* mal_jack_on_shutdown_proc)             (mal_jack_client_t* client, mal_JackShutdownCallback function, void* arg);
typedef mal_jack_nframes_t (* mal_jack_get_sample_rate_proc)         (mal_jack_client_t* client);
typedef mal_jack_nframes_t (* mal_jack_get_buffer_size_proc)         (mal_jack_client_t* client);
typedef const char**       (* mal_jack_get_ports_proc)               (mal_jack_client_t* client, const char* port_name_pattern, const char* type_name_pattern, unsigned long flags);
typedef int                (* mal_jack_activate_proc)                (mal_jack_client_t* client);
typedef int                (* mal_jack_deactivate_proc)              (mal_jack_client_t* client);
typedef int                (* mal_jack_connect_proc)                 (mal_jack_client_t* client, const char* source_port, const char* destination_port);
typedef mal_jack_port_t*   (* mal_jack_port_register_proc)           (mal_jack_client_t* client, const char* port_name, const char* port_type, unsigned long flags, unsigned long buffer_size);
typedef const char*        (* mal_jack_port_name_proc)               (const mal_jack_port_t* port);
typedef void*              (* mal_jack_port_get_buffer_proc)         (mal_jack_port_t* port, mal_jack_nframes_t nframes);
typedef void               (* mal_jack_free_proc)                    (void* ptr);

mal_result mal_context_open_client__jack(mal_context* pContext, mal_jack_client_t** ppClient)
{
    mal_assert(pContext != NULL);
    mal_assert(ppClient != NULL);

    if (ppClient) {
        *ppClient = NULL;
    }

    size_t maxClientNameSize = ((mal_jack_client_name_size_proc)pContext->jack.jack_client_name_size)(); // Includes null terminator.

    char clientName[256];
    mal_strncpy_s(clientName, mal_min(sizeof(clientName), maxClientNameSize), (pContext->config.jack.pClientName != NULL) ? pContext->config.jack.pClientName : "mini_al", (size_t)-1);

    mal_jack_status_t status;
    mal_jack_client_t* pClient = ((mal_jack_client_open_proc)pContext->jack.jack_client_open)(clientName, (pContext->config.jack.tryStartServer) ? 0 : mal_JackNoStartServer, &status, NULL);
    if (pClient == NULL) {
        return MAL_FAILED_TO_OPEN_BACKEND_DEVICE;
    }

    if (ppClient) {
        *ppClient = pClient;
    }

    return MAL_SUCCESS;
}

mal_bool32 mal_context_is_device_id_equal__jack(mal_context* pContext, const mal_device_id* pID0, const mal_device_id* pID1)
{
    mal_assert(pContext != NULL);
    mal_assert(pID0 != NULL);
    mal_assert(pID1 != NULL);
    (void)pContext;

    return pID0->jack == pID1->jack;
}

mal_result mal_context_enumerate_devices__jack(mal_context* pContext, mal_enum_devices_callback_proc callback, void* pUserData)
{
    mal_assert(pContext != NULL);
    mal_assert(callback != NULL);

    mal_bool32 cbResult = MAL_TRUE;

    // Playback.
    if (cbResult) {
        mal_device_info deviceInfo;
        mal_zero_object(&deviceInfo);
        mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MAL_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
        cbResult = callback(pContext, mal_device_type_playback, &deviceInfo, pUserData);
    }

    // Capture.
    if (cbResult) {
        mal_device_info deviceInfo;
        mal_zero_object(&deviceInfo);
        mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MAL_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
        cbResult = callback(pContext, mal_device_type_capture, &deviceInfo, pUserData);
    }

    return MAL_SUCCESS;
}

mal_result mal_context_get_device_info__jack(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, mal_device_info* pDeviceInfo)
{
    mal_assert(pContext != NULL);

    (void)pContext;

    /* No exclusive mode with the JACK backend. */
    if (shareMode == mal_share_mode_exclusive) {
        return MAL_SHARE_MODE_NOT_SUPPORTED;
    }

    if (pDeviceID != NULL && pDeviceID->jack != 0) {
        return MAL_NO_DEVICE;   // Don't know the device.
    }

    // Name / Description
    if (deviceType == mal_device_type_playback) {
        mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MAL_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
    } else {
        mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MAL_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
    }

    // Jack only supports f32 and has a specific channel count and sample rate.
    pDeviceInfo->formatCount = 1;
    pDeviceInfo->formats[0] = mal_format_f32;

    // The channel count and sample rate can only be determined by opening the device.
    mal_jack_client_t* pClient;
    mal_result result = mal_context_open_client__jack(pContext, &pClient);
    if (result != MAL_SUCCESS) {
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[JACK] Failed to open client.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
    }

    pDeviceInfo->minSampleRate = ((mal_jack_get_sample_rate_proc)pContext->jack.jack_get_sample_rate)((mal_jack_client_t*)pClient);
    pDeviceInfo->maxSampleRate = pDeviceInfo->minSampleRate;

    pDeviceInfo->minChannels = 0;
    pDeviceInfo->maxChannels = 0;

    const char** ppPorts = ((mal_jack_get_ports_proc)pContext->jack.jack_get_ports)((mal_jack_client_t*)pClient, NULL, NULL, mal_JackPortIsPhysical | ((deviceType == mal_device_type_playback) ? mal_JackPortIsInput : mal_JackPortIsOutput));
    if (ppPorts == NULL) {
        ((mal_jack_client_close_proc)pContext->jack.jack_client_close)((mal_jack_client_t*)pClient);
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[JACK] Failed to query physical ports.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
    }

    while (ppPorts[pDeviceInfo->minChannels] != NULL) {
        pDeviceInfo->minChannels += 1;
        pDeviceInfo->maxChannels += 1;
    }

    ((mal_jack_free_proc)pContext->jack.jack_free)((void*)ppPorts);
    ((mal_jack_client_close_proc)pContext->jack.jack_client_close)((mal_jack_client_t*)pClient);

    return MAL_SUCCESS;
}


void mal_device_uninit__jack(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    mal_context* pContext = pDevice->pContext;
    mal_assert(pContext != NULL);

    if (pDevice->jack.pClient != NULL) {
        ((mal_jack_client_close_proc)pContext->jack.jack_client_close)((mal_jack_client_t*)pDevice->jack.pClient);
    }

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        mal_free(pDevice->jack.pIntermediaryBufferCapture);
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        mal_free(pDevice->jack.pIntermediaryBufferPlayback);
    }

    if (pDevice->type == mal_device_type_duplex) {
        mal_pcm_rb_uninit(&pDevice->jack.duplexRB);
    }
}

void mal_device__jack_shutdown_callback(void* pUserData)
{
    // JACK died. Stop the device.
    mal_device* pDevice = (mal_device*)pUserData;
    mal_assert(pDevice != NULL);

    mal_device_stop(pDevice);
}

int mal_device__jack_buffer_size_callback(mal_jack_nframes_t frameCount, void* pUserData)
{
    mal_device* pDevice = (mal_device*)pUserData;
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        float* pNewBuffer = (float*)mal_realloc(pDevice->jack.pIntermediaryBufferCapture, frameCount * (pDevice->capture.internalChannels * mal_get_bytes_per_sample(pDevice->capture.internalFormat)));
        if (pNewBuffer == NULL) {
            return MAL_OUT_OF_MEMORY;
        }

        pDevice->jack.pIntermediaryBufferCapture = pNewBuffer;
        pDevice->playback.internalBufferSizeInFrames = frameCount * pDevice->capture.internalPeriods;
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        float* pNewBuffer = (float*)mal_realloc(pDevice->jack.pIntermediaryBufferPlayback, frameCount * (pDevice->playback.internalChannels * mal_get_bytes_per_sample(pDevice->playback.internalFormat)));
        if (pNewBuffer == NULL) {
            return MAL_OUT_OF_MEMORY;
        }

        pDevice->jack.pIntermediaryBufferPlayback = pNewBuffer;
        pDevice->playback.internalBufferSizeInFrames = frameCount * pDevice->playback.internalPeriods;
    }

    return 0;
}

int mal_device__jack_process_callback(mal_jack_nframes_t frameCount, void* pUserData)
{
    mal_device* pDevice = (mal_device*)pUserData;
    mal_assert(pDevice != NULL);

    mal_context* pContext = pDevice->pContext;
    mal_assert(pContext != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        // Channels need to be interleaved.
        for (mal_uint32 iChannel = 0; iChannel < pDevice->capture.internalChannels; ++iChannel) {
            const float* pSrc = (const float*)((mal_jack_port_get_buffer_proc)pContext->jack.jack_port_get_buffer)((mal_jack_port_t*)pDevice->jack.pPortsCapture[iChannel], frameCount);
            if (pSrc != NULL) {
                float* pDst = pDevice->jack.pIntermediaryBufferCapture + iChannel;
                for (mal_jack_nframes_t iFrame = 0; iFrame < frameCount; ++iFrame) {
                    *pDst = *pSrc;

                    pDst += pDevice->capture.internalChannels;
                    pSrc += 1;
                }
            }
        }

        if (pDevice->type == mal_device_type_duplex) {
            mal_device__handle_duplex_callback_capture(pDevice, frameCount, pDevice->jack.pIntermediaryBufferCapture, &pDevice->jack.duplexRB);
        } else {
            mal_device__send_frames_to_client(pDevice, frameCount, pDevice->jack.pIntermediaryBufferCapture);
        }
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        if (pDevice->type == mal_device_type_duplex) {
            mal_device__handle_duplex_callback_playback(pDevice, frameCount, pDevice->jack.pIntermediaryBufferPlayback, &pDevice->jack.duplexRB);
        } else {
            mal_device__read_frames_from_client(pDevice, frameCount, pDevice->jack.pIntermediaryBufferPlayback);
        }

        // Channels need to be deinterleaved.
        for (mal_uint32 iChannel = 0; iChannel < pDevice->playback.internalChannels; ++iChannel) {
            float* pDst = (float*)((mal_jack_port_get_buffer_proc)pContext->jack.jack_port_get_buffer)((mal_jack_port_t*)pDevice->jack.pPortsPlayback[iChannel], frameCount);
            if (pDst != NULL) {
                const float* pSrc = pDevice->jack.pIntermediaryBufferPlayback + iChannel;
                for (mal_jack_nframes_t iFrame = 0; iFrame < frameCount; ++iFrame) {
                    *pDst = *pSrc;

                    pDst += 1;
                    pSrc += pDevice->playback.internalChannels;
                }
            }
        }
    }

    return 0;
}

mal_result mal_device_init__jack(mal_context* pContext, const mal_device_config* pConfig, mal_device* pDevice)
{
    mal_assert(pContext != NULL);
    mal_assert(pConfig != NULL);
    mal_assert(pDevice != NULL);

    (void)pContext;

    /* Only supporting default devices with JACK. */
    if (((pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) && pConfig->playback.pDeviceID != NULL && pConfig->playback.pDeviceID->jack != 0) ||
        ((pConfig->deviceType == mal_device_type_capture  || pConfig->deviceType == mal_device_type_duplex) && pConfig->capture.pDeviceID  != NULL && pConfig->capture.pDeviceID->jack  != 0)) {
        return MAL_NO_DEVICE;
    }

    /* No exclusive mode with the JACK backend. */
    if (((pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) && pConfig->playback.shareMode == mal_share_mode_exclusive) ||
        ((pConfig->deviceType == mal_device_type_capture  || pConfig->deviceType == mal_device_type_duplex) && pConfig->capture.shareMode  == mal_share_mode_exclusive)) {
        return MAL_SHARE_MODE_NOT_SUPPORTED;
    }

    /* Open the client. */
    mal_result result = mal_context_open_client__jack(pContext, (mal_jack_client_t**)&pDevice->jack.pClient);
    if (result != MAL_SUCCESS) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[JACK] Failed to open client.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
    }

    /* Callbacks. */
    if (((mal_jack_set_process_callback_proc)pContext->jack.jack_set_process_callback)((mal_jack_client_t*)pDevice->jack.pClient, mal_device__jack_process_callback, pDevice) != 0) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[JACK] Failed to set process callback.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
    }
    if (((mal_jack_set_buffer_size_callback_proc)pContext->jack.jack_set_buffer_size_callback)((mal_jack_client_t*)pDevice->jack.pClient, mal_device__jack_buffer_size_callback, pDevice) != 0) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[JACK] Failed to set buffer size callback.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
    }

    ((mal_jack_on_shutdown_proc)pContext->jack.jack_on_shutdown)((mal_jack_client_t*)pDevice->jack.pClient, mal_device__jack_shutdown_callback, pDevice);


    /* The buffer size in frames can change. */
    mal_uint32 periods            = 2;
    mal_uint32 bufferSizeInFrames = ((mal_jack_get_buffer_size_proc)pContext->jack.jack_get_buffer_size)((mal_jack_client_t*)pDevice->jack.pClient) * periods;
    
    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        const char** ppPorts;

        pDevice->capture.internalFormat = mal_format_f32;
        pDevice->capture.internalChannels = 0;
        pDevice->capture.internalSampleRate = ((mal_jack_get_sample_rate_proc)pContext->jack.jack_get_sample_rate)((mal_jack_client_t*)pDevice->jack.pClient);
        mal_get_standard_channel_map(mal_standard_channel_map_alsa, pDevice->capture.internalChannels, pDevice->capture.internalChannelMap);

        ppPorts = ((mal_jack_get_ports_proc)pContext->jack.jack_get_ports)((mal_jack_client_t*)pDevice->jack.pClient, NULL, NULL, mal_JackPortIsPhysical | mal_JackPortIsOutput);
        if (ppPorts == NULL) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[JACK] Failed to query physical ports.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        while (ppPorts[pDevice->capture.internalChannels] != NULL) {
            char name[64];
            mal_strcpy_s(name, sizeof(name), "capture");
            mal_itoa_s((int)pDevice->capture.internalChannels, name+7, sizeof(name)-7, 10); // 7 = length of "capture"

            pDevice->jack.pPortsCapture[pDevice->capture.internalChannels] = ((mal_jack_port_register_proc)pContext->jack.jack_port_register)((mal_jack_client_t*)pDevice->jack.pClient, name, MAL_JACK_DEFAULT_AUDIO_TYPE, mal_JackPortIsInput, 0);
            if (pDevice->jack.pPortsCapture[pDevice->capture.internalChannels] == NULL) {
                ((mal_jack_free_proc)pContext->jack.jack_free)((void*)ppPorts);
                mal_device_uninit__jack(pDevice);
                return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[JACK] Failed to register ports.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
            }

            pDevice->capture.internalChannels += 1;
        }

        ((mal_jack_free_proc)pContext->jack.jack_free)((void*)ppPorts);

        pDevice->capture.internalBufferSizeInFrames = bufferSizeInFrames;
        pDevice->capture.internalPeriods            = periods;

        pDevice->jack.pIntermediaryBufferCapture = (float*)mal_malloc((pDevice->capture.internalBufferSizeInFrames/pDevice->capture.internalPeriods) * (pDevice->capture.internalChannels * mal_get_bytes_per_sample(pDevice->capture.internalFormat)));
        if (pDevice->jack.pIntermediaryBufferCapture == NULL) {
            mal_device_uninit__jack(pDevice);
            return MAL_OUT_OF_MEMORY;
        }
    }

    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        const char** ppPorts;

        pDevice->playback.internalFormat = mal_format_f32;
        pDevice->playback.internalChannels = 0;
        pDevice->playback.internalSampleRate = ((mal_jack_get_sample_rate_proc)pContext->jack.jack_get_sample_rate)((mal_jack_client_t*)pDevice->jack.pClient);
        mal_get_standard_channel_map(mal_standard_channel_map_alsa, pDevice->playback.internalChannels, pDevice->playback.internalChannelMap);

        ppPorts = ((mal_jack_get_ports_proc)pContext->jack.jack_get_ports)((mal_jack_client_t*)pDevice->jack.pClient, NULL, NULL, mal_JackPortIsPhysical | mal_JackPortIsInput);
        if (ppPorts == NULL) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[JACK] Failed to query physical ports.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        while (ppPorts[pDevice->playback.internalChannels] != NULL) {
            char name[64];
            mal_strcpy_s(name, sizeof(name), "playback");
            mal_itoa_s((int)pDevice->playback.internalChannels, name+8, sizeof(name)-8, 10); // 8 = length of "playback"

            pDevice->jack.pPortsPlayback[pDevice->playback.internalChannels] = ((mal_jack_port_register_proc)pContext->jack.jack_port_register)((mal_jack_client_t*)pDevice->jack.pClient, name, MAL_JACK_DEFAULT_AUDIO_TYPE, mal_JackPortIsOutput, 0);
            if (pDevice->jack.pPortsPlayback[pDevice->playback.internalChannels] == NULL) {
                ((mal_jack_free_proc)pContext->jack.jack_free)((void*)ppPorts);
                mal_device_uninit__jack(pDevice);
                return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[JACK] Failed to register ports.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
            }

            pDevice->playback.internalChannels += 1;
        }

        ((mal_jack_free_proc)pContext->jack.jack_free)((void*)ppPorts);

        pDevice->playback.internalBufferSizeInFrames = bufferSizeInFrames;
        pDevice->playback.internalPeriods            = periods;

        pDevice->jack.pIntermediaryBufferPlayback = (float*)mal_malloc((pDevice->playback.internalBufferSizeInFrames/pDevice->playback.internalPeriods) * (pDevice->playback.internalChannels * mal_get_bytes_per_sample(pDevice->playback.internalFormat)));
        if (pDevice->jack.pIntermediaryBufferPlayback == NULL) {
            mal_device_uninit__jack(pDevice);
            return MAL_OUT_OF_MEMORY;
        }
    }

    if (pDevice->type == mal_device_type_duplex) {
        mal_uint32 rbSizeInFrames = (mal_uint32)mal_calculate_frame_count_after_src(pDevice->sampleRate, pDevice->capture.internalSampleRate, pDevice->capture.internalBufferSizeInFrames);
        result = mal_pcm_rb_init(pDevice->capture.format, pDevice->capture.channels, rbSizeInFrames, NULL, &pDevice->jack.duplexRB);
        if (result != MAL_SUCCESS) {
            mal_device_uninit__jack(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[JACK] Failed to initialize ring buffer.", result);
        }
    }

    return MAL_SUCCESS;
}


mal_result mal_device_start__jack(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    mal_context* pContext = pDevice->pContext;
    mal_assert(pContext != NULL);

    int resultJACK = ((mal_jack_activate_proc)pContext->jack.jack_activate)((mal_jack_client_t*)pDevice->jack.pClient);
    if (resultJACK != 0) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[JACK] Failed to activate the JACK client.", MAL_FAILED_TO_START_BACKEND_DEVICE);
    }

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        const char** ppServerPorts = ((mal_jack_get_ports_proc)pContext->jack.jack_get_ports)((mal_jack_client_t*)pDevice->jack.pClient, NULL, NULL, mal_JackPortIsPhysical | mal_JackPortIsOutput);
        if (ppServerPorts == NULL) {
            ((mal_jack_deactivate_proc)pContext->jack.jack_deactivate)((mal_jack_client_t*)pDevice->jack.pClient);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[JACK] Failed to retrieve physical ports.", MAL_ERROR);
        }

        for (size_t i = 0; ppServerPorts[i] != NULL; ++i) {
            const char* pServerPort = ppServerPorts[i];
            const char* pClientPort = ((mal_jack_port_name_proc)pContext->jack.jack_port_name)((mal_jack_port_t*)pDevice->jack.pPortsCapture[i]);

            resultJACK = ((mal_jack_connect_proc)pContext->jack.jack_connect)((mal_jack_client_t*)pDevice->jack.pClient, pServerPort, pClientPort);
            if (resultJACK != 0) {
                ((mal_jack_free_proc)pContext->jack.jack_free)((void*)ppServerPorts);
                ((mal_jack_deactivate_proc)pContext->jack.jack_deactivate)((mal_jack_client_t*)pDevice->jack.pClient);
                return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[JACK] Failed to connect ports.", MAL_ERROR);
            }
        }

        ((mal_jack_free_proc)pContext->jack.jack_free)((void*)ppServerPorts);
    }
    
    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        const char** ppServerPorts = ((mal_jack_get_ports_proc)pContext->jack.jack_get_ports)((mal_jack_client_t*)pDevice->jack.pClient, NULL, NULL, mal_JackPortIsPhysical | mal_JackPortIsInput);
        if (ppServerPorts == NULL) {
            ((mal_jack_deactivate_proc)pContext->jack.jack_deactivate)((mal_jack_client_t*)pDevice->jack.pClient);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[JACK] Failed to retrieve physical ports.", MAL_ERROR);
        }

        for (size_t i = 0; ppServerPorts[i] != NULL; ++i) {
            const char* pServerPort = ppServerPorts[i];
            const char* pClientPort = ((mal_jack_port_name_proc)pContext->jack.jack_port_name)((mal_jack_port_t*)pDevice->jack.pPortsPlayback[i]);

            resultJACK = ((mal_jack_connect_proc)pContext->jack.jack_connect)((mal_jack_client_t*)pDevice->jack.pClient, pClientPort, pServerPort);
            if (resultJACK != 0) {
                ((mal_jack_free_proc)pContext->jack.jack_free)((void*)ppServerPorts);
                ((mal_jack_deactivate_proc)pContext->jack.jack_deactivate)((mal_jack_client_t*)pDevice->jack.pClient);
                return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[JACK] Failed to connect ports.", MAL_ERROR);
            }
        }

        ((mal_jack_free_proc)pContext->jack.jack_free)((void*)ppServerPorts);
    }

    return MAL_SUCCESS;
}

mal_result mal_device_stop__jack(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    mal_context* pContext = pDevice->pContext;
    mal_assert(pContext != NULL);

    if (((mal_jack_deactivate_proc)pContext->jack.jack_deactivate)((mal_jack_client_t*)pDevice->jack.pClient) != 0) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[JACK] An error occurred when deactivating the JACK client.", MAL_ERROR);
    }
    
    mal_stop_proc onStop = pDevice->onStop;
    if (onStop) {
        onStop(pDevice);
    }

    return MAL_SUCCESS;
}


mal_result mal_context_uninit__jack(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    mal_assert(pContext->backend == mal_backend_jack);

#ifndef MAL_NO_RUNTIME_LINKING
    mal_dlclose(pContext->jack.jackSO);
#endif

    return MAL_SUCCESS;
}

mal_result mal_context_init__jack(mal_context* pContext)
{
    mal_assert(pContext != NULL);

#ifndef MAL_NO_RUNTIME_LINKING
    // libjack.so
    const char* libjackNames[] = {
#ifdef MAL_WIN32
        "libjack.dll"
#else
        "libjack.so",
        "libjack.so.0"
#endif
    };

    for (size_t i = 0; i < mal_countof(libjackNames); ++i) {
        pContext->jack.jackSO = mal_dlopen(libjackNames[i]);
        if (pContext->jack.jackSO != NULL) {
            break;
        }
    }

    if (pContext->jack.jackSO == NULL) {
        return MAL_NO_BACKEND;
    }

    pContext->jack.jack_client_open              = (mal_proc)mal_dlsym(pContext->jack.jackSO, "jack_client_open");
    pContext->jack.jack_client_close             = (mal_proc)mal_dlsym(pContext->jack.jackSO, "jack_client_close");
    pContext->jack.jack_client_name_size         = (mal_proc)mal_dlsym(pContext->jack.jackSO, "jack_client_name_size");
    pContext->jack.jack_set_process_callback     = (mal_proc)mal_dlsym(pContext->jack.jackSO, "jack_set_process_callback");
    pContext->jack.jack_set_buffer_size_callback = (mal_proc)mal_dlsym(pContext->jack.jackSO, "jack_set_buffer_size_callback");
    pContext->jack.jack_on_shutdown              = (mal_proc)mal_dlsym(pContext->jack.jackSO, "jack_on_shutdown");
    pContext->jack.jack_get_sample_rate          = (mal_proc)mal_dlsym(pContext->jack.jackSO, "jack_get_sample_rate");
    pContext->jack.jack_get_buffer_size          = (mal_proc)mal_dlsym(pContext->jack.jackSO, "jack_get_buffer_size");
    pContext->jack.jack_get_ports                = (mal_proc)mal_dlsym(pContext->jack.jackSO, "jack_get_ports");
    pContext->jack.jack_activate                 = (mal_proc)mal_dlsym(pContext->jack.jackSO, "jack_activate");
    pContext->jack.jack_deactivate               = (mal_proc)mal_dlsym(pContext->jack.jackSO, "jack_deactivate");
    pContext->jack.jack_connect                  = (mal_proc)mal_dlsym(pContext->jack.jackSO, "jack_connect");
    pContext->jack.jack_port_register            = (mal_proc)mal_dlsym(pContext->jack.jackSO, "jack_port_register");
    pContext->jack.jack_port_name                = (mal_proc)mal_dlsym(pContext->jack.jackSO, "jack_port_name");
    pContext->jack.jack_port_get_buffer          = (mal_proc)mal_dlsym(pContext->jack.jackSO, "jack_port_get_buffer");
    pContext->jack.jack_free                     = (mal_proc)mal_dlsym(pContext->jack.jackSO, "jack_free");
#else
    // This strange assignment system is here just to ensure type safety of mini_al's function pointer
    // types. If anything differs slightly the compiler should throw a warning.
    mal_jack_client_open_proc              _jack_client_open              = jack_client_open;
    mal_jack_client_close_proc             _jack_client_close             = jack_client_close;
    mal_jack_client_name_size_proc         _jack_client_name_size         = jack_client_name_size;
    mal_jack_set_process_callback_proc     _jack_set_process_callback     = jack_set_process_callback;
    mal_jack_set_buffer_size_callback_proc _jack_set_buffer_size_callback = jack_set_buffer_size_callback;
    mal_jack_on_shutdown_proc              _jack_on_shutdown              = jack_on_shutdown;
    mal_jack_get_sample_rate_proc          _jack_get_sample_rate          = jack_get_sample_rate;
    mal_jack_get_buffer_size_proc          _jack_get_buffer_size          = jack_get_buffer_size;
    mal_jack_get_ports_proc                _jack_get_ports                = jack_get_ports;
    mal_jack_activate_proc                 _jack_activate                 = jack_activate;
    mal_jack_deactivate_proc               _jack_deactivate               = jack_deactivate;
    mal_jack_connect_proc                  _jack_connect                  = jack_connect;
    mal_jack_port_register_proc            _jack_port_register            = jack_port_register;
    mal_jack_port_name_proc                _jack_port_name                = jack_port_name;
    mal_jack_port_get_buffer_proc          _jack_port_get_buffer          = jack_port_get_buffer;
    mal_jack_free_proc                     _jack_free                     = jack_free;

    pContext->jack.jack_client_open              = (mal_proc)_jack_client_open;
    pContext->jack.jack_client_close             = (mal_proc)_jack_client_close;
    pContext->jack.jack_client_name_size         = (mal_proc)_jack_client_name_size;
    pContext->jack.jack_set_process_callback     = (mal_proc)_jack_set_process_callback;
    pContext->jack.jack_set_buffer_size_callback = (mal_proc)_jack_set_buffer_size_callback;
    pContext->jack.jack_on_shutdown              = (mal_proc)_jack_on_shutdown;
    pContext->jack.jack_get_sample_rate          = (mal_proc)_jack_get_sample_rate;
    pContext->jack.jack_get_buffer_size          = (mal_proc)_jack_get_buffer_size;
    pContext->jack.jack_get_ports                = (mal_proc)_jack_get_ports;
    pContext->jack.jack_activate                 = (mal_proc)_jack_activate;
    pContext->jack.jack_deactivate               = (mal_proc)_jack_deactivate;
    pContext->jack.jack_connect                  = (mal_proc)_jack_connect;
    pContext->jack.jack_port_register            = (mal_proc)_jack_port_register;
    pContext->jack.jack_port_name                = (mal_proc)_jack_port_name;
    pContext->jack.jack_port_get_buffer          = (mal_proc)_jack_port_get_buffer;
    pContext->jack.jack_free                     = (mal_proc)_jack_free;
#endif

    pContext->isBackendAsynchronous = MAL_TRUE;

    pContext->onUninit        = mal_context_uninit__jack;
    pContext->onDeviceIDEqual = mal_context_is_device_id_equal__jack;
    pContext->onEnumDevices   = mal_context_enumerate_devices__jack;
    pContext->onGetDeviceInfo = mal_context_get_device_info__jack;
    pContext->onDeviceInit    = mal_device_init__jack;
    pContext->onDeviceUninit  = mal_device_uninit__jack;
    pContext->onDeviceStart   = mal_device_start__jack;
    pContext->onDeviceStop    = mal_device_stop__jack;


    // Getting here means the JACK library is installed, but it doesn't necessarily mean it's usable. We need to quickly test this by connecting
    // a temporary client.
    mal_jack_client_t* pDummyClient;
    mal_result result = mal_context_open_client__jack(pContext, &pDummyClient);
    if (result != MAL_SUCCESS) {
        return MAL_NO_BACKEND;
    }

    ((mal_jack_client_close_proc)pContext->jack.jack_client_close)((mal_jack_client_t*)pDummyClient);
    return MAL_SUCCESS;
}
#endif  // JACK



///////////////////////////////////////////////////////////////////////////////
//
// Core Audio Backend
//
///////////////////////////////////////////////////////////////////////////////
#ifdef MAL_HAS_COREAUDIO
#include <TargetConditionals.h>

#if defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE == 1
    #define MAL_APPLE_MOBILE
#else
    #define MAL_APPLE_DESKTOP
#endif

#if defined(MAL_APPLE_DESKTOP)
#include <CoreAudio/CoreAudio.h>
#else
#include <AVFoundation/AVFoundation.h>
#endif

#include <AudioToolbox/AudioToolbox.h>

// CoreFoundation
typedef Boolean (* mal_CFStringGetCString_proc)(CFStringRef theString, char* buffer, CFIndex bufferSize, CFStringEncoding encoding);

// CoreAudio
#if defined(MAL_APPLE_DESKTOP)
typedef OSStatus (* mal_AudioObjectGetPropertyData_proc)(AudioObjectID inObjectID, const AudioObjectPropertyAddress* inAddress, UInt32 inQualifierDataSize, const void* inQualifierData, UInt32* ioDataSize, void* outData);
typedef OSStatus (* mal_AudioObjectGetPropertyDataSize_proc)(AudioObjectID inObjectID, const AudioObjectPropertyAddress* inAddress, UInt32 inQualifierDataSize, const void* inQualifierData, UInt32* outDataSize);
typedef OSStatus (* mal_AudioObjectSetPropertyData_proc)(AudioObjectID inObjectID, const AudioObjectPropertyAddress* inAddress, UInt32 inQualifierDataSize, const void* inQualifierData, UInt32 inDataSize, const void* inData);
typedef OSStatus (* mal_AudioObjectAddPropertyListener_proc)(AudioObjectID inObjectID, const AudioObjectPropertyAddress* inAddress, AudioObjectPropertyListenerProc inListener, void* inClientData);
#endif

// AudioToolbox
typedef AudioComponent (* mal_AudioComponentFindNext_proc)(AudioComponent inComponent, const AudioComponentDescription* inDesc);
typedef OSStatus (* mal_AudioComponentInstanceDispose_proc)(AudioComponentInstance inInstance);
typedef OSStatus (* mal_AudioComponentInstanceNew_proc)(AudioComponent inComponent, AudioComponentInstance* outInstance);
typedef OSStatus (* mal_AudioOutputUnitStart_proc)(AudioUnit inUnit);
typedef OSStatus (* mal_AudioOutputUnitStop_proc)(AudioUnit inUnit);
typedef OSStatus (* mal_AudioUnitAddPropertyListener_proc)(AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitPropertyListenerProc inProc, void* inProcUserData);
typedef OSStatus (* mal_AudioUnitGetPropertyInfo_proc)(AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, UInt32* outDataSize, Boolean* outWriteable);
typedef OSStatus (* mal_AudioUnitGetProperty_proc)(AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, void* outData, UInt32* ioDataSize);
typedef OSStatus (* mal_AudioUnitSetProperty_proc)(AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, const void* inData, UInt32 inDataSize);
typedef OSStatus (* mal_AudioUnitInitialize_proc)(AudioUnit inUnit);
typedef OSStatus (* mal_AudioUnitRender_proc)(AudioUnit inUnit, AudioUnitRenderActionFlags* ioActionFlags, const AudioTimeStamp* inTimeStamp, UInt32 inOutputBusNumber, UInt32 inNumberFrames, AudioBufferList* ioData);


#define MAL_COREAUDIO_OUTPUT_BUS    0
#define MAL_COREAUDIO_INPUT_BUS     1

mal_result mal_device_reinit_internal__coreaudio(mal_device* pDevice, mal_device_type deviceType, mal_bool32 disposePreviousAudioUnit);


// Core Audio
//
// So far, Core Audio has been the worst backend to work with due to being both unintuitive and having almost no documentation
// apart from comments in the headers (which admittedly are quite good). For my own purposes, and for anybody out there whose
// needing to figure out how this darn thing works, I'm going to outline a few things here.
//
// Since mini_al is a fairly low-level API, one of the things it needs is control over specific devices, and it needs to be
// able to identify whether or not it can be used as playback and/or capture. The AudioObject API is the only one I've seen
// that supports this level of detail. There was some public domain sample code I stumbled across that used the AudioComponent
// and AudioUnit APIs, but I couldn't see anything that gave low-level control over device selection and capabilities (the
// distinction between playback and capture in particular). Therefore, mini_al is using the AudioObject API.
//
// Most (all?) functions in the AudioObject API take a AudioObjectID as it's input. This is the device identifier. When
// retrieving global information, such as the device list, you use kAudioObjectSystemObject. When retrieving device-specific
// data, you pass in the ID for that device. In order to retrieve device-specific IDs you need to enumerate over each of the
// devices. This is done using the AudioObjectGetPropertyDataSize() and AudioObjectGetPropertyData() APIs which seem to be
// the central APIs for retrieving information about the system and specific devices.
//
// To use the AudioObjectGetPropertyData() API you need to use the notion of a property address. A property address is a
// structure with three variables and is used to identify which property you are getting or setting. The first is the "selector"
// which is basically the specific property that you're wanting to retrieve or set. The second is the "scope", which is
// typically set to kAudioObjectPropertyScopeGlobal, kAudioObjectPropertyScopeInput for input-specific properties and
// kAudioObjectPropertyScopeOutput for output-specific properties. The last is the "element" which is always set to
// kAudioObjectPropertyElementMaster in mini_al's case. I don't know of any cases where this would be set to anything different.
//
// Back to the earlier issue of device retrieval, you first use the AudioObjectGetPropertyDataSize() API to retrieve the size
// of the raw data which is just a list of AudioDeviceID's. You use the kAudioObjectSystemObject AudioObjectID, and a property
// address with the kAudioHardwarePropertyDevices selector and the kAudioObjectPropertyScopeGlobal scope. Once you have the
// size, allocate a block of memory of that size and then call AudioObjectGetPropertyData(). The data is just a list of
// AudioDeviceID's so just do "dataSize/sizeof(AudioDeviceID)" to know the device count.

mal_result mal_result_from_OSStatus(OSStatus status)
{
    switch (status)
    {
        case noErr:                                   return MAL_SUCCESS;
    #if defined(MAL_APPLE_DESKTOP)
        case kAudioHardwareNotRunningError:           return MAL_DEVICE_NOT_STARTED;
        case kAudioHardwareUnspecifiedError:          return MAL_ERROR;
        case kAudioHardwareUnknownPropertyError:      return MAL_INVALID_ARGS;
        case kAudioHardwareBadPropertySizeError:      return MAL_INVALID_OPERATION;
        case kAudioHardwareIllegalOperationError:     return MAL_INVALID_OPERATION;
        case kAudioHardwareBadObjectError:            return MAL_INVALID_ARGS;
        case kAudioHardwareBadDeviceError:            return MAL_INVALID_ARGS;
        case kAudioHardwareBadStreamError:            return MAL_INVALID_ARGS;
        case kAudioHardwareUnsupportedOperationError: return MAL_INVALID_OPERATION;
        case kAudioDeviceUnsupportedFormatError:      return MAL_FORMAT_NOT_SUPPORTED;
        case kAudioDevicePermissionsError:            return MAL_ACCESS_DENIED;
    #endif
        default:                                      return MAL_ERROR;
    }
}

#if 0
mal_channel mal_channel_from_AudioChannelBitmap(AudioChannelBitmap bit)
{
    switch (bit)
    {
        case kAudioChannelBit_Left:                 return MAL_CHANNEL_LEFT;
        case kAudioChannelBit_Right:                return MAL_CHANNEL_RIGHT;
        case kAudioChannelBit_Center:               return MAL_CHANNEL_FRONT_CENTER;
        case kAudioChannelBit_LFEScreen:            return MAL_CHANNEL_LFE;
        case kAudioChannelBit_LeftSurround:         return MAL_CHANNEL_BACK_LEFT;
        case kAudioChannelBit_RightSurround:        return MAL_CHANNEL_BACK_RIGHT;
        case kAudioChannelBit_LeftCenter:           return MAL_CHANNEL_FRONT_LEFT_CENTER;
        case kAudioChannelBit_RightCenter:          return MAL_CHANNEL_FRONT_RIGHT_CENTER;
        case kAudioChannelBit_CenterSurround:       return MAL_CHANNEL_BACK_CENTER;
        case kAudioChannelBit_LeftSurroundDirect:   return MAL_CHANNEL_SIDE_LEFT;
        case kAudioChannelBit_RightSurroundDirect:  return MAL_CHANNEL_SIDE_RIGHT;
        case kAudioChannelBit_TopCenterSurround:    return MAL_CHANNEL_TOP_CENTER;
        case kAudioChannelBit_VerticalHeightLeft:   return MAL_CHANNEL_TOP_FRONT_LEFT;
        case kAudioChannelBit_VerticalHeightCenter: return MAL_CHANNEL_TOP_FRONT_CENTER;
        case kAudioChannelBit_VerticalHeightRight:  return MAL_CHANNEL_TOP_FRONT_RIGHT;
        case kAudioChannelBit_TopBackLeft:          return MAL_CHANNEL_TOP_BACK_LEFT;
        case kAudioChannelBit_TopBackCenter:        return MAL_CHANNEL_TOP_BACK_CENTER;
        case kAudioChannelBit_TopBackRight:         return MAL_CHANNEL_TOP_BACK_RIGHT;
        default:                                    return MAL_CHANNEL_NONE;
    }
}
#endif

mal_channel mal_channel_from_AudioChannelLabel(AudioChannelLabel label)
{
    switch (label)
    {
        case kAudioChannelLabel_Unknown:              return MAL_CHANNEL_NONE;
        case kAudioChannelLabel_Unused:               return MAL_CHANNEL_NONE;
        case kAudioChannelLabel_UseCoordinates:       return MAL_CHANNEL_NONE;
        case kAudioChannelLabel_Left:                 return MAL_CHANNEL_LEFT;
        case kAudioChannelLabel_Right:                return MAL_CHANNEL_RIGHT;
        case kAudioChannelLabel_Center:               return MAL_CHANNEL_FRONT_CENTER;
        case kAudioChannelLabel_LFEScreen:            return MAL_CHANNEL_LFE;
        case kAudioChannelLabel_LeftSurround:         return MAL_CHANNEL_BACK_LEFT;
        case kAudioChannelLabel_RightSurround:        return MAL_CHANNEL_BACK_RIGHT;
        case kAudioChannelLabel_LeftCenter:           return MAL_CHANNEL_FRONT_LEFT_CENTER;
        case kAudioChannelLabel_RightCenter:          return MAL_CHANNEL_FRONT_RIGHT_CENTER;
        case kAudioChannelLabel_CenterSurround:       return MAL_CHANNEL_BACK_CENTER;
        case kAudioChannelLabel_LeftSurroundDirect:   return MAL_CHANNEL_SIDE_LEFT;
        case kAudioChannelLabel_RightSurroundDirect:  return MAL_CHANNEL_SIDE_RIGHT;
        case kAudioChannelLabel_TopCenterSurround:    return MAL_CHANNEL_TOP_CENTER;
        case kAudioChannelLabel_VerticalHeightLeft:   return MAL_CHANNEL_TOP_FRONT_LEFT;
        case kAudioChannelLabel_VerticalHeightCenter: return MAL_CHANNEL_TOP_FRONT_CENTER;
        case kAudioChannelLabel_VerticalHeightRight:  return MAL_CHANNEL_TOP_FRONT_RIGHT;
        case kAudioChannelLabel_TopBackLeft:          return MAL_CHANNEL_TOP_BACK_LEFT;
        case kAudioChannelLabel_TopBackCenter:        return MAL_CHANNEL_TOP_BACK_CENTER;
        case kAudioChannelLabel_TopBackRight:         return MAL_CHANNEL_TOP_BACK_RIGHT;
        case kAudioChannelLabel_RearSurroundLeft:     return MAL_CHANNEL_BACK_LEFT;
        case kAudioChannelLabel_RearSurroundRight:    return MAL_CHANNEL_BACK_RIGHT;
        case kAudioChannelLabel_LeftWide:             return MAL_CHANNEL_SIDE_LEFT;
        case kAudioChannelLabel_RightWide:            return MAL_CHANNEL_SIDE_RIGHT;
        case kAudioChannelLabel_LFE2:                 return MAL_CHANNEL_LFE;
        case kAudioChannelLabel_LeftTotal:            return MAL_CHANNEL_LEFT;
        case kAudioChannelLabel_RightTotal:           return MAL_CHANNEL_RIGHT;
        case kAudioChannelLabel_HearingImpaired:      return MAL_CHANNEL_NONE;
        case kAudioChannelLabel_Narration:            return MAL_CHANNEL_MONO;
        case kAudioChannelLabel_Mono:                 return MAL_CHANNEL_MONO;
        case kAudioChannelLabel_DialogCentricMix:     return MAL_CHANNEL_MONO;
        case kAudioChannelLabel_CenterSurroundDirect: return MAL_CHANNEL_BACK_CENTER;
        case kAudioChannelLabel_Haptic:               return MAL_CHANNEL_NONE;
        case kAudioChannelLabel_Ambisonic_W:          return MAL_CHANNEL_NONE;
        case kAudioChannelLabel_Ambisonic_X:          return MAL_CHANNEL_NONE;
        case kAudioChannelLabel_Ambisonic_Y:          return MAL_CHANNEL_NONE;
        case kAudioChannelLabel_Ambisonic_Z:          return MAL_CHANNEL_NONE;
        case kAudioChannelLabel_MS_Mid:               return MAL_CHANNEL_LEFT;
        case kAudioChannelLabel_MS_Side:              return MAL_CHANNEL_RIGHT;
        case kAudioChannelLabel_XY_X:                 return MAL_CHANNEL_LEFT;
        case kAudioChannelLabel_XY_Y:                 return MAL_CHANNEL_RIGHT;
        case kAudioChannelLabel_HeadphonesLeft:       return MAL_CHANNEL_LEFT;
        case kAudioChannelLabel_HeadphonesRight:      return MAL_CHANNEL_RIGHT;
        case kAudioChannelLabel_ClickTrack:           return MAL_CHANNEL_NONE;
        case kAudioChannelLabel_ForeignLanguage:      return MAL_CHANNEL_NONE;
        case kAudioChannelLabel_Discrete:             return MAL_CHANNEL_NONE;
        case kAudioChannelLabel_Discrete_0:           return MAL_CHANNEL_AUX_0;
        case kAudioChannelLabel_Discrete_1:           return MAL_CHANNEL_AUX_1;
        case kAudioChannelLabel_Discrete_2:           return MAL_CHANNEL_AUX_2;
        case kAudioChannelLabel_Discrete_3:           return MAL_CHANNEL_AUX_3;
        case kAudioChannelLabel_Discrete_4:           return MAL_CHANNEL_AUX_4;
        case kAudioChannelLabel_Discrete_5:           return MAL_CHANNEL_AUX_5;
        case kAudioChannelLabel_Discrete_6:           return MAL_CHANNEL_AUX_6;
        case kAudioChannelLabel_Discrete_7:           return MAL_CHANNEL_AUX_7;
        case kAudioChannelLabel_Discrete_8:           return MAL_CHANNEL_AUX_8;
        case kAudioChannelLabel_Discrete_9:           return MAL_CHANNEL_AUX_9;
        case kAudioChannelLabel_Discrete_10:          return MAL_CHANNEL_AUX_10;
        case kAudioChannelLabel_Discrete_11:          return MAL_CHANNEL_AUX_11;
        case kAudioChannelLabel_Discrete_12:          return MAL_CHANNEL_AUX_12;
        case kAudioChannelLabel_Discrete_13:          return MAL_CHANNEL_AUX_13;
        case kAudioChannelLabel_Discrete_14:          return MAL_CHANNEL_AUX_14;
        case kAudioChannelLabel_Discrete_15:          return MAL_CHANNEL_AUX_15;
        case kAudioChannelLabel_Discrete_65535:       return MAL_CHANNEL_NONE;
        
    #if 0   // Introduced in a later version of macOS.
        case kAudioChannelLabel_HOA_ACN:              return MAL_CHANNEL_NONE;
        case kAudioChannelLabel_HOA_ACN_0:            return MAL_CHANNEL_AUX_0;
        case kAudioChannelLabel_HOA_ACN_1:            return MAL_CHANNEL_AUX_1;
        case kAudioChannelLabel_HOA_ACN_2:            return MAL_CHANNEL_AUX_2;
        case kAudioChannelLabel_HOA_ACN_3:            return MAL_CHANNEL_AUX_3;
        case kAudioChannelLabel_HOA_ACN_4:            return MAL_CHANNEL_AUX_4;
        case kAudioChannelLabel_HOA_ACN_5:            return MAL_CHANNEL_AUX_5;
        case kAudioChannelLabel_HOA_ACN_6:            return MAL_CHANNEL_AUX_6;
        case kAudioChannelLabel_HOA_ACN_7:            return MAL_CHANNEL_AUX_7;
        case kAudioChannelLabel_HOA_ACN_8:            return MAL_CHANNEL_AUX_8;
        case kAudioChannelLabel_HOA_ACN_9:            return MAL_CHANNEL_AUX_9;
        case kAudioChannelLabel_HOA_ACN_10:           return MAL_CHANNEL_AUX_10;
        case kAudioChannelLabel_HOA_ACN_11:           return MAL_CHANNEL_AUX_11;
        case kAudioChannelLabel_HOA_ACN_12:           return MAL_CHANNEL_AUX_12;
        case kAudioChannelLabel_HOA_ACN_13:           return MAL_CHANNEL_AUX_13;
        case kAudioChannelLabel_HOA_ACN_14:           return MAL_CHANNEL_AUX_14;
        case kAudioChannelLabel_HOA_ACN_15:           return MAL_CHANNEL_AUX_15;
        case kAudioChannelLabel_HOA_ACN_65024:        return MAL_CHANNEL_NONE;
    #endif
        
        default:                                      return MAL_CHANNEL_NONE;
    }
}

mal_result mal_format_from_AudioStreamBasicDescription(const AudioStreamBasicDescription* pDescription, mal_format* pFormatOut)
{
    mal_assert(pDescription != NULL);
    mal_assert(pFormatOut != NULL);
    
    *pFormatOut = mal_format_unknown;   // Safety.
    
    // There's a few things mini_al doesn't support.
    if (pDescription->mFormatID != kAudioFormatLinearPCM) {
        return MAL_FORMAT_NOT_SUPPORTED;
    }
    
    // We don't support any non-packed formats that are aligned high.
    if ((pDescription->mFormatFlags & kLinearPCMFormatFlagIsAlignedHigh) != 0) {
        return MAL_FORMAT_NOT_SUPPORTED;
    }

    // Only supporting native-endian.
    if ((mal_is_little_endian() && (pDescription->mFormatFlags & kAudioFormatFlagIsBigEndian) != 0) || (mal_is_big_endian() && (pDescription->mFormatFlags & kAudioFormatFlagIsBigEndian) == 0)) {
        return MAL_FORMAT_NOT_SUPPORTED;
    }
    
    // We are not currently supporting non-interleaved formats (this will be added in a future version of mini_al).
    //if ((pDescription->mFormatFlags & kAudioFormatFlagIsNonInterleaved) != 0) {
    //    return MAL_FORMAT_NOT_SUPPORTED;
    //}

    if ((pDescription->mFormatFlags & kLinearPCMFormatFlagIsFloat) != 0) {
        if (pDescription->mBitsPerChannel == 32) {
            *pFormatOut = mal_format_f32;
            return MAL_SUCCESS;
        }
    } else {
        if ((pDescription->mFormatFlags & kLinearPCMFormatFlagIsSignedInteger) != 0) {
            if (pDescription->mBitsPerChannel == 16) {
                *pFormatOut = mal_format_s16;
                return MAL_SUCCESS;
            } else if (pDescription->mBitsPerChannel == 24) {
                if (pDescription->mBytesPerFrame == (pDescription->mBitsPerChannel/8 * pDescription->mChannelsPerFrame)) {
                    *pFormatOut = mal_format_s24;
                    return MAL_SUCCESS;
                } else {
                    if (pDescription->mBytesPerFrame/pDescription->mChannelsPerFrame == sizeof(mal_int32)) {
                        // TODO: Implement mal_format_s24_32.
                        //*pFormatOut = mal_format_s24_32;
                        //return MAL_SUCCESS;
                        return MAL_FORMAT_NOT_SUPPORTED;
                    }
                }
            } else if (pDescription->mBitsPerChannel == 32) {
                *pFormatOut = mal_format_s32;
                return MAL_SUCCESS;
            }
        } else {
            if (pDescription->mBitsPerChannel == 8) {
                *pFormatOut = mal_format_u8;
                return MAL_SUCCESS;
            }
        }
    }
    
    // Getting here means the format is not supported.
    return MAL_FORMAT_NOT_SUPPORTED;
}

mal_result mal_get_channel_map_from_AudioChannelLayout(AudioChannelLayout* pChannelLayout, mal_channel channelMap[MAL_MAX_CHANNELS])
{
    mal_assert(pChannelLayout != NULL);
    
    if (pChannelLayout->mChannelLayoutTag == kAudioChannelLayoutTag_UseChannelDescriptions) {
        for (UInt32 iChannel = 0; iChannel < pChannelLayout->mNumberChannelDescriptions; ++iChannel) {
            channelMap[iChannel] = mal_channel_from_AudioChannelLabel(pChannelLayout->mChannelDescriptions[iChannel].mChannelLabel);
        }
    } else
#if 0
    if (pChannelLayout->mChannelLayoutTag == kAudioChannelLayoutTag_UseChannelBitmap) {
        // This is the same kind of system that's used by Windows audio APIs.
        UInt32 iChannel = 0;
        AudioChannelBitmap bitmap = pChannelLayout->mChannelBitmap;
        for (UInt32 iBit = 0; iBit < 32; ++iBit) {
            AudioChannelBitmap bit = bitmap & (1 << iBit);
            if (bit != 0) {
                channelMap[iChannel++] = mal_channel_from_AudioChannelBit(bit);
            }
        }
    } else
#endif
    {
        // Need to use the tag to determine the channel map. For now I'm just assuming a default channel map, but later on this should
        // be updated to determine the mapping based on the tag.
        UInt32 channelCount = AudioChannelLayoutTag_GetNumberOfChannels(pChannelLayout->mChannelLayoutTag);
        switch (pChannelLayout->mChannelLayoutTag)
        {
            case kAudioChannelLayoutTag_Mono:
            case kAudioChannelLayoutTag_Stereo:
            case kAudioChannelLayoutTag_StereoHeadphones:
            case kAudioChannelLayoutTag_MatrixStereo:
            case kAudioChannelLayoutTag_MidSide:
            case kAudioChannelLayoutTag_XY:
            case kAudioChannelLayoutTag_Binaural:
            case kAudioChannelLayoutTag_Ambisonic_B_Format:
            {
                mal_get_standard_channel_map(mal_standard_channel_map_default, channelCount, channelMap);
            } break;
            
            case kAudioChannelLayoutTag_Octagonal:
            {
                channelMap[7] = MAL_CHANNEL_SIDE_RIGHT;
                channelMap[6] = MAL_CHANNEL_SIDE_LEFT;
            } // Intentional fallthrough.
            case kAudioChannelLayoutTag_Hexagonal:
            {
                channelMap[5] = MAL_CHANNEL_BACK_CENTER;
            } // Intentional fallthrough.
            case kAudioChannelLayoutTag_Pentagonal:
            {
                channelMap[4] = MAL_CHANNEL_FRONT_CENTER;
            } // Intentional fallghrough.
            case kAudioChannelLayoutTag_Quadraphonic:
            {
                channelMap[3] = MAL_CHANNEL_BACK_RIGHT;
                channelMap[2] = MAL_CHANNEL_BACK_LEFT;
                channelMap[1] = MAL_CHANNEL_RIGHT;
                channelMap[0] = MAL_CHANNEL_LEFT;
            } break;
            
            // TODO: Add support for more tags here.
        
            default:
            {
                mal_get_standard_channel_map(mal_standard_channel_map_default, channelCount, channelMap);
            } break;
        }
    }
    
    return MAL_SUCCESS;
}


#if defined(MAL_APPLE_DESKTOP)
mal_result mal_get_device_object_ids__coreaudio(mal_context* pContext, UInt32* pDeviceCount, AudioObjectID** ppDeviceObjectIDs) // NOTE: Free the returned buffer with mal_free().
{
    mal_assert(pContext != NULL);
    mal_assert(pDeviceCount != NULL);
    mal_assert(ppDeviceObjectIDs != NULL);
    (void)pContext;

    // Safety.
    *pDeviceCount = 0;
    *ppDeviceObjectIDs = NULL;
    
    AudioObjectPropertyAddress propAddressDevices;
    propAddressDevices.mSelector = kAudioHardwarePropertyDevices;
    propAddressDevices.mScope    = kAudioObjectPropertyScopeGlobal;
    propAddressDevices.mElement  = kAudioObjectPropertyElementMaster;

    UInt32 deviceObjectsDataSize;
    OSStatus status = ((mal_AudioObjectGetPropertyDataSize_proc)pContext->coreaudio.AudioObjectGetPropertyDataSize)(kAudioObjectSystemObject, &propAddressDevices, 0, NULL, &deviceObjectsDataSize);
    if (status != noErr) {
        return mal_result_from_OSStatus(status);
    }
    
    AudioObjectID* pDeviceObjectIDs = (AudioObjectID*)mal_malloc(deviceObjectsDataSize);
    if (pDeviceObjectIDs == NULL) {
        return MAL_OUT_OF_MEMORY;
    }
    
    status = ((mal_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(kAudioObjectSystemObject, &propAddressDevices, 0, NULL, &deviceObjectsDataSize, pDeviceObjectIDs);
    if (status != noErr) {
        mal_free(pDeviceObjectIDs);
        return mal_result_from_OSStatus(status);
    }
    
    *pDeviceCount = deviceObjectsDataSize / sizeof(AudioObjectID);
    *ppDeviceObjectIDs = pDeviceObjectIDs;
    return MAL_SUCCESS;
}

mal_result mal_get_AudioObject_uid_as_CFStringRef(mal_context* pContext, AudioObjectID objectID, CFStringRef* pUID)
{
    mal_assert(pContext != NULL);

    AudioObjectPropertyAddress propAddress;
    propAddress.mSelector = kAudioDevicePropertyDeviceUID;
    propAddress.mScope    = kAudioObjectPropertyScopeGlobal;
    propAddress.mElement  = kAudioObjectPropertyElementMaster;

    UInt32 dataSize = sizeof(*pUID);
    OSStatus status = ((mal_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(objectID, &propAddress, 0, NULL, &dataSize, pUID);
    if (status != noErr) {
        return mal_result_from_OSStatus(status);
    }
    
    return MAL_SUCCESS;
}

mal_result mal_get_AudioObject_uid(mal_context* pContext, AudioObjectID objectID, size_t bufferSize, char* bufferOut)
{
    mal_assert(pContext != NULL);

    CFStringRef uid;
    mal_result result = mal_get_AudioObject_uid_as_CFStringRef(pContext, objectID, &uid);
    if (result != MAL_SUCCESS) {
        return result;
    }
    
    if (!((mal_CFStringGetCString_proc)pContext->coreaudio.CFStringGetCString)(uid, bufferOut, bufferSize, kCFStringEncodingUTF8)) {
        return MAL_ERROR;
    }
    
    return MAL_SUCCESS;
}

mal_result mal_get_AudioObject_name(mal_context* pContext, AudioObjectID objectID, size_t bufferSize, char* bufferOut)
{
    mal_assert(pContext != NULL);

    AudioObjectPropertyAddress propAddress;
    propAddress.mSelector = kAudioDevicePropertyDeviceNameCFString;
    propAddress.mScope    = kAudioObjectPropertyScopeGlobal;
    propAddress.mElement  = kAudioObjectPropertyElementMaster;

    CFStringRef deviceName = NULL;
    UInt32 dataSize = sizeof(deviceName);
    OSStatus status = ((mal_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(objectID, &propAddress, 0, NULL, &dataSize, &deviceName);
    if (status != noErr) {
        return mal_result_from_OSStatus(status);
    }
    
    if (!((mal_CFStringGetCString_proc)pContext->coreaudio.CFStringGetCString)(deviceName, bufferOut, bufferSize, kCFStringEncodingUTF8)) {
        return MAL_ERROR;
    }
    
    return MAL_SUCCESS;
}

mal_bool32 mal_does_AudioObject_support_scope(mal_context* pContext, AudioObjectID deviceObjectID, AudioObjectPropertyScope scope)
{
    mal_assert(pContext != NULL);

    // To know whether or not a device is an input device we need ot look at the stream configuration. If it has an output channel it's a
    // playback device.
    AudioObjectPropertyAddress propAddress;
    propAddress.mSelector = kAudioDevicePropertyStreamConfiguration;
    propAddress.mScope    = scope;
    propAddress.mElement  = kAudioObjectPropertyElementMaster;
    
    UInt32 dataSize;
    OSStatus status = ((mal_AudioObjectGetPropertyDataSize_proc)pContext->coreaudio.AudioObjectGetPropertyDataSize)(deviceObjectID, &propAddress, 0, NULL, &dataSize);
    if (status != noErr) {
        return MAL_FALSE;
    }
    
    AudioBufferList* pBufferList = (AudioBufferList*)mal_malloc(dataSize);
    if (pBufferList == NULL) {
        return MAL_FALSE;   // Out of memory.
    }
    
    status = ((mal_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(deviceObjectID, &propAddress, 0, NULL, &dataSize, pBufferList);
    if (status != noErr) {
        mal_free(pBufferList);
        return MAL_FALSE;
    }

    mal_bool32 isSupported = MAL_FALSE;
    if (pBufferList->mNumberBuffers > 0) {
        isSupported = MAL_TRUE;
    }
    
    mal_free(pBufferList);
    return isSupported;
}

mal_bool32 mal_does_AudioObject_support_playback(mal_context* pContext, AudioObjectID deviceObjectID)
{
    return mal_does_AudioObject_support_scope(pContext, deviceObjectID, kAudioObjectPropertyScopeOutput);
}

mal_bool32 mal_does_AudioObject_support_capture(mal_context* pContext, AudioObjectID deviceObjectID)
{
    return mal_does_AudioObject_support_scope(pContext, deviceObjectID, kAudioObjectPropertyScopeInput);
}


mal_result mal_get_AudioObject_stream_descriptions(mal_context* pContext, AudioObjectID deviceObjectID, mal_device_type deviceType, UInt32* pDescriptionCount, AudioStreamRangedDescription** ppDescriptions)    // NOTE: Free the returned pointer with mal_free().
{
    mal_assert(pContext != NULL);
    mal_assert(pDescriptionCount != NULL);
    mal_assert(ppDescriptions != NULL);
    
    // TODO: Experiment with kAudioStreamPropertyAvailablePhysicalFormats instead of (or in addition to) kAudioStreamPropertyAvailableVirtualFormats. My
    //       MacBook Pro uses s24/32 format, however, which mini_al does not currently support.
    AudioObjectPropertyAddress propAddress;
    propAddress.mSelector = kAudioStreamPropertyAvailableVirtualFormats; //kAudioStreamPropertyAvailablePhysicalFormats;
    propAddress.mScope    = (deviceType == mal_device_type_playback) ? kAudioObjectPropertyScopeOutput : kAudioObjectPropertyScopeInput;
    propAddress.mElement  = kAudioObjectPropertyElementMaster;
    
    UInt32 dataSize;
    OSStatus status = ((mal_AudioObjectGetPropertyDataSize_proc)pContext->coreaudio.AudioObjectGetPropertyDataSize)(deviceObjectID, &propAddress, 0, NULL, &dataSize);
    if (status != noErr) {
        return mal_result_from_OSStatus(status);
    }
    
    AudioStreamRangedDescription* pDescriptions = (AudioStreamRangedDescription*)mal_malloc(dataSize);
    if (pDescriptions == NULL) {
        return MAL_OUT_OF_MEMORY;
    }
    
    status = ((mal_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(deviceObjectID, &propAddress, 0, NULL, &dataSize, pDescriptions);
    if (status != noErr) {
        mal_free(pDescriptions);
        return mal_result_from_OSStatus(status);
    }
    
    *pDescriptionCount = dataSize / sizeof(*pDescriptions);
    *ppDescriptions = pDescriptions;
    return MAL_SUCCESS;
}


mal_result mal_get_AudioObject_channel_layout(mal_context* pContext, AudioObjectID deviceObjectID, mal_device_type deviceType, AudioChannelLayout** ppChannelLayout)   // NOTE: Free the returned pointer with mal_free().
{
    mal_assert(pContext != NULL);
    mal_assert(ppChannelLayout != NULL);
    
    *ppChannelLayout = NULL;    // Safety.
    
    AudioObjectPropertyAddress propAddress;
    propAddress.mSelector = kAudioDevicePropertyPreferredChannelLayout;
    propAddress.mScope    = (deviceType == mal_device_type_playback) ? kAudioObjectPropertyScopeOutput : kAudioObjectPropertyScopeInput;
    propAddress.mElement  = kAudioObjectPropertyElementMaster;
    
    UInt32 dataSize;
    OSStatus status = ((mal_AudioObjectGetPropertyDataSize_proc)pContext->coreaudio.AudioObjectGetPropertyDataSize)(deviceObjectID, &propAddress, 0, NULL, &dataSize);
    if (status != noErr) {
        return mal_result_from_OSStatus(status);
    }
    
    AudioChannelLayout* pChannelLayout = (AudioChannelLayout*)mal_malloc(dataSize);
    if (pChannelLayout == NULL) {
        return MAL_OUT_OF_MEMORY;
    }
    
    status = ((mal_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(deviceObjectID, &propAddress, 0, NULL, &dataSize, pChannelLayout);
    if (status != noErr) {
        mal_free(pChannelLayout);
        return mal_result_from_OSStatus(status);
    }
    
    *ppChannelLayout = pChannelLayout;
    return MAL_SUCCESS;
}

mal_result mal_get_AudioObject_channel_count(mal_context* pContext, AudioObjectID deviceObjectID, mal_device_type deviceType, mal_uint32* pChannelCount)
{
    mal_assert(pContext != NULL);
    mal_assert(pChannelCount != NULL);
    
    *pChannelCount = 0; // Safety.

    AudioChannelLayout* pChannelLayout;
    mal_result result = mal_get_AudioObject_channel_layout(pContext, deviceObjectID, deviceType, &pChannelLayout);
    if (result != MAL_SUCCESS) {
        return result;
    }
    
    if (pChannelLayout->mChannelLayoutTag == kAudioChannelLayoutTag_UseChannelDescriptions) {
        *pChannelCount = pChannelLayout->mNumberChannelDescriptions;
    } else if (pChannelLayout->mChannelLayoutTag == kAudioChannelLayoutTag_UseChannelBitmap) {
        *pChannelCount = mal_count_set_bits(pChannelLayout->mChannelBitmap);
    } else {
        *pChannelCount = AudioChannelLayoutTag_GetNumberOfChannels(pChannelLayout->mChannelLayoutTag);
    }
    
    mal_free(pChannelLayout);
    return MAL_SUCCESS;
}

mal_result mal_get_AudioObject_channel_map(mal_context* pContext, AudioObjectID deviceObjectID, mal_device_type deviceType, mal_channel channelMap[MAL_MAX_CHANNELS])
{
    mal_assert(pContext != NULL);
    
    AudioChannelLayout* pChannelLayout;
    mal_result result = mal_get_AudioObject_channel_layout(pContext, deviceObjectID, deviceType, &pChannelLayout);
    if (result != MAL_SUCCESS) {
        return result;  // Rather than always failing here, would it be more robust to simply assume a default?
    }
    
    result = mal_get_channel_map_from_AudioChannelLayout(pChannelLayout, channelMap);
    if (result != MAL_SUCCESS) {
        mal_free(pChannelLayout);
        return result;
    }
    
    mal_free(pChannelLayout);
    return result;
}

mal_result mal_get_AudioObject_sample_rates(mal_context* pContext, AudioObjectID deviceObjectID, mal_device_type deviceType, UInt32* pSampleRateRangesCount, AudioValueRange** ppSampleRateRanges)   // NOTE: Free the returned pointer with mal_free().
{
    mal_assert(pContext != NULL);
    mal_assert(pSampleRateRangesCount != NULL);
    mal_assert(ppSampleRateRanges != NULL);
  
    // Safety.
    *pSampleRateRangesCount = 0;
    *ppSampleRateRanges = NULL;
    
    AudioObjectPropertyAddress propAddress;
    propAddress.mSelector = kAudioDevicePropertyAvailableNominalSampleRates;
    propAddress.mScope    = (deviceType == mal_device_type_playback) ? kAudioObjectPropertyScopeOutput : kAudioObjectPropertyScopeInput;
    propAddress.mElement  = kAudioObjectPropertyElementMaster;
    
    UInt32 dataSize;
    OSStatus status = ((mal_AudioObjectGetPropertyDataSize_proc)pContext->coreaudio.AudioObjectGetPropertyDataSize)(deviceObjectID, &propAddress, 0, NULL, &dataSize);
    if (status != noErr) {
        return mal_result_from_OSStatus(status);
    }
    
    AudioValueRange* pSampleRateRanges = (AudioValueRange*)mal_malloc(dataSize);
    if (pSampleRateRanges == NULL) {
        return MAL_OUT_OF_MEMORY;
    }
    
    status = ((mal_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(deviceObjectID, &propAddress, 0, NULL, &dataSize, pSampleRateRanges);
    if (status != noErr) {
        mal_free(pSampleRateRanges);
        return mal_result_from_OSStatus(status);
    }
    
    *pSampleRateRangesCount = dataSize / sizeof(*pSampleRateRanges);
    *ppSampleRateRanges = pSampleRateRanges;
    return MAL_SUCCESS;
}

mal_result mal_get_AudioObject_get_closest_sample_rate(mal_context* pContext, AudioObjectID deviceObjectID, mal_device_type deviceType, mal_uint32 sampleRateIn, mal_uint32* pSampleRateOut)
{
    mal_assert(pContext != NULL);
    mal_assert(pSampleRateOut != NULL);
    
    *pSampleRateOut = 0;    // Safety.
    
    UInt32 sampleRateRangeCount;
    AudioValueRange* pSampleRateRanges;
    mal_result result = mal_get_AudioObject_sample_rates(pContext, deviceObjectID, deviceType, &sampleRateRangeCount, &pSampleRateRanges);
    if (result != MAL_SUCCESS) {
        return result;
    }
    
    if (sampleRateRangeCount == 0) {
        mal_free(pSampleRateRanges);
        return MAL_ERROR;   // Should never hit this case should we?
    }
    
    if (sampleRateIn == 0) {
        // Search in order of mini_al's preferred priority.
        for (UInt32 iMALSampleRate = 0; iMALSampleRate < mal_countof(g_malStandardSampleRatePriorities); ++iMALSampleRate) {
            mal_uint32 malSampleRate = g_malStandardSampleRatePriorities[iMALSampleRate];
            for (UInt32 iCASampleRate = 0; iCASampleRate < sampleRateRangeCount; ++iCASampleRate) {
                AudioValueRange caSampleRate = pSampleRateRanges[iCASampleRate];
                if (caSampleRate.mMinimum <= malSampleRate && caSampleRate.mMaximum >= malSampleRate) {
                    *pSampleRateOut = malSampleRate;
                    mal_free(pSampleRateRanges);
                    return MAL_SUCCESS;
                }
            }
        }
        
        // If we get here it means none of mini_al's standard sample rates matched any of the supported sample rates from the device. In this
        // case we just fall back to the first one reported by Core Audio.
        mal_assert(sampleRateRangeCount > 0);
        
        *pSampleRateOut = pSampleRateRanges[0].mMinimum;
        mal_free(pSampleRateRanges);
        return MAL_SUCCESS;
    } else {
        // Find the closest match to this sample rate.
        UInt32 currentAbsoluteDifference = INT32_MAX;
        UInt32 iCurrentClosestRange = (UInt32)-1;
        for (UInt32 iRange = 0; iRange < sampleRateRangeCount; ++iRange) {
            if (pSampleRateRanges[iRange].mMinimum <= sampleRateIn && pSampleRateRanges[iRange].mMaximum >= sampleRateIn) {
                *pSampleRateOut = sampleRateIn;
                mal_free(pSampleRateRanges);
                return MAL_SUCCESS;
            } else {
                UInt32 absoluteDifference;
                if (pSampleRateRanges[iRange].mMinimum > sampleRateIn) {
                    absoluteDifference = pSampleRateRanges[iRange].mMinimum - sampleRateIn;
                } else {
                    absoluteDifference = sampleRateIn - pSampleRateRanges[iRange].mMaximum;
                }
                
                if (currentAbsoluteDifference > absoluteDifference) {
                    currentAbsoluteDifference = absoluteDifference;
                    iCurrentClosestRange = iRange;
                }
            }
        }
        
        mal_assert(iCurrentClosestRange != (UInt32)-1);
        
        *pSampleRateOut = pSampleRateRanges[iCurrentClosestRange].mMinimum;
        mal_free(pSampleRateRanges);
        return MAL_SUCCESS;
    }
    
    // Should never get here, but it would mean we weren't able to find any suitable sample rates.
    //mal_free(pSampleRateRanges);
    //return MAL_ERROR;
}


mal_result mal_get_AudioObject_closest_buffer_size_in_frames(mal_context* pContext, AudioObjectID deviceObjectID, mal_device_type deviceType, mal_uint32 bufferSizeInFramesIn, mal_uint32* pBufferSizeInFramesOut)
{
    mal_assert(pContext != NULL);
    mal_assert(pBufferSizeInFramesOut != NULL);
    
    *pBufferSizeInFramesOut = 0;    // Safety.
    
    AudioObjectPropertyAddress propAddress;
    propAddress.mSelector = kAudioDevicePropertyBufferFrameSizeRange;
    propAddress.mScope    = (deviceType == mal_device_type_playback) ? kAudioObjectPropertyScopeOutput : kAudioObjectPropertyScopeInput;
    propAddress.mElement  = kAudioObjectPropertyElementMaster;

    AudioValueRange bufferSizeRange;
    UInt32 dataSize = sizeof(bufferSizeRange);
    OSStatus status = ((mal_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(deviceObjectID, &propAddress, 0, NULL, &dataSize, &bufferSizeRange);
    if (status != noErr) {
        return mal_result_from_OSStatus(status);
    }
    
    // This is just a clamp.
    if (bufferSizeInFramesIn < bufferSizeRange.mMinimum) {
        *pBufferSizeInFramesOut = (mal_uint32)bufferSizeRange.mMinimum;
    } else if (bufferSizeInFramesIn > bufferSizeRange.mMaximum) {
        *pBufferSizeInFramesOut = (mal_uint32)bufferSizeRange.mMaximum;
    } else {
        *pBufferSizeInFramesOut = bufferSizeInFramesIn;
    }

    return MAL_SUCCESS;
}

mal_result mal_set_AudioObject_buffer_size_in_frames(mal_context* pContext, AudioObjectID deviceObjectID, mal_device_type deviceType, mal_uint32* pBufferSizeInOut)
{
    mal_assert(pContext != NULL);

    mal_uint32 chosenBufferSizeInFrames;
    mal_result result = mal_get_AudioObject_closest_buffer_size_in_frames(pContext, deviceObjectID, deviceType, *pBufferSizeInOut, &chosenBufferSizeInFrames);
    if (result != MAL_SUCCESS) {
        return result;
    }

    // Try setting the size of the buffer... If this fails we just use whatever is currently set.
    AudioObjectPropertyAddress propAddress;
    propAddress.mSelector = kAudioDevicePropertyBufferFrameSize;
    propAddress.mScope    = (deviceType == mal_device_type_playback) ? kAudioObjectPropertyScopeOutput : kAudioObjectPropertyScopeInput;
    propAddress.mElement  = kAudioObjectPropertyElementMaster;
    
    ((mal_AudioObjectSetPropertyData_proc)pContext->coreaudio.AudioObjectSetPropertyData)(deviceObjectID, &propAddress, 0, NULL, sizeof(chosenBufferSizeInFrames), &chosenBufferSizeInFrames);
    
    // Get the actual size of the buffer.
    UInt32 dataSize = sizeof(*pBufferSizeInOut);
    OSStatus status = ((mal_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(deviceObjectID, &propAddress, 0, NULL, &dataSize, &chosenBufferSizeInFrames);
    if (status != noErr) {
        return mal_result_from_OSStatus(status);
    }
    
    *pBufferSizeInOut = chosenBufferSizeInFrames;
    return MAL_SUCCESS;
}


mal_result mal_find_AudioObjectID(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, AudioObjectID* pDeviceObjectID)
{
    mal_assert(pContext != NULL);
    mal_assert(pDeviceObjectID != NULL);

    // Safety.
    *pDeviceObjectID = 0;
    
    if (pDeviceID == NULL) {
        // Default device.
        AudioObjectPropertyAddress propAddressDefaultDevice;
        propAddressDefaultDevice.mScope = kAudioObjectPropertyScopeGlobal;
        propAddressDefaultDevice.mElement = kAudioObjectPropertyElementMaster;
        if (deviceType == mal_device_type_playback) {
            propAddressDefaultDevice.mSelector = kAudioHardwarePropertyDefaultOutputDevice;
        } else {
            propAddressDefaultDevice.mSelector = kAudioHardwarePropertyDefaultInputDevice;
        }
        
        UInt32 defaultDeviceObjectIDSize = sizeof(AudioObjectID);
        AudioObjectID defaultDeviceObjectID;
        OSStatus status = ((mal_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(kAudioObjectSystemObject, &propAddressDefaultDevice, 0, NULL, &defaultDeviceObjectIDSize, &defaultDeviceObjectID);
        if (status == noErr) {
            *pDeviceObjectID = defaultDeviceObjectID;
            return MAL_SUCCESS;
        }
    } else {
        // Explicit device.
        UInt32 deviceCount;
        AudioObjectID* pDeviceObjectIDs;
        mal_result result = mal_get_device_object_ids__coreaudio(pContext, &deviceCount, &pDeviceObjectIDs);
        if (result != MAL_SUCCESS) {
            return result;
        }
        
        for (UInt32 iDevice = 0; iDevice < deviceCount; ++iDevice) {
            AudioObjectID deviceObjectID = pDeviceObjectIDs[iDevice];
            
            char uid[256];
            if (mal_get_AudioObject_uid(pContext, deviceObjectID, sizeof(uid), uid) != MAL_SUCCESS) {
                continue;
            }
            
            if (deviceType == mal_device_type_playback) {
                if (mal_does_AudioObject_support_playback(pContext, deviceObjectID)) {
                    if (strcmp(uid, pDeviceID->coreaudio) == 0) {
                        *pDeviceObjectID = deviceObjectID;
                        return MAL_SUCCESS;
                    }
                }
            } else {
                if (mal_does_AudioObject_support_capture(pContext, deviceObjectID)) {
                    if (strcmp(uid, pDeviceID->coreaudio) == 0) {
                        *pDeviceObjectID = deviceObjectID;
                        return MAL_SUCCESS;
                    }
                }
            }
        }
    }
    
    // If we get here it means we couldn't find the device.
    return MAL_NO_DEVICE;
}


mal_result mal_find_best_format__coreaudio(mal_context* pContext, AudioObjectID deviceObjectID, mal_device_type deviceType, mal_format format, mal_uint32 channels, mal_uint32 sampleRate, mal_bool32 usingDefaultFormat, mal_bool32 usingDefaultChannels, mal_bool32 usingDefaultSampleRate, AudioStreamBasicDescription* pFormat)
{
    UInt32 deviceFormatDescriptionCount;
    AudioStreamRangedDescription* pDeviceFormatDescriptions;
    mal_result result = mal_get_AudioObject_stream_descriptions(pContext, deviceObjectID, deviceType, &deviceFormatDescriptionCount, &pDeviceFormatDescriptions);
    if (result != MAL_SUCCESS) {
        return result;
    }
    
    mal_uint32 desiredSampleRate = sampleRate;
    if (usingDefaultSampleRate) {
        // When using the device's default sample rate, we get the highest priority standard rate supported by the device. Otherwise
        // we just use the pre-set rate.
        for (mal_uint32 iStandardRate = 0; iStandardRate < mal_countof(g_malStandardSampleRatePriorities); ++iStandardRate) {
            mal_uint32 standardRate = g_malStandardSampleRatePriorities[iStandardRate];
            
            mal_bool32 foundRate = MAL_FALSE;
            for (UInt32 iDeviceRate = 0; iDeviceRate < deviceFormatDescriptionCount; ++iDeviceRate) {
                mal_uint32 deviceRate = (mal_uint32)pDeviceFormatDescriptions[iDeviceRate].mFormat.mSampleRate;
                
                if (deviceRate == standardRate) {
                    desiredSampleRate = standardRate;
                    foundRate = MAL_TRUE;
                    break;
                }
            }
            
            if (foundRate) {
                break;
            }
        }
    }
    
    mal_uint32 desiredChannelCount = channels;
    if (usingDefaultChannels) {
        mal_get_AudioObject_channel_count(pContext, deviceObjectID, deviceType, &desiredChannelCount);    // <-- Not critical if this fails.
    }
    
    mal_format desiredFormat = format;
    if (usingDefaultFormat) {
        desiredFormat = g_malFormatPriorities[0];
    }
    
    // If we get here it means we don't have an exact match to what the client is asking for. We'll need to find the closest one. The next
    // loop will check for formats that have the same sample rate to what we're asking for. If there is, we prefer that one in all cases.
    AudioStreamBasicDescription bestDeviceFormatSoFar;
    mal_zero_object(&bestDeviceFormatSoFar);
    
    mal_bool32 hasSupportedFormat = MAL_FALSE;
    for (UInt32 iFormat = 0; iFormat < deviceFormatDescriptionCount; ++iFormat) {
        mal_format format;
        mal_result formatResult = mal_format_from_AudioStreamBasicDescription(&pDeviceFormatDescriptions[iFormat].mFormat, &format);
        if (formatResult == MAL_SUCCESS && format != mal_format_unknown) {
            hasSupportedFormat = MAL_TRUE;
            bestDeviceFormatSoFar = pDeviceFormatDescriptions[iFormat].mFormat;
            break;
        }
    }
    
    if (!hasSupportedFormat) {
        return MAL_FORMAT_NOT_SUPPORTED;
    }
    
    
    for (UInt32 iFormat = 0; iFormat < deviceFormatDescriptionCount; ++iFormat) {
        AudioStreamBasicDescription thisDeviceFormat = pDeviceFormatDescriptions[iFormat].mFormat;
    
        // If the format is not supported by mini_al we need to skip this one entirely.
        mal_format thisSampleFormat;
        mal_result formatResult = mal_format_from_AudioStreamBasicDescription(&pDeviceFormatDescriptions[iFormat].mFormat, &thisSampleFormat);
        if (formatResult != MAL_SUCCESS || thisSampleFormat == mal_format_unknown) {
            continue;   // The format is not supported by mini_al. Skip.
        }
        
        mal_format bestSampleFormatSoFar;
        mal_format_from_AudioStreamBasicDescription(&bestDeviceFormatSoFar, &bestSampleFormatSoFar);
        
    
        // Getting here means the format is supported by mini_al which makes this format a candidate.
        if (thisDeviceFormat.mSampleRate != desiredSampleRate) {
            // The sample rate does not match, but this format could still be usable, although it's a very low priority. If the best format
            // so far has an equal sample rate we can just ignore this one.
            if (bestDeviceFormatSoFar.mSampleRate == desiredSampleRate) {
                continue;   // The best sample rate so far has the same sample rate as what we requested which means it's still the best so far. Skip this format.
            } else {
                // In this case, neither the best format so far nor this one have the same sample rate. Check the channel count next.
                if (thisDeviceFormat.mChannelsPerFrame != desiredChannelCount) {
                    // This format has a different sample rate _and_ a different channel count.
                    if (bestDeviceFormatSoFar.mChannelsPerFrame == desiredChannelCount) {
                        continue;   // No change to the best format.
                    } else {
                        // Both this format and the best so far have different sample rates and different channel counts. Whichever has the
                        // best format is the new best.
                        if (mal_get_format_priority_index(thisSampleFormat) < mal_get_format_priority_index(bestSampleFormatSoFar)) {
                            bestDeviceFormatSoFar = thisDeviceFormat;
                            continue;
                        } else {
                            continue;   // No change to the best format.
                        }
                    }
                } else {
                    // This format has a different sample rate but the desired channel count.
                    if (bestDeviceFormatSoFar.mChannelsPerFrame == desiredChannelCount) {
                        // Both this format and the best so far have the desired channel count. Whichever has the best format is the new best.
                        if (mal_get_format_priority_index(thisSampleFormat) < mal_get_format_priority_index(bestSampleFormatSoFar)) {
                            bestDeviceFormatSoFar = thisDeviceFormat;
                            continue;
                        } else {
                            continue;   // No change to the best format for now.
                        }
                    } else {
                        // This format has the desired channel count, but the best so far does not. We have a new best.
                        bestDeviceFormatSoFar = thisDeviceFormat;
                        continue;
                    }
                }
            }
        } else {
            // The sample rates match which makes this format a very high priority contender. If the best format so far has a different
            // sample rate it needs to be replaced with this one.
            if (bestDeviceFormatSoFar.mSampleRate != desiredSampleRate) {
                bestDeviceFormatSoFar = thisDeviceFormat;
                continue;
            } else {
                // In this case both this format and the best format so far have the same sample rate. Check the channel count next.
                if (thisDeviceFormat.mChannelsPerFrame == desiredChannelCount) {
                    // In this case this format has the same channel count as what the client is requesting. If the best format so far has
                    // a different count, this one becomes the new best.
                    if (bestDeviceFormatSoFar.mChannelsPerFrame != desiredChannelCount) {
                        bestDeviceFormatSoFar = thisDeviceFormat;
                        continue;
                    } else {
                        // In this case both this format and the best so far have the ideal sample rate and channel count. Check the format.
                        if (thisSampleFormat == desiredFormat) {
                            bestDeviceFormatSoFar = thisDeviceFormat;
                            break;  // Found the exact match.
                        } else {
                            // The formats are different. The new best format is the one with the highest priority format according to mini_al.
                            if (mal_get_format_priority_index(thisSampleFormat) < mal_get_format_priority_index(bestSampleFormatSoFar)) {
                                bestDeviceFormatSoFar = thisDeviceFormat;
                                continue;
                            } else {
                                continue;   // No change to the best format for now.
                            }
                        }
                    }
                } else {
                    // In this case the channel count is different to what the client has requested. If the best so far has the same channel
                    // count as the requested count then it remains the best.
                    if (bestDeviceFormatSoFar.mChannelsPerFrame == desiredChannelCount) {
                        continue;
                    } else {
                        // This is the case where both have the same sample rate (good) but different channel counts. Right now both have about
                        // the same priority, but we need to compare the format now.
                        if (thisSampleFormat == bestSampleFormatSoFar) {
                            if (mal_get_format_priority_index(thisSampleFormat) < mal_get_format_priority_index(bestSampleFormatSoFar)) {
                                bestDeviceFormatSoFar = thisDeviceFormat;
                                continue;
                            } else {
                                continue;   // No change to the best format for now.
                            }
                        }
                    }
                }
            }
        }
    }
    
    *pFormat = bestDeviceFormatSoFar;
    return MAL_SUCCESS;
}
#endif

mal_result mal_get_AudioUnit_channel_map(mal_context* pContext, AudioUnit audioUnit, mal_device_type deviceType, mal_channel channelMap[MAL_MAX_CHANNELS])
{
    mal_assert(pContext != NULL);
    
    AudioUnitScope deviceScope;
    AudioUnitElement deviceBus;
    if (deviceType == mal_device_type_playback) {
        deviceScope = kAudioUnitScope_Output;
        deviceBus = MAL_COREAUDIO_OUTPUT_BUS;
    } else {
        deviceScope = kAudioUnitScope_Input;
        deviceBus = MAL_COREAUDIO_INPUT_BUS;
    }
    
    UInt32 channelLayoutSize;
    OSStatus status = ((mal_AudioUnitGetPropertyInfo_proc)pContext->coreaudio.AudioUnitGetPropertyInfo)(audioUnit, kAudioUnitProperty_AudioChannelLayout, deviceScope, deviceBus, &channelLayoutSize, NULL);
    if (status != noErr) {
        return mal_result_from_OSStatus(status);
    }
    
    AudioChannelLayout* pChannelLayout = (AudioChannelLayout*)mal_malloc(channelLayoutSize);
    if (pChannelLayout == NULL) {
        return MAL_OUT_OF_MEMORY;
    }
    
    status = ((mal_AudioUnitGetProperty_proc)pContext->coreaudio.AudioUnitGetProperty)(audioUnit, kAudioUnitProperty_AudioChannelLayout, deviceScope, deviceBus, pChannelLayout, &channelLayoutSize);
    if (status != noErr) {
        mal_free(pChannelLayout);
        return mal_result_from_OSStatus(status);
    }
    
    mal_result result = mal_get_channel_map_from_AudioChannelLayout(pChannelLayout, channelMap);
    if (result != MAL_SUCCESS) {
        mal_free(pChannelLayout);
        return result;
    }

    mal_free(pChannelLayout);
    return MAL_SUCCESS;
}

mal_bool32 mal_context_is_device_id_equal__coreaudio(mal_context* pContext, const mal_device_id* pID0, const mal_device_id* pID1)
{
    mal_assert(pContext != NULL);
    mal_assert(pID0 != NULL);
    mal_assert(pID1 != NULL);
    (void)pContext;

    return strcmp(pID0->coreaudio, pID1->coreaudio) == 0;
}

mal_result mal_context_enumerate_devices__coreaudio(mal_context* pContext, mal_enum_devices_callback_proc callback, void* pUserData)
{
    mal_assert(pContext != NULL);
    mal_assert(callback != NULL);
    
#if defined(MAL_APPLE_DESKTOP)
    UInt32 deviceCount;
    AudioObjectID* pDeviceObjectIDs;
    mal_result result = mal_get_device_object_ids__coreaudio(pContext, &deviceCount, &pDeviceObjectIDs);
    if (result != MAL_SUCCESS) {
        return result;
    }
  
    for (UInt32 iDevice = 0; iDevice < deviceCount; ++iDevice) {
        AudioObjectID deviceObjectID = pDeviceObjectIDs[iDevice];

        mal_device_info info;
        mal_zero_object(&info);
        if (mal_get_AudioObject_uid(pContext, deviceObjectID, sizeof(info.id.coreaudio), info.id.coreaudio) != MAL_SUCCESS) {
            continue;
        }
        if (mal_get_AudioObject_name(pContext, deviceObjectID, sizeof(info.name), info.name) != MAL_SUCCESS) {
            continue;
        }

        if (mal_does_AudioObject_support_playback(pContext, deviceObjectID)) {
            if (!callback(pContext, mal_device_type_playback, &info, pUserData)) {
                break;
            }
        }
        if (mal_does_AudioObject_support_capture(pContext, deviceObjectID)) {
            if (!callback(pContext, mal_device_type_capture, &info, pUserData)) {
                break;
            }
        }
    }
    
    mal_free(pDeviceObjectIDs);
#else
    // Only supporting default devices on non-Desktop platforms.
    mal_device_info info;
    
    mal_zero_object(&info);
    mal_strncpy_s(info.name, sizeof(info.name), MAL_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
    if (!callback(pContext, mal_device_type_playback, &info, pUserData)) {
        return MAL_SUCCESS;
    }
    
    mal_zero_object(&info);
    mal_strncpy_s(info.name, sizeof(info.name), MAL_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
    if (!callback(pContext, mal_device_type_capture, &info, pUserData)) {
        return MAL_SUCCESS;
    }
#endif
    
    return MAL_SUCCESS;
}

mal_result mal_context_get_device_info__coreaudio(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, mal_device_info* pDeviceInfo)
{
    mal_assert(pContext != NULL);
    (void)pDeviceInfo;

    /* No exclusive mode with the Core Audio backend for now. */
    if (shareMode == mal_share_mode_exclusive) {
        return MAL_SHARE_MODE_NOT_SUPPORTED;
    }
    
#if defined(MAL_APPLE_DESKTOP)
    // Desktop
    // =======
    AudioObjectID deviceObjectID;
    mal_result result = mal_find_AudioObjectID(pContext, deviceType, pDeviceID, &deviceObjectID);
    if (result != MAL_SUCCESS) {
        return result;
    }
    
    result = mal_get_AudioObject_uid(pContext, deviceObjectID, sizeof(pDeviceInfo->id.coreaudio), pDeviceInfo->id.coreaudio);
    if (result != MAL_SUCCESS) {
        return result;
    }
    
    result = mal_get_AudioObject_name(pContext, deviceObjectID, sizeof(pDeviceInfo->name), pDeviceInfo->name);
    if (result != MAL_SUCCESS) {
        return result;
    }
    
    // Formats.
    UInt32 streamDescriptionCount;
    AudioStreamRangedDescription* pStreamDescriptions;
    result = mal_get_AudioObject_stream_descriptions(pContext, deviceObjectID, deviceType, &streamDescriptionCount, &pStreamDescriptions);
    if (result != MAL_SUCCESS) {
        return result;
    }
    
    for (UInt32 iStreamDescription = 0; iStreamDescription < streamDescriptionCount; ++iStreamDescription) {
        mal_format format;
        result = mal_format_from_AudioStreamBasicDescription(&pStreamDescriptions[iStreamDescription].mFormat, &format);
        if (result != MAL_SUCCESS) {
            continue;
        }
        
        mal_assert(format != mal_format_unknown);
        
        // Make sure the format isn't already in the output list.
        mal_bool32 exists = MAL_FALSE;
        for (mal_uint32 iOutputFormat = 0; iOutputFormat < pDeviceInfo->formatCount; ++iOutputFormat) {
            if (pDeviceInfo->formats[iOutputFormat] == format) {
                exists = MAL_TRUE;
                break;
            }
        }
        
        if (!exists) {
            pDeviceInfo->formats[pDeviceInfo->formatCount++] = format;
        }
    }
    
    mal_free(pStreamDescriptions);
    
    
    // Channels.
    result = mal_get_AudioObject_channel_count(pContext, deviceObjectID, deviceType, &pDeviceInfo->minChannels);
    if (result != MAL_SUCCESS) {
        return result;
    }
    pDeviceInfo->maxChannels = pDeviceInfo->minChannels;
    
    
    // Sample rates.
    UInt32 sampleRateRangeCount;
    AudioValueRange* pSampleRateRanges;
    result = mal_get_AudioObject_sample_rates(pContext, deviceObjectID, deviceType, &sampleRateRangeCount, &pSampleRateRanges);
    if (result != MAL_SUCCESS) {
        return result;
    }
    
    if (sampleRateRangeCount > 0) {
        pDeviceInfo->minSampleRate = UINT32_MAX;
        pDeviceInfo->maxSampleRate = 0;
        for (UInt32 iSampleRate = 0; iSampleRate < sampleRateRangeCount; ++iSampleRate) {
            if (pDeviceInfo->minSampleRate > pSampleRateRanges[iSampleRate].mMinimum) {
                pDeviceInfo->minSampleRate = pSampleRateRanges[iSampleRate].mMinimum;
            }
            if (pDeviceInfo->maxSampleRate < pSampleRateRanges[iSampleRate].mMaximum) {
                pDeviceInfo->maxSampleRate = pSampleRateRanges[iSampleRate].mMaximum;
            }
        }
    }
#else
    // Mobile
    // ======
    if (deviceType == mal_device_type_playback) {
        mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MAL_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
    } else {
        mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MAL_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
    }
    
    // Retrieving device information is more annoying on mobile than desktop. For simplicity I'm locking this down to whatever format is
    // reported on a temporary I/O unit. The problem, however, is that this doesn't return a value for the sample rate which we need to
    // retrieve from the AVAudioSession shared instance.
    AudioComponentDescription desc;
    desc.componentType = kAudioUnitType_Output;
    desc.componentSubType = kAudioUnitSubType_RemoteIO;
    desc.componentManufacturer = kAudioUnitManufacturer_Apple;
    desc.componentFlags = 0;
    desc.componentFlagsMask = 0;
    
    AudioComponent component = ((mal_AudioComponentFindNext_proc)pContext->coreaudio.AudioComponentFindNext)(NULL, &desc);
    if (component == NULL) {
        return MAL_FAILED_TO_INIT_BACKEND;
    }
    
    AudioUnit audioUnit;
    OSStatus status = ((mal_AudioComponentInstanceNew_proc)pContext->coreaudio.AudioComponentInstanceNew)(component, &audioUnit);
    if (status != noErr) {
        return mal_result_from_OSStatus(status);
    }
    
    AudioUnitScope   formatScope   = (deviceType == mal_device_type_playback) ? kAudioUnitScope_Input : kAudioUnitScope_Output;
    AudioUnitElement formatElement = (deviceType == mal_device_type_playback) ? MAL_COREAUDIO_OUTPUT_BUS : MAL_COREAUDIO_INPUT_BUS;
    
    AudioStreamBasicDescription bestFormat;
    UInt32 propSize = sizeof(bestFormat);
    status = ((mal_AudioUnitGetProperty_proc)pContext->coreaudio.AudioUnitGetProperty)(audioUnit, kAudioUnitProperty_StreamFormat, formatScope, formatElement, &bestFormat, &propSize);
    if (status != noErr) {
        ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(audioUnit);
        return mal_result_from_OSStatus(status);
    }
    
    ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(audioUnit);
    audioUnit = NULL;
    
    
    pDeviceInfo->minChannels = bestFormat.mChannelsPerFrame;
    pDeviceInfo->maxChannels = bestFormat.mChannelsPerFrame;
    
    pDeviceInfo->formatCount = 1;
    mal_result result = mal_format_from_AudioStreamBasicDescription(&bestFormat, &pDeviceInfo->formats[0]);
    if (result != MAL_SUCCESS) {
        return result;
    }
    
    // It looks like Apple are wanting to push the whole AVAudioSession thing. Thus, we need to use that to determine device settings. To do
    // this we just get the shared instance and inspect.
    @autoreleasepool {
        AVAudioSession* pAudioSession = [AVAudioSession sharedInstance];
        mal_assert(pAudioSession != NULL);

        pDeviceInfo->minSampleRate = (mal_uint32)pAudioSession.sampleRate;
        pDeviceInfo->maxSampleRate = pDeviceInfo->minSampleRate;
    }
#endif
    
    return MAL_SUCCESS;
}


void mal_device_uninit__coreaudio(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);
    mal_assert(mal_device__get_state(pDevice) == MAL_STATE_UNINITIALIZED);
    
    if (pDevice->coreaudio.audioUnitCapture != NULL) {
        ((mal_AudioComponentInstanceDispose_proc)pDevice->pContext->coreaudio.AudioComponentInstanceDispose)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
    }
    if (pDevice->coreaudio.audioUnitPlayback != NULL) {
        ((mal_AudioComponentInstanceDispose_proc)pDevice->pContext->coreaudio.AudioComponentInstanceDispose)((AudioUnit)pDevice->coreaudio.audioUnitPlayback);
    }
    
    if (pDevice->coreaudio.pAudioBufferList) {
        mal_free(pDevice->coreaudio.pAudioBufferList);
    }

    if (pDevice->type == mal_device_type_duplex) {
        mal_pcm_rb_uninit(&pDevice->coreaudio.duplexRB);
    }
}


OSStatus mal_on_output__coreaudio(void* pUserData, AudioUnitRenderActionFlags* pActionFlags, const AudioTimeStamp* pTimeStamp, UInt32 busNumber, UInt32 frameCount, AudioBufferList* pBufferList)
{
    (void)pActionFlags;
    (void)pTimeStamp;
    (void)busNumber;

    mal_device* pDevice = (mal_device*)pUserData;
    mal_assert(pDevice != NULL);

#if defined(MAL_DEBUG_OUTPUT)
    printf("INFO: Output Callback: busNumber=%d, frameCount=%d, mNumberBuffers=%d\n", busNumber, frameCount, pBufferList->mNumberBuffers);
#endif

    // We need to check whether or not we are outputting interleaved or non-interleaved samples. The
    // way we do this is slightly different for each type.
    mal_stream_layout layout = mal_stream_layout_interleaved;
    if (pBufferList->mBuffers[0].mNumberChannels != pDevice->playback.internalChannels) {
        layout = mal_stream_layout_deinterleaved;
    }
    
    if (layout == mal_stream_layout_interleaved) {
        // For now we can assume everything is interleaved.
        for (UInt32 iBuffer = 0; iBuffer < pBufferList->mNumberBuffers; ++iBuffer) {
            if (pBufferList->mBuffers[iBuffer].mNumberChannels == pDevice->playback.internalChannels) {
                mal_uint32 frameCountForThisBuffer = pBufferList->mBuffers[iBuffer].mDataByteSize / mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
                if (frameCountForThisBuffer > 0) {
                    if (pDevice->type == mal_device_type_duplex) {
                        mal_device__handle_duplex_callback_playback(pDevice, frameCountForThisBuffer, pBufferList->mBuffers[iBuffer].mData, &pDevice->coreaudio.duplexRB);
                    } else {
                        mal_device__read_frames_from_client(pDevice, frameCountForThisBuffer, pBufferList->mBuffers[iBuffer].mData);
                    }
                }
                
            #if defined(MAL_DEBUG_OUTPUT)
                printf("  frameCount=%d, mNumberChannels=%d, mDataByteSize=%d\n", frameCount, pBufferList->mBuffers[iBuffer].mNumberChannels, pBufferList->mBuffers[iBuffer].mDataByteSize);
            #endif
            } else {
                // This case is where the number of channels in the output buffer do not match our internal channels. It could mean that it's
                // not interleaved, in which case we can't handle right now since mini_al does not yet support non-interleaved streams. We just
                // output silence here.
                mal_zero_memory(pBufferList->mBuffers[iBuffer].mData, pBufferList->mBuffers[iBuffer].mDataByteSize);

            #if defined(MAL_DEBUG_OUTPUT)
                printf("  WARNING: Outputting silence. frameCount=%d, mNumberChannels=%d, mDataByteSize=%d\n", frameCount, pBufferList->mBuffers[iBuffer].mNumberChannels, pBufferList->mBuffers[iBuffer].mDataByteSize);
            #endif
            }
        }
    } else {
        // This is the deinterleaved case. We need to update each buffer in groups of internalChannels. This
        // assumes each buffer is the same size.
        mal_uint8 tempBuffer[4096];
        for (UInt32 iBuffer = 0; iBuffer < pBufferList->mNumberBuffers; iBuffer += pDevice->playback.internalChannels) {
            mal_uint32 frameCountPerBuffer = pBufferList->mBuffers[iBuffer].mDataByteSize / mal_get_bytes_per_sample(pDevice->playback.internalFormat);
            
            mal_uint32 framesRemaining = frameCountPerBuffer;
            while (framesRemaining > 0) {
                mal_uint32 framesToRead = sizeof(tempBuffer) / mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
                if (framesToRead > framesRemaining) {
                    framesToRead = framesRemaining;
                }
                
                if (pDevice->type == mal_device_type_duplex) {
                    mal_device__handle_duplex_callback_playback(pDevice, framesToRead, tempBuffer, &pDevice->coreaudio.duplexRB);
                } else {
                    mal_device__read_frames_from_client(pDevice, framesToRead, tempBuffer);
                }
                
                void* ppDeinterleavedBuffers[MAL_MAX_CHANNELS];
                for (mal_uint32 iChannel = 0; iChannel < pDevice->playback.internalChannels; ++iChannel) {
                    ppDeinterleavedBuffers[iChannel] = (void*)mal_offset_ptr(pBufferList->mBuffers[iBuffer].mData, (frameCountPerBuffer - framesRemaining) * mal_get_bytes_per_sample(pDevice->playback.internalFormat));
                }
                
                mal_deinterleave_pcm_frames(pDevice->playback.internalFormat, pDevice->playback.internalChannels, framesToRead, tempBuffer, ppDeinterleavedBuffers);
                
                framesRemaining -= framesToRead;
            }
        }
    }
    
    return noErr;
}

OSStatus mal_on_input__coreaudio(void* pUserData, AudioUnitRenderActionFlags* pActionFlags, const AudioTimeStamp* pTimeStamp, UInt32 busNumber, UInt32 frameCount, AudioBufferList* pUnusedBufferList)
{
    (void)pActionFlags;
    (void)pTimeStamp;
    (void)busNumber;
    (void)frameCount;
    (void)pUnusedBufferList;
    
    mal_device* pDevice = (mal_device*)pUserData;
    mal_assert(pDevice != NULL);
    
    AudioBufferList* pRenderedBufferList = (AudioBufferList*)pDevice->coreaudio.pAudioBufferList;
    mal_assert(pRenderedBufferList);
    
    // We need to check whether or not we are outputting interleaved or non-interleaved samples. The
    // way we do this is slightly different for each type.
    mal_stream_layout layout = mal_stream_layout_interleaved;
    if (pRenderedBufferList->mBuffers[0].mNumberChannels != pDevice->capture.internalChannels) {
        layout = mal_stream_layout_deinterleaved;
    }
    
#if defined(MAL_DEBUG_OUTPUT)
    printf("INFO: Input Callback: busNumber=%d, frameCount=%d, mNumberBuffers=%d\n", busNumber, frameCount, pRenderedBufferList->mNumberBuffers);
#endif
    
    OSStatus status = ((mal_AudioUnitRender_proc)pDevice->pContext->coreaudio.AudioUnitRender)((AudioUnit)pDevice->coreaudio.audioUnitCapture, pActionFlags, pTimeStamp, busNumber, frameCount, pRenderedBufferList);
    if (status != noErr) {
    #if defined(MAL_DEBUG_OUTPUT)
        printf("  ERROR: AudioUnitRender() failed with %d\n", status);
    #endif
        return status;
    }
    
    if (layout == mal_stream_layout_interleaved) {
        for (UInt32 iBuffer = 0; iBuffer < pRenderedBufferList->mNumberBuffers; ++iBuffer) {
            if (pRenderedBufferList->mBuffers[iBuffer].mNumberChannels == pDevice->capture.internalChannels) {
                if (pDevice->type == mal_device_type_duplex) {
                    mal_device__handle_duplex_callback_capture(pDevice, frameCount, pRenderedBufferList->mBuffers[iBuffer].mData, &pDevice->coreaudio.duplexRB);
                } else {
                    mal_device__send_frames_to_client(pDevice, frameCount, pRenderedBufferList->mBuffers[iBuffer].mData);
                }
            #if defined(MAL_DEBUG_OUTPUT)
                printf("  mDataByteSize=%d\n", pRenderedBufferList->mBuffers[iBuffer].mDataByteSize);
            #endif
            } else {
                // This case is where the number of channels in the output buffer do not match our internal channels. It could mean that it's
                // not interleaved, in which case we can't handle right now since mini_al does not yet support non-interleaved streams.
                
                mal_uint8 silentBuffer[4096];
                mal_zero_memory(silentBuffer, sizeof(silentBuffer));
                
                mal_uint32 framesRemaining = frameCount;
                while (framesRemaining > 0) {
                    mal_uint32 framesToSend = sizeof(silentBuffer) / mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
                    if (framesToSend > framesRemaining) {
                        framesToSend = framesRemaining;
                    }
                    
                    if (pDevice->type == mal_device_type_duplex) {
                        mal_device__handle_duplex_callback_capture(pDevice, framesToSend, silentBuffer, &pDevice->coreaudio.duplexRB);
                    } else {
                        mal_device__send_frames_to_client(pDevice, framesToSend, silentBuffer);
                    }
                    
                    framesRemaining -= framesToSend;
                }
                
            #if defined(MAL_DEBUG_OUTPUT)
                printf("  WARNING: Outputting silence. frameCount=%d, mNumberChannels=%d, mDataByteSize=%d\n", frameCount, pRenderedBufferList->mBuffers[iBuffer].mNumberChannels, pRenderedBufferList->mBuffers[iBuffer].mDataByteSize);
            #endif
            }
        }
    } else {
        // This is the deinterleaved case. We need to interleave the audio data before sending it to the client. This
        // assumes each buffer is the same size.
        mal_uint8 tempBuffer[4096];
        for (UInt32 iBuffer = 0; iBuffer < pRenderedBufferList->mNumberBuffers; iBuffer += pDevice->capture.internalChannels) {
            mal_uint32 framesRemaining = frameCount;
            while (framesRemaining > 0) {
                mal_uint32 framesToSend = sizeof(tempBuffer) / mal_get_bytes_per_sample(pDevice->capture.internalFormat);
                if (framesToSend > framesRemaining) {
                    framesToSend = framesRemaining;
                }
                
                void* ppDeinterleavedBuffers[MAL_MAX_CHANNELS];
                for (mal_uint32 iChannel = 0; iChannel < pDevice->capture.internalChannels; ++iChannel) {
                    ppDeinterleavedBuffers[iChannel] = (void*)mal_offset_ptr(pRenderedBufferList->mBuffers[iBuffer].mData, (frameCount - framesRemaining) * mal_get_bytes_per_sample(pDevice->capture.internalFormat));
                }
                
                mal_interleave_pcm_frames(pDevice->capture.internalFormat, pDevice->capture.internalChannels, framesToSend, (const void**)ppDeinterleavedBuffers, tempBuffer);

                if (pDevice->type == mal_device_type_duplex) {
                    mal_device__handle_duplex_callback_capture(pDevice, framesToSend, tempBuffer, &pDevice->coreaudio.duplexRB);
                } else {
                    mal_device__send_frames_to_client(pDevice, framesToSend, tempBuffer);
                }

                framesRemaining -= framesToSend;
            }
        }
    }

    return noErr;
}

void on_start_stop__coreaudio(void* pUserData, AudioUnit audioUnit, AudioUnitPropertyID propertyID, AudioUnitScope scope, AudioUnitElement element)
{
    (void)propertyID;
    
    mal_device* pDevice = (mal_device*)pUserData;
    mal_assert(pDevice != NULL);
    
    // There's been a report of a deadlock here when triggered by mal_device_uninit(). It looks like
    // AudioUnitGetProprty (called below) and AudioComponentInstanceDispose (called in mal_device_uninit)
    // can try waiting on the same lock. I'm going to try working around this by not calling any Core
    // Audio APIs in the callback when the device has been stopped or uninitialized.
    if (mal_device__get_state(pDevice) == MAL_STATE_UNINITIALIZED || mal_device__get_state(pDevice) == MAL_STATE_STOPPING || mal_device__get_state(pDevice) == MAL_STATE_STOPPED) {
        mal_stop_proc onStop = pDevice->onStop;
        if (onStop) {
            onStop(pDevice);
        }
        
        mal_event_signal(&pDevice->coreaudio.stopEvent);
    } else {
        UInt32 isRunning;
        UInt32 isRunningSize = sizeof(isRunning);
        OSStatus status = ((mal_AudioUnitGetProperty_proc)pDevice->pContext->coreaudio.AudioUnitGetProperty)(audioUnit, kAudioOutputUnitProperty_IsRunning, scope, element, &isRunning, &isRunningSize);
        if (status != noErr) {
            return; // Don't really know what to do in this case... just ignore it, I suppose...
        }
        
        if (!isRunning) {
            // The stop event is a bit annoying in Core Audio because it will be called when we automatically switch the default device. Some scenarios to consider:
            //
            // 1) When the device is unplugged, this will be called _before_ the default device change notification.
            // 2) When the device is changed via the default device change notification, this will be called _after_ the switch.
            //
            // For case #1, we just check if there's a new default device available. If so, we just ignore the stop event. For case #2 we check a flag.
            if (((audioUnit == pDevice->coreaudio.audioUnitPlayback) && pDevice->coreaudio.isDefaultPlaybackDevice) ||
                ((audioUnit == pDevice->coreaudio.audioUnitCapture)  && pDevice->coreaudio.isDefaultCaptureDevice)) {
                // It looks like the device is switching through an external event, such as the user unplugging the device or changing the default device
                // via the operating system's sound settings. If we're re-initializing the device, we just terminate because we want the stopping of the
                // device to be seamless to the client (we don't want them receiving the onStop event and thinking that the device has stopped when it
                // hasn't!).
                if (((audioUnit == pDevice->coreaudio.audioUnitPlayback) && pDevice->coreaudio.isSwitchingPlaybackDevice) ||
                    ((audioUnit == pDevice->coreaudio.audioUnitCapture)  && pDevice->coreaudio.isSwitchingCaptureDevice)) {
                    return;
                }
                
                // Getting here means the device is not reinitializing which means it may have been unplugged. From what I can see, it looks like Core Audio
                // will try switching to the new default device seamlessly. We need to somehow find a way to determine whether or not Core Audio will most
                // likely be successful in switching to the new device.
                //
                // TODO: Try to predict if Core Audio will switch devices. If not, the onStop callback needs to be posted.
                return;
            }
            
            // Getting here means we need to stop the device.
            mal_stop_proc onStop = pDevice->onStop;
            if (onStop) {
                onStop(pDevice);
            }
        }
    }
}

#if defined(MAL_APPLE_DESKTOP)
OSStatus mal_default_device_changed__coreaudio(AudioObjectID objectID, UInt32 addressCount, const AudioObjectPropertyAddress* pAddresses, void* pUserData)
{
    (void)objectID;

    mal_device* pDevice = (mal_device*)pUserData;
    mal_assert(pDevice != NULL);
    
    // Not sure if I really need to check this, but it makes me feel better.
    if (addressCount == 0) {
        return noErr;
    }
    
    if (pAddresses[0].mSelector == kAudioHardwarePropertyDefaultOutputDevice) {
        pDevice->coreaudio.isSwitchingPlaybackDevice = MAL_TRUE;
        mal_result reinitResult = mal_device_reinit_internal__coreaudio(pDevice, mal_device_type_playback, MAL_TRUE);
        pDevice->coreaudio.isSwitchingPlaybackDevice = MAL_FALSE;
        
        if (reinitResult == MAL_SUCCESS) {
            mal_device__post_init_setup(pDevice, mal_device_type_playback);
            
            // Restart the device if required. If this fails we need to stop the device entirely.
            if (mal_device__get_state(pDevice) == MAL_STATE_STARTED) {
                OSStatus status = ((mal_AudioOutputUnitStart_proc)pDevice->pContext->coreaudio.AudioOutputUnitStart)((AudioUnit)pDevice->coreaudio.audioUnitPlayback);
                if (status != noErr) {
                    if (pDevice->type == mal_device_type_duplex) {
                        ((mal_AudioOutputUnitStop_proc)pDevice->pContext->coreaudio.AudioOutputUnitStop)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
                    }
                    mal_device__set_state(pDevice, MAL_STATE_STOPPED);
                }
            }
        }
    }
    
    if (pAddresses[0].mSelector == kAudioHardwarePropertyDefaultInputDevice) {
        pDevice->coreaudio.isSwitchingPlaybackDevice = MAL_TRUE;
        mal_result reinitResult = mal_device_reinit_internal__coreaudio(pDevice, mal_device_type_capture, MAL_TRUE);
        pDevice->coreaudio.isSwitchingPlaybackDevice = MAL_FALSE;
        
        if (reinitResult == MAL_SUCCESS) {
            mal_device__post_init_setup(pDevice, mal_device_type_capture);
            
            // Restart the device if required. If this fails we need to stop the device entirely.
            if (mal_device__get_state(pDevice) == MAL_STATE_STARTED) {
                OSStatus status = ((mal_AudioOutputUnitStart_proc)pDevice->pContext->coreaudio.AudioOutputUnitStart)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
                if (status != noErr) {
                    if (pDevice->type == mal_device_type_duplex) {
                        ((mal_AudioOutputUnitStop_proc)pDevice->pContext->coreaudio.AudioOutputUnitStop)((AudioUnit)pDevice->coreaudio.audioUnitPlayback);
                    }
                    mal_device__set_state(pDevice, MAL_STATE_STOPPED);
                }
            }
        }
    }
    
    return noErr;
}
#endif

typedef struct
{
    // Input.
    mal_format formatIn;
    mal_uint32 channelsIn;
    mal_uint32 sampleRateIn;
    mal_channel channelMapIn[MAL_MAX_CHANNELS];
    mal_uint32 bufferSizeInFramesIn;
    mal_uint32 bufferSizeInMillisecondsIn;
    mal_uint32 periodsIn;
    mal_bool32 usingDefaultFormat;
    mal_bool32 usingDefaultChannels;
    mal_bool32 usingDefaultSampleRate;
    mal_bool32 usingDefaultChannelMap;
    mal_share_mode shareMode;
    mal_bool32 registerStopEvent;

    // Output.
#if defined(MAL_APPLE_DESKTOP)
    AudioObjectID deviceObjectID;
#endif
    AudioComponent component;
    AudioUnit audioUnit;
    AudioBufferList* pAudioBufferList;  // Only used for input devices.
    mal_format formatOut;
    mal_uint32 channelsOut;
    mal_uint32 sampleRateOut;
    mal_channel channelMapOut[MAL_MAX_CHANNELS];
    mal_uint32 bufferSizeInFramesOut;
    mal_uint32 periodsOut;
    char deviceName[256];
} mal_device_init_internal_data__coreaudio;

mal_result mal_device_init_internal__coreaudio(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_device_init_internal_data__coreaudio* pData, void* pDevice_DoNotReference)   /* <-- pDevice is typed as void* intentionally so as to avoid accidentally referencing it. */
{
    /* This API should only be used for a single device type: playback or capture. No full-duplex mode. */
    if (deviceType == mal_device_type_duplex) {
        return MAL_INVALID_ARGS;
    }

    mal_assert(pContext != NULL);
    mal_assert(deviceType == mal_device_type_playback || deviceType == mal_device_type_capture);

#if defined(MAL_APPLE_DESKTOP)
    pData->deviceObjectID = 0;
#endif
    pData->component = NULL;
    pData->audioUnit = NULL;
    pData->pAudioBufferList = NULL;
    
    mal_result result;
    
#if defined(MAL_APPLE_DESKTOP)
    AudioObjectID deviceObjectID;
    result = mal_find_AudioObjectID(pContext, deviceType, pDeviceID, &deviceObjectID);
    if (result != MAL_SUCCESS) {
        return result;
    }
    
    pData->deviceObjectID = deviceObjectID;
#endif
    
    // Core audio doesn't really use the notion of a period so we can leave this unmodified, but not too over the top.
    pData->periodsOut = pData->periodsIn;
    if (pData->periodsOut < 1) {
        pData->periodsOut = 1;
    }
    if (pData->periodsOut > 16) {
        pData->periodsOut = 16;
    }
    
    
    // Audio unit.
    OSStatus status = ((mal_AudioComponentInstanceNew_proc)pContext->coreaudio.AudioComponentInstanceNew)(pContext->coreaudio.component, (AudioUnit*)&pData->audioUnit);
    if (status != noErr) {
        return mal_result_from_OSStatus(status);
    }
    
    
    // The input/output buses need to be explicitly enabled and disabled. We set the flag based on the output unit first, then we just swap it for input.
    UInt32 enableIOFlag = 1;
    if (deviceType == mal_device_type_capture) {
        enableIOFlag = 0;
    }
    
    status = ((mal_AudioUnitSetProperty_proc)pContext->coreaudio.AudioUnitSetProperty)(pData->audioUnit, kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Output, MAL_COREAUDIO_OUTPUT_BUS, &enableIOFlag, sizeof(enableIOFlag));
    if (status != noErr) {
        ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
        return mal_result_from_OSStatus(status);
    }
    
    enableIOFlag = (enableIOFlag == 0) ? 1 : 0;
    status = ((mal_AudioUnitSetProperty_proc)pContext->coreaudio.AudioUnitSetProperty)(pData->audioUnit, kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Input, MAL_COREAUDIO_INPUT_BUS, &enableIOFlag, sizeof(enableIOFlag));
    if (status != noErr) {
        ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
        return mal_result_from_OSStatus(status);
    }
    
    
    // Set the device to use with this audio unit. This is only used on desktop since we are using defaults on mobile.
#if defined(MAL_APPLE_DESKTOP)
    status = ((mal_AudioUnitSetProperty_proc)pContext->coreaudio.AudioUnitSetProperty)(pData->audioUnit, kAudioOutputUnitProperty_CurrentDevice, kAudioUnitScope_Global, (deviceType == mal_device_type_playback) ? MAL_COREAUDIO_OUTPUT_BUS : MAL_COREAUDIO_INPUT_BUS, &deviceObjectID, sizeof(AudioDeviceID));
    if (status != noErr) {
        ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
        return mal_result_from_OSStatus(result);
    }
#endif
    
    // Format. This is the hardest part of initialization because there's a few variables to take into account.
    //   1) The format must be supported by the device.
    //   2) The format must be supported mini_al.
    //   3) There's a priority that mini_al prefers.
    //
    // Ideally we would like to use a format that's as close to the hardware as possible so we can get as close to a passthrough as possible. The
    // most important property is the sample rate. mini_al can do format conversion for any sample rate and channel count, but cannot do the same
    // for the sample data format. If the sample data format is not supported by mini_al it must be ignored completely.
    //
    // On mobile platforms this is a bit different. We just force the use of whatever the audio unit's current format is set to.
    AudioStreamBasicDescription bestFormat;
    {
        AudioUnitScope   formatScope   = (deviceType == mal_device_type_playback) ? kAudioUnitScope_Input : kAudioUnitScope_Output;
        AudioUnitElement formatElement = (deviceType == mal_device_type_playback) ? MAL_COREAUDIO_OUTPUT_BUS : MAL_COREAUDIO_INPUT_BUS;
    
    #if defined(MAL_APPLE_DESKTOP)
        result = mal_find_best_format__coreaudio(pContext, deviceObjectID, deviceType, pData->formatIn, pData->channelsIn, pData->sampleRateIn, pData->usingDefaultFormat, pData->usingDefaultChannels, pData->usingDefaultSampleRate, &bestFormat);
        if (result != MAL_SUCCESS) {
            ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
            return result;
        }
        
        // From what I can see, Apple's documentation implies that we should keep the sample rate consistent.
        AudioStreamBasicDescription origFormat;
        UInt32 origFormatSize = sizeof(origFormat);
        if (deviceType == mal_device_type_playback) {
            status = ((mal_AudioUnitGetProperty_proc)pContext->coreaudio.AudioUnitGetProperty)(pData->audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, MAL_COREAUDIO_OUTPUT_BUS, &origFormat, &origFormatSize);
        } else {
            status = ((mal_AudioUnitGetProperty_proc)pContext->coreaudio.AudioUnitGetProperty)(pData->audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, MAL_COREAUDIO_INPUT_BUS, &origFormat, &origFormatSize);
        }
        
        if (status != noErr) {
            ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
            return result;
        }
        
        bestFormat.mSampleRate = origFormat.mSampleRate;
        
        status = ((mal_AudioUnitSetProperty_proc)pContext->coreaudio.AudioUnitSetProperty)(pData->audioUnit, kAudioUnitProperty_StreamFormat, formatScope, formatElement, &bestFormat, sizeof(bestFormat));
        if (status != noErr) {
            // We failed to set the format, so fall back to the current format of the audio unit.
            bestFormat = origFormat;
        }
    #else
        UInt32 propSize = sizeof(bestFormat);
        status = ((mal_AudioUnitGetProperty_proc)pContext->coreaudio.AudioUnitGetProperty)(pData->audioUnit, kAudioUnitProperty_StreamFormat, formatScope, formatElement, &bestFormat, &propSize);
        if (status != noErr) {
            ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
            return mal_result_from_OSStatus(status);
        }
        
        // Sample rate is a little different here because for some reason kAudioUnitProperty_StreamFormat returns 0... Oh well. We need to instead try
        // setting the sample rate to what the user has requested and then just see the results of it. Need to use some Objective-C here for this since
        // it depends on Apple's AVAudioSession API. To do this we just get the shared AVAudioSession instance and then set it. Note that from what I
        // can tell, it looks like the sample rate is shared between playback and capture for everything.
        @autoreleasepool {
            AVAudioSession* pAudioSession = [AVAudioSession sharedInstance];
            mal_assert(pAudioSession != NULL);
            
            [pAudioSession setPreferredSampleRate:(double)pData->sampleRateIn error:nil];
            bestFormat.mSampleRate = pAudioSession.sampleRate;
        }
        
        status = ((mal_AudioUnitSetProperty_proc)pContext->coreaudio.AudioUnitSetProperty)(pData->audioUnit, kAudioUnitProperty_StreamFormat, formatScope, formatElement, &bestFormat, sizeof(bestFormat));
        if (status != noErr) {
            ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
            return mal_result_from_OSStatus(status);
        }
    #endif
        
        result = mal_format_from_AudioStreamBasicDescription(&bestFormat, &pData->formatOut);
        if (result != MAL_SUCCESS) {
            ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
            return result;
        }
        
        if (pData->formatOut == mal_format_unknown) {
            ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
            return MAL_FORMAT_NOT_SUPPORTED;
        }
        
        pData->channelsOut = bestFormat.mChannelsPerFrame;
        pData->sampleRateOut = bestFormat.mSampleRate;
    }
    
    
    // Internal channel map. This is weird in my testing. If I use the AudioObject to get the
    // channel map, the channel descriptions are set to "Unknown" for some reason. To work around
    // this it looks like retrieving it from the AudioUnit will work. However, and this is where
    // it gets weird, it doesn't seem to work with capture devices, nor at all on iOS... Therefore
    // I'm going to fall back to a default assumption in these cases.
#if defined(MAL_APPLE_DESKTOP)
    result = mal_get_AudioUnit_channel_map(pContext, pData->audioUnit, deviceType, pData->channelMapOut);
    if (result != MAL_SUCCESS) {
    #if 0
        // Try falling back to the channel map from the AudioObject.
        result = mal_get_AudioObject_channel_map(pContext, deviceObjectID, deviceType, pData->channelMapOut);
        if (result != MAL_SUCCESS) {
            return result;
        }
    #else
        // Fall back to default assumptions.
        mal_get_standard_channel_map(mal_standard_channel_map_default, pData->channelsOut, pData->channelMapOut);
    #endif
    }
#else
    // TODO: Figure out how to get the channel map using AVAudioSession.
    mal_get_standard_channel_map(mal_standard_channel_map_default, pData->channelsOut, pData->channelMapOut);
#endif
    
    
    // Buffer size. Not allowing this to be configurable on iOS.
    mal_uint32 actualBufferSizeInFrames = pData->bufferSizeInFramesIn;
    
#if defined(MAL_APPLE_DESKTOP)
    if (actualBufferSizeInFrames == 0) {
        actualBufferSizeInFrames = mal_calculate_buffer_size_in_frames_from_milliseconds(pData->bufferSizeInMillisecondsIn, pData->sampleRateOut);
    }
    
    actualBufferSizeInFrames = actualBufferSizeInFrames / pData->periodsOut;
    result = mal_set_AudioObject_buffer_size_in_frames(pContext, deviceObjectID, deviceType, &actualBufferSizeInFrames);
    if (result != MAL_SUCCESS) {
        return result;
    }
    
    pData->bufferSizeInFramesOut = actualBufferSizeInFrames * pData->periodsOut;
#else
    actualBufferSizeInFrames = 4096;
    pData->bufferSizeInFramesOut = actualBufferSizeInFrames;
#endif


    
    // During testing I discovered that the buffer size can be too big. You'll get an error like this:
    //
    //   kAudioUnitErr_TooManyFramesToProcess : inFramesToProcess=4096, mMaxFramesPerSlice=512
    //
    // Note how inFramesToProcess is smaller than mMaxFramesPerSlice. To fix, we need to set kAudioUnitProperty_MaximumFramesPerSlice to that
    // of the size of our buffer, or do it the other way around and set our buffer size to the kAudioUnitProperty_MaximumFramesPerSlice.
    {
        /*AudioUnitScope propScope = (deviceType == mal_device_type_playback) ? kAudioUnitScope_Input : kAudioUnitScope_Output;
        AudioUnitElement propBus = (deviceType == mal_device_type_playback) ? MAL_COREAUDIO_OUTPUT_BUS : MAL_COREAUDIO_INPUT_BUS;
    
        status = ((mal_AudioUnitSetProperty_proc)pContext->coreaudio.AudioUnitSetProperty)(pData->audioUnit, kAudioUnitProperty_MaximumFramesPerSlice, propScope, propBus, &actualBufferSizeInFrames, sizeof(actualBufferSizeInFrames));
        if (status != noErr) {
            ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
            return mal_result_from_OSStatus(status);
        }*/
        
        status = ((mal_AudioUnitSetProperty_proc)pContext->coreaudio.AudioUnitSetProperty)(pData->audioUnit, kAudioUnitProperty_MaximumFramesPerSlice, kAudioUnitScope_Global, 0, &actualBufferSizeInFrames, sizeof(actualBufferSizeInFrames));
        if (status != noErr) {
            ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
            return mal_result_from_OSStatus(status);
        }
    }
    
    // We need a buffer list if this is an input device. We render into this in the input callback.
    if (deviceType == mal_device_type_capture) {
        mal_bool32 isInterleaved = (bestFormat.mFormatFlags & kAudioFormatFlagIsNonInterleaved) == 0;
        
        size_t allocationSize = sizeof(AudioBufferList) - sizeof(AudioBuffer);  // Subtract sizeof(AudioBuffer) because that part is dynamically sized.
        if (isInterleaved) {
            // Interleaved case. This is the simple case because we just have one buffer.
            allocationSize += sizeof(AudioBuffer) * 1;
            allocationSize += actualBufferSizeInFrames * mal_get_bytes_per_frame(pData->formatOut, pData->channelsOut);
        } else {
            // Non-interleaved case. This is the more complex case because there's more than one buffer.
            allocationSize += sizeof(AudioBuffer) * pData->channelsOut;
            allocationSize += actualBufferSizeInFrames * mal_get_bytes_per_sample(pData->formatOut) * pData->channelsOut;
        }
        
        AudioBufferList* pBufferList = (AudioBufferList*)mal_malloc(allocationSize);
        if (pBufferList == NULL) {
            ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
            return MAL_OUT_OF_MEMORY;
        }
        
        if (isInterleaved) {
            pBufferList->mNumberBuffers = 1;
            pBufferList->mBuffers[0].mNumberChannels = pData->channelsOut;
            pBufferList->mBuffers[0].mDataByteSize = actualBufferSizeInFrames * mal_get_bytes_per_frame(pData->formatOut, pData->channelsOut);
            pBufferList->mBuffers[0].mData = (mal_uint8*)pBufferList + sizeof(AudioBufferList);
        } else {
            pBufferList->mNumberBuffers = pData->channelsOut;
            for (mal_uint32 iBuffer = 0; iBuffer < pBufferList->mNumberBuffers; ++iBuffer) {
                pBufferList->mBuffers[iBuffer].mNumberChannels = 1;
                pBufferList->mBuffers[iBuffer].mDataByteSize = actualBufferSizeInFrames * mal_get_bytes_per_sample(pData->formatOut);
                pBufferList->mBuffers[iBuffer].mData = (mal_uint8*)pBufferList + ((sizeof(AudioBufferList) - sizeof(AudioBuffer)) + (sizeof(AudioBuffer) * pData->channelsOut)) + (actualBufferSizeInFrames * mal_get_bytes_per_sample(pData->formatOut) * iBuffer);
            }
        }
        
        pData->pAudioBufferList = pBufferList;
    }
    
    // Callbacks.
    AURenderCallbackStruct callbackInfo;
    callbackInfo.inputProcRefCon = pDevice_DoNotReference;
    if (deviceType == mal_device_type_playback) {
        callbackInfo.inputProc = mal_on_output__coreaudio;
        status = ((mal_AudioUnitSetProperty_proc)pContext->coreaudio.AudioUnitSetProperty)(pData->audioUnit, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Global, MAL_COREAUDIO_OUTPUT_BUS, &callbackInfo, sizeof(callbackInfo));
        if (status != noErr) {
            ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
            return mal_result_from_OSStatus(status);
        }
    } else {
        callbackInfo.inputProc = mal_on_input__coreaudio;
        status = ((mal_AudioUnitSetProperty_proc)pContext->coreaudio.AudioUnitSetProperty)(pData->audioUnit, kAudioOutputUnitProperty_SetInputCallback, kAudioUnitScope_Global, MAL_COREAUDIO_INPUT_BUS, &callbackInfo, sizeof(callbackInfo));
        if (status != noErr) {
            ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
            return mal_result_from_OSStatus(status);
        }
    }
    
    // We need to listen for stop events.
    if (pData->registerStopEvent) {
        status = ((mal_AudioUnitAddPropertyListener_proc)pContext->coreaudio.AudioUnitAddPropertyListener)(pData->audioUnit, kAudioOutputUnitProperty_IsRunning, on_start_stop__coreaudio, pDevice_DoNotReference);
        if (status != noErr) {
            ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
            return mal_result_from_OSStatus(status);
        }
    }
    
    // Initialize the audio unit.
    status = ((mal_AudioUnitInitialize_proc)pContext->coreaudio.AudioUnitInitialize)(pData->audioUnit);
    if (status != noErr) {
        mal_free(pData->pAudioBufferList);
        pData->pAudioBufferList = NULL;
        ((mal_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
        return mal_result_from_OSStatus(status);
    }
    
    // Grab the name.
#if defined(MAL_APPLE_DESKTOP)
    mal_get_AudioObject_name(pContext, deviceObjectID, sizeof(pData->deviceName), pData->deviceName);
#else
    if (deviceType == mal_device_type_playback) {
        mal_strcpy_s(pData->deviceName, sizeof(pData->deviceName), MAL_DEFAULT_PLAYBACK_DEVICE_NAME);
    } else {
        mal_strcpy_s(pData->deviceName, sizeof(pData->deviceName), MAL_DEFAULT_CAPTURE_DEVICE_NAME);
    }
#endif
    
    return result;
}

mal_result mal_device_reinit_internal__coreaudio(mal_device* pDevice, mal_device_type deviceType, mal_bool32 disposePreviousAudioUnit)
{
    /* This should only be called for playback or capture, not duplex. */
    if (deviceType == mal_device_type_duplex) {
        return MAL_INVALID_ARGS;
    }

    mal_device_init_internal_data__coreaudio data;
    if (deviceType == mal_device_type_capture) {
        data.formatIn               = pDevice->capture.format;
        data.channelsIn             = pDevice->capture.channels;
        data.sampleRateIn           = pDevice->sampleRate;
        mal_copy_memory(data.channelMapIn, pDevice->capture.channelMap, sizeof(pDevice->capture.channelMap));
        data.usingDefaultFormat     = pDevice->capture.usingDefaultFormat;
        data.usingDefaultChannels   = pDevice->capture.usingDefaultChannels;
        data.usingDefaultSampleRate = pDevice->usingDefaultSampleRate;
        data.usingDefaultChannelMap = pDevice->capture.usingDefaultChannelMap;
        data.shareMode              = pDevice->capture.shareMode;
        data.registerStopEvent      = MAL_TRUE;
        
        if (disposePreviousAudioUnit) {
            ((mal_AudioOutputUnitStop_proc)pDevice->pContext->coreaudio.AudioOutputUnitStop)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
            ((mal_AudioComponentInstanceDispose_proc)pDevice->pContext->coreaudio.AudioComponentInstanceDispose)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
        }
        if (pDevice->coreaudio.pAudioBufferList) {
            mal_free(pDevice->coreaudio.pAudioBufferList);
        }
        
    #if defined(MAL_APPLE_DESKTOP)
        pDevice->coreaudio.deviceObjectIDCapture = (mal_uint32)data.deviceObjectID;
    #endif
        pDevice->coreaudio.audioUnitCapture = (mal_ptr)data.audioUnit;
        pDevice->coreaudio.pAudioBufferList = (mal_ptr)data.pAudioBufferList;
    }
    if (deviceType == mal_device_type_playback) {
        data.formatIn               = pDevice->playback.format;
        data.channelsIn             = pDevice->playback.channels;
        data.sampleRateIn           = pDevice->sampleRate;
        mal_copy_memory(data.channelMapIn, pDevice->playback.channelMap, sizeof(pDevice->playback.channelMap));
        data.usingDefaultFormat     = pDevice->playback.usingDefaultFormat;
        data.usingDefaultChannels   = pDevice->playback.usingDefaultChannels;
        data.usingDefaultSampleRate = pDevice->usingDefaultSampleRate;
        data.usingDefaultChannelMap = pDevice->playback.usingDefaultChannelMap;
        data.shareMode              = pDevice->playback.shareMode;
        data.registerStopEvent      = (pDevice->type != mal_device_type_duplex);
        
        if (disposePreviousAudioUnit) {
            ((mal_AudioOutputUnitStop_proc)pDevice->pContext->coreaudio.AudioOutputUnitStop)((AudioUnit)pDevice->coreaudio.audioUnitPlayback);
            ((mal_AudioComponentInstanceDispose_proc)pDevice->pContext->coreaudio.AudioComponentInstanceDispose)((AudioUnit)pDevice->coreaudio.audioUnitPlayback);
        }
        
    #if defined(MAL_APPLE_DESKTOP)
        pDevice->coreaudio.deviceObjectIDPlayback = (mal_uint32)data.deviceObjectID;
    #endif
        pDevice->coreaudio.audioUnitPlayback = (mal_ptr)data.audioUnit;
    }
    data.bufferSizeInFramesIn       = pDevice->coreaudio.originalBufferSizeInFrames;
    data.bufferSizeInMillisecondsIn = pDevice->coreaudio.originalBufferSizeInMilliseconds;
    data.periodsIn                  = pDevice->coreaudio.originalPeriods;

    mal_result result = mal_device_init_internal__coreaudio(pDevice->pContext, deviceType, NULL, &data, (void*)pDevice);
    if (result != MAL_SUCCESS) {
        return result;
    }
    
    return MAL_SUCCESS;
}


mal_result mal_device_init__coreaudio(mal_context* pContext, const mal_device_config* pConfig, mal_device* pDevice)
{
    (void)pConfig;

    mal_assert(pContext != NULL);
    mal_assert(pConfig != NULL);
    mal_assert(pDevice != NULL);

    /* No exclusive mode with the Core Audio backend for now. */
    if (((pConfig->deviceType == mal_device_type_capture  || pConfig->deviceType == mal_device_type_duplex) && pConfig->capture.shareMode  == mal_share_mode_exclusive) ||
        ((pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) && pConfig->playback.shareMode == mal_share_mode_exclusive)) {
        return MAL_SHARE_MODE_NOT_SUPPORTED;
    }
    
    /* Capture needs to be initialized first. */
    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        mal_device_init_internal_data__coreaudio data;
        data.formatIn                   = pConfig->capture.format;
        data.channelsIn                 = pConfig->capture.channels;
        data.sampleRateIn               = pConfig->sampleRate;
        mal_copy_memory(data.channelMapIn, pConfig->capture.channelMap, sizeof(pConfig->capture.channelMap));
        data.usingDefaultFormat         = pDevice->capture.usingDefaultFormat;
        data.usingDefaultChannels       = pDevice->capture.usingDefaultChannels;
        data.usingDefaultSampleRate     = pDevice->usingDefaultSampleRate;
        data.usingDefaultChannelMap     = pDevice->capture.usingDefaultChannelMap;
        data.shareMode                  = pConfig->capture.shareMode;
        data.bufferSizeInFramesIn       = pConfig->bufferSizeInFrames;
        data.bufferSizeInMillisecondsIn = pConfig->bufferSizeInMilliseconds;
        data.registerStopEvent          = MAL_TRUE;
        
        mal_result result = mal_device_init_internal__coreaudio(pDevice->pContext, mal_device_type_capture, pConfig->capture.pDeviceID, &data, (void*)pDevice);
        if (result != MAL_SUCCESS) {
            return result;
        }
        
        pDevice->coreaudio.isDefaultCaptureDevice   = (pConfig->capture.pDeviceID == NULL);
    #if defined(MAL_APPLE_DESKTOP)
        pDevice->coreaudio.deviceObjectIDCapture    = (mal_uint32)data.deviceObjectID;
    #endif
        pDevice->coreaudio.audioUnitCapture         = (mal_ptr)data.audioUnit;
        pDevice->coreaudio.pAudioBufferList         = (mal_ptr)data.pAudioBufferList;
        
        pDevice->capture.internalFormat             = data.formatOut;
        pDevice->capture.internalChannels           = data.channelsOut;
        pDevice->capture.internalSampleRate         = data.sampleRateOut;
        mal_copy_memory(pDevice->capture.internalChannelMap, data.channelMapOut, sizeof(data.channelMapOut));
        pDevice->capture.internalBufferSizeInFrames = data.bufferSizeInFramesOut;
        pDevice->capture.internalPeriods            = data.periodsOut;
        
        // TODO: This needs to be made global.
    #if defined(MAL_APPLE_DESKTOP)
        // If we are using the default device we'll need to listen for changes to the system's default device so we can seemlessly
        // switch the device in the background.
        if (pConfig->capture.pDeviceID == NULL) {
            AudioObjectPropertyAddress propAddress;
            propAddress.mSelector = kAudioHardwarePropertyDefaultInputDevice;
            propAddress.mScope    = kAudioObjectPropertyScopeGlobal;
            propAddress.mElement  = kAudioObjectPropertyElementMaster;
            ((mal_AudioObjectAddPropertyListener_proc)pDevice->pContext->coreaudio.AudioObjectAddPropertyListener)(kAudioObjectSystemObject, &propAddress, &mal_default_device_changed__coreaudio, pDevice);
        }
    #endif
    }
    
    /* Playback. */
    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        mal_device_init_internal_data__coreaudio data;
        data.formatIn                   = pConfig->playback.format;
        data.channelsIn                 = pConfig->playback.channels;
        data.sampleRateIn               = pConfig->sampleRate;
        mal_copy_memory(data.channelMapIn, pConfig->playback.channelMap, sizeof(pConfig->playback.channelMap));
        data.usingDefaultFormat         = pDevice->playback.usingDefaultFormat;
        data.usingDefaultChannels       = pDevice->playback.usingDefaultChannels;
        data.usingDefaultSampleRate     = pDevice->usingDefaultSampleRate;
        data.usingDefaultChannelMap     = pDevice->playback.usingDefaultChannelMap;
        data.shareMode                  = pConfig->playback.shareMode;
        
        /* In full-duplex mode we want the playback buffer to be the same size as the capture buffer. */
        if (pConfig->deviceType == mal_device_type_duplex) {
            data.bufferSizeInFramesIn       = pDevice->capture.internalBufferSizeInFrames;
            data.periodsIn                  = pDevice->capture.internalPeriods;
            data.registerStopEvent          = MAL_FALSE;
        } else {
            data.bufferSizeInFramesIn       = pConfig->bufferSizeInFrames;
            data.bufferSizeInMillisecondsIn = pConfig->bufferSizeInMilliseconds;
            data.periodsIn                  = pConfig->periods;
            data.registerStopEvent          = MAL_TRUE;
        }
        
        mal_result result = mal_device_init_internal__coreaudio(pDevice->pContext, mal_device_type_playback, pConfig->playback.pDeviceID, &data, (void*)pDevice);
        if (result != MAL_SUCCESS) {
            if (pConfig->deviceType == mal_device_type_duplex) {
                ((mal_AudioComponentInstanceDispose_proc)pDevice->pContext->coreaudio.AudioComponentInstanceDispose)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
                if (pDevice->coreaudio.pAudioBufferList) {
                    mal_free(pDevice->coreaudio.pAudioBufferList);
                }
            }
            return result;
        }
        
        pDevice->coreaudio.isDefaultPlaybackDevice   = (pConfig->playback.pDeviceID == NULL);
    #if defined(MAL_APPLE_DESKTOP)
        pDevice->coreaudio.deviceObjectIDPlayback    = (mal_uint32)data.deviceObjectID;
    #endif
        pDevice->coreaudio.audioUnitPlayback         = (mal_ptr)data.audioUnit;
        
        pDevice->playback.internalFormat             = data.formatOut;
        pDevice->playback.internalChannels           = data.channelsOut;
        pDevice->playback.internalSampleRate         = data.sampleRateOut;
        mal_copy_memory(pDevice->playback.internalChannelMap, data.channelMapOut, sizeof(data.channelMapOut));
        pDevice->playback.internalBufferSizeInFrames = data.bufferSizeInFramesOut;
        pDevice->playback.internalPeriods            = data.periodsOut;
        
        // TODO: This needs to be made global.
    #if defined(MAL_APPLE_DESKTOP)
        // If we are using the default device we'll need to listen for changes to the system's default device so we can seemlessly
        // switch the device in the background.
        if (pConfig->playback.pDeviceID == NULL) {
            AudioObjectPropertyAddress propAddress;
            propAddress.mSelector = kAudioHardwarePropertyDefaultOutputDevice;
            propAddress.mScope    = kAudioObjectPropertyScopeGlobal;
            propAddress.mElement  = kAudioObjectPropertyElementMaster;
            ((mal_AudioObjectAddPropertyListener_proc)pDevice->pContext->coreaudio.AudioObjectAddPropertyListener)(kAudioObjectSystemObject, &propAddress, &mal_default_device_changed__coreaudio, pDevice);
        }
    #endif
    }
    
    pDevice->coreaudio.originalBufferSizeInFrames       = pConfig->bufferSizeInFrames;
    pDevice->coreaudio.originalBufferSizeInMilliseconds = pConfig->bufferSizeInMilliseconds;
    pDevice->coreaudio.originalPeriods                  = pConfig->periods;
    
    /*
    When stopping the device, a callback is called on another thread. We need to wait for this callback
    before returning from mal_device_stop(). This event is used for this.
    */
    mal_event_init(pContext, &pDevice->coreaudio.stopEvent);

    /* Need a ring buffer for duplex mode. */
    if (pConfig->deviceType == mal_device_type_duplex) {
        mal_uint32 rbSizeInFrames = (mal_uint32)mal_calculate_frame_count_after_src(pDevice->sampleRate, pDevice->capture.internalSampleRate, pDevice->capture.internalBufferSizeInFrames);
        mal_result result = mal_pcm_rb_init(pDevice->capture.format, pDevice->capture.channels, rbSizeInFrames, NULL, &pDevice->coreaudio.duplexRB);
        if (result != MAL_SUCCESS) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[Core Audio] Failed to initialize ring buffer.", result);
        }
    }

    return MAL_SUCCESS;
}


mal_result mal_device_start__coreaudio(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);
    
    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        OSStatus status = ((mal_AudioOutputUnitStart_proc)pDevice->pContext->coreaudio.AudioOutputUnitStart)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
        if (status != noErr) {
            return mal_result_from_OSStatus(status);
        }
    }
    
    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        OSStatus status = ((mal_AudioOutputUnitStart_proc)pDevice->pContext->coreaudio.AudioOutputUnitStart)((AudioUnit)pDevice->coreaudio.audioUnitPlayback);
        if (status != noErr) {
            if (pDevice->type == mal_device_type_duplex) {
                ((mal_AudioOutputUnitStop_proc)pDevice->pContext->coreaudio.AudioOutputUnitStop)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
            }
            return mal_result_from_OSStatus(status);
        }
    }
    
    return MAL_SUCCESS;
}

mal_result mal_device_stop__coreaudio(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);
    
    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        OSStatus status = ((mal_AudioOutputUnitStop_proc)pDevice->pContext->coreaudio.AudioOutputUnitStop)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
        if (status != noErr) {
            return mal_result_from_OSStatus(status);
        }
    }
    
    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        OSStatus status = ((mal_AudioOutputUnitStop_proc)pDevice->pContext->coreaudio.AudioOutputUnitStop)((AudioUnit)pDevice->coreaudio.audioUnitPlayback);
        if (status != noErr) {
            return mal_result_from_OSStatus(status);
        }
    }
    
    /* We need to wait for the callback to finish before returning. */
    mal_event_wait(&pDevice->coreaudio.stopEvent);
    return MAL_SUCCESS;
}


mal_result mal_context_uninit__coreaudio(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    mal_assert(pContext->backend == mal_backend_coreaudio);
    
#if !defined(MAL_NO_RUNTIME_LINKING) && !defined(MAL_APPLE_MOBILE)
    mal_dlclose(pContext->coreaudio.hAudioUnit);
    mal_dlclose(pContext->coreaudio.hCoreAudio);
    mal_dlclose(pContext->coreaudio.hCoreFoundation);
#endif

    (void)pContext;
    return MAL_SUCCESS;
}

mal_result mal_context_init__coreaudio(mal_context* pContext)
{
    mal_assert(pContext != NULL);

#if defined(MAL_APPLE_MOBILE)
    @autoreleasepool {
        AVAudioSession* pAudioSession = [AVAudioSession sharedInstance];
        mal_assert(pAudioSession != NULL);

        [pAudioSession setCategory: AVAudioSessionCategoryPlayAndRecord error:nil];
        
        // By default we want mini_al to use the speakers instead of the receiver. In the future this may
        // be customizable.
        mal_bool32 useSpeakers = MAL_TRUE;
        if (useSpeakers) {
            [pAudioSession overrideOutputAudioPort:AVAudioSessionPortOverrideSpeaker error:nil];
        }
    }
#endif
    
#if !defined(MAL_NO_RUNTIME_LINKING) && !defined(MAL_APPLE_MOBILE)
    pContext->coreaudio.hCoreFoundation = mal_dlopen("CoreFoundation.framework/CoreFoundation");
    if (pContext->coreaudio.hCoreFoundation == NULL) {
        return MAL_API_NOT_FOUND;
    }
    
    pContext->coreaudio.CFStringGetCString             = mal_dlsym(pContext->coreaudio.hCoreFoundation, "CFStringGetCString");
    
    
    pContext->coreaudio.hCoreAudio = mal_dlopen("CoreAudio.framework/CoreAudio");
    if (pContext->coreaudio.hCoreAudio == NULL) {
        mal_dlclose(pContext->coreaudio.hCoreFoundation);
        return MAL_API_NOT_FOUND;
    }
    
    pContext->coreaudio.AudioObjectGetPropertyData     = mal_dlsym(pContext->coreaudio.hCoreAudio, "AudioObjectGetPropertyData");
    pContext->coreaudio.AudioObjectGetPropertyDataSize = mal_dlsym(pContext->coreaudio.hCoreAudio, "AudioObjectGetPropertyDataSize");
    pContext->coreaudio.AudioObjectSetPropertyData     = mal_dlsym(pContext->coreaudio.hCoreAudio, "AudioObjectSetPropertyData");
    pContext->coreaudio.AudioObjectAddPropertyListener = mal_dlsym(pContext->coreaudio.hCoreAudio, "AudioObjectAddPropertyListener");

    
    // It looks like Apple has moved some APIs from AudioUnit into AudioToolbox on more recent versions of macOS. They are still
    // defined in AudioUnit, but just in case they decide to remove them from there entirely I'm going to implement a fallback.
    // The way it'll work is that it'll first try AudioUnit, and if the required symbols are not present there we'll fall back to
    // AudioToolbox.
    pContext->coreaudio.hAudioUnit = mal_dlopen("AudioUnit.framework/AudioUnit");
    if (pContext->coreaudio.hAudioUnit == NULL) {
        mal_dlclose(pContext->coreaudio.hCoreAudio);
        mal_dlclose(pContext->coreaudio.hCoreFoundation);
        return MAL_API_NOT_FOUND;
    }
    
    if (mal_dlsym(pContext->coreaudio.hAudioUnit, "AudioComponentFindNext") == NULL) {
        // Couldn't find the required symbols in AudioUnit, so fall back to AudioToolbox.
        mal_dlclose(pContext->coreaudio.hAudioUnit);
        pContext->coreaudio.hAudioUnit = mal_dlopen("AudioToolbox.framework/AudioToolbox");
        if (pContext->coreaudio.hAudioUnit == NULL) {
            mal_dlclose(pContext->coreaudio.hCoreAudio);
            mal_dlclose(pContext->coreaudio.hCoreFoundation);
            return MAL_API_NOT_FOUND;
        }
    }
    
    pContext->coreaudio.AudioComponentFindNext         = mal_dlsym(pContext->coreaudio.hAudioUnit, "AudioComponentFindNext");
    pContext->coreaudio.AudioComponentInstanceDispose  = mal_dlsym(pContext->coreaudio.hAudioUnit, "AudioComponentInstanceDispose");
    pContext->coreaudio.AudioComponentInstanceNew      = mal_dlsym(pContext->coreaudio.hAudioUnit, "AudioComponentInstanceNew");
    pContext->coreaudio.AudioOutputUnitStart           = mal_dlsym(pContext->coreaudio.hAudioUnit, "AudioOutputUnitStart");
    pContext->coreaudio.AudioOutputUnitStop            = mal_dlsym(pContext->coreaudio.hAudioUnit, "AudioOutputUnitStop");
    pContext->coreaudio.AudioUnitAddPropertyListener   = mal_dlsym(pContext->coreaudio.hAudioUnit, "AudioUnitAddPropertyListener");
    pContext->coreaudio.AudioUnitGetPropertyInfo       = mal_dlsym(pContext->coreaudio.hAudioUnit, "AudioUnitGetPropertyInfo");
    pContext->coreaudio.AudioUnitGetProperty           = mal_dlsym(pContext->coreaudio.hAudioUnit, "AudioUnitGetProperty");
    pContext->coreaudio.AudioUnitSetProperty           = mal_dlsym(pContext->coreaudio.hAudioUnit, "AudioUnitSetProperty");
    pContext->coreaudio.AudioUnitInitialize            = mal_dlsym(pContext->coreaudio.hAudioUnit, "AudioUnitInitialize");
    pContext->coreaudio.AudioUnitRender                = mal_dlsym(pContext->coreaudio.hAudioUnit, "AudioUnitRender");
#else
    pContext->coreaudio.CFStringGetCString             = (mal_proc)CFStringGetCString;
    
    #if defined(MAL_APPLE_DESKTOP)
    pContext->coreaudio.AudioObjectGetPropertyData     = (mal_proc)AudioObjectGetPropertyData;
    pContext->coreaudio.AudioObjectGetPropertyDataSize = (mal_proc)AudioObjectGetPropertyDataSize;
    pContext->coreaudio.AudioObjectSetPropertyData     = (mal_proc)AudioObjectSetPropertyData;
    pContext->coreaudio.AudioObjectAddPropertyListener = (mal_proc)AudioObjectAddPropertyListener;
    #endif
    
    pContext->coreaudio.AudioComponentFindNext         = (mal_proc)AudioComponentFindNext;
    pContext->coreaudio.AudioComponentInstanceDispose  = (mal_proc)AudioComponentInstanceDispose;
    pContext->coreaudio.AudioComponentInstanceNew      = (mal_proc)AudioComponentInstanceNew;
    pContext->coreaudio.AudioOutputUnitStart           = (mal_proc)AudioOutputUnitStart;
    pContext->coreaudio.AudioOutputUnitStop            = (mal_proc)AudioOutputUnitStop;
    pContext->coreaudio.AudioUnitAddPropertyListener   = (mal_proc)AudioUnitAddPropertyListener;
    pContext->coreaudio.AudioUnitGetPropertyInfo       = (mal_proc)AudioUnitGetPropertyInfo;
    pContext->coreaudio.AudioUnitGetProperty           = (mal_proc)AudioUnitGetProperty;
    pContext->coreaudio.AudioUnitSetProperty           = (mal_proc)AudioUnitSetProperty;
    pContext->coreaudio.AudioUnitInitialize            = (mal_proc)AudioUnitInitialize;
    pContext->coreaudio.AudioUnitRender                = (mal_proc)AudioUnitRender;
#endif

    pContext->isBackendAsynchronous = MAL_TRUE;
    
    pContext->onUninit        = mal_context_uninit__coreaudio;
    pContext->onDeviceIDEqual = mal_context_is_device_id_equal__coreaudio;
    pContext->onEnumDevices   = mal_context_enumerate_devices__coreaudio;
    pContext->onGetDeviceInfo = mal_context_get_device_info__coreaudio;
    pContext->onDeviceInit    = mal_device_init__coreaudio;
    pContext->onDeviceUninit  = mal_device_uninit__coreaudio;
    pContext->onDeviceStart   = mal_device_start__coreaudio;
    pContext->onDeviceStop    = mal_device_stop__coreaudio;
    
    // Audio component.
    AudioComponentDescription desc;
    desc.componentType         = kAudioUnitType_Output;
#if defined(MAL_APPLE_DESKTOP)
    desc.componentSubType      = kAudioUnitSubType_HALOutput;
#else
    desc.componentSubType      = kAudioUnitSubType_RemoteIO;
#endif
    desc.componentManufacturer = kAudioUnitManufacturer_Apple;
    desc.componentFlags        = 0;
    desc.componentFlagsMask    = 0;
    
    pContext->coreaudio.component = ((mal_AudioComponentFindNext_proc)pContext->coreaudio.AudioComponentFindNext)(NULL, &desc);
    if (pContext->coreaudio.component == NULL) {
#if !defined(MAL_NO_RUNTIME_LINKING) && !defined(MAL_APPLE_MOBILE)
        mal_dlclose(pContext->coreaudio.hAudioUnit);
        mal_dlclose(pContext->coreaudio.hCoreAudio);
        mal_dlclose(pContext->coreaudio.hCoreFoundation);
#endif
        return MAL_FAILED_TO_INIT_BACKEND;
    }

    return MAL_SUCCESS;
}
#endif  // Core Audio



///////////////////////////////////////////////////////////////////////////////
//
// sndio Backend
//
///////////////////////////////////////////////////////////////////////////////
#ifdef MAL_HAS_SNDIO
#include <fcntl.h>
#include <sys/stat.h>

// Only supporting OpenBSD. This did not work very well at all on FreeBSD when I tried it. Not sure if this is due
// to mini_al's implementation or if it's some kind of system configuration issue, but basically the default device
// just doesn't emit any sound, or at times you'll hear tiny pieces. I will consider enabling this when there's
// demand for it or if I can get it tested and debugged more thoroughly.

//#if defined(__NetBSD__) || defined(__OpenBSD__)
//#include <sys/audioio.h>
//#endif
//#if defined(__FreeBSD__) || defined(__DragonFly__)
//#include <sys/soundcard.h>
//#endif

#define MAL_SIO_DEVANY	"default"
#define MAL_SIO_PLAY	1
#define MAL_SIO_REC		2
#define MAL_SIO_NENC	8
#define MAL_SIO_NCHAN	8
#define MAL_SIO_NRATE	16
#define MAL_SIO_NCONF	4

struct mal_sio_hdl; // <-- Opaque

struct mal_sio_par
{
    unsigned int bits;
    unsigned int bps;
    unsigned int sig;
    unsigned int le;
    unsigned int msb;
    unsigned int rchan;
    unsigned int pchan;
    unsigned int rate;
    unsigned int bufsz;
    unsigned int xrun;
    unsigned int round;
    unsigned int appbufsz;
    int __pad[3];
    unsigned int __magic;
};

struct mal_sio_enc
{
    unsigned int bits;
    unsigned int bps;
    unsigned int sig;
    unsigned int le;
    unsigned int msb;
};

struct mal_sio_conf
{
    unsigned int enc;
    unsigned int rchan;
    unsigned int pchan;
    unsigned int rate;
};

struct mal_sio_cap
{
    struct mal_sio_enc enc[MAL_SIO_NENC];
	unsigned int rchan[MAL_SIO_NCHAN];
	unsigned int pchan[MAL_SIO_NCHAN];
	unsigned int rate[MAL_SIO_NRATE];
	int __pad[7];
	unsigned int nconf;
	struct mal_sio_conf confs[MAL_SIO_NCONF];
};

typedef struct mal_sio_hdl* (* mal_sio_open_proc)   (const char*, unsigned int, int);
typedef void                (* mal_sio_close_proc)  (struct mal_sio_hdl*);
typedef int                 (* mal_sio_setpar_proc) (struct mal_sio_hdl*, struct mal_sio_par*);
typedef int                 (* mal_sio_getpar_proc) (struct mal_sio_hdl*, struct mal_sio_par*);
typedef int                 (* mal_sio_getcap_proc) (struct mal_sio_hdl*, struct mal_sio_cap*);
typedef size_t              (* mal_sio_write_proc)  (struct mal_sio_hdl*, const void*, size_t);
typedef size_t              (* mal_sio_read_proc)   (struct mal_sio_hdl*, void*, size_t);
typedef int                 (* mal_sio_start_proc)  (struct mal_sio_hdl*);
typedef int                 (* mal_sio_stop_proc)   (struct mal_sio_hdl*);
typedef int                 (* mal_sio_initpar_proc)(struct mal_sio_par*);

mal_format mal_format_from_sio_enc__sndio(unsigned int bits, unsigned int bps, unsigned int sig, unsigned int le, unsigned int msb)
{
    // We only support native-endian right now.
    if ((mal_is_little_endian() && le == 0) || (mal_is_big_endian() && le == 1)) {
        return mal_format_unknown;
    }
    
    if (bits ==  8 && bps == 1 && sig == 0) {
        return mal_format_u8;
    }
    if (bits == 16 && bps == 2 && sig == 1) {
        return mal_format_s16;
    }
    if (bits == 24 && bps == 3 && sig == 1) {
        return mal_format_s24;
    }
    if (bits == 24 && bps == 4 && sig == 1 && msb == 0) {
        //return mal_format_s24_32;
    }
    if (bits == 32 && bps == 4 && sig == 1) {
        return mal_format_s32;
    }
    
    return mal_format_unknown;
}

mal_format mal_find_best_format_from_sio_cap__sndio(struct mal_sio_cap* caps)
{
    mal_assert(caps != NULL);
    
    mal_format bestFormat = mal_format_unknown;
    for (unsigned int iConfig = 0; iConfig < caps->nconf; iConfig += 1) {
        for (unsigned int iEncoding = 0; iEncoding < MAL_SIO_NENC; iEncoding += 1) {
            if ((caps->confs[iConfig].enc & (1UL << iEncoding)) == 0) {
                continue;
            }
            
            unsigned int bits = caps->enc[iEncoding].bits;
            unsigned int bps  = caps->enc[iEncoding].bps;
            unsigned int sig  = caps->enc[iEncoding].sig;
            unsigned int le   = caps->enc[iEncoding].le;
            unsigned int msb  = caps->enc[iEncoding].msb;
            mal_format format = mal_format_from_sio_enc__sndio(bits, bps, sig, le, msb);
            if (format == mal_format_unknown) {
                continue;   // Format not supported.
            }
            
            if (bestFormat == mal_format_unknown) {
                bestFormat = format;
            } else {
                if (mal_get_format_priority_index(bestFormat) > mal_get_format_priority_index(format)) {    // <-- Lower = better.
                    bestFormat = format;
                }
            }
        }
    }
    
    return mal_format_unknown;
}

mal_uint32 mal_find_best_channels_from_sio_cap__sndio(struct mal_sio_cap* caps, mal_device_type deviceType, mal_format requiredFormat)
{
    mal_assert(caps != NULL);
    mal_assert(requiredFormat != mal_format_unknown);
    
    // Just pick whatever configuration has the most channels.
    mal_uint32 maxChannels = 0;
    for (unsigned int iConfig = 0; iConfig < caps->nconf; iConfig += 1) {
        // The encoding should be of requiredFormat.
        for (unsigned int iEncoding = 0; iEncoding < MAL_SIO_NENC; iEncoding += 1) {
            if ((caps->confs[iConfig].enc & (1UL << iEncoding)) == 0) {
                continue;
            }
            
            unsigned int bits = caps->enc[iEncoding].bits;
            unsigned int bps  = caps->enc[iEncoding].bps;
            unsigned int sig  = caps->enc[iEncoding].sig;
            unsigned int le   = caps->enc[iEncoding].le;
            unsigned int msb  = caps->enc[iEncoding].msb;
            mal_format format = mal_format_from_sio_enc__sndio(bits, bps, sig, le, msb);
            if (format != requiredFormat) {
                continue;
            }
            
            // Getting here means the format is supported. Iterate over each channel count and grab the biggest one.
            for (unsigned int iChannel = 0; iChannel < MAL_SIO_NCHAN; iChannel += 1) {
                unsigned int chan = 0;
                if (deviceType == mal_device_type_playback) {
                    chan = caps->confs[iConfig].pchan;
                } else {
                    chan = caps->confs[iConfig].rchan;
                }
            
                if ((chan & (1UL << iChannel)) == 0) {
                    continue;
                }
                
                unsigned int channels;
                if (deviceType == mal_device_type_playback) {
                    channels = caps->pchan[iChannel];
                } else {
                    channels = caps->rchan[iChannel];
                }
                
                if (maxChannels < channels) {
                    maxChannels = channels;
                }
            }
        }
    }
    
    return maxChannels;
}

mal_uint32 mal_find_best_sample_rate_from_sio_cap__sndio(struct mal_sio_cap* caps, mal_device_type deviceType, mal_format requiredFormat, mal_uint32 requiredChannels)
{
    mal_assert(caps != NULL);
    mal_assert(requiredFormat != mal_format_unknown);
    mal_assert(requiredChannels > 0);
    mal_assert(requiredChannels <= MAL_MAX_CHANNELS);
    
    mal_uint32 firstSampleRate = 0; // <-- If the device does not support a standard rate we'll fall back to the first one that's found.
    
    mal_uint32 bestSampleRate = 0;    
    for (unsigned int iConfig = 0; iConfig < caps->nconf; iConfig += 1) {
        // The encoding should be of requiredFormat.
        for (unsigned int iEncoding = 0; iEncoding < MAL_SIO_NENC; iEncoding += 1) {
            if ((caps->confs[iConfig].enc & (1UL << iEncoding)) == 0) {
                continue;
            }
            
            unsigned int bits = caps->enc[iEncoding].bits;
            unsigned int bps  = caps->enc[iEncoding].bps;
            unsigned int sig  = caps->enc[iEncoding].sig;
            unsigned int le   = caps->enc[iEncoding].le;
            unsigned int msb  = caps->enc[iEncoding].msb;
            mal_format format = mal_format_from_sio_enc__sndio(bits, bps, sig, le, msb);
            if (format != requiredFormat) {
                continue;
            }
            
            // Getting here means the format is supported. Iterate over each channel count and grab the biggest one.
            for (unsigned int iChannel = 0; iChannel < MAL_SIO_NCHAN; iChannel += 1) {
                unsigned int chan = 0;
                if (deviceType == mal_device_type_playback) {
                    chan = caps->confs[iConfig].pchan;
                } else {
                    chan = caps->confs[iConfig].rchan;
                }
            
                if ((chan & (1UL << iChannel)) == 0) {
                    continue;
                }
                
                unsigned int channels;
                if (deviceType == mal_device_type_playback) {
                    channels = caps->pchan[iChannel];
                } else {
                    channels = caps->rchan[iChannel];
                }
                
                if (channels != requiredChannels) {
                    continue;
                }
                
                // Getting here means we have found a compatible encoding/channel pair.
                for (unsigned int iRate = 0; iRate < MAL_SIO_NRATE; iRate += 1) {
                    mal_uint32 rate = (mal_uint32)caps->rate[iRate];
                
                    if (firstSampleRate == 0) {
                        firstSampleRate = rate;
                    }
                    
                    // Disregard this rate if it's not a standard one.
                    mal_uint32 ratePriority = mal_get_standard_sample_rate_priority_index(rate);
                    if (ratePriority == (mal_uint32)-1) {
                        continue;
                    }
                    
                    if (mal_get_standard_sample_rate_priority_index(bestSampleRate) > ratePriority) {   // Lower = better.
                        bestSampleRate = rate;
                    }
                }
            }
        }
    }
    
    // If a standard sample rate was not found just fall back to the first one that was iterated.
    if (bestSampleRate == 0) {
        bestSampleRate = firstSampleRate;
    }
    
    return bestSampleRate;
}


mal_bool32 mal_context_is_device_id_equal__sndio(mal_context* pContext, const mal_device_id* pID0, const mal_device_id* pID1)
{
    mal_assert(pContext != NULL);
    mal_assert(pID0 != NULL);
    mal_assert(pID1 != NULL);
    (void)pContext;

    return mal_strcmp(pID0->sndio, pID1->sndio) == 0;
}

mal_result mal_context_enumerate_devices__sndio(mal_context* pContext, mal_enum_devices_callback_proc callback, void* pUserData)
{
    mal_assert(pContext != NULL);
    mal_assert(callback != NULL);
    
    // sndio doesn't seem to have a good device enumeration API, so I'm therefore only enumerating
    // over default devices for now.
    mal_bool32 isTerminating = MAL_FALSE;
    struct mal_sio_hdl* handle;
    
    // Playback.
    if (!isTerminating) {
        handle = ((mal_sio_open_proc)pContext->sndio.sio_open)(MAL_SIO_DEVANY, MAL_SIO_PLAY, 0);
        if (handle != NULL) {
            // Supports playback.
            mal_device_info deviceInfo;
            mal_zero_object(&deviceInfo);
            mal_strcpy_s(deviceInfo.id.sndio, sizeof(deviceInfo.id.sndio), MAL_SIO_DEVANY);
            mal_strcpy_s(deviceInfo.name, sizeof(deviceInfo.name), MAL_DEFAULT_PLAYBACK_DEVICE_NAME);
            
            isTerminating = !callback(pContext, mal_device_type_playback, &deviceInfo, pUserData);
            
            ((mal_sio_close_proc)pContext->sndio.sio_close)(handle);
        }
    }
    
    // Capture.
    if (!isTerminating) {
        handle = ((mal_sio_open_proc)pContext->sndio.sio_open)(MAL_SIO_DEVANY, MAL_SIO_REC, 0);
        if (handle != NULL) {
            // Supports capture.
            mal_device_info deviceInfo;
            mal_zero_object(&deviceInfo);
            mal_strcpy_s(deviceInfo.id.sndio, sizeof(deviceInfo.id.sndio), "default");
            mal_strcpy_s(deviceInfo.name, sizeof(deviceInfo.name), MAL_DEFAULT_CAPTURE_DEVICE_NAME);

            isTerminating = !callback(pContext, mal_device_type_capture, &deviceInfo, pUserData);
            
            ((mal_sio_close_proc)pContext->sndio.sio_close)(handle);
        }
    }
    
    return MAL_SUCCESS;
}

mal_result mal_context_get_device_info__sndio(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, mal_device_info* pDeviceInfo)
{
    mal_assert(pContext != NULL);
    (void)shareMode;
    
    // We need to open the device before we can get information about it.
    char devid[256];
    if (pDeviceID == NULL) {
        mal_strcpy_s(devid, sizeof(devid), MAL_SIO_DEVANY);
        mal_strcpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), (deviceType == mal_device_type_playback) ? MAL_DEFAULT_PLAYBACK_DEVICE_NAME : MAL_DEFAULT_CAPTURE_DEVICE_NAME);
    } else {
        mal_strcpy_s(devid, sizeof(devid), pDeviceID->sndio);
        mal_strcpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), devid);
    }
    
    struct mal_sio_hdl* handle = ((mal_sio_open_proc)pContext->sndio.sio_open)(devid, (deviceType == mal_device_type_playback) ? MAL_SIO_PLAY : MAL_SIO_REC, 0);
    if (handle == NULL) {
        return MAL_NO_DEVICE;
    }
    
    struct mal_sio_cap caps;
    if (((mal_sio_getcap_proc)pContext->sndio.sio_getcap)(handle, &caps) == 0) {
        return MAL_ERROR;
    }
    
    for (unsigned int iConfig = 0; iConfig < caps.nconf; iConfig += 1) {
        // The main thing we care about is that the encoding is supported by mini_al. If it is, we want to give
        // preference to some formats over others.
        for (unsigned int iEncoding = 0; iEncoding < MAL_SIO_NENC; iEncoding += 1) {
            if ((caps.confs[iConfig].enc & (1UL << iEncoding)) == 0) {
                continue;
            }
            
            unsigned int bits = caps.enc[iEncoding].bits;
            unsigned int bps  = caps.enc[iEncoding].bps;
            unsigned int sig  = caps.enc[iEncoding].sig;
            unsigned int le   = caps.enc[iEncoding].le;
            unsigned int msb  = caps.enc[iEncoding].msb;
            mal_format format = mal_format_from_sio_enc__sndio(bits, bps, sig, le, msb);
            if (format == mal_format_unknown) {
                continue;   // Format not supported.
            }
            
            // Add this format if it doesn't already exist.
            mal_bool32 formatExists = MAL_FALSE;
            for (mal_uint32 iExistingFormat = 0; iExistingFormat < pDeviceInfo->formatCount; iExistingFormat += 1) {
                if (pDeviceInfo->formats[iExistingFormat] == format) {
                    formatExists = MAL_TRUE;
                    break;
                }
            }
            
            if (!formatExists) {
                pDeviceInfo->formats[pDeviceInfo->formatCount++] = format;
            }
        }
        
        // Channels.
        for (unsigned int iChannel = 0; iChannel < MAL_SIO_NCHAN; iChannel += 1) {
            unsigned int chan = 0;
            if (deviceType == mal_device_type_playback) {
                chan = caps.confs[iConfig].pchan;
            } else {
                chan = caps.confs[iConfig].rchan;
            }
        
            if ((chan & (1UL << iChannel)) == 0) {
                continue;
            }
            
            unsigned int channels;
            if (deviceType == mal_device_type_playback) {
                channels = caps.pchan[iChannel];
            } else {
                channels = caps.rchan[iChannel];
            }
            
            if (pDeviceInfo->minChannels > channels) {
                pDeviceInfo->minChannels = channels;
            }
            if (pDeviceInfo->maxChannels < channels) {
                pDeviceInfo->maxChannels = channels;
            }
        }
        
        // Sample rates.
        for (unsigned int iRate = 0; iRate < MAL_SIO_NRATE; iRate += 1) {
            if ((caps.confs[iConfig].rate & (1UL << iRate)) != 0) {
                unsigned int rate = caps.rate[iRate];
                if (pDeviceInfo->minSampleRate > rate) {
                    pDeviceInfo->minSampleRate = rate;
                }
                if (pDeviceInfo->maxSampleRate < rate) {
                    pDeviceInfo->maxSampleRate = rate;
                }
            }
        }
    }

    ((mal_sio_close_proc)pContext->sndio.sio_close)(handle);
    return MAL_SUCCESS;
}

void mal_device_uninit__sndio(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        ((mal_sio_close_proc)pDevice->pContext->sndio.sio_close)((struct mal_sio_hdl*)pDevice->sndio.handleCapture);
    }

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        ((mal_sio_close_proc)pDevice->pContext->sndio.sio_close)((struct mal_sio_hdl*)pDevice->sndio.handlePlayback);
    }
}

mal_result mal_device_init_handle__sndio(mal_context* pContext, const mal_device_config* pConfig, mal_device_type deviceType, mal_device* pDevice)
{
    mal_result result;
    const char* pDeviceName;
    mal_ptr handle;
    int openFlags = 0;
    struct mal_sio_cap caps;
    struct mal_sio_par par;
    mal_device_id* pDeviceID;
    mal_format format;
    mal_uint32 channels;
    mal_uint32 sampleRate;
    mal_format internalFormat;
    mal_uint32 internalChannels;
    mal_uint32 internalSampleRate;
    mal_uint32 internalBufferSizeInFrames;
    mal_uint32 internalPeriods;

    mal_assert(pContext   != NULL);
    mal_assert(pConfig    != NULL);
    mal_assert(deviceType != mal_device_type_duplex);
    mal_assert(pDevice    != NULL);

    if (deviceType == mal_device_type_capture) {
        openFlags  = MAL_SIO_REC;
        pDeviceID  = pConfig->capture.pDeviceID;
        format     = pConfig->capture.format;
        channels   = pConfig->capture.channels;
        sampleRate = pConfig->sampleRate;
    } else {
        openFlags = MAL_SIO_PLAY;
        pDeviceID  = pConfig->playback.pDeviceID;
        format     = pConfig->playback.format;
        channels   = pConfig->playback.channels;
        sampleRate = pConfig->sampleRate;
    }

    pDeviceName = MAL_SIO_DEVANY;
    if (pDeviceID != NULL) {
        pDeviceName = pDeviceID->sndio;
    }

    handle = (mal_ptr)((mal_sio_open_proc)pContext->sndio.sio_open)(pDeviceName, openFlags, 0);
    if (handle == NULL) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[sndio] Failed to open device.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
    }

    /* We need to retrieve the device caps to determine the most appropriate format to use. */
    if (((mal_sio_getcap_proc)pContext->sndio.sio_getcap)((struct mal_sio_hdl*)handle, &caps) == 0) {
        ((mal_sio_close_proc)pContext->sndio.sio_close)((struct mal_sio_hdl*)handle);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[sndio] Failed to retrieve device caps.", MAL_ERROR);
    }

    /*
    Note: sndio reports a huge range of available channels. This is inconvenient for us because there's no real
    way, as far as I can tell, to get the _actual_ channel count of the device. I'm therefore restricting this
    to the requested channels, regardless of whether or not the default channel count is requested.
    
    For hardware devices, I'm suspecting only a single channel count will be reported and we can safely use the
    value returned by mal_find_best_channels_from_sio_cap__sndio().
    */
    if (deviceType == mal_device_type_capture) {
        if (pDevice->capture.usingDefaultFormat) {
            format = mal_find_best_format_from_sio_cap__sndio(&caps);
        }
        if (pDevice->capture.usingDefaultChannels) {
            if (strlen(pDeviceName) > strlen("rsnd/") && strncmp(pDeviceName, "rsnd/", strlen("rsnd/")) == 0) {
                channels = mal_find_best_channels_from_sio_cap__sndio(&caps, deviceType, format);
            }
        }
    } else {
        if (pDevice->playback.usingDefaultFormat) {
            format = mal_find_best_format_from_sio_cap__sndio(&caps);
        }
        if (pDevice->playback.usingDefaultChannels) {
            if (strlen(pDeviceName) > strlen("rsnd/") && strncmp(pDeviceName, "rsnd/", strlen("rsnd/")) == 0) {
                channels = mal_find_best_channels_from_sio_cap__sndio(&caps, deviceType, format);
            }
        }
    }
    
    if (pDevice->usingDefaultSampleRate) {
        sampleRate = mal_find_best_sample_rate_from_sio_cap__sndio(&caps, pConfig->deviceType, format, channels);
    }


    ((mal_sio_initpar_proc)pDevice->pContext->sndio.sio_initpar)(&par);
    par.msb = 0;
    par.le  = mal_is_little_endian();
    
    switch (format) {
        case mal_format_u8:
        {
            par.bits = 8;
            par.bps  = 1;
            par.sig  = 0;
        } break;
        
        case mal_format_s24:
        {
            par.bits = 24;
            par.bps  = 3;
            par.sig  = 1;
        } break;
        
        case mal_format_s32:
        {
            par.bits = 32;
            par.bps  = 4;
            par.sig  = 1;
        } break;
        
        case mal_format_s16:
        case mal_format_f32:
        default:
        {
            par.bits = 16;
            par.bps  = 2;
            par.sig  = 1;
        } break;
    }
    
    if (deviceType == mal_device_type_capture) {
        par.rchan = channels;
    } else {
        par.pchan = channels;
    }

    par.rate = sampleRate;

    internalBufferSizeInFrames = pConfig->bufferSizeInFrames;
    if (internalBufferSizeInFrames == 0) {
        internalBufferSizeInFrames = mal_calculate_buffer_size_in_frames_from_milliseconds(pConfig->bufferSizeInMilliseconds, par.rate);
    }

    par.round    = internalBufferSizeInFrames / pConfig->periods;
    par.appbufsz = par.round * pConfig->periods;
    
    if (((mal_sio_setpar_proc)pContext->sndio.sio_setpar)((struct mal_sio_hdl*)handle, &par) == 0) {
        ((mal_sio_close_proc)pContext->sndio.sio_close)((struct mal_sio_hdl*)handle);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[sndio] Failed to set buffer size.", MAL_FORMAT_NOT_SUPPORTED);
    }
    if (((mal_sio_getpar_proc)pContext->sndio.sio_getpar)((struct mal_sio_hdl*)handle, &par) == 0) {
        ((mal_sio_close_proc)pContext->sndio.sio_close)((struct mal_sio_hdl*)handle);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[sndio] Failed to retrieve buffer size.", MAL_FORMAT_NOT_SUPPORTED);
    }

    internalFormat             = mal_format_from_sio_enc__sndio(par.bits, par.bps, par.sig, par.le, par.msb);
    internalChannels           = (deviceType == mal_device_type_capture) ? par.rchan : par.pchan;
    internalSampleRate         = par.rate;
    internalPeriods            = par.appbufsz / par.round;
    internalBufferSizeInFrames = par.appbufsz;

    if (deviceType == mal_device_type_capture) {
	pDevice->sndio.handleCapture                 = handle;
        pDevice->capture.internalFormat              = internalFormat;
        pDevice->capture.internalChannels            = internalChannels;
        pDevice->capture.internalSampleRate          = internalSampleRate;
        mal_get_standard_channel_map(mal_standard_channel_map_sndio, pDevice->capture.internalChannels, pDevice->capture.internalChannelMap);
        pDevice->capture.internalBufferSizeInFrames  = internalBufferSizeInFrames;
        pDevice->capture.internalPeriods             = internalPeriods;
    } else {
	pDevice->sndio.handlePlayback                = handle;
        pDevice->playback.internalFormat             = internalFormat;
        pDevice->playback.internalChannels           = internalChannels;
        pDevice->playback.internalSampleRate         = internalSampleRate;
        mal_get_standard_channel_map(mal_standard_channel_map_sndio, pDevice->playback.internalChannels, pDevice->playback.internalChannelMap);
        pDevice->playback.internalBufferSizeInFrames = internalBufferSizeInFrames;
        pDevice->playback.internalPeriods            = internalPeriods;
    }

#ifdef MAL_DEBUG_OUTPUT
    printf("DEVICE INFO\n");
    printf("    Format:      %s\n", mal_get_format_name(internalFormat));
    printf("    Channels:    %d\n", internalChannels);
    printf("    Sample Rate: %d\n", internalSampleRate);
    printf("    Buffer Size: %d\n", internalBufferSizeInFrames);
    printf("    Periods:     %d\n", internalPeriods);
    printf("    appbufsz:    %d\n", par.appbufsz);
    printf("    round:       %d\n", par.round);
#endif

    return MAL_SUCCESS;
}

mal_result mal_device_init__sndio(mal_context* pContext, const mal_device_config* pConfig, mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    mal_zero_object(&pDevice->sndio);

    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        mal_result result = mal_device_init_handle__sndio(pContext, pConfig, mal_device_type_capture, pDevice);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        mal_result result = mal_device_init_handle__sndio(pContext, pConfig, mal_device_type_playback, pDevice);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_device_stop__sndio(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        ((mal_sio_stop_proc)pDevice->pContext->sndio.sio_stop)((struct mal_sio_hdl*)pDevice->sndio.handleCapture);
        mal_atomic_exchange_32(&pDevice->sndio.isStartedCapture, MAL_FALSE);
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        ((mal_sio_stop_proc)pDevice->pContext->sndio.sio_stop)((struct mal_sio_hdl*)pDevice->sndio.handlePlayback);
        mal_atomic_exchange_32(&pDevice->sndio.isStartedPlayback, MAL_FALSE);
    }

    return MAL_SUCCESS;
}

mal_result mal_device_write__sndio(mal_device* pDevice, const void* pPCMFrames, mal_uint32 frameCount)
{
    int result;

    if (!pDevice->sndio.isStartedPlayback) {
        ((mal_sio_start_proc)pDevice->pContext->sndio.sio_start)((struct mal_sio_hdl*)pDevice->sndio.handlePlayback);   /* <-- Doesn't actually playback until data is written. */
        mal_atomic_exchange_32(&pDevice->sndio.isStartedPlayback, MAL_TRUE);
    }

    result = ((mal_sio_write_proc)pDevice->pContext->sndio.sio_write)((struct mal_sio_hdl*)pDevice->sndio.handlePlayback, pPCMFrames, frameCount * mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels));
    if (result == 0) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[sndio] Failed to send data from the client to the device.", MAL_FAILED_TO_SEND_DATA_TO_DEVICE);
    }
    
    return MAL_SUCCESS;
}

mal_result mal_device_read__sndio(mal_device* pDevice, void* pPCMFrames, mal_uint32 frameCount)
{
    int result;

    if (!pDevice->sndio.isStartedCapture) {
        ((mal_sio_start_proc)pDevice->pContext->sndio.sio_start)((struct mal_sio_hdl*)pDevice->sndio.handleCapture);   /* <-- Doesn't actually playback until data is written. */
        mal_atomic_exchange_32(&pDevice->sndio.isStartedCapture, MAL_TRUE);
    }
    
    result = ((mal_sio_read_proc)pDevice->pContext->sndio.sio_read)((struct mal_sio_hdl*)pDevice->sndio.handleCapture, pPCMFrames, frameCount * mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));
    if (result == 0) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[sndio] Failed to read data from the device to be sent to the device.", MAL_FAILED_TO_SEND_DATA_TO_DEVICE);
    }
    
    return MAL_SUCCESS;
}

mal_result mal_context_uninit__sndio(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    mal_assert(pContext->backend == mal_backend_sndio);

    (void)pContext;
    return MAL_SUCCESS;
}

mal_result mal_context_init__sndio(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    
#ifndef MAL_NO_RUNTIME_LINKING
    // libpulse.so
    const char* libsndioNames[] = {
        "libsndio.so"
    };

    for (size_t i = 0; i < mal_countof(libsndioNames); ++i) {
        pContext->sndio.sndioSO = mal_dlopen(libsndioNames[i]);
        if (pContext->sndio.sndioSO != NULL) {
            break;
        }
    }

    if (pContext->sndio.sndioSO == NULL) {
        return MAL_NO_BACKEND;
    }
    
    pContext->sndio.sio_open    = (mal_proc)mal_dlsym(pContext->sndio.sndioSO, "sio_open");
    pContext->sndio.sio_close   = (mal_proc)mal_dlsym(pContext->sndio.sndioSO, "sio_close");
    pContext->sndio.sio_setpar  = (mal_proc)mal_dlsym(pContext->sndio.sndioSO, "sio_setpar");
    pContext->sndio.sio_getpar  = (mal_proc)mal_dlsym(pContext->sndio.sndioSO, "sio_getpar");
    pContext->sndio.sio_getcap  = (mal_proc)mal_dlsym(pContext->sndio.sndioSO, "sio_getcap");
    pContext->sndio.sio_write   = (mal_proc)mal_dlsym(pContext->sndio.sndioSO, "sio_write");
    pContext->sndio.sio_read    = (mal_proc)mal_dlsym(pContext->sndio.sndioSO, "sio_read");
    pContext->sndio.sio_start   = (mal_proc)mal_dlsym(pContext->sndio.sndioSO, "sio_start");
    pContext->sndio.sio_stop    = (mal_proc)mal_dlsym(pContext->sndio.sndioSO, "sio_stop");
    pContext->sndio.sio_initpar = (mal_proc)mal_dlsym(pContext->sndio.sndioSO, "sio_initpar");
#else
    pContext->sndio.sio_open    = sio_open;
    pContext->sndio.sio_close   = sio_close;
    pContext->sndio.sio_setpar  = sio_setpar;
    pContext->sndio.sio_getpar  = sio_getpar;
    pContext->sndio.sio_getcap  = sio_getcap;
    pContext->sndio.sio_write   = sio_write;
    pContext->sndio.sio_read    = sio_read;
    pContext->sndio.sio_start   = sio_start;
    pContext->sndio.sio_stop    = sio_stop;
    pContext->sndio.sio_initpar = sio_initpar;
#endif

    pContext->onUninit              = mal_context_uninit__sndio;
    pContext->onDeviceIDEqual       = mal_context_is_device_id_equal__sndio;
    pContext->onEnumDevices         = mal_context_enumerate_devices__sndio;
    pContext->onGetDeviceInfo       = mal_context_get_device_info__sndio;
    pContext->onDeviceInit          = mal_device_init__sndio;
    pContext->onDeviceUninit        = mal_device_uninit__sndio;
    pContext->onDeviceStart         = NULL; /* Not required for synchronous backends. */
    pContext->onDeviceStop          = mal_device_stop__sndio;
    pContext->onDeviceWrite         = mal_device_write__sndio;
    pContext->onDeviceRead          = mal_device_read__sndio;

    return MAL_SUCCESS;
}
#endif  // sndio



///////////////////////////////////////////////////////////////////////////////
//
// audio(4) Backend
//
///////////////////////////////////////////////////////////////////////////////
#ifdef MAL_HAS_AUDIO4
#include <fcntl.h>
#include <poll.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/audioio.h>

#if defined(__OpenBSD__)
    #include <sys/param.h>
    #if defined(OpenBSD) && OpenBSD >= 201709
        #define MAL_AUDIO4_USE_NEW_API
    #endif
#endif

void mal_construct_device_id__audio4(char* id, size_t idSize, const char* base, int deviceIndex)
{
    mal_assert(id != NULL);
    mal_assert(idSize > 0);
    mal_assert(deviceIndex >= 0);
    
    size_t baseLen = strlen(base);
    mal_assert(idSize > baseLen);
    
    mal_strcpy_s(id, idSize, base);
    mal_itoa_s(deviceIndex, id+baseLen, idSize-baseLen, 10);
}

mal_result mal_extract_device_index_from_id__audio4(const char* id, const char* base, int* pIndexOut)
{
    mal_assert(id != NULL);
    mal_assert(base != NULL);
    mal_assert(pIndexOut != NULL);
    
    size_t idLen = strlen(id);
    size_t baseLen = strlen(base);
    if (idLen <= baseLen) {
        return MAL_ERROR;   // Doesn't look like the id starts with the base.
    }
    
    if (strncmp(id, base, baseLen) != 0) {
        return MAL_ERROR;   // ID does not begin with base.
    }
    
    const char* deviceIndexStr = id + baseLen;
    if (deviceIndexStr[0] == '\0') {
        return MAL_ERROR;   // No index specified in the ID.
    }
    
    if (pIndexOut) {
        *pIndexOut = atoi(deviceIndexStr);
    }
    
    return MAL_SUCCESS;
}

mal_bool32 mal_context_is_device_id_equal__audio4(mal_context* pContext, const mal_device_id* pID0, const mal_device_id* pID1)
{
    mal_assert(pContext != NULL);
    mal_assert(pID0 != NULL);
    mal_assert(pID1 != NULL);
    (void)pContext;

    return mal_strcmp(pID0->audio4, pID1->audio4) == 0;
}

#if !defined(MAL_AUDIO4_USE_NEW_API)    /* Old API */
mal_format mal_format_from_encoding__audio4(unsigned int encoding, unsigned int precision)
{
    if (precision == 8 && (encoding == AUDIO_ENCODING_ULINEAR || encoding == AUDIO_ENCODING_ULINEAR || encoding == AUDIO_ENCODING_ULINEAR_LE || encoding == AUDIO_ENCODING_ULINEAR_BE)) {
        return mal_format_u8;
    } else {
        if (mal_is_little_endian() && encoding == AUDIO_ENCODING_SLINEAR_LE) {
            if (precision == 16) {
                return mal_format_s16;
            } else if (precision == 24) {
                return mal_format_s24;
            } else if (precision == 32) {
                return mal_format_s32;
            }
        } else if (mal_is_big_endian() && encoding == AUDIO_ENCODING_SLINEAR_BE) {
            if (precision == 16) {
                return mal_format_s16;
            } else if (precision == 24) {
                return mal_format_s24;
            } else if (precision == 32) {
                return mal_format_s32;
            }
        }
    }

    return mal_format_unknown;  // Encoding not supported.
}

void mal_encoding_from_format__audio4(mal_format format, unsigned int* pEncoding, unsigned int* pPrecision)
{
    mal_assert(format     != mal_format_unknown);
    mal_assert(pEncoding  != NULL);
    mal_assert(pPrecision != NULL);

    switch (format)
    {
        case mal_format_u8:
        {
            *pEncoding = AUDIO_ENCODING_ULINEAR;
            *pPrecision = 8;
        } break;

        case mal_format_s24:
        {
            *pEncoding = (mal_is_little_endian()) ? AUDIO_ENCODING_SLINEAR_LE : AUDIO_ENCODING_SLINEAR_BE;
            *pPrecision = 24;
        } break;

        case mal_format_s32:
        {
            *pEncoding = (mal_is_little_endian()) ? AUDIO_ENCODING_SLINEAR_LE : AUDIO_ENCODING_SLINEAR_BE;
            *pPrecision = 32;
        } break;

        case mal_format_s16:
        case mal_format_f32:
        default:
        {
            *pEncoding = (mal_is_little_endian()) ? AUDIO_ENCODING_SLINEAR_LE : AUDIO_ENCODING_SLINEAR_BE;
            *pPrecision = 16;
        } break;
    }
}

mal_format mal_format_from_prinfo__audio4(struct audio_prinfo* prinfo)
{
    return mal_format_from_encoding__audio4(prinfo->encoding, prinfo->precision);
}
#else
mal_format mal_format_from_swpar__audio4(struct audio_swpar* par)
{
    if (par->bits == 8 && par->bps == 1 && par->sig == 0) {
        return mal_format_u8;
    }
    if (par->bits == 16 && par->bps == 2 && par->sig == 1 && par->le == mal_is_little_endian()) {
        return mal_format_s16;
    }
    if (par->bits == 24 && par->bps == 3 && par->sig == 1 && par->le == mal_is_little_endian()) {
        return mal_format_s24;
    }
    if (par->bits == 32 && par->bps == 4 && par->sig == 1 && par->le == mal_is_little_endian()) {
        return mal_format_f32;
    }

    // Format not supported.
    return mal_format_unknown;
}
#endif

mal_result mal_context_get_device_info_from_fd__audio4(mal_context* pContext, mal_device_type deviceType, int fd, mal_device_info* pInfoOut)
{
    mal_assert(pContext != NULL);
    mal_assert(fd >= 0);
    mal_assert(pInfoOut != NULL);
    
    (void)pContext;
    (void)deviceType;

    audio_device_t fdDevice;
    if (ioctl(fd, AUDIO_GETDEV, &fdDevice) < 0) {
        return MAL_ERROR;   // Failed to retrieve device info.
    }

    // Name.
    mal_strcpy_s(pInfoOut->name, sizeof(pInfoOut->name), fdDevice.name);

#if !defined(MAL_AUDIO4_USE_NEW_API)
    // Supported formats. We get this by looking at the encodings. 
    int counter = 0;
    for (;;) {
        audio_encoding_t encoding;
        mal_zero_object(&encoding);
        encoding.index = counter;
        if (ioctl(fd, AUDIO_GETENC, &encoding) < 0) {
            break;
        }

        mal_format format = mal_format_from_encoding__audio4(encoding.encoding, encoding.precision);
        if (format != mal_format_unknown) {
            pInfoOut->formats[pInfoOut->formatCount++] = format;
        }

        counter += 1;
    }

    audio_info_t fdInfo;
    if (ioctl(fd, AUDIO_GETINFO, &fdInfo) < 0) {
        return MAL_ERROR;
    }

    if (deviceType == mal_device_type_playback) {
        pInfoOut->minChannels = fdInfo.play.channels; 
        pInfoOut->maxChannels = fdInfo.play.channels;
        pInfoOut->minSampleRate = fdInfo.play.sample_rate;
        pInfoOut->maxSampleRate = fdInfo.play.sample_rate;
    } else {
        pInfoOut->minChannels = fdInfo.record.channels;
        pInfoOut->maxChannels = fdInfo.record.channels;
        pInfoOut->minSampleRate = fdInfo.record.sample_rate;
        pInfoOut->maxSampleRate = fdInfo.record.sample_rate;
    }
#else
    struct audio_swpar fdPar;
    if (ioctl(fd, AUDIO_GETPAR, &fdPar) < 0) {
        return MAL_ERROR;
    }
    
    mal_format format = mal_format_from_swpar__audio4(&fdPar);
    if (format == mal_format_unknown) {
        return MAL_FORMAT_NOT_SUPPORTED;
    }
    pInfoOut->formats[pInfoOut->formatCount++] = format;
    
    if (deviceType == mal_device_type_playback) {
        pInfoOut->minChannels = fdPar.pchan;
        pInfoOut->maxChannels = fdPar.pchan;
    } else {
        pInfoOut->minChannels = fdPar.rchan;
        pInfoOut->maxChannels = fdPar.rchan;
    }
    
    pInfoOut->minSampleRate = fdPar.rate;
    pInfoOut->maxSampleRate = fdPar.rate;
#endif
    
    return MAL_SUCCESS;
}

mal_result mal_context_enumerate_devices__audio4(mal_context* pContext, mal_enum_devices_callback_proc callback, void* pUserData)
{
    mal_assert(pContext != NULL);
    mal_assert(callback != NULL);
    
    const int maxDevices = 64;
    
    // Every device will be named "/dev/audioN", with a "/dev/audioctlN" equivalent. We use the "/dev/audioctlN"
    // version here since we can open it even when another process has control of the "/dev/audioN" device.
    char devpath[256];
    for (int iDevice = 0; iDevice < maxDevices; ++iDevice) {
        mal_strcpy_s(devpath, sizeof(devpath), "/dev/audioctl");
        mal_itoa_s(iDevice, devpath+strlen(devpath), sizeof(devpath)-strlen(devpath), 10);
    
        struct stat st;
        if (stat(devpath, &st) < 0) {
            break;
        }

        // The device exists, but we need to check if it's usable as playback and/or capture.
        int fd;
        mal_bool32 isTerminating = MAL_FALSE;
        
        // Playback.
        if (!isTerminating) {
            fd = open(devpath, O_RDONLY, 0);
            if (fd >= 0) {
                // Supports playback.
                mal_device_info deviceInfo;
                mal_zero_object(&deviceInfo);
                mal_construct_device_id__audio4(deviceInfo.id.audio4, sizeof(deviceInfo.id.audio4), "/dev/audio", iDevice);
                if (mal_context_get_device_info_from_fd__audio4(pContext, mal_device_type_playback, fd, &deviceInfo) == MAL_SUCCESS) {
                    isTerminating = !callback(pContext, mal_device_type_playback, &deviceInfo, pUserData);
                }
                
                close(fd);
            }
        }
        
        // Capture.
        if (!isTerminating) {
            fd = open(devpath, O_WRONLY, 0);
            if (fd >= 0) {
                // Supports capture.
                mal_device_info deviceInfo;
                mal_zero_object(&deviceInfo);
                mal_construct_device_id__audio4(deviceInfo.id.audio4, sizeof(deviceInfo.id.audio4), "/dev/audio", iDevice);
                if (mal_context_get_device_info_from_fd__audio4(pContext, mal_device_type_capture, fd, &deviceInfo) == MAL_SUCCESS) {
                    isTerminating = !callback(pContext, mal_device_type_capture, &deviceInfo, pUserData);
                }
                
                close(fd);
            }
        }
        
        if (isTerminating) {
            break;
        }
    }
    
    return MAL_SUCCESS;
}

mal_result mal_context_get_device_info__audio4(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, mal_device_info* pDeviceInfo)
{
    mal_assert(pContext != NULL);
    (void)shareMode;
    
    // We need to open the "/dev/audioctlN" device to get the info. To do this we need to extract the number
    // from the device ID which will be in "/dev/audioN" format.
    int fd = -1;
    int deviceIndex = -1;
    char ctlid[256];
    if (pDeviceID == NULL) {
        // Default device.
        mal_strcpy_s(ctlid, sizeof(ctlid), "/dev/audioctl");
    } else {
        // Specific device. We need to convert from "/dev/audioN" to "/dev/audioctlN".
        mal_result result = mal_extract_device_index_from_id__audio4(pDeviceID->audio4, "/dev/audio", &deviceIndex);
        if (result != MAL_SUCCESS) {
            return result;
        }
        
        mal_construct_device_id__audio4(ctlid, sizeof(ctlid), "/dev/audioctl", deviceIndex);
    }
    
    fd = open(ctlid, (deviceType == mal_device_type_playback) ? O_WRONLY : O_RDONLY, 0);
    if (fd == -1) {
        return MAL_NO_DEVICE;
    }
    
    if (deviceIndex == -1) {
        mal_strcpy_s(pDeviceInfo->id.audio4, sizeof(pDeviceInfo->id.audio4), "/dev/audio");
    } else {
        mal_construct_device_id__audio4(pDeviceInfo->id.audio4, sizeof(pDeviceInfo->id.audio4), "/dev/audio", deviceIndex);
    }
    
    mal_result result = mal_context_get_device_info_from_fd__audio4(pContext, deviceType, fd, pDeviceInfo);
    
    close(fd);
    return result;
}

void mal_device_uninit__audio4(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        close(pDevice->audio4.fdCapture);
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        close(pDevice->audio4.fdPlayback);
    }
}

mal_result mal_device_init_fd__audio4(mal_context* pContext, const mal_device_config* pConfig, mal_device_type deviceType, mal_device* pDevice)
{
    const char* pDefaultDeviceNames[] = {
        "/dev/audio",
	"/dev/audio0"
    };
    int fd;
    int fdFlags = 0;
#if !defined(MAL_AUDIO4_USE_NEW_API)    /* Old API */
    audio_info_t fdInfo;
#else
    struct audio_swpar fdPar;
#endif
    mal_format internalFormat;
    mal_uint32 internalChannels;
    mal_uint32 internalSampleRate;
    mal_uint32 internalBufferSizeInFrames;
    mal_uint32 internalPeriods;

    mal_assert(pContext   != NULL);
    mal_assert(pConfig    != NULL);
    mal_assert(deviceType != mal_device_type_duplex);
    mal_assert(pDevice    != NULL);

    (void)pContext;

    /* The first thing to do is open the file. */
    if (deviceType == mal_device_type_capture) {
        fdFlags = O_RDONLY;
    } else {
        fdFlags = O_WRONLY;
    }
    fdFlags |= O_NONBLOCK;

    if ((deviceType == mal_device_type_capture && pConfig->capture.pDeviceID == NULL) || (deviceType == mal_device_type_playback && pConfig->playback.pDeviceID == NULL)) {
        /* Default device. */
        for (size_t iDevice = 0; iDevice < mal_countof(pDefaultDeviceNames); ++iDevice) {
            fd = open(pDefaultDeviceNames[iDevice], fdFlags, 0);
            if (fd != -1) {
                break;
            }
        }
    } else {
        /* Specific device. */
        fd = open((deviceType == mal_device_type_capture) ? pConfig->capture.pDeviceID->audio4 : pConfig->playback.pDeviceID->audio4, fdFlags, 0);
    }

    if (fd == -1) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[audio4] Failed to open device.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
    }

#if !defined(MAL_AUDIO4_USE_NEW_API)    /* Old API */
    AUDIO_INITINFO(&fdInfo);

    /* We get the driver to do as much of the data conversion as possible. */
    if (deviceType == mal_device_type_capture) {
        fdInfo.mode = AUMODE_RECORD;
        mal_encoding_from_format__audio4(pConfig->capture.format, &fdInfo.record.encoding, &fdInfo.record.precision);
        fdInfo.record.channels    = pConfig->capture.channels;
        fdInfo.record.sample_rate = pConfig->sampleRate;
    } else {
        fdInfo.mode = AUMODE_PLAY;
        mal_encoding_from_format__audio4(pConfig->playback.format, &fdInfo.play.encoding, &fdInfo.play.precision);
        fdInfo.play.channels    = pConfig->playback.channels;
        fdInfo.play.sample_rate = pConfig->sampleRate;
    }

    if (ioctl(fd, AUDIO_SETINFO, &fdInfo) < 0) {
        close(fd);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[audio4] Failed to set device format. AUDIO_SETINFO failed.", MAL_FORMAT_NOT_SUPPORTED);
    }
    
    if (ioctl(fd, AUDIO_GETINFO, &fdInfo) < 0) {
        close(fd);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[audio4] AUDIO_GETINFO failed.", MAL_FORMAT_NOT_SUPPORTED);
    }

    if (deviceType == mal_device_type_capture) {
        internalFormat     = mal_format_from_prinfo__audio4(&fdInfo.record);
        internalChannels   = fdInfo.record.channels;
        internalSampleRate = fdInfo.record.sample_rate;
    } else {
        internalFormat     = mal_format_from_prinfo__audio4(&fdInfo.play);
        internalChannels   = fdInfo.play.channels;
        internalSampleRate = fdInfo.play.sample_rate;
    }

    if (internalFormat == mal_format_unknown) {
        close(fd);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[audio4] The device's internal device format is not supported by mini_al. The device is unusable.", MAL_FORMAT_NOT_SUPPORTED);
    }

    /* Buffer. */
    {
        mal_uint32 internalBufferSizeInBytes;

        internalBufferSizeInFrames = pConfig->bufferSizeInFrames;
        if (internalBufferSizeInFrames == 0) {
            internalBufferSizeInFrames = mal_calculate_buffer_size_in_frames_from_milliseconds(pConfig->bufferSizeInMilliseconds, internalSampleRate);
        }

        internalBufferSizeInBytes = internalBufferSizeInFrames * mal_get_bytes_per_frame(internalFormat, internalChannels);
        if (internalBufferSizeInBytes < 16) {
            internalBufferSizeInBytes = 16;
        }

        internalPeriods = pConfig->periods;
        if (internalPeriods < 2) {
            internalPeriods = 2;
        }

        /* What mini_al calls a fragment, audio4 calls a block. */
        AUDIO_INITINFO(&fdInfo);
        fdInfo.hiwat     = internalPeriods;
        fdInfo.lowat     = internalPeriods-1;
        fdInfo.blocksize = internalBufferSizeInBytes / internalPeriods;
        if (ioctl(fd, AUDIO_SETINFO, &fdInfo) < 0) {
            close(fd);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[audio4] Failed to set internal buffer size. AUDIO_SETINFO failed.", MAL_FORMAT_NOT_SUPPORTED);
        }

        internalPeriods            = fdInfo.hiwat;
        internalBufferSizeInFrames = (fdInfo.blocksize * fdInfo.hiwat) / mal_get_bytes_per_frame(internalFormat, internalChannels);
    }
#else
    /* We need to retrieve the format of the device so we can know the channel count and sample rate. Then we can calculate the buffer size. */
    if (ioctl(fd, AUDIO_GETPAR, &fdPar) < 0) {
        close(fd);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[audio4] Failed to retrieve initial device parameters.", MAL_FORMAT_NOT_SUPPORTED);
    }

    internalFormat     = mal_format_from_swpar__audio4(&fdPar);
    internalChannels   = (deviceType == mal_device_type_capture) ? fdPar.rchan : fdPar.pchan;
    internalSampleRate = fdPar.rate;

    if (internalFormat == mal_format_unknown) {
        close(fd);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[audio4] The device's internal device format is not supported by mini_al. The device is unusable.", MAL_FORMAT_NOT_SUPPORTED);
    }

    /* Buffer. */
    {
        mal_uint32 internalBufferSizeInBytes;

        internalBufferSizeInFrames = pConfig->bufferSizeInFrames;
        if (internalBufferSizeInFrames == 0) {
            internalBufferSizeInFrames = mal_calculate_buffer_size_in_frames_from_milliseconds(pConfig->bufferSizeInMilliseconds, internalSampleRate);
        }

        /* What mini_al calls a fragment, audio4 calls a block. */
        internalBufferSizeInBytes = internalBufferSizeInFrames * mal_get_bytes_per_frame(internalFormat, internalChannels);
        if (internalBufferSizeInBytes < 16) {
            internalBufferSizeInBytes = 16;
        }
    
        fdPar.nblks = pConfig->periods;
        fdPar.round = internalBufferSizeInBytes / fdPar.nblks;
    
        if (ioctl(fd, AUDIO_SETPAR, &fdPar) < 0) {
            close(fd);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[audio4] Failed to set device parameters.", MAL_FORMAT_NOT_SUPPORTED);
        }

        if (ioctl(fd, AUDIO_GETPAR, &fdPar) < 0) {
            close(fd);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[audio4] Failed to retrieve actual device parameters.", MAL_FORMAT_NOT_SUPPORTED);
        }
    }

    internalFormat             = mal_format_from_swpar__audio4(&fdPar);
    internalChannels           = (deviceType == mal_device_type_capture) ? fdPar.rchan : fdPar.pchan;
    internalSampleRate         = fdPar.rate;
    internalPeriods            = fdPar.nblks;
    internalBufferSizeInFrames = (fdPar.nblks * fdPar.round) / mal_get_bytes_per_frame(internalFormat, internalChannels);
#endif

    if (internalFormat == mal_format_unknown) {
        close(fd);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[audio4] The device's internal device format is not supported by mini_al. The device is unusable.", MAL_FORMAT_NOT_SUPPORTED);
    }

    if (deviceType == mal_device_type_capture) {
        pDevice->audio4.fdCapture                    = fd;
        pDevice->capture.internalFormat              = internalFormat;
        pDevice->capture.internalChannels            = internalChannels;
        pDevice->capture.internalSampleRate          = internalSampleRate;
        mal_get_standard_channel_map(mal_standard_channel_map_sound4, internalChannels, pDevice->capture.internalChannelMap);
        pDevice->capture.internalBufferSizeInFrames  = internalBufferSizeInFrames;
        pDevice->capture.internalPeriods             = internalPeriods;
    } else {
        pDevice->audio4.fdPlayback                   = fd;
        pDevice->playback.internalFormat             = internalFormat;
        pDevice->playback.internalChannels           = internalChannels;
        pDevice->playback.internalSampleRate         = internalSampleRate;
        mal_get_standard_channel_map(mal_standard_channel_map_sound4, internalChannels, pDevice->playback.internalChannelMap);
        pDevice->playback.internalBufferSizeInFrames = internalBufferSizeInFrames;
        pDevice->playback.internalPeriods            = internalPeriods;
    }

    return MAL_SUCCESS;
}

mal_result mal_device_init__audio4(mal_context* pContext, const mal_device_config* pConfig, mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    mal_zero_object(&pDevice->audio4);
    
    pDevice->audio4.fdCapture  = -1;
    pDevice->audio4.fdPlayback = -1;

    // The version of the operating system dictates whether or not the device is exclusive or shared. NetBSD
    // introduced in-kernel mixing which means it's shared. All other BSD flavours are exclusive as far as
    // I'm aware.
#if defined(__NetBSD_Version__) && __NetBSD_Version__ >= 800000000
    /* NetBSD 8.0+ */
    if (((pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) && pConfig->playback.shareMode == mal_share_mode_exclusive) ||
        ((pConfig->deviceType == mal_device_type_capture  || pConfig->deviceType == mal_device_type_duplex) && pConfig->capture.shareMode  == mal_share_mode_exclusive)) {
        return MAL_SHARE_MODE_NOT_SUPPORTED;
    }
#else
    /* All other flavors. */
#endif

    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        mal_result result = mal_device_init_fd__audio4(pContext, pConfig, mal_device_type_capture, pDevice);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        mal_result result = mal_device_init_fd__audio4(pContext, pConfig, mal_device_type_playback, pDevice);
        if (result != MAL_SUCCESS) {
            if (pConfig->deviceType == mal_device_type_duplex) {
                close(pDevice->audio4.fdCapture);
            }
            return result;
        }
    }

    return MAL_SUCCESS;
}

#if 0
mal_result mal_device_start__audio4(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        if (pDevice->audio4.fdCapture == -1) {
            return MAL_INVALID_ARGS;
        }
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        if (pDevice->audio4.fdPlayback == -1) {
            return MAL_INVALID_ARGS;
        }
    }

    return MAL_SUCCESS;
}
#endif

mal_result mal_device_stop_fd__audio4(mal_device* pDevice, int fd)
{
    if (fd == -1) {
        return MAL_INVALID_ARGS;
    }

#if !defined(MAL_AUDIO4_USE_NEW_API)
    if (ioctl(fd, AUDIO_FLUSH, 0) < 0) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[audio4] Failed to stop device. AUDIO_FLUSH failed.", MAL_FAILED_TO_STOP_BACKEND_DEVICE);
    }
#else
    if (ioctl(fd, AUDIO_STOP, 0) < 0) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[audio4] Failed to stop device. AUDIO_STOP failed.", MAL_FAILED_TO_STOP_BACKEND_DEVICE);
    }
#endif

    return MAL_SUCCESS;
}

mal_result mal_device_stop__audio4(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        mal_result result = mal_device_stop_fd__audio4(pDevice, pDevice->audio4.fdCapture);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        mal_result result = mal_device_stop_fd__audio4(pDevice, pDevice->audio4.fdPlayback);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_device_write__audio4(mal_device* pDevice, const void* pPCMFrames, mal_uint32 frameCount)
{
    int result = write(pDevice->audio4.fdPlayback, pPCMFrames, frameCount * mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels));
    if (result < 0) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[audio4] Failed to write data to the device.", MAL_FAILED_TO_SEND_DATA_TO_DEVICE);
    }

    return MAL_SUCCESS;
}

mal_result mal_device_read__audio4(mal_device* pDevice, void* pPCMFrames, mal_uint32 frameCount)
{
    int result = read(pDevice->audio4.fdCapture, pPCMFrames, frameCount * mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));
    if (result < 0) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[audio4] Failed to read data from the device.", MAL_FAILED_TO_READ_DATA_FROM_DEVICE);
    }

    return MAL_SUCCESS;
}

mal_result mal_context_uninit__audio4(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    mal_assert(pContext->backend == mal_backend_audio4);

    (void)pContext;
    return MAL_SUCCESS;
}

mal_result mal_context_init__audio4(mal_context* pContext)
{
    mal_assert(pContext != NULL);

    pContext->onUninit              = mal_context_uninit__audio4;
    pContext->onDeviceIDEqual       = mal_context_is_device_id_equal__audio4;
    pContext->onEnumDevices         = mal_context_enumerate_devices__audio4;
    pContext->onGetDeviceInfo       = mal_context_get_device_info__audio4;
    pContext->onDeviceInit          = mal_device_init__audio4;
    pContext->onDeviceUninit        = mal_device_uninit__audio4;
    pContext->onDeviceStart         = NULL;
    pContext->onDeviceStop          = mal_device_stop__audio4;
    pContext->onDeviceWrite         = mal_device_write__audio4;
    pContext->onDeviceRead          = mal_device_read__audio4;

    return MAL_SUCCESS;
}
#endif  /* audio4 */


///////////////////////////////////////////////////////////////////////////////
//
// OSS Backend
//
///////////////////////////////////////////////////////////////////////////////
#ifdef MAL_HAS_OSS
#include <sys/ioctl.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/soundcard.h>

#ifndef SNDCTL_DSP_HALT
#define SNDCTL_DSP_HALT SNDCTL_DSP_RESET
#endif

int mal_open_temp_device__oss()
{
    // The OSS sample code uses "/dev/mixer" as the device for getting system properties so I'm going to do the same.
    int fd = open("/dev/mixer", O_RDONLY, 0);
    if (fd >= 0) {
        return fd;
    }

    return -1;
}

mal_result mal_context_open_device__oss(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, int* pfd)
{
    mal_assert(pContext != NULL);
    mal_assert(pfd != NULL);
    (void)pContext;

    *pfd = -1;

    /* This function should only be called for playback or capture, not duplex. */
    if (deviceType == mal_device_type_duplex) {
        return MAL_INVALID_ARGS;
    }

    const char* deviceName = "/dev/dsp";
    if (pDeviceID != NULL) {
        deviceName = pDeviceID->oss;
    }

    int flags = (deviceType == mal_device_type_playback) ? O_WRONLY : O_RDONLY;
    if (shareMode == mal_share_mode_exclusive) {
        flags |= O_EXCL;
    }

    *pfd = open(deviceName, flags, 0);
    if (*pfd == -1) {
        return MAL_FAILED_TO_OPEN_BACKEND_DEVICE;
    }

    return MAL_SUCCESS;
}

mal_bool32 mal_context_is_device_id_equal__oss(mal_context* pContext, const mal_device_id* pID0, const mal_device_id* pID1)
{
    mal_assert(pContext != NULL);
    mal_assert(pID0 != NULL);
    mal_assert(pID1 != NULL);
    (void)pContext;

    return mal_strcmp(pID0->oss, pID1->oss) == 0;
}

mal_result mal_context_enumerate_devices__oss(mal_context* pContext, mal_enum_devices_callback_proc callback, void* pUserData)
{
    mal_assert(pContext != NULL);
    mal_assert(callback != NULL);

    int fd = mal_open_temp_device__oss();
    if (fd == -1) {
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[OSS] Failed to open a temporary device for retrieving system information used for device enumeration.", MAL_NO_BACKEND);
    }

    oss_sysinfo si;
    int result = ioctl(fd, SNDCTL_SYSINFO, &si);
    if (result != -1) {
        for (int iAudioDevice = 0; iAudioDevice < si.numaudios; ++iAudioDevice) {
            oss_audioinfo ai;
            ai.dev = iAudioDevice;
            result = ioctl(fd, SNDCTL_AUDIOINFO, &ai);
            if (result != -1) {
                if (ai.devnode[0] != '\0') {    // <-- Can be blank, according to documentation.
                    mal_device_info deviceInfo;
                    mal_zero_object(&deviceInfo);

                    // ID
                    mal_strncpy_s(deviceInfo.id.oss, sizeof(deviceInfo.id.oss), ai.devnode, (size_t)-1);

                    // The human readable device name should be in the "ai.handle" variable, but it can
                    // sometimes be empty in which case we just fall back to "ai.name" which is less user
                    // friendly, but usually has a value.
                    if (ai.handle[0] != '\0') {
                        mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), ai.handle, (size_t)-1);
                    } else {
                        mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), ai.name, (size_t)-1);
                    }

                    // The device can be both playback and capture.
                    mal_bool32 isTerminating = MAL_FALSE;
                    if (!isTerminating && (ai.caps & PCM_CAP_OUTPUT) != 0) {
                        isTerminating = !callback(pContext, mal_device_type_playback, &deviceInfo, pUserData);
                    }
                    if (!isTerminating && (ai.caps & PCM_CAP_INPUT) != 0) {
                        isTerminating = !callback(pContext, mal_device_type_capture, &deviceInfo, pUserData);
                    }

                    if (isTerminating) {
                        break;
                    }
                }
            }
        }
    } else {
        close(fd);
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[OSS] Failed to retrieve system information for device enumeration.", MAL_NO_BACKEND);
    }

    close(fd);
    return MAL_SUCCESS;
}

mal_result mal_context_get_device_info__oss(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, mal_device_info* pDeviceInfo)
{
    mal_assert(pContext != NULL);
    (void)shareMode;

    // Handle the default device a little differently.
    if (pDeviceID == NULL) {
        if (deviceType == mal_device_type_playback) {
            mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MAL_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
        } else {
            mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MAL_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
        }

        return MAL_SUCCESS;
    }


    // If we get here it means we are _not_ using the default device.
    mal_bool32 foundDevice = MAL_FALSE;

    int fdTemp = mal_open_temp_device__oss();
    if (fdTemp == -1) {
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[OSS] Failed to open a temporary device for retrieving system information used for device enumeration.", MAL_NO_BACKEND);
    }

    oss_sysinfo si;
    int result = ioctl(fdTemp, SNDCTL_SYSINFO, &si);
    if (result != -1) {
        for (int iAudioDevice = 0; iAudioDevice < si.numaudios; ++iAudioDevice) {
            oss_audioinfo ai;
            ai.dev = iAudioDevice;
            result = ioctl(fdTemp, SNDCTL_AUDIOINFO, &ai);
            if (result != -1) {
                if (mal_strcmp(ai.devnode, pDeviceID->oss) == 0) {
                    // It has the same name, so now just confirm the type.
                    if ((deviceType == mal_device_type_playback && ((ai.caps & PCM_CAP_OUTPUT) != 0)) ||
                        (deviceType == mal_device_type_capture  && ((ai.caps & PCM_CAP_INPUT)  != 0))) {
                        // ID
                        mal_strncpy_s(pDeviceInfo->id.oss, sizeof(pDeviceInfo->id.oss), ai.devnode, (size_t)-1);

                        // The human readable device name should be in the "ai.handle" variable, but it can
                        // sometimes be empty in which case we just fall back to "ai.name" which is less user
                        // friendly, but usually has a value.
                        if (ai.handle[0] != '\0') {
                            mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), ai.handle, (size_t)-1);
                        } else {
                            mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), ai.name, (size_t)-1);
                        }

                        pDeviceInfo->minChannels = ai.min_channels;
                        pDeviceInfo->maxChannels = ai.max_channels;
                        pDeviceInfo->minSampleRate = ai.min_rate;
                        pDeviceInfo->maxSampleRate = ai.max_rate;
                        pDeviceInfo->formatCount = 0;

                        unsigned int formatMask;
                        if (deviceType == mal_device_type_playback) {
                            formatMask = ai.oformats;
                        } else {
                            formatMask = ai.iformats;
                        }

                        if ((formatMask & AFMT_U8) != 0) {
                            pDeviceInfo->formats[pDeviceInfo->formatCount++] = mal_format_u8;
                        }
                        if (((formatMask & AFMT_S16_LE) != 0 && mal_is_little_endian()) || (AFMT_S16_BE && mal_is_big_endian())) {
                            pDeviceInfo->formats[pDeviceInfo->formatCount++] = mal_format_s16;
                        }
                        if (((formatMask & AFMT_S32_LE) != 0 && mal_is_little_endian()) || (AFMT_S32_BE && mal_is_big_endian())) {
                            pDeviceInfo->formats[pDeviceInfo->formatCount++] = mal_format_s32;
                        }

                        foundDevice = MAL_TRUE;
                        break;
                    }
                }
            }
        }
    } else {
        close(fdTemp);
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[OSS] Failed to retrieve system information for device enumeration.", MAL_NO_BACKEND);
    }


    close(fdTemp);

    if (!foundDevice) {
        return MAL_NO_DEVICE;
    }


    return MAL_SUCCESS;
}

void mal_device_uninit__oss(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        close(pDevice->oss.fdCapture);
    }
    
    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        close(pDevice->oss.fdPlayback);
    }
}

int mal_format_to_oss(mal_format format)
{
    int ossFormat = AFMT_U8;
    switch (format) {
        case mal_format_s16: ossFormat = (mal_is_little_endian()) ? AFMT_S16_LE : AFMT_S16_BE; break;
        case mal_format_s24: ossFormat = (mal_is_little_endian()) ? AFMT_S32_LE : AFMT_S32_BE; break;
        case mal_format_s32: ossFormat = (mal_is_little_endian()) ? AFMT_S32_LE : AFMT_S32_BE; break;
        case mal_format_f32: ossFormat = (mal_is_little_endian()) ? AFMT_S16_LE : AFMT_S16_BE; break;
        case mal_format_u8:
        default: ossFormat = AFMT_U8; break;
    }

    return ossFormat;
}

mal_format mal_format_from_oss(int ossFormat)
{
    if (ossFormat == AFMT_U8) {
        return mal_format_u8;
    } else {
        if (mal_is_little_endian()) {
            switch (ossFormat) {
                case AFMT_S16_LE: return mal_format_s16;
                case AFMT_S32_LE: return mal_format_s32;
                default: return mal_format_unknown;
            }
        } else {
            switch (ossFormat) {
                case AFMT_S16_BE: return mal_format_s16;
                case AFMT_S32_BE: return mal_format_s32;
                default: return mal_format_unknown;
            }
        }
    }

    return mal_format_unknown;
}

mal_result mal_device_init_fd__oss(mal_context* pContext, const mal_device_config* pConfig, mal_device_type deviceType, mal_device* pDevice)
{
    mal_result result;
    int ossResult;
    int fd;
    const mal_device_id* pDeviceID = NULL;
    mal_share_mode shareMode;
    int ossFormat;
    int ossChannels;
    int ossSampleRate;
    int ossFragment;

    mal_assert(pContext != NULL);
    mal_assert(pConfig != NULL);
    mal_assert(deviceType != mal_device_type_duplex);
    mal_assert(pDevice != NULL);

    (void)pContext;

    if (deviceType == mal_device_type_capture) {
        pDeviceID     = pConfig->capture.pDeviceID;
        shareMode     = pConfig->capture.shareMode;
        ossFormat     = mal_format_to_oss(pConfig->capture.format);
        ossChannels   = (int)pConfig->capture.channels;
        ossSampleRate = (int)pConfig->sampleRate;
    } else {
        pDeviceID     = pConfig->playback.pDeviceID;
        shareMode     = pConfig->playback.shareMode;
        ossFormat     = mal_format_to_oss(pConfig->playback.format);
        ossChannels   = (int)pConfig->playback.channels;
        ossSampleRate = (int)pConfig->sampleRate;
    }

    result = mal_context_open_device__oss(pContext, deviceType, pDeviceID, shareMode, &fd);
    if (result != MAL_SUCCESS) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OSS] Failed to open device.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
    }

    /*
    The OSS documantation is very clear about the order we should be initializing the device's properties:
      1) Format
      2) Channels
      3) Sample rate.
    */

    /* Format. */
    ossResult = ioctl(fd, SNDCTL_DSP_SETFMT, &ossFormat);
    if (ossResult == -1) {
        close(fd);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OSS] Failed to set format.", MAL_FORMAT_NOT_SUPPORTED);
    }

    /* Channels. */
    ossResult = ioctl(fd, SNDCTL_DSP_CHANNELS, &ossChannels);
    if (ossResult == -1) {
        close(fd);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OSS] Failed to set channel count.", MAL_FORMAT_NOT_SUPPORTED);
    }

    /* Sample Rate. */
    ossResult = ioctl(fd, SNDCTL_DSP_SPEED, &ossSampleRate);
    if (ossResult == -1) {
        close(fd);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OSS] Failed to set sample rate.", MAL_FORMAT_NOT_SUPPORTED);
    }

    /*
    Buffer.

    The documentation says that the fragment settings should be set as soon as possible, but I'm not sure if
    it should be done before or after format/channels/rate.
    
    OSS wants the fragment size in bytes and a power of 2. When setting, we specify the power, not the actual
    value.
    */
    {
        mal_uint32 fragmentSizeInBytes;
        mal_uint32 bufferSizeInFrames;
        mal_uint32 ossFragmentSizePower;
        
        bufferSizeInFrames = pConfig->bufferSizeInFrames;
        if (bufferSizeInFrames == 0) {
            bufferSizeInFrames = mal_calculate_buffer_size_in_frames_from_milliseconds(pConfig->bufferSizeInMilliseconds, (mal_uint32)ossSampleRate);
        }

        fragmentSizeInBytes = mal_round_to_power_of_2((bufferSizeInFrames / pConfig->periods) * mal_get_bytes_per_frame(mal_format_from_oss(ossFormat), ossChannels));
        if (fragmentSizeInBytes < 16) {
            fragmentSizeInBytes = 16;
        }

        ossFragmentSizePower = 4;
        fragmentSizeInBytes >>= 4;
        while (fragmentSizeInBytes >>= 1) {
            ossFragmentSizePower += 1;
        }

        ossFragment = (int)((pConfig->periods << 16) | ossFragmentSizePower);
        ossResult = ioctl(fd, SNDCTL_DSP_SETFRAGMENT, &ossFragment);
        if (ossResult == -1) {
            close(fd);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OSS] Failed to set fragment size and period count.", MAL_FORMAT_NOT_SUPPORTED);
        }
    }

    /* Internal settings. */
    if (deviceType == mal_device_type_capture) {
        pDevice->oss.fdCapture                       = fd;
        pDevice->capture.internalFormat              = mal_format_from_oss(ossFormat);
        pDevice->capture.internalChannels            = ossChannels;
        pDevice->capture.internalSampleRate          = ossSampleRate;
        mal_get_standard_channel_map(mal_standard_channel_map_sound4, pDevice->capture.internalChannels, pDevice->capture.internalChannelMap);
        pDevice->capture.internalPeriods             = (mal_uint32)(ossFragment >> 16);
        pDevice->capture.internalBufferSizeInFrames  = (((mal_uint32)(1 << (ossFragment & 0xFFFF))) * pDevice->capture.internalPeriods) / mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);

        if (pDevice->capture.internalFormat == mal_format_unknown) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OSS] The device's internal format is not supported by mini_al.", MAL_FORMAT_NOT_SUPPORTED);
        }
    } else {
        pDevice->oss.fdPlayback                      = fd;
        pDevice->playback.internalFormat             = mal_format_from_oss(ossFormat);
        pDevice->playback.internalChannels           = ossChannels;
        pDevice->playback.internalSampleRate         = ossSampleRate;
        mal_get_standard_channel_map(mal_standard_channel_map_sound4, pDevice->playback.internalChannels, pDevice->playback.internalChannelMap);
        pDevice->playback.internalPeriods            = (mal_uint32)(ossFragment >> 16);
        pDevice->playback.internalBufferSizeInFrames = (((mal_uint32)(1 << (ossFragment & 0xFFFF))) * pDevice->playback.internalPeriods) / mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);

        if (pDevice->playback.internalFormat == mal_format_unknown) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OSS] The device's internal format is not supported by mini_al.", MAL_FORMAT_NOT_SUPPORTED);
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_device_init__oss(mal_context* pContext, const mal_device_config* pConfig, mal_device* pDevice)
{
    mal_assert(pContext != NULL);
    mal_assert(pConfig  != NULL);
    mal_assert(pDevice  != NULL);

    mal_zero_object(&pDevice->oss);

    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        mal_result result = mal_device_init_fd__oss(pContext, pConfig, mal_device_type_capture, pDevice);
        if (result != MAL_SUCCESS) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OSS] Failed to open device.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }
    }

    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        mal_result result = mal_device_init_fd__oss(pContext, pConfig, mal_device_type_playback, pDevice);
        if (result != MAL_SUCCESS) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OSS] Failed to open device.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_device_stop__oss(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    /*
    We want to use SNDCTL_DSP_HALT. From the documentation:
    
      In multithreaded applications SNDCTL_DSP_HALT (SNDCTL_DSP_RESET) must only be called by the thread
      that actually reads/writes the audio device. It must not be called by some master thread to kill the
      audio thread. The audio thread will not stop or get any kind of notification that the device was
      stopped by the master thread. The device gets stopped but the next read or write call will silently
      restart the device.
    
    This is actually safe in our case, because this function is only ever called from within our worker
    thread anyway. Just keep this in mind, though...
    */

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        int result = ioctl(pDevice->oss.fdCapture, SNDCTL_DSP_HALT, 0);
        if (result == -1) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OSS] Failed to stop device. SNDCTL_DSP_HALT failed.", MAL_FAILED_TO_STOP_BACKEND_DEVICE);
        }
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        int result = ioctl(pDevice->oss.fdPlayback, SNDCTL_DSP_HALT, 0);
        if (result == -1) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OSS] Failed to stop device. SNDCTL_DSP_HALT failed.", MAL_FAILED_TO_STOP_BACKEND_DEVICE);
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_device_write__oss(mal_device* pDevice, const void* pPCMFrames, mal_uint32 frameCount)
{
    int resultOSS = write(pDevice->oss.fdPlayback, pPCMFrames, frameCount * mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels));
    if (resultOSS < 0) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OSS] Failed to send data from the client to the device.", MAL_FAILED_TO_SEND_DATA_TO_DEVICE);
    }
    
    return MAL_SUCCESS;
}

mal_result mal_device_read__oss(mal_device* pDevice, void* pPCMFrames, mal_uint32 frameCount)
{
    int resultOSS = read(pDevice->oss.fdCapture, pPCMFrames, frameCount * mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));
    if (resultOSS < 0) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OSS] Failed to read data from the device to be sent to the client.", MAL_FAILED_TO_READ_DATA_FROM_DEVICE);
    }
    
    return MAL_SUCCESS;
}

mal_result mal_context_uninit__oss(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    mal_assert(pContext->backend == mal_backend_oss);

    (void)pContext;
    return MAL_SUCCESS;
}

mal_result mal_context_init__oss(mal_context* pContext)
{
    mal_assert(pContext != NULL);

    /* Try opening a temporary device first so we can get version information. This is closed at the end. */
    int fd = mal_open_temp_device__oss();
    if (fd == -1) {
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[OSS] Failed to open temporary device for retrieving system properties.", MAL_NO_BACKEND);   /* Looks liks OSS isn't installed, or there are no available devices. */
    }

    /* Grab the OSS version. */
    int ossVersion = 0;
    int result = ioctl(fd, OSS_GETVERSION, &ossVersion);
    if (result == -1) {
        close(fd);
        return mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_ERROR, "[OSS] Failed to retrieve OSS version.", MAL_NO_BACKEND);
    }

    pContext->oss.versionMajor = ((ossVersion & 0xFF0000) >> 16);
    pContext->oss.versionMinor = ((ossVersion & 0x00FF00) >> 8);

    pContext->onUninit              = mal_context_uninit__oss;
    pContext->onDeviceIDEqual       = mal_context_is_device_id_equal__oss;
    pContext->onEnumDevices         = mal_context_enumerate_devices__oss;
    pContext->onGetDeviceInfo       = mal_context_get_device_info__oss;
    pContext->onDeviceInit          = mal_device_init__oss;
    pContext->onDeviceUninit        = mal_device_uninit__oss;
    pContext->onDeviceStart         = NULL; /* Not required for synchronous backends. */
    pContext->onDeviceStop          = mal_device_stop__oss;
    pContext->onDeviceWrite         = mal_device_write__oss;
    pContext->onDeviceRead          = mal_device_read__oss;

    close(fd);
    return MAL_SUCCESS;
}
#endif  /* OSS */


///////////////////////////////////////////////////////////////////////////////
//
// AAudio Backend
//
///////////////////////////////////////////////////////////////////////////////
#ifdef MAL_HAS_AAUDIO
//#include <AAudio/AAudio.h>

#define MAL_AAUDIO_UNSPECIFIED 0

typedef int32_t mal_aaudio_result_t;
typedef int32_t mal_aaudio_direction_t;
typedef int32_t mal_aaudio_sharing_mode_t;
typedef int32_t mal_aaudio_format_t;
typedef int32_t mal_aaudio_stream_state_t;
typedef int32_t mal_aaudio_performance_mode_t;
typedef int32_t mal_aaudio_data_callback_result_t;

/* Result codes. mini_al only cares about the success code. */
#define MAL_AAUDIO_OK                               0

/* Directions. */
#define MAL_AAUDIO_DIRECTION_OUTPUT                 0
#define MAL_AAUDIO_DIRECTION_INPUT                  1

/* Sharing modes. */
#define MAL_AAUDIO_SHARING_MODE_EXCLUSIVE           0
#define MAL_AAUDIO_SHARING_MODE_SHARED              1

/* Formats. */
#define MAL_AAUDIO_FORMAT_PCM_I16                   1
#define MAL_AAUDIO_FORMAT_PCM_FLOAT                 2

/* Stream states. */
#define MAL_AAUDIO_STREAM_STATE_UNINITIALIZED       0
#define MAL_AAUDIO_STREAM_STATE_UNKNOWN             1
#define MAL_AAUDIO_STREAM_STATE_OPEN                2
#define MAL_AAUDIO_STREAM_STATE_STARTING            3
#define MAL_AAUDIO_STREAM_STATE_STARTED             4
#define MAL_AAUDIO_STREAM_STATE_PAUSING             5
#define MAL_AAUDIO_STREAM_STATE_PAUSED              6
#define MAL_AAUDIO_STREAM_STATE_FLUSHING            7
#define MAL_AAUDIO_STREAM_STATE_FLUSHED             8
#define MAL_AAUDIO_STREAM_STATE_STOPPING            9
#define MAL_AAUDIO_STREAM_STATE_STOPPED             10
#define MAL_AAUDIO_STREAM_STATE_CLOSING             11
#define MAL_AAUDIO_STREAM_STATE_CLOSED              12
#define MAL_AAUDIO_STREAM_STATE_DISCONNECTED        13

/* Performance modes. */
#define MAL_AAUDIO_PERFORMANCE_MODE_NONE            10
#define MAL_AAUDIO_PERFORMANCE_MODE_POWER_SAVING    11
#define MAL_AAUDIO_PERFORMANCE_MODE_LOW_LATENCY     12

/* Callback results. */
#define MAL_AAUDIO_CALLBACK_RESULT_CONTINUE         0
#define MAL_AAUDIO_CALLBACK_RESULT_STOP             1

/* Objects. */
typedef struct mal_AAudioStreamBuilder_t* mal_AAudioStreamBuilder;
typedef struct mal_AAudioStream_t*        mal_AAudioStream;

typedef mal_aaudio_data_callback_result_t (*mal_AAudioStream_dataCallback)(mal_AAudioStream* pStream, void* pUserData, void* pAudioData, int32_t numFrames);

typedef mal_aaudio_result_t       (* MAL_PFN_AAudio_createStreamBuilder)                   (mal_AAudioStreamBuilder** ppBuilder);
typedef mal_aaudio_result_t       (* MAL_PFN_AAudioStreamBuilder_delete)                   (mal_AAudioStreamBuilder* pBuilder);
typedef void                      (* MAL_PFN_AAudioStreamBuilder_setDeviceId)              (mal_AAudioStreamBuilder* pBuilder, int32_t deviceId);
typedef void                      (* MAL_PFN_AAudioStreamBuilder_setDirection)             (mal_AAudioStreamBuilder* pBuilder, mal_aaudio_direction_t direction);
typedef void                      (* MAL_PFN_AAudioStreamBuilder_setSharingMode)           (mal_AAudioStreamBuilder* pBuilder, mal_aaudio_sharing_mode_t sharingMode);
typedef void                      (* MAL_PFN_AAudioStreamBuilder_setFormat)                (mal_AAudioStreamBuilder* pBuilder, mal_aaudio_format_t format);
typedef void                      (* MAL_PFN_AAudioStreamBuilder_setChannelCount)          (mal_AAudioStreamBuilder* pBuilder, int32_t channelCount);
typedef void                      (* MAL_PFN_AAudioStreamBuilder_setSampleRate)            (mal_AAudioStreamBuilder* pBuilder, int32_t sampleRate);
typedef void                      (* MAL_PFN_AAudioStreamBuilder_setBufferCapacityInFrames)(mal_AAudioStreamBuilder* pBuilder, int32_t numFrames);
typedef void                      (* MAL_PFN_AAudioStreamBuilder_setFramesPerDataCallback) (mal_AAudioStreamBuilder* pBuilder, int32_t numFrames);
typedef void                      (* MAL_PFN_AAudioStreamBuilder_setDataCallback)          (mal_AAudioStreamBuilder* pBuilder, mal_AAudioStream_dataCallback callback, void* pUserData);
typedef void                      (* MAL_PFN_AAudioStreamBuilder_setPerformanceMode)       (mal_AAudioStreamBuilder* pBuilder, mal_aaudio_performance_mode_t mode);
typedef mal_aaudio_result_t       (* MAL_PFN_AAudioStreamBuilder_openStream)               (mal_AAudioStreamBuilder* pBuilder, mal_AAudioStream** ppStream);
typedef mal_aaudio_result_t       (* MAL_PFN_AAudioStream_close)                           (mal_AAudioStream* pStream);
typedef mal_aaudio_stream_state_t (* MAL_PFN_AAudioStream_getState)                        (mal_AAudioStream* pStream);
typedef mal_aaudio_result_t       (* MAL_PFN_AAudioStream_waitForStateChange)              (mal_AAudioStream* pStream, mal_aaudio_stream_state_t inputState, mal_aaudio_stream_state_t* pNextState, int64_t timeoutInNanoseconds);
typedef mal_aaudio_format_t       (* MAL_PFN_AAudioStream_getFormat)                       (mal_AAudioStream* pStream);
typedef int32_t                   (* MAL_PFN_AAudioStream_getChannelCount)                 (mal_AAudioStream* pStream);
typedef int32_t                   (* MAL_PFN_AAudioStream_getSampleRate)                   (mal_AAudioStream* pStream);
typedef int32_t                   (* MAL_PFN_AAudioStream_getBufferCapacityInFrames)       (mal_AAudioStream* pStream);
typedef int32_t                   (* MAL_PFN_AAudioStream_getFramesPerDataCallback)        (mal_AAudioStream* pStream);
typedef int32_t                   (* MAL_PFN_AAudioStream_getFramesPerBurst)               (mal_AAudioStream* pStream);
typedef mal_aaudio_result_t       (* MAL_PFN_AAudioStream_requestStart)                    (mal_AAudioStream* pStream);
typedef mal_aaudio_result_t       (* MAL_PFN_AAudioStream_requestStop)                     (mal_AAudioStream* pStream);

mal_result mal_result_from_aaudio(mal_aaudio_result_t resultAA)
{
    switch (resultAA)
    {
        case MAL_AAUDIO_OK: return MAL_SUCCESS;
        default: break;
    }

    return MAL_ERROR;
}

mal_aaudio_data_callback_result_t mal_stream_data_callback_capture__aaudio(mal_AAudioStream* pStream, void* pUserData, void* pAudioData, int32_t frameCount)
{
    mal_device* pDevice = (mal_device*)pUserData;
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_duplex) {
        mal_device__handle_duplex_callback_capture(pDevice, frameCount, pAudioData, &pDevice->aaudio.duplexRB);
    } else {
        mal_device__send_frames_to_client(pDevice, frameCount, pAudioData);     /* Send directly to the client. */
    }

    (void)pStream;
    return MAL_AAUDIO_CALLBACK_RESULT_CONTINUE;
}

mal_aaudio_data_callback_result_t mal_stream_data_callback_playback__aaudio(mal_AAudioStream* pStream, void* pUserData, void* pAudioData, int32_t frameCount)
{
    mal_device* pDevice = (mal_device*)pUserData;
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_duplex) {
        mal_device__handle_duplex_callback_playback(pDevice, frameCount, pAudioData, &pDevice->aaudio.duplexRB);
    } else {
        mal_device__read_frames_from_client(pDevice, frameCount, pAudioData);   /* Read directly from the client. */
    }

    (void)pStream;
    return MAL_AAUDIO_CALLBACK_RESULT_CONTINUE;
}

mal_result mal_open_stream__aaudio(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, const mal_device_config* pConfig, const mal_device* pDevice, mal_AAudioStream** ppStream)
{
    mal_AAudioStreamBuilder* pBuilder;
    mal_aaudio_result_t resultAA;

    mal_assert(deviceType != mal_device_type_duplex);   /* This function should not be called for a full-duplex device type. */

    *ppStream = NULL;

    resultAA = ((MAL_PFN_AAudio_createStreamBuilder)pContext->aaudio.AAudio_createStreamBuilder)(&pBuilder);
    if (resultAA != MAL_AAUDIO_OK) {
        return mal_result_from_aaudio(resultAA);
    }

    if (pDeviceID != NULL) {
        ((MAL_PFN_AAudioStreamBuilder_setDeviceId)pContext->aaudio.AAudioStreamBuilder_setDeviceId)(pBuilder, pDeviceID->aaudio);
    }

    ((MAL_PFN_AAudioStreamBuilder_setDirection)pContext->aaudio.AAudioStreamBuilder_setDirection)(pBuilder, (deviceType == mal_device_type_playback) ? MAL_AAUDIO_DIRECTION_OUTPUT : MAL_AAUDIO_DIRECTION_INPUT);
    ((MAL_PFN_AAudioStreamBuilder_setSharingMode)pContext->aaudio.AAudioStreamBuilder_setSharingMode)(pBuilder, (shareMode == mal_share_mode_shared) ? MAL_AAUDIO_SHARING_MODE_SHARED : MAL_AAUDIO_SHARING_MODE_EXCLUSIVE);

    if (pConfig != NULL) {
        if (pDevice == NULL || !pDevice->usingDefaultSampleRate) {
            ((MAL_PFN_AAudioStreamBuilder_setSampleRate)pContext->aaudio.AAudioStreamBuilder_setSampleRate)(pBuilder, pConfig->sampleRate);
        }

        if (deviceType == mal_device_type_capture) {
            if (pDevice == NULL || !pDevice->capture.usingDefaultChannels) {
                ((MAL_PFN_AAudioStreamBuilder_setChannelCount)pContext->aaudio.AAudioStreamBuilder_setChannelCount)(pBuilder, pConfig->capture.channels);
            }
            if (pDevice == NULL || !pDevice->capture.usingDefaultFormat) {
                ((MAL_PFN_AAudioStreamBuilder_setFormat)pContext->aaudio.AAudioStreamBuilder_setFormat)(pBuilder, (pConfig->capture.format == mal_format_s16) ? MAL_AAUDIO_FORMAT_PCM_I16 : MAL_AAUDIO_FORMAT_PCM_FLOAT);
            }
        } else {
            if (pDevice == NULL || !pDevice->playback.usingDefaultChannels) {
                ((MAL_PFN_AAudioStreamBuilder_setChannelCount)pContext->aaudio.AAudioStreamBuilder_setChannelCount)(pBuilder, pConfig->playback.channels);
            }
            if (pDevice == NULL || !pDevice->playback.usingDefaultFormat) {
                ((MAL_PFN_AAudioStreamBuilder_setFormat)pContext->aaudio.AAudioStreamBuilder_setFormat)(pBuilder, (pConfig->playback.format == mal_format_s16) ? MAL_AAUDIO_FORMAT_PCM_I16 : MAL_AAUDIO_FORMAT_PCM_FLOAT);
            }
        }

        mal_uint32 bufferCapacityInFrames = pConfig->bufferSizeInFrames;
        if (bufferCapacityInFrames == 0) {
            bufferCapacityInFrames = mal_calculate_buffer_size_in_frames_from_milliseconds(pConfig->bufferSizeInMilliseconds, pConfig->sampleRate);
        }
        ((MAL_PFN_AAudioStreamBuilder_setBufferCapacityInFrames)pContext->aaudio.AAudioStreamBuilder_setBufferCapacityInFrames)(pBuilder, bufferCapacityInFrames);

        /* TODO: Don't set the data callback when synchronous reading and writing is being used. */
        ((MAL_PFN_AAudioStreamBuilder_setFramesPerDataCallback)pContext->aaudio.AAudioStreamBuilder_setFramesPerDataCallback)(pBuilder, bufferCapacityInFrames / pConfig->periods);

        if (deviceType == mal_device_type_capture) {
            ((MAL_PFN_AAudioStreamBuilder_setDataCallback)pContext->aaudio.AAudioStreamBuilder_setDataCallback)(pBuilder, mal_stream_data_callback_capture__aaudio, (void*)pDevice);
        } else {
            ((MAL_PFN_AAudioStreamBuilder_setDataCallback)pContext->aaudio.AAudioStreamBuilder_setDataCallback)(pBuilder, mal_stream_data_callback_playback__aaudio, (void*)pDevice);
        }

        /* Not sure how this affects things, but since there's a mapping between mini_al's performance profiles and AAudio's performance modes, let go ahead and set it. */
        ((MAL_PFN_AAudioStreamBuilder_setPerformanceMode)pContext->aaudio.AAudioStreamBuilder_setPerformanceMode)(pBuilder, (pConfig->performanceProfile == mal_performance_profile_low_latency) ? MAL_AAUDIO_PERFORMANCE_MODE_LOW_LATENCY : MAL_AAUDIO_PERFORMANCE_MODE_NONE);
    }

    resultAA = ((MAL_PFN_AAudioStreamBuilder_openStream)pContext->aaudio.AAudioStreamBuilder_openStream)(pBuilder, ppStream);
    if (resultAA != MAL_AAUDIO_OK) {
        *ppStream = NULL;
        ((MAL_PFN_AAudioStreamBuilder_delete)pContext->aaudio.AAudioStreamBuilder_delete)(pBuilder);
        return mal_result_from_aaudio(resultAA);
    }

    ((MAL_PFN_AAudioStreamBuilder_delete)pContext->aaudio.AAudioStreamBuilder_delete)(pBuilder);
    return MAL_SUCCESS;
}

mal_result mal_close_stream__aaudio(mal_context* pContext, mal_AAudioStream* pStream)
{
    return mal_result_from_aaudio(((MAL_PFN_AAudioStream_close)pContext->aaudio.AAudioStream_close)(pStream));
}

mal_bool32 mal_has_default_device__aaudio(mal_context* pContext, mal_device_type deviceType)
{
    /* The only way to know this is to try creating a stream. */
    mal_AAudioStream* pStream;
    mal_result result = mal_open_stream__aaudio(pContext, deviceType, NULL, mal_share_mode_shared, NULL, NULL, &pStream);
    if (result != MAL_SUCCESS) {
        return MAL_FALSE;
    }

    mal_close_stream__aaudio(pContext, pStream);
    return MAL_TRUE;
}

mal_result mal_wait_for_simple_state_transition__aaudio(mal_context* pContext, mal_AAudioStream* pStream, mal_aaudio_stream_state_t oldState, mal_aaudio_stream_state_t newState)
{
    mal_aaudio_stream_state_t actualNewState;
    mal_aaudio_result_t resultAA = ((MAL_PFN_AAudioStream_waitForStateChange)pContext->aaudio.AAudioStream_waitForStateChange)(pStream, oldState, &actualNewState, 5000000000); /* 5 second timeout. */
    if (resultAA != MAL_AAUDIO_OK) {
        return mal_result_from_aaudio(resultAA);
    }

    if (newState != actualNewState) {
        return MAL_ERROR;   /* Failed to transition into the expected state. */
    }

    return MAL_SUCCESS;
}


mal_bool32 mal_context_is_device_id_equal__aaudio(mal_context* pContext, const mal_device_id* pID0, const mal_device_id* pID1)
{
    mal_assert(pContext != NULL);
    mal_assert(pID0 != NULL);
    mal_assert(pID1 != NULL);
    (void)pContext;

    return pID0->aaudio == pID1->aaudio;
}

mal_result mal_context_enumerate_devices__aaudio(mal_context* pContext, mal_enum_devices_callback_proc callback, void* pUserData)
{
    mal_bool32 cbResult = MAL_TRUE;

    mal_assert(pContext != NULL);
    mal_assert(callback != NULL);

    /* Unfortunately AAudio does not have an enumeration API. Therefore I'm only going to report default devices, but only if it can instantiate a stream. */

    /* Playback. */
    if (cbResult) {
        mal_device_info deviceInfo;
        mal_zero_object(&deviceInfo);
        deviceInfo.id.aaudio = MAL_AAUDIO_UNSPECIFIED;
        mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MAL_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);

        if (mal_has_default_device__aaudio(pContext, mal_device_type_playback)) {
            cbResult = callback(pContext, mal_device_type_playback, &deviceInfo, pUserData);
        }
    }

    /* Capture. */
    if (cbResult) {
        mal_device_info deviceInfo;
        mal_zero_object(&deviceInfo);
        deviceInfo.id.aaudio = MAL_AAUDIO_UNSPECIFIED;
        mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MAL_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);

        if (mal_has_default_device__aaudio(pContext, mal_device_type_capture)) {
            cbResult = callback(pContext, mal_device_type_capture, &deviceInfo, pUserData);
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_context_get_device_info__aaudio(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, mal_device_info* pDeviceInfo)
{
    mal_AAudioStream* pStream;
    mal_result result;

    mal_assert(pContext != NULL);

    /* No exclusive mode with AAudio. */
    if (shareMode == mal_share_mode_exclusive) {
        return MAL_SHARE_MODE_NOT_SUPPORTED;
    }

    /* ID */
    if (pDeviceID != NULL) {
        pDeviceInfo->id.aaudio = pDeviceID->aaudio;
    } else {
        pDeviceInfo->id.aaudio = MAL_AAUDIO_UNSPECIFIED;
    }
    
    /* Name */
    if (deviceType == mal_device_type_playback) {
        mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MAL_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
    } else {
        mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MAL_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
    }


    /* We'll need to open the device to get accurate sample rate and channel count information. */
    result = mal_open_stream__aaudio(pContext, deviceType, pDeviceID, shareMode, NULL, NULL, &pStream);
    if (result != MAL_SUCCESS) {
        return result;
    }

    pDeviceInfo->minChannels   = ((MAL_PFN_AAudioStream_getChannelCount)pContext->aaudio.AAudioStream_getChannelCount)(pStream);
    pDeviceInfo->maxChannels   = pDeviceInfo->minChannels;
    pDeviceInfo->minSampleRate = ((MAL_PFN_AAudioStream_getSampleRate)pContext->aaudio.AAudioStream_getSampleRate)(pStream);
    pDeviceInfo->maxSampleRate = pDeviceInfo->minSampleRate;

    mal_close_stream__aaudio(pContext, pStream);
    pStream = NULL;


    /* AAudio supports s16 and f32. */
    pDeviceInfo->formatCount = 2;
    pDeviceInfo->formats[0] = mal_format_s16;
    pDeviceInfo->formats[1] = mal_format_f32;

    return MAL_SUCCESS;
}


void mal_device_uninit__aaudio(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        mal_close_stream__aaudio(pDevice->pContext, (mal_AAudioStream*)pDevice->aaudio.pStreamCapture);
        pDevice->aaudio.pStreamCapture = NULL;
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        mal_close_stream__aaudio(pDevice->pContext, (mal_AAudioStream*)pDevice->aaudio.pStreamPlayback);
        pDevice->aaudio.pStreamPlayback = NULL;
    }

    if (pDevice->type == mal_device_type_duplex) {
        mal_pcm_rb_uninit(&pDevice->aaudio.duplexRB);
    }
}

mal_result mal_device_init__aaudio(mal_context* pContext, const mal_device_config* pConfig, mal_device* pDevice)
{
    mal_result result;

    mal_assert(pDevice != NULL);

    /* No exclusive mode with AAudio. */
    if (((pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) && pConfig->playback.shareMode == mal_share_mode_exclusive) ||
        ((pConfig->deviceType == mal_device_type_capture  || pConfig->deviceType == mal_device_type_duplex) && pConfig->capture.shareMode  == mal_share_mode_exclusive)) {
        return MAL_SHARE_MODE_NOT_SUPPORTED;
    }

    /* We first need to try opening the stream. */
    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        result = mal_open_stream__aaudio(pContext, mal_device_type_capture, pConfig->capture.pDeviceID, pConfig->capture.shareMode, pConfig, pDevice, (mal_AAudioStream**)&pDevice->aaudio.pStreamCapture);
        if (result != MAL_SUCCESS) {
            return result;  /* Failed to open the AAudio stream. */
        }

        pDevice->capture.internalFormat     = (((MAL_PFN_AAudioStream_getFormat)pContext->aaudio.AAudioStream_getFormat)((mal_AAudioStream*)pDevice->aaudio.pStreamCapture) == MAL_AAUDIO_FORMAT_PCM_I16) ? mal_format_s16 : mal_format_f32;
        pDevice->capture.internalChannels   = ((MAL_PFN_AAudioStream_getChannelCount)pContext->aaudio.AAudioStream_getChannelCount)((mal_AAudioStream*)pDevice->aaudio.pStreamCapture);
        pDevice->capture.internalSampleRate = ((MAL_PFN_AAudioStream_getSampleRate)pContext->aaudio.AAudioStream_getSampleRate)((mal_AAudioStream*)pDevice->aaudio.pStreamCapture);
        mal_get_standard_channel_map(mal_standard_channel_map_default, pDevice->capture.internalChannels, pDevice->capture.internalChannelMap); /* <-- Cannot find info on channel order, so assuming a default. */
        pDevice->capture.internalBufferSizeInFrames = ((MAL_PFN_AAudioStream_getBufferCapacityInFrames)pContext->aaudio.AAudioStream_getBufferCapacityInFrames)((mal_AAudioStream*)pDevice->aaudio.pStreamCapture);

        /* TODO: When synchronous reading and writing is supported, use AAudioStream_getFramesPerBurst() instead of AAudioStream_getFramesPerDataCallback(). Keep
         * using AAudioStream_getFramesPerDataCallback() for asynchronous mode, though. */
        int32_t framesPerPeriod = ((MAL_PFN_AAudioStream_getFramesPerDataCallback)pContext->aaudio.AAudioStream_getFramesPerDataCallback)((mal_AAudioStream*)pDevice->aaudio.pStreamCapture);
        if (framesPerPeriod > 0) {
            pDevice->capture.internalPeriods = 1;
        } else {
            pDevice->capture.internalPeriods = pDevice->capture.internalBufferSizeInFrames / framesPerPeriod;
        }
    }

    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        result = mal_open_stream__aaudio(pContext, mal_device_type_capture, pConfig->capture.pDeviceID, pConfig->capture.shareMode, pConfig, pDevice, (mal_AAudioStream**)&pDevice->aaudio.pStreamCapture);
        if (result != MAL_SUCCESS) {
            return result;  /* Failed to open the AAudio stream. */
        }

        pDevice->playback.internalFormat     = (((MAL_PFN_AAudioStream_getFormat)pContext->aaudio.AAudioStream_getFormat)((mal_AAudioStream*)pDevice->aaudio.pStreamPlayback) == MAL_AAUDIO_FORMAT_PCM_I16) ? mal_format_s16 : mal_format_f32;
        pDevice->playback.internalChannels   = ((MAL_PFN_AAudioStream_getChannelCount)pContext->aaudio.AAudioStream_getChannelCount)((mal_AAudioStream*)pDevice->aaudio.pStreamPlayback);
        pDevice->playback.internalSampleRate = ((MAL_PFN_AAudioStream_getSampleRate)pContext->aaudio.AAudioStream_getSampleRate)((mal_AAudioStream*)pDevice->aaudio.pStreamPlayback);
        mal_get_standard_channel_map(mal_standard_channel_map_default, pDevice->playback.internalChannels, pDevice->playback.internalChannelMap); /* <-- Cannot find info on channel order, so assuming a default. */
        pDevice->playback.internalBufferSizeInFrames = ((MAL_PFN_AAudioStream_getBufferCapacityInFrames)pContext->aaudio.AAudioStream_getBufferCapacityInFrames)((mal_AAudioStream*)pDevice->aaudio.pStreamPlayback);

        /* TODO: When synchronous reading and writing is supported, use AAudioStream_getFramesPerBurst() instead of AAudioStream_getFramesPerDataCallback(). Keep
         * using AAudioStream_getFramesPerDataCallback() for asynchronous mode, though. */
        int32_t framesPerPeriod = ((MAL_PFN_AAudioStream_getFramesPerDataCallback)pContext->aaudio.AAudioStream_getFramesPerDataCallback)((mal_AAudioStream*)pDevice->aaudio.pStreamPlayback);
        if (framesPerPeriod > 0) {
            pDevice->playback.internalPeriods = 1;
        } else {
            pDevice->playback.internalPeriods = pDevice->playback.internalBufferSizeInFrames / framesPerPeriod;
        }
    }

    if (pConfig->deviceType == mal_device_type_duplex) {
        mal_uint32 rbSizeInFrames = (mal_uint32)mal_calculate_frame_count_after_src(pDevice->sampleRate, pDevice->capture.internalSampleRate, pDevice->capture.internalBufferSizeInFrames);
        mal_result result = mal_pcm_rb_init(pDevice->capture.format, pDevice->capture.channels, rbSizeInFrames, NULL, &pDevice->aaudio.duplexRB);
        if (result != MAL_SUCCESS) {
            if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
                mal_close_stream__aaudio(pDevice->pContext, (mal_AAudioStream*)pDevice->aaudio.pStreamCapture);
            }
            if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
                mal_close_stream__aaudio(pDevice->pContext, (mal_AAudioStream*)pDevice->aaudio.pStreamPlayback);
            }
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[AAudio] Failed to initialize ring buffer.", result);
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_device_start_stream__aaudio(mal_device* pDevice, mal_AAudioStream* pStream)
{
    mal_aaudio_result_t resultAA;

    mal_assert(pDevice != NULL);

    resultAA = ((MAL_PFN_AAudioStream_requestStart)pDevice->pContext->aaudio.AAudioStream_requestStart)(pStream);
    if (resultAA != MAL_AAUDIO_OK) {
        return mal_result_from_aaudio(resultAA);
    }

    /* Do we actually need to wait for the device to transition into it's started state? */

    /* The device should be in either a starting or started state. If it's not set to started we need to wait for it to transition. It should go from starting to started. */
    mal_aaudio_stream_state_t currentState = ((MAL_PFN_AAudioStream_getState)pDevice->pContext->aaudio.AAudioStream_getState)(pStream);
    if (currentState != MAL_AAUDIO_STREAM_STATE_STARTED) {
        mal_result result;

        if (currentState != MAL_AAUDIO_STREAM_STATE_STARTING) {
            return MAL_ERROR;   /* Expecting the stream to be a starting or started state. */
        }

        result = mal_wait_for_simple_state_transition__aaudio(pDevice->pContext, pStream, currentState, MAL_AAUDIO_STREAM_STATE_STARTED);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_device_stop_stream__aaudio(mal_device* pDevice, mal_AAudioStream* pStream)
{
    mal_aaudio_result_t resultAA;

    mal_assert(pDevice != NULL);

    resultAA = ((MAL_PFN_AAudioStream_requestStop)pDevice->pContext->aaudio.AAudioStream_requestStop)(pStream);
    if (resultAA != MAL_AAUDIO_OK) {
        return mal_result_from_aaudio(resultAA);
    }

    /* The device should be in either a stopping or stopped state. If it's not set to started we need to wait for it to transition. It should go from stopping to stopped. */
    mal_aaudio_stream_state_t currentState = ((MAL_PFN_AAudioStream_getState)pDevice->pContext->aaudio.AAudioStream_getState)(pStream);
    if (currentState != MAL_AAUDIO_STREAM_STATE_STOPPED) {
        mal_result result;

        if (currentState != MAL_AAUDIO_STREAM_STATE_STOPPING) {
            return MAL_ERROR;   /* Expecting the stream to be a stopping or stopped state. */
        }

        result = mal_wait_for_simple_state_transition__aaudio(pDevice->pContext, pStream, currentState, MAL_AAUDIO_STREAM_STATE_STOPPED);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_device_start__aaudio(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        mal_result result = mal_device_start_stream__aaudio(pDevice, (mal_AAudioStream*)pDevice->aaudio.pStreamCapture);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        mal_result result = mal_device_start_stream__aaudio(pDevice, (mal_AAudioStream*)pDevice->aaudio.pStreamPlayback);
        if (result != MAL_SUCCESS) {
            if (pDevice->type == mal_device_type_duplex) {
                mal_device_stop_stream__aaudio(pDevice, (mal_AAudioStream*)pDevice->aaudio.pStreamCapture);
            }
            return result;
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_device_stop__aaudio(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        mal_result result = mal_device_stop_stream__aaudio(pDevice, (mal_AAudioStream*)pDevice->aaudio.pStreamCapture);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        mal_result result = mal_device_stop_stream__aaudio(pDevice, (mal_AAudioStream*)pDevice->aaudio.pStreamPlayback);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    mal_stop_proc onStop = pDevice->onStop;
    if (onStop) {
        onStop(pDevice);
    }

    return MAL_SUCCESS;
}


mal_result mal_context_uninit__aaudio(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    mal_assert(pContext->backend == mal_backend_aaudio);
    
    mal_dlclose(pContext->aaudio.hAAudio);
    pContext->aaudio.hAAudio = NULL;

    return MAL_SUCCESS;
}

mal_result mal_context_init__aaudio(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    (void)pContext;

    const char* libNames[] = {
        "libaaudio.so"
    };

    for (size_t i = 0; i < mal_countof(libNames); ++i) {
        pContext->aaudio.hAAudio = mal_dlopen(libNames[i]);
        if (pContext->aaudio.hAAudio != NULL) {
            break;
        }
    }

    if (pContext->aaudio.hAAudio == NULL) {
        return MAL_FAILED_TO_INIT_BACKEND;
    }

    pContext->aaudio.AAudio_createStreamBuilder                    = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudio_createStreamBuilder");
    pContext->aaudio.AAudioStreamBuilder_delete                    = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStreamBuilder_delete");
    pContext->aaudio.AAudioStreamBuilder_setDeviceId               = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStreamBuilder_setDeviceId");
    pContext->aaudio.AAudioStreamBuilder_setDirection              = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStreamBuilder_setDirection");
    pContext->aaudio.AAudioStreamBuilder_setSharingMode            = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStreamBuilder_setSharingMode");
    pContext->aaudio.AAudioStreamBuilder_setFormat                 = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStreamBuilder_setFormat");
    pContext->aaudio.AAudioStreamBuilder_setChannelCount           = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStreamBuilder_setChannelCount");
    pContext->aaudio.AAudioStreamBuilder_setSampleRate             = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStreamBuilder_setSampleRate");
    pContext->aaudio.AAudioStreamBuilder_setBufferCapacityInFrames = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStreamBuilder_setBufferCapacityInFrames");
    pContext->aaudio.AAudioStreamBuilder_setFramesPerDataCallback  = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStreamBuilder_setFramesPerDataCallback");
    pContext->aaudio.AAudioStreamBuilder_setDataCallback           = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStreamBuilder_setDataCallback");
    pContext->aaudio.AAudioStreamBuilder_setPerformanceMode        = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStreamBuilder_setPerformanceMode");
    pContext->aaudio.AAudioStreamBuilder_openStream                = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStreamBuilder_openStream");
    pContext->aaudio.AAudioStream_close                            = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStream_close");
    pContext->aaudio.AAudioStream_getState                         = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStream_getState");
    pContext->aaudio.AAudioStream_waitForStateChange               = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStream_waitForStateChange");
    pContext->aaudio.AAudioStream_getFormat                        = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStream_getFormat");
    pContext->aaudio.AAudioStream_getChannelCount                  = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStream_getChannelCount");
    pContext->aaudio.AAudioStream_getSampleRate                    = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStream_getSampleRate");
    pContext->aaudio.AAudioStream_getBufferCapacityInFrames        = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStream_getBufferCapacityInFrames");
    pContext->aaudio.AAudioStream_getFramesPerDataCallback         = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStream_getFramesPerDataCallback");
    pContext->aaudio.AAudioStream_getFramesPerBurst                = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStream_getFramesPerBurst");
    pContext->aaudio.AAudioStream_requestStart                     = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStream_requestStart");
    pContext->aaudio.AAudioStream_requestStop                      = (mal_proc)mal_dlsym(pContext->aaudio.hAAudio, "AAudioStream_requestStop");

    pContext->isBackendAsynchronous = MAL_TRUE;

    pContext->onUninit        = mal_context_uninit__aaudio;
    pContext->onDeviceIDEqual = mal_context_is_device_id_equal__aaudio;
    pContext->onEnumDevices   = mal_context_enumerate_devices__aaudio;
    pContext->onGetDeviceInfo = mal_context_get_device_info__aaudio;
    pContext->onDeviceInit    = mal_device_init__aaudio;
    pContext->onDeviceUninit  = mal_device_uninit__aaudio;
    pContext->onDeviceStart   = mal_device_start__aaudio;
    pContext->onDeviceStop    = mal_device_stop__aaudio;

    return MAL_SUCCESS;
}
#endif  // AAudio


///////////////////////////////////////////////////////////////////////////////
//
// OpenSL|ES Backend
//
///////////////////////////////////////////////////////////////////////////////
#ifdef MAL_HAS_OPENSL
#include <SLES/OpenSLES.h>
#ifdef MAL_ANDROID
#include <SLES/OpenSLES_Android.h>
#endif

// OpenSL|ES has one-per-application objects :(
SLObjectItf g_malEngineObjectSL = NULL;
SLEngineItf g_malEngineSL = NULL;
mal_uint32 g_malOpenSLInitCounter = 0;

#define MAL_OPENSL_OBJ(p)         (*((SLObjectItf)(p)))
#define MAL_OPENSL_OUTPUTMIX(p)   (*((SLOutputMixItf)(p)))
#define MAL_OPENSL_PLAY(p)        (*((SLPlayItf)(p)))
#define MAL_OPENSL_RECORD(p)      (*((SLRecordItf)(p)))

#ifdef MAL_ANDROID
#define MAL_OPENSL_BUFFERQUEUE(p) (*((SLAndroidSimpleBufferQueueItf)(p)))
#else
#define MAL_OPENSL_BUFFERQUEUE(p) (*((SLBufferQueueItf)(p)))
#endif

// Converts an individual OpenSL-style channel identifier (SL_SPEAKER_FRONT_LEFT, etc.) to mini_al.
mal_uint8 mal_channel_id_to_mal__opensl(SLuint32 id)
{
    switch (id)
    {
        case SL_SPEAKER_FRONT_LEFT:            return MAL_CHANNEL_FRONT_LEFT;
        case SL_SPEAKER_FRONT_RIGHT:           return MAL_CHANNEL_FRONT_RIGHT;
        case SL_SPEAKER_FRONT_CENTER:          return MAL_CHANNEL_FRONT_CENTER;
        case SL_SPEAKER_LOW_FREQUENCY:         return MAL_CHANNEL_LFE;
        case SL_SPEAKER_BACK_LEFT:             return MAL_CHANNEL_BACK_LEFT;
        case SL_SPEAKER_BACK_RIGHT:            return MAL_CHANNEL_BACK_RIGHT;
        case SL_SPEAKER_FRONT_LEFT_OF_CENTER:  return MAL_CHANNEL_FRONT_LEFT_CENTER;
        case SL_SPEAKER_FRONT_RIGHT_OF_CENTER: return MAL_CHANNEL_FRONT_RIGHT_CENTER;
        case SL_SPEAKER_BACK_CENTER:           return MAL_CHANNEL_BACK_CENTER;
        case SL_SPEAKER_SIDE_LEFT:             return MAL_CHANNEL_SIDE_LEFT;
        case SL_SPEAKER_SIDE_RIGHT:            return MAL_CHANNEL_SIDE_RIGHT;
        case SL_SPEAKER_TOP_CENTER:            return MAL_CHANNEL_TOP_CENTER;
        case SL_SPEAKER_TOP_FRONT_LEFT:        return MAL_CHANNEL_TOP_FRONT_LEFT;
        case SL_SPEAKER_TOP_FRONT_CENTER:      return MAL_CHANNEL_TOP_FRONT_CENTER;
        case SL_SPEAKER_TOP_FRONT_RIGHT:       return MAL_CHANNEL_TOP_FRONT_RIGHT;
        case SL_SPEAKER_TOP_BACK_LEFT:         return MAL_CHANNEL_TOP_BACK_LEFT;
        case SL_SPEAKER_TOP_BACK_CENTER:       return MAL_CHANNEL_TOP_BACK_CENTER;
        case SL_SPEAKER_TOP_BACK_RIGHT:        return MAL_CHANNEL_TOP_BACK_RIGHT;
        default: return 0;
    }
}

// Converts an individual mini_al channel identifier (MAL_CHANNEL_FRONT_LEFT, etc.) to OpenSL-style.
SLuint32 mal_channel_id_to_opensl(mal_uint8 id)
{
    switch (id)
    {
        case MAL_CHANNEL_MONO:               return SL_SPEAKER_FRONT_CENTER;
        case MAL_CHANNEL_FRONT_LEFT:         return SL_SPEAKER_FRONT_LEFT;
        case MAL_CHANNEL_FRONT_RIGHT:        return SL_SPEAKER_FRONT_RIGHT;
        case MAL_CHANNEL_FRONT_CENTER:       return SL_SPEAKER_FRONT_CENTER;
        case MAL_CHANNEL_LFE:                return SL_SPEAKER_LOW_FREQUENCY;
        case MAL_CHANNEL_BACK_LEFT:          return SL_SPEAKER_BACK_LEFT;
        case MAL_CHANNEL_BACK_RIGHT:         return SL_SPEAKER_BACK_RIGHT;
        case MAL_CHANNEL_FRONT_LEFT_CENTER:  return SL_SPEAKER_FRONT_LEFT_OF_CENTER;
        case MAL_CHANNEL_FRONT_RIGHT_CENTER: return SL_SPEAKER_FRONT_RIGHT_OF_CENTER;
        case MAL_CHANNEL_BACK_CENTER:        return SL_SPEAKER_BACK_CENTER;
        case MAL_CHANNEL_SIDE_LEFT:          return SL_SPEAKER_SIDE_LEFT;
        case MAL_CHANNEL_SIDE_RIGHT:         return SL_SPEAKER_SIDE_RIGHT;
        case MAL_CHANNEL_TOP_CENTER:         return SL_SPEAKER_TOP_CENTER;
        case MAL_CHANNEL_TOP_FRONT_LEFT:     return SL_SPEAKER_TOP_FRONT_LEFT;
        case MAL_CHANNEL_TOP_FRONT_CENTER:   return SL_SPEAKER_TOP_FRONT_CENTER;
        case MAL_CHANNEL_TOP_FRONT_RIGHT:    return SL_SPEAKER_TOP_FRONT_RIGHT;
        case MAL_CHANNEL_TOP_BACK_LEFT:      return SL_SPEAKER_TOP_BACK_LEFT;
        case MAL_CHANNEL_TOP_BACK_CENTER:    return SL_SPEAKER_TOP_BACK_CENTER;
        case MAL_CHANNEL_TOP_BACK_RIGHT:     return SL_SPEAKER_TOP_BACK_RIGHT;
        default: return 0;
    }
}

// Converts a channel mapping to an OpenSL-style channel mask.
SLuint32 mal_channel_map_to_channel_mask__opensl(const mal_channel channelMap[MAL_MAX_CHANNELS], mal_uint32 channels)
{
    SLuint32 channelMask = 0;
    for (mal_uint32 iChannel = 0; iChannel < channels; ++iChannel) {
        channelMask |= mal_channel_id_to_opensl(channelMap[iChannel]);
    }

    return channelMask;
}

// Converts an OpenSL-style channel mask to a mini_al channel map.
void mal_channel_mask_to_channel_map__opensl(SLuint32 channelMask, mal_uint32 channels, mal_channel channelMap[MAL_MAX_CHANNELS])
{
    if (channels == 1 && channelMask == 0) {
        channelMap[0] = MAL_CHANNEL_MONO;
    } else if (channels == 2 && channelMask == 0) {
        channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
        channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
    } else {
        if (channels == 1 && (channelMask & SL_SPEAKER_FRONT_CENTER) != 0) {
            channelMap[0] = MAL_CHANNEL_MONO;
        } else {
            // Just iterate over each bit.
            mal_uint32 iChannel = 0;
            for (mal_uint32 iBit = 0; iBit < 32; ++iBit) {
                SLuint32 bitValue = (channelMask & (1UL << iBit));
                if (bitValue != 0) {
                    // The bit is set.
                    channelMap[iChannel] = mal_channel_id_to_mal__opensl(bitValue);
                    iChannel += 1;
                }
            }
        }
    }
}

SLuint32 mal_round_to_standard_sample_rate__opensl(SLuint32 samplesPerSec)
{
    if (samplesPerSec <= SL_SAMPLINGRATE_8) {
        return SL_SAMPLINGRATE_8;
    }
    if (samplesPerSec <= SL_SAMPLINGRATE_11_025) {
        return SL_SAMPLINGRATE_11_025;
    }
    if (samplesPerSec <= SL_SAMPLINGRATE_12) {
        return SL_SAMPLINGRATE_12;
    }
    if (samplesPerSec <= SL_SAMPLINGRATE_16) {
        return SL_SAMPLINGRATE_16;
    }
    if (samplesPerSec <= SL_SAMPLINGRATE_22_05) {
        return SL_SAMPLINGRATE_22_05;
    }
    if (samplesPerSec <= SL_SAMPLINGRATE_24) {
        return SL_SAMPLINGRATE_24;
    }
    if (samplesPerSec <= SL_SAMPLINGRATE_32) {
        return SL_SAMPLINGRATE_32;
    }
    if (samplesPerSec <= SL_SAMPLINGRATE_44_1) {
        return SL_SAMPLINGRATE_44_1;
    }
    if (samplesPerSec <= SL_SAMPLINGRATE_48) {
        return SL_SAMPLINGRATE_48;
    }

    // Android doesn't support more than 48000.
#ifndef MAL_ANDROID
    if (samplesPerSec <= SL_SAMPLINGRATE_64) {
        return SL_SAMPLINGRATE_64;
    }
    if (samplesPerSec <= SL_SAMPLINGRATE_88_2) {
        return SL_SAMPLINGRATE_88_2;
    }
    if (samplesPerSec <= SL_SAMPLINGRATE_96) {
        return SL_SAMPLINGRATE_96;
    }
    if (samplesPerSec <= SL_SAMPLINGRATE_192) {
        return SL_SAMPLINGRATE_192;
    }
#endif

    return SL_SAMPLINGRATE_16;
}


mal_bool32 mal_context_is_device_id_equal__opensl(mal_context* pContext, const mal_device_id* pID0, const mal_device_id* pID1)
{
    mal_assert(pContext != NULL);
    mal_assert(pID0 != NULL);
    mal_assert(pID1 != NULL);
    (void)pContext;

    return pID0->opensl == pID1->opensl;
}

mal_result mal_context_enumerate_devices__opensl(mal_context* pContext, mal_enum_devices_callback_proc callback, void* pUserData)
{
    mal_assert(pContext != NULL);
    mal_assert(callback != NULL);

    mal_assert(g_malOpenSLInitCounter > 0); /* <-- If you trigger this it means you've either not initialized the context, or you've uninitialized it and then attempted to enumerate devices. */
    if (g_malOpenSLInitCounter == 0) {
        return MAL_INVALID_OPERATION;
    }

    // TODO: Test Me.
    //
    // This is currently untested, so for now we are just returning default devices.
#if 0 && !defined(MAL_ANDROID)
    mal_bool32 isTerminated = MAL_FALSE;

    SLuint32 pDeviceIDs[128];
    SLint32 deviceCount = sizeof(pDeviceIDs) / sizeof(pDeviceIDs[0]);

    SLAudioIODeviceCapabilitiesItf deviceCaps;
    SLresult resultSL = (*g_malEngineObjectSL)->GetInterface(g_malEngineObjectSL, SL_IID_AUDIOIODEVICECAPABILITIES, &deviceCaps);
    if (resultSL != SL_RESULT_SUCCESS) {
        // The interface may not be supported so just report a default device.
        goto return_default_device;
    }

    // Playback
    if (!isTerminated) {
        resultSL = (*deviceCaps)->GetAvailableAudioOutputs(deviceCaps, &deviceCount, pDeviceIDs);
        if (resultSL != SL_RESULT_SUCCESS) {
            return MAL_NO_DEVICE;
        }

        for (SLint32 iDevice = 0; iDevice < deviceCount; ++iDevice) {
            mal_device_info deviceInfo;
            mal_zero_object(&deviceInfo);
            deviceInfo.id.opensl = pDeviceIDs[iDevice];

            SLAudioOutputDescriptor desc;
            resultSL = (*deviceCaps)->QueryAudioOutputCapabilities(deviceCaps, deviceInfo.id.opensl, &desc);
            if (resultSL == SL_RESULT_SUCCESS) {
                mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), (const char*)desc.pDeviceName, (size_t)-1);

                mal_bool32 cbResult = callback(pContext, mal_device_type_playback, &deviceInfo, pUserData);
                if (cbResult == MAL_FALSE) {
                    isTerminated = MAL_TRUE;
                    break;
                }
            }
        }
    }

    // Capture
    if (!isTerminated) {
        resultSL = (*deviceCaps)->GetAvailableAudioInputs(deviceCaps, &deviceCount, pDeviceIDs);
        if (resultSL != SL_RESULT_SUCCESS) {
            return MAL_NO_DEVICE;
        }

        for (SLint32 iDevice = 0; iDevice < deviceCount; ++iDevice) {
            mal_device_info deviceInfo;
            mal_zero_object(&deviceInfo);
            deviceInfo.id.opensl = pDeviceIDs[iDevice];

            SLAudioInputDescriptor desc;
            resultSL = (*deviceCaps)->QueryAudioInputCapabilities(deviceCaps, deviceInfo.id.opensl, &desc);
            if (resultSL == SL_RESULT_SUCCESS) {
                mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), (const char*)desc.deviceName, (size_t)-1);

                mal_bool32 cbResult = callback(pContext, mal_device_type_capture, &deviceInfo, pUserData);
                if (cbResult == MAL_FALSE) {
                    isTerminated = MAL_TRUE;
                    break;
                }
            }
        }
    }

    return MAL_SUCCESS;
#else
    goto return_default_device;
#endif

return_default_device:;
    mal_bool32 cbResult = MAL_TRUE;

    // Playback.
    if (cbResult) {
        mal_device_info deviceInfo;
        mal_zero_object(&deviceInfo);
        mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MAL_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
        cbResult = callback(pContext, mal_device_type_playback, &deviceInfo, pUserData);
    }

    // Capture.
    if (cbResult) {
        mal_device_info deviceInfo;
        mal_zero_object(&deviceInfo);
        mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MAL_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
        cbResult = callback(pContext, mal_device_type_capture, &deviceInfo, pUserData);
    }

    return MAL_SUCCESS;
}

mal_result mal_context_get_device_info__opensl(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, mal_device_info* pDeviceInfo)
{
    mal_assert(pContext != NULL);

    mal_assert(g_malOpenSLInitCounter > 0); /* <-- If you trigger this it means you've either not initialized the context, or you've uninitialized it and then attempted to get device info. */
    if (g_malOpenSLInitCounter == 0) {
        return MAL_INVALID_OPERATION;
    }

    /* No exclusive mode with OpenSL|ES. */
    if (shareMode == mal_share_mode_exclusive) {
        return MAL_SHARE_MODE_NOT_SUPPORTED;
    }

    // TODO: Test Me.
    //
    // This is currently untested, so for now we are just returning default devices.
#if 0 && !defined(MAL_ANDROID)
    SLAudioIODeviceCapabilitiesItf deviceCaps;
    SLresult resultSL = (*g_malEngineObjectSL)->GetInterface(g_malEngineObjectSL, SL_IID_AUDIOIODEVICECAPABILITIES, &deviceCaps);
    if (resultSL != SL_RESULT_SUCCESS) {
        // The interface may not be supported so just report a default device.
        goto return_default_device;
    }

    if (deviceType == mal_device_type_playback) {
        SLAudioOutputDescriptor desc;
        resultSL = (*deviceCaps)->QueryAudioOutputCapabilities(deviceCaps, pDeviceID->opensl, &desc);
        if (resultSL != SL_RESULT_SUCCESS) {
            return MAL_NO_DEVICE;
        }

        mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), (const char*)desc.pDeviceName, (size_t)-1);
    } else {
        SLAudioInputDescriptor desc;
        resultSL = (*deviceCaps)->QueryAudioInputCapabilities(deviceCaps, pDeviceID->opensl, &desc);
        if (resultSL != SL_RESULT_SUCCESS) {
            return MAL_NO_DEVICE;
        }

        mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), (const char*)desc.deviceName, (size_t)-1);
    }

    goto return_detailed_info;
#else
    goto return_default_device;
#endif

return_default_device:
    if (pDeviceID != NULL) {
        if ((deviceType == mal_device_type_playback && pDeviceID->opensl != SL_DEFAULTDEVICEID_AUDIOOUTPUT) ||
            (deviceType == mal_device_type_capture  && pDeviceID->opensl != SL_DEFAULTDEVICEID_AUDIOINPUT)) {
            return MAL_NO_DEVICE;   // Don't know the device.
        }
    }

    // Name / Description
    if (deviceType == mal_device_type_playback) {
        mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MAL_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
    } else {
        mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MAL_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
    }

    goto return_detailed_info;


return_detailed_info:

    // For now we're just outputting a set of values that are supported by the API but not necessarily supported
    // by the device natively. Later on we should work on this so that it more closely reflects the device's
    // actual native format.
    pDeviceInfo->minChannels = 1;
    pDeviceInfo->maxChannels = 2;
    pDeviceInfo->minSampleRate = 8000;
    pDeviceInfo->maxSampleRate = 48000;
    pDeviceInfo->formatCount = 2;
    pDeviceInfo->formats[0] = mal_format_u8;
    pDeviceInfo->formats[1] = mal_format_s16;
#if defined(MAL_ANDROID) && __ANDROID_API__ >= 21
    pDeviceInfo->formats[pDeviceInfo->formatCount] = mal_format_f32;
    pDeviceInfo->formatCount += 1;
#endif

    return MAL_SUCCESS;
}


#ifdef MAL_ANDROID
//void mal_buffer_queue_callback_capture__opensl_android(SLAndroidSimpleBufferQueueItf pBufferQueue, SLuint32 eventFlags, const void* pBuffer, SLuint32 bufferSize, SLuint32 dataUsed, void* pContext)
void mal_buffer_queue_callback_capture__opensl_android(SLAndroidSimpleBufferQueueItf pBufferQueue, void* pUserData)
{
    mal_device* pDevice = (mal_device*)pUserData;
    mal_assert(pDevice != NULL);

    (void)pBufferQueue;

    // For now, don't do anything unless the buffer was fully processed. From what I can tell, it looks like
    // OpenSL|ES 1.1 improves on buffer queues to the point that we could much more intelligently handle this,
    // but unfortunately it looks like Android is only supporting OpenSL|ES 1.0.1 for now :(

    /* Don't do anything if the device is not started. */
    if (pDevice->state != MAL_STATE_STARTED) {
        return;
    }

    size_t periodSizeInBytes = (pDevice->capture.internalBufferSizeInFrames / pDevice->capture.internalPeriods) * mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
    mal_uint8* pBuffer = pDevice->opensl.pBufferCapture + (pDevice->opensl.currentBufferIndexCapture * periodSizeInBytes);

    if (pDevice->type == mal_device_type_duplex) {
        mal_device__handle_duplex_callback_capture(pDevice, (pDevice->capture.internalBufferSizeInFrames / pDevice->capture.internalPeriods), pBuffer, &pDevice->opensl.duplexRB);
    } else {
        mal_device__send_frames_to_client(pDevice, (pDevice->capture.internalBufferSizeInFrames / pDevice->capture.internalPeriods), pBuffer);
    }

    SLresult resultSL = MAL_OPENSL_BUFFERQUEUE(pDevice->opensl.pBufferQueueCapture)->Enqueue((SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueueCapture, pBuffer, periodSizeInBytes);
    if (resultSL != SL_RESULT_SUCCESS) {
        return;
    }

    pDevice->opensl.currentBufferIndexCapture = (pDevice->opensl.currentBufferIndexCapture + 1) % pDevice->capture.internalPeriods;
}

void mal_buffer_queue_callback_playback__opensl_android(SLAndroidSimpleBufferQueueItf pBufferQueue, void* pUserData)
{
    mal_device* pDevice = (mal_device*)pUserData;
    mal_assert(pDevice != NULL);

    (void)pBufferQueue;

    /* Don't do anything if the device is not started. */
    if (pDevice->state != MAL_STATE_STARTED) {
        return;
    }

    size_t periodSizeInBytes = (pDevice->playback.internalBufferSizeInFrames / pDevice->playback.internalPeriods) * mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
    mal_uint8* pBuffer = pDevice->opensl.pBufferPlayback + (pDevice->opensl.currentBufferIndexPlayback * periodSizeInBytes);

    if (pDevice->type == mal_device_type_duplex) {
        mal_device__handle_duplex_callback_playback(pDevice, (pDevice->playback.internalBufferSizeInFrames / pDevice->playback.internalPeriods), pBuffer, &pDevice->opensl.duplexRB);
    } else {
        mal_device__read_frames_from_client(pDevice, (pDevice->playback.internalBufferSizeInFrames / pDevice->playback.internalPeriods), pBuffer);
    }

    SLresult resultSL = MAL_OPENSL_BUFFERQUEUE(pDevice->opensl.pBufferQueuePlayback)->Enqueue((SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueuePlayback, pBuffer, periodSizeInBytes);
    if (resultSL != SL_RESULT_SUCCESS) {
        return;
    }

    pDevice->opensl.currentBufferIndexPlayback = (pDevice->opensl.currentBufferIndexPlayback + 1) % pDevice->playback.internalPeriods;
}
#endif

void mal_device_uninit__opensl(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    mal_assert(g_malOpenSLInitCounter > 0); /* <-- If you trigger this it means you've either not initialized the context, or you've uninitialized it before uninitializing the device. */
    if (g_malOpenSLInitCounter == 0) {
        return;
    }

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        if (pDevice->opensl.pAudioRecorderObj) {
            MAL_OPENSL_OBJ(pDevice->opensl.pAudioRecorderObj)->Destroy((SLObjectItf)pDevice->opensl.pAudioRecorderObj);
        }

        mal_free(pDevice->opensl.pBufferCapture);
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        if (pDevice->opensl.pAudioPlayerObj) {
            MAL_OPENSL_OBJ(pDevice->opensl.pAudioPlayerObj)->Destroy((SLObjectItf)pDevice->opensl.pAudioPlayerObj);
        }
        if (pDevice->opensl.pOutputMixObj) {
            MAL_OPENSL_OBJ(pDevice->opensl.pOutputMixObj)->Destroy((SLObjectItf)pDevice->opensl.pOutputMixObj);
        }

        mal_free(pDevice->opensl.pBufferPlayback);
    }

    if (pDevice->type == mal_device_type_duplex) {
        mal_pcm_rb_uninit(&pDevice->opensl.duplexRB);
    }
}

#if defined(MAL_ANDROID) && __ANDROID_API__ >= 21
typedef SLAndroidDataFormat_PCM_EX  mal_SLDataFormat_PCM;
#else
typedef SLDataFormat_PCM            mal_SLDataFormat_PCM;
#endif

mal_result mal_SLDataFormat_PCM_init__opensl(mal_format format, mal_uint32 channels, mal_uint32 sampleRate, const mal_channel* channelMap, mal_SLDataFormat_PCM* pDataFormat)
{
#if defined(MAL_ANDROID) && __ANDROID_API__ >= 21
    if (format == mal_format_f32) {
        pDataFormat->formatType     = SL_ANDROID_DATAFORMAT_PCM_EX;
        pDataFormat->representation = SL_ANDROID_PCM_REPRESENTATION_FLOAT;
    } else {
        pDataFormat->formatType = SL_DATAFORMAT_PCM;
    }
#else
    pDataFormat->formatType = SL_DATAFORMAT_PCM;
#endif

    pDataFormat->numChannels   = channels;
    ((SLDataFormat_PCM*)pDataFormat)->samplesPerSec = mal_round_to_standard_sample_rate__opensl(sampleRate * 1000);  /* In millihertz. Annoyingly, the sample rate variable is named differently between SLAndroidDataFormat_PCM_EX and SLDataFormat_PCM */
    pDataFormat->bitsPerSample = mal_get_bytes_per_sample(format)*8;
    pDataFormat->channelMask   = mal_channel_map_to_channel_mask__opensl(channelMap, channels);
    pDataFormat->endianness    = (mal_is_little_endian()) ? SL_BYTEORDER_LITTLEENDIAN : SL_BYTEORDER_BIGENDIAN;

    /*
    Android has a few restrictions on the format as documented here: https://developer.android.com/ndk/guides/audio/opensl-for-android.html
     - Only mono and stereo is supported.
     - Only u8 and s16 formats are supported.
     - Maximum sample rate of 48000.
    */
#ifdef MAL_ANDROID
    if (pDataFormat->numChannels > 2) {
        pDataFormat->numChannels = 2;
    }
#if __ANDROID_API__ >= 21
    if (pDataFormat->formatType == SL_ANDROID_DATAFORMAT_PCM_EX) {
        /* It's floating point. */
        mal_assert(pDataFormat->representation == SL_ANDROID_PCM_REPRESENTATION_FLOAT);
        if (pDataFormat->bitsPerSample > 32) {
            pDataFormat->bitsPerSample = 32;
        }
    } else {
        if (pDataFormat->bitsPerSample > 16) {
            pDataFormat->bitsPerSample = 16;
        }
    }
#else
    if (pDataFormat->bitsPerSample > 16) {
        pDataFormat->bitsPerSample = 16;
    }
#endif
    if (((SLDataFormat_PCM*)pDataFormat)->samplesPerSec > SL_SAMPLINGRATE_48) {
        ((SLDataFormat_PCM*)pDataFormat)->samplesPerSec = SL_SAMPLINGRATE_48;
    }
#endif

    pDataFormat->containerSize = pDataFormat->bitsPerSample;  /* Always tightly packed for now. */

    return MAL_SUCCESS;
}

mal_result mal_deconstruct_SLDataFormat_PCM__opensl(mal_SLDataFormat_PCM* pDataFormat, mal_format* pFormat, mal_uint32* pChannels, mal_uint32* pSampleRate, mal_channel* pChannelMap)
{
    mal_bool32 isFloatingPoint = MAL_FALSE;
#if defined(MAL_ANDROID) && __ANDROID_API__ >= 21
    if (pDataFormat->formatType == SL_ANDROID_DATAFORMAT_PCM_EX) {
        mal_assert(pDataFormat->representation == SL_ANDROID_PCM_REPRESENTATION_FLOAT);
        isFloatingPoint = MAL_TRUE;
    }
#endif
    if (isFloatingPoint) {
        if (pDataFormat->bitsPerSample == 32) {
            *pFormat = mal_format_f32;
        }
    } else {
        if (pDataFormat->bitsPerSample == 8) {
            *pFormat = mal_format_u8;
        } else if (pDataFormat->bitsPerSample == 16) {
            *pFormat = mal_format_s16;
        } else if (pDataFormat->bitsPerSample == 24) {
            *pFormat = mal_format_s24;
        } else if (pDataFormat->bitsPerSample == 32) {
            *pFormat = mal_format_s32;
        }
    }

    *pChannels   = pDataFormat->numChannels;
    *pSampleRate = ((SLDataFormat_PCM*)pDataFormat)->samplesPerSec / 1000;
    mal_channel_mask_to_channel_map__opensl(pDataFormat->channelMask, pDataFormat->numChannels, pChannelMap);

    return MAL_SUCCESS;
}

mal_result mal_device_init__opensl(mal_context* pContext, const mal_device_config* pConfig, mal_device* pDevice)
{
    (void)pContext;

    mal_assert(g_malOpenSLInitCounter > 0); /* <-- If you trigger this it means you've either not initialized the context, or you've uninitialized it and then attempted to initialize a new device. */
    if (g_malOpenSLInitCounter == 0) {
        return MAL_INVALID_OPERATION;
    }

    /*
    For now, only supporting Android implementations of OpenSL|ES since that's the only one I've
    been able to test with and I currently depend on Android-specific extensions (simple buffer
    queues).
    */
#ifndef MAL_ANDROID
    return MAL_NO_BACKEND;
#endif

    /* No exclusive mode with OpenSL|ES. */
    if (((pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) && pConfig->playback.shareMode == mal_share_mode_exclusive) ||
        ((pConfig->deviceType == mal_device_type_capture  || pConfig->deviceType == mal_device_type_duplex) && pConfig->capture.shareMode  == mal_share_mode_exclusive)) {
        return MAL_SHARE_MODE_NOT_SUPPORTED;
    }

    /* Now we can start initializing the device properly. */
    mal_assert(pDevice != NULL);
    mal_zero_object(&pDevice->opensl);

    SLDataLocator_AndroidSimpleBufferQueue queue;
    queue.locatorType = SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE;
    queue.numBuffers = pConfig->periods;


    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        mal_SLDataFormat_PCM pcm;
        mal_SLDataFormat_PCM_init__opensl(pConfig->capture.format, pConfig->capture.channels, pConfig->sampleRate, pConfig->capture.channelMap, &pcm);

        SLDataLocator_IODevice locatorDevice;
        locatorDevice.locatorType = SL_DATALOCATOR_IODEVICE;
        locatorDevice.deviceType  = SL_IODEVICE_AUDIOINPUT;
        locatorDevice.deviceID    = (pConfig->capture.pDeviceID == NULL) ? SL_DEFAULTDEVICEID_AUDIOINPUT : pConfig->capture.pDeviceID->opensl;
        locatorDevice.device      = NULL;

        SLDataSource source;
        source.pLocator = &locatorDevice;
        source.pFormat  = NULL;

        SLDataSink sink;
        sink.pLocator = &queue;
        sink.pFormat  = (SLDataFormat_PCM*)&pcm;

        const SLInterfaceID itfIDs1[] = {SL_IID_ANDROIDSIMPLEBUFFERQUEUE};
        const SLboolean itfIDsRequired1[] = {SL_BOOLEAN_TRUE};
        SLresult resultSL = (*g_malEngineSL)->CreateAudioRecorder(g_malEngineSL, (SLObjectItf*)&pDevice->opensl.pAudioRecorderObj, &source, &sink, 1, itfIDs1, itfIDsRequired1);
        if (resultSL == SL_RESULT_CONTENT_UNSUPPORTED) {
            /* Unsupported format. Fall back to something safer and try again. If this fails, just abort. */
            pcm.formatType    = SL_DATAFORMAT_PCM;
            pcm.numChannels   = 1;
            ((SLDataFormat_PCM*)&pcm)->samplesPerSec = SL_SAMPLINGRATE_16;  /* The name of the sample rate variable is different between SLAndroidDataFormat_PCM_EX and SLDataFormat_PCM. */
            pcm.bitsPerSample = 16;
            pcm.containerSize = pcm.bitsPerSample;  /* Always tightly packed for now. */
            pcm.channelMask   = SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT;
            resultSL = (*g_malEngineSL)->CreateAudioRecorder(g_malEngineSL, (SLObjectItf*)&pDevice->opensl.pAudioRecorderObj, &source, &sink, 1, itfIDs1, itfIDsRequired1);
        }

        if (resultSL != SL_RESULT_SUCCESS) {
            mal_device_uninit__opensl(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to create audio recorder.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        if (MAL_OPENSL_OBJ(pDevice->opensl.pAudioRecorderObj)->Realize((SLObjectItf)pDevice->opensl.pAudioRecorderObj, SL_BOOLEAN_FALSE) != SL_RESULT_SUCCESS) {
            mal_device_uninit__opensl(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to realize audio recorder.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        if (MAL_OPENSL_OBJ(pDevice->opensl.pAudioRecorderObj)->GetInterface((SLObjectItf)pDevice->opensl.pAudioRecorderObj, SL_IID_RECORD, &pDevice->opensl.pAudioRecorder) != SL_RESULT_SUCCESS) {
            mal_device_uninit__opensl(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to retrieve SL_IID_RECORD interface.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        if (MAL_OPENSL_OBJ(pDevice->opensl.pAudioRecorderObj)->GetInterface((SLObjectItf)pDevice->opensl.pAudioRecorderObj, SL_IID_ANDROIDSIMPLEBUFFERQUEUE, &pDevice->opensl.pBufferQueueCapture) != SL_RESULT_SUCCESS) {
            mal_device_uninit__opensl(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to retrieve SL_IID_ANDROIDSIMPLEBUFFERQUEUE interface.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        if (MAL_OPENSL_BUFFERQUEUE(pDevice->opensl.pBufferQueueCapture)->RegisterCallback((SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueueCapture, mal_buffer_queue_callback_capture__opensl_android, pDevice) != SL_RESULT_SUCCESS) {
            mal_device_uninit__opensl(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to register buffer queue callback.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        /* The internal format is determined by the "pcm" object. */
        mal_deconstruct_SLDataFormat_PCM__opensl(&pcm, &pDevice->capture.internalFormat, &pDevice->capture.internalChannels, &pDevice->capture.internalSampleRate, pDevice->capture.internalChannelMap);

        /* Buffer. */
        mal_uint32 bufferSizeInFrames = pConfig->bufferSizeInFrames;
        if (bufferSizeInFrames == 0) {
            bufferSizeInFrames = mal_calculate_buffer_size_in_frames_from_milliseconds(pConfig->bufferSizeInMilliseconds, pDevice->capture.internalSampleRate);
        }
        pDevice->capture.internalPeriods            = pConfig->periods;
        pDevice->capture.internalBufferSizeInFrames = (bufferSizeInFrames / pDevice->capture.internalPeriods) * pDevice->capture.internalPeriods;
        pDevice->opensl.currentBufferIndexCapture   = 0;

        size_t bufferSizeInBytes = pDevice->capture.internalBufferSizeInFrames * mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
        pDevice->opensl.pBufferCapture = (mal_uint8*)mal_malloc(bufferSizeInBytes);
        if (pDevice->opensl.pBufferCapture == NULL) {
            mal_device_uninit__opensl(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to allocate memory for data buffer.", MAL_OUT_OF_MEMORY);
        }
        MAL_ZERO_MEMORY(pDevice->opensl.pBufferCapture, bufferSizeInBytes);
    }

    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        mal_SLDataFormat_PCM pcm;
        mal_SLDataFormat_PCM_init__opensl(pConfig->playback.format, pConfig->playback.channels, pConfig->sampleRate, pConfig->playback.channelMap, &pcm);

        SLresult resultSL = (*g_malEngineSL)->CreateOutputMix(g_malEngineSL, (SLObjectItf*)&pDevice->opensl.pOutputMixObj, 0, NULL, NULL);
        if (resultSL != SL_RESULT_SUCCESS) {
            mal_device_uninit__opensl(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to create output mix.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        if (MAL_OPENSL_OBJ(pDevice->opensl.pOutputMixObj)->Realize((SLObjectItf)pDevice->opensl.pOutputMixObj, SL_BOOLEAN_FALSE)) {
            mal_device_uninit__opensl(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to realize output mix object.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        if (MAL_OPENSL_OBJ(pDevice->opensl.pOutputMixObj)->GetInterface((SLObjectItf)pDevice->opensl.pOutputMixObj, SL_IID_OUTPUTMIX, &pDevice->opensl.pOutputMix) != SL_RESULT_SUCCESS) {
            mal_device_uninit__opensl(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to retrieve SL_IID_OUTPUTMIX interface.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        /* Set the output device. */
        if (pConfig->playback.pDeviceID != NULL) {
            SLuint32 deviceID_OpenSL = pConfig->playback.pDeviceID->opensl;
            MAL_OPENSL_OUTPUTMIX(pDevice->opensl.pOutputMix)->ReRoute((SLOutputMixItf)pDevice->opensl.pOutputMix, 1, &deviceID_OpenSL);
        }

        SLDataSource source;
        source.pLocator = &queue;
        source.pFormat  = (SLDataFormat_PCM*)&pcm;

        SLDataLocator_OutputMix outmixLocator;
        outmixLocator.locatorType = SL_DATALOCATOR_OUTPUTMIX;
        outmixLocator.outputMix   = (SLObjectItf)pDevice->opensl.pOutputMixObj;

        SLDataSink sink;
        sink.pLocator = &outmixLocator;
        sink.pFormat  = NULL;

        const SLInterfaceID itfIDs1[] = {SL_IID_ANDROIDSIMPLEBUFFERQUEUE};
        const SLboolean itfIDsRequired1[] = {SL_BOOLEAN_TRUE};
        resultSL = (*g_malEngineSL)->CreateAudioPlayer(g_malEngineSL, (SLObjectItf*)&pDevice->opensl.pAudioPlayerObj, &source, &sink, 1, itfIDs1, itfIDsRequired1);
        if (resultSL == SL_RESULT_CONTENT_UNSUPPORTED) {
            /* Unsupported format. Fall back to something safer and try again. If this fails, just abort. */
            pcm.formatType = SL_DATAFORMAT_PCM;
            pcm.numChannels = 2;
            ((SLDataFormat_PCM*)&pcm)->samplesPerSec = SL_SAMPLINGRATE_16;
            pcm.bitsPerSample = 16;
            pcm.containerSize = pcm.bitsPerSample;  /* Always tightly packed for now. */
            pcm.channelMask = SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT;
            resultSL = (*g_malEngineSL)->CreateAudioPlayer(g_malEngineSL, (SLObjectItf*)&pDevice->opensl.pAudioPlayerObj, &source, &sink, 1, itfIDs1, itfIDsRequired1);
        }

        if (resultSL != SL_RESULT_SUCCESS) {
            mal_device_uninit__opensl(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to create audio player.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        if (MAL_OPENSL_OBJ(pDevice->opensl.pAudioPlayerObj)->Realize((SLObjectItf)pDevice->opensl.pAudioPlayerObj, SL_BOOLEAN_FALSE) != SL_RESULT_SUCCESS) {
            mal_device_uninit__opensl(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to realize audio player.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        if (MAL_OPENSL_OBJ(pDevice->opensl.pAudioPlayerObj)->GetInterface((SLObjectItf)pDevice->opensl.pAudioPlayerObj, SL_IID_PLAY, &pDevice->opensl.pAudioPlayer) != SL_RESULT_SUCCESS) {
            mal_device_uninit__opensl(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to retrieve SL_IID_PLAY interface.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        if (MAL_OPENSL_OBJ(pDevice->opensl.pAudioPlayerObj)->GetInterface((SLObjectItf)pDevice->opensl.pAudioPlayerObj, SL_IID_ANDROIDSIMPLEBUFFERQUEUE, &pDevice->opensl.pBufferQueuePlayback) != SL_RESULT_SUCCESS) {
            mal_device_uninit__opensl(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to retrieve SL_IID_ANDROIDSIMPLEBUFFERQUEUE interface.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        if (MAL_OPENSL_BUFFERQUEUE(pDevice->opensl.pBufferQueuePlayback)->RegisterCallback((SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueuePlayback, mal_buffer_queue_callback_playback__opensl_android, pDevice) != SL_RESULT_SUCCESS) {
            mal_device_uninit__opensl(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to register buffer queue callback.", MAL_FAILED_TO_OPEN_BACKEND_DEVICE);
        }

        /* The internal format is determined by the "pcm" object. */
        mal_deconstruct_SLDataFormat_PCM__opensl(&pcm, &pDevice->playback.internalFormat, &pDevice->playback.internalChannels, &pDevice->playback.internalSampleRate, pDevice->playback.internalChannelMap);

        /* Buffer. */
        mal_uint32 bufferSizeInFrames = pConfig->bufferSizeInFrames;
        if (bufferSizeInFrames == 0) {
            bufferSizeInFrames = mal_calculate_buffer_size_in_frames_from_milliseconds(pConfig->bufferSizeInMilliseconds, pDevice->playback.internalSampleRate);
        }
        pDevice->playback.internalPeriods            = pConfig->periods;
        pDevice->playback.internalBufferSizeInFrames = (bufferSizeInFrames / pDevice->playback.internalPeriods) * pDevice->playback.internalPeriods;
        pDevice->opensl.currentBufferIndexPlayback   = 0;

        size_t bufferSizeInBytes = pDevice->playback.internalBufferSizeInFrames * mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
        pDevice->opensl.pBufferPlayback = (mal_uint8*)mal_malloc(bufferSizeInBytes);
        if (pDevice->opensl.pBufferPlayback == NULL) {
            mal_device_uninit__opensl(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to allocate memory for data buffer.", MAL_OUT_OF_MEMORY);
        }
        MAL_ZERO_MEMORY(pDevice->opensl.pBufferPlayback, bufferSizeInBytes);
    }

    if (pConfig->deviceType == mal_device_type_duplex) {
        mal_uint32 rbSizeInFrames = (mal_uint32)mal_calculate_frame_count_after_src(pDevice->sampleRate, pDevice->capture.internalSampleRate, pDevice->capture.internalBufferSizeInFrames);
        mal_result result = mal_pcm_rb_init(pDevice->capture.format, pDevice->capture.channels, rbSizeInFrames, NULL, &pDevice->opensl.duplexRB);
        if (result != MAL_SUCCESS) {
            mal_device_uninit__opensl(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to initialize ring buffer.", result);
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_device_start__opensl(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    mal_assert(g_malOpenSLInitCounter > 0); /* <-- If you trigger this it means you've either not initialized the context, or you've uninitialized it and then attempted to start the device. */
    if (g_malOpenSLInitCounter == 0) {
        return MAL_INVALID_OPERATION;
    }

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        SLresult resultSL = MAL_OPENSL_RECORD(pDevice->opensl.pAudioRecorder)->SetRecordState((SLRecordItf)pDevice->opensl.pAudioRecorder, SL_RECORDSTATE_RECORDING);
        if (resultSL != SL_RESULT_SUCCESS) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to start internal capture device.", MAL_FAILED_TO_START_BACKEND_DEVICE);
        }

        size_t periodSizeInBytes = (pDevice->capture.internalBufferSizeInFrames / pDevice->capture.internalPeriods) * mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
        for (mal_uint32 iPeriod = 0; iPeriod < pDevice->capture.internalPeriods; ++iPeriod) {
            resultSL = MAL_OPENSL_BUFFERQUEUE(pDevice->opensl.pBufferQueuePlayback)->Enqueue((SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueueCapture, pDevice->opensl.pBufferCapture + (periodSizeInBytes * iPeriod), periodSizeInBytes);
            if (resultSL != SL_RESULT_SUCCESS) {
                MAL_OPENSL_RECORD(pDevice->opensl.pAudioRecorder)->SetRecordState((SLRecordItf)pDevice->opensl.pAudioRecorder, SL_RECORDSTATE_STOPPED);
                return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to enqueue buffer for capture device.", MAL_FAILED_TO_START_BACKEND_DEVICE);
            }
        }
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        SLresult resultSL = MAL_OPENSL_PLAY(pDevice->opensl.pAudioPlayer)->SetPlayState((SLPlayItf)pDevice->opensl.pAudioPlayer, SL_PLAYSTATE_PLAYING);
        if (resultSL != SL_RESULT_SUCCESS) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to start internal playback device.", MAL_FAILED_TO_START_BACKEND_DEVICE);
        }

        /* In playback mode (no duplex) we need to load some initial buffers. In duplex mode we need to enqueu silent buffers. */
        if (pDevice->type == mal_device_type_duplex) {
            MAL_ZERO_MEMORY(pDevice->opensl.pBufferPlayback, pDevice->playback.internalBufferSizeInFrames * mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels));
        } else {
            mal_device__read_frames_from_client(pDevice, pDevice->playback.internalBufferSizeInFrames, pDevice->opensl.pBufferPlayback);   
        }

        size_t periodSizeInBytes = (pDevice->playback.internalBufferSizeInFrames / pDevice->playback.internalPeriods) * mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
        for (mal_uint32 iPeriod = 0; iPeriod < pDevice->playback.internalPeriods; ++iPeriod) {
            resultSL = MAL_OPENSL_BUFFERQUEUE(pDevice->opensl.pBufferQueuePlayback)->Enqueue((SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueuePlayback, pDevice->opensl.pBufferPlayback + (periodSizeInBytes * iPeriod), periodSizeInBytes);
            if (resultSL != SL_RESULT_SUCCESS) {
                MAL_OPENSL_PLAY(pDevice->opensl.pAudioPlayer)->SetPlayState((SLPlayItf)pDevice->opensl.pAudioPlayer, SL_PLAYSTATE_STOPPED);
                return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to enqueue buffer for playback device.", MAL_FAILED_TO_START_BACKEND_DEVICE);
            }
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_device_stop__opensl(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    mal_assert(g_malOpenSLInitCounter > 0); /* <-- If you trigger this it means you've either not initialized the context, or you've uninitialized it before stopping/uninitializing the device. */
    if (g_malOpenSLInitCounter == 0) {
        return MAL_INVALID_OPERATION;
    }

    /* TODO: Wait until all buffers have been processed. Hint: Maybe SLAndroidSimpleBufferQueue::GetState() could be used in a loop? */

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        SLresult resultSL = MAL_OPENSL_PLAY(pDevice->opensl.pAudioPlayer)->SetPlayState((SLPlayItf)pDevice->opensl.pAudioPlayer, SL_PLAYSTATE_STOPPED);
        if (resultSL != SL_RESULT_SUCCESS) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to stop internal playback device.", MAL_FAILED_TO_STOP_BACKEND_DEVICE);
        }

        MAL_OPENSL_BUFFERQUEUE(pDevice->opensl.pBufferQueueCapture)->Clear((SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueueCapture);
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        SLresult resultSL = MAL_OPENSL_RECORD(pDevice->opensl.pAudioRecorder)->SetRecordState((SLRecordItf)pDevice->opensl.pAudioRecorder, SL_RECORDSTATE_STOPPED);
        if (resultSL != SL_RESULT_SUCCESS) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "[OpenSL] Failed to stop internal capture device.", MAL_FAILED_TO_STOP_BACKEND_DEVICE);
        }

        MAL_OPENSL_BUFFERQUEUE(pDevice->opensl.pBufferQueuePlayback)->Clear((SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueuePlayback);
    }

    /* Make sure the client is aware that the device has stopped. There may be an OpenSL|ES callback for this, but I haven't found it. */
    mal_stop_proc onStop = pDevice->onStop;
    if (onStop) {
        onStop(pDevice);
    }

    return MAL_SUCCESS;
}


mal_result mal_context_uninit__opensl(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    mal_assert(pContext->backend == mal_backend_opensl);
    (void)pContext;

    /* Uninit global data. */
    if (g_malOpenSLInitCounter > 0) {
        if (mal_atomic_decrement_32(&g_malOpenSLInitCounter) == 0) {
            (*g_malEngineObjectSL)->Destroy(g_malEngineObjectSL);
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_context_init__opensl(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    (void)pContext;

    /* Initialize global data first if applicable. */
    if (mal_atomic_increment_32(&g_malOpenSLInitCounter) == 1) {
        SLresult resultSL = slCreateEngine(&g_malEngineObjectSL, 0, NULL, 0, NULL, NULL);
        if (resultSL != SL_RESULT_SUCCESS) {
            mal_atomic_decrement_32(&g_malOpenSLInitCounter);
            return MAL_NO_BACKEND;
        }

        (*g_malEngineObjectSL)->Realize(g_malEngineObjectSL, SL_BOOLEAN_FALSE);

        resultSL = (*g_malEngineObjectSL)->GetInterface(g_malEngineObjectSL, SL_IID_ENGINE, &g_malEngineSL);
        if (resultSL != SL_RESULT_SUCCESS) {
            (*g_malEngineObjectSL)->Destroy(g_malEngineObjectSL);
            mal_atomic_decrement_32(&g_malOpenSLInitCounter);
            return MAL_NO_BACKEND;
        }
    }

    pContext->isBackendAsynchronous = MAL_TRUE;

    pContext->onUninit        = mal_context_uninit__opensl;
    pContext->onDeviceIDEqual = mal_context_is_device_id_equal__opensl;
    pContext->onEnumDevices   = mal_context_enumerate_devices__opensl;
    pContext->onGetDeviceInfo = mal_context_get_device_info__opensl;
    pContext->onDeviceInit    = mal_device_init__opensl;
    pContext->onDeviceUninit  = mal_device_uninit__opensl;
    pContext->onDeviceStart   = mal_device_start__opensl;
    pContext->onDeviceStop    = mal_device_stop__opensl;

    return MAL_SUCCESS;
}
#endif  /* OpenSL|ES */


///////////////////////////////////////////////////////////////////////////////
//
// Web Audio Backend
//
///////////////////////////////////////////////////////////////////////////////
#ifdef MAL_HAS_WEBAUDIO
#include <emscripten/emscripten.h>

mal_bool32 mal_is_capture_supported__webaudio()
{
    return EM_ASM_INT({
        return (navigator.mediaDevices !== undefined && navigator.mediaDevices.getUserMedia !== undefined);
    }, 0) != 0; /* Must pass in a dummy argument for C99 compatibility. */
}

#ifdef __cplusplus
extern "C" {
#endif
EMSCRIPTEN_KEEPALIVE void mal_device_process_pcm_frames_capture__webaudio(mal_device* pDevice, int frameCount, float* pFrames)
{
    mal_result result;

    if (pDevice->type == mal_device_type_duplex) {
        mal_device__handle_duplex_callback_capture(pDevice, (mal_uint32)frameCount, pFrames, &pDevice->webaudio.duplexRB);
    } else {
        mal_device__send_frames_to_client(pDevice, (mal_uint32)frameCount, pFrames);    /* Send directly to the client. */
    }
}

EMSCRIPTEN_KEEPALIVE void mal_device_process_pcm_frames_playback__webaudio(mal_device* pDevice, int frameCount, float* pFrames)
{
    if (pDevice->type == mal_device_type_duplex) {
        mal_device__handle_duplex_callback_playback(pDevice, (mal_uint32)frameCount, pFrames, &pDevice->webaudio.duplexRB);
    } else {
        mal_device__read_frames_from_client(pDevice, (mal_uint32)frameCount, pFrames);  /* Read directly from the device. */
    }
}
#ifdef __cplusplus
}
#endif

mal_bool32 mal_context_is_device_id_equal__webaudio(mal_context* pContext, const mal_device_id* pID0, const mal_device_id* pID1)
{
    mal_assert(pContext != NULL);
    mal_assert(pID0 != NULL);
    mal_assert(pID1 != NULL);
    (void)pContext;

    return mal_strcmp(pID0->webaudio, pID1->webaudio) == 0;
}

mal_result mal_context_enumerate_devices__webaudio(mal_context* pContext, mal_enum_devices_callback_proc callback, void* pUserData)
{
    mal_assert(pContext != NULL);
    mal_assert(callback != NULL);

    // Only supporting default devices for now.
    mal_bool32 cbResult = MAL_TRUE;

    // Playback.
    if (cbResult) {
        mal_device_info deviceInfo;
        mal_zero_object(&deviceInfo);
        mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MAL_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
        cbResult = callback(pContext, mal_device_type_playback, &deviceInfo, pUserData);
    }

    // Capture.
    if (cbResult) {
        if (mal_is_capture_supported__webaudio()) {
            mal_device_info deviceInfo;
            mal_zero_object(&deviceInfo);
            mal_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MAL_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
            cbResult = callback(pContext, mal_device_type_capture, &deviceInfo, pUserData);
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_context_get_device_info__webaudio(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, mal_device_info* pDeviceInfo)
{
    mal_assert(pContext != NULL);

    /* No exclusive mode with Web Audio. */
    if (shareMode == mal_share_mode_exclusive) {
        return MAL_SHARE_MODE_NOT_SUPPORTED;
    }

    if (deviceType == mal_device_type_capture && !mal_is_capture_supported__webaudio()) {
        return MAL_NO_DEVICE;
    }


    mal_zero_memory(pDeviceInfo->id.webaudio, sizeof(pDeviceInfo->id.webaudio));

    /* Only supporting default devices for now. */
    if (deviceType == mal_device_type_playback) {
        mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MAL_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
    } else {
        mal_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MAL_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
    }

    /* Web Audio can support any number of channels and sample rates. It only supports f32 formats, however. */
    pDeviceInfo->minChannels = 1;
    pDeviceInfo->maxChannels = MAL_MAX_CHANNELS;
    if (pDeviceInfo->maxChannels > 32) {
        pDeviceInfo->maxChannels = 32;  /* Maximum output channel count is 32 for createScriptProcessor() (JavaScript). */
    }

    /* We can query the sample rate by just using a temporary audio context. */
    pDeviceInfo->minSampleRate = EM_ASM_INT({
        try {
            var temp = new (window.AudioContext || window.webkitAudioContext)();
            var sampleRate = temp.sampleRate;
            temp.close();
            return sampleRate;
        } catch(e) {
            return 0;
        }
    }, 0);  /* Must pass in a dummy argument for C99 compatibility. */
    pDeviceInfo->maxSampleRate = pDeviceInfo->minSampleRate;
    if (pDeviceInfo->minSampleRate == 0) {
        return MAL_NO_DEVICE;
    }

    /* Web Audio only supports f32. */
    pDeviceInfo->formatCount = 1;
    pDeviceInfo->formats[0]  = mal_format_f32;

    return MAL_SUCCESS;
}


void mal_device_uninit_by_index__webaudio(mal_device* pDevice, mal_device_type deviceType, int deviceIndex)
{
    mal_assert(pDevice != NULL);

    EM_ASM({
        var device = mal.get_device_by_index($0);

        /* Make sure all nodes are disconnected and marked for collection. */
        if (device.scriptNode !== undefined) {
            device.scriptNode.onaudioprocess = function(e) {};  /* We want to reset the callback to ensure it doesn't get called after AudioContext.close() has returned. Shouldn't happen since we're disconnecting, but just to be safe... */
            device.scriptNode.disconnect();
            device.scriptNode = undefined;
        }
        if (device.streamNode !== undefined) {
            device.streamNode.disconnect();
            device.streamNode = undefined;
        }

        /*
        Stop the device. I think there is a chance the callback could get fired after calling this, hence why we want
        to clear the callback before closing.
        */
        device.webaudio.close();
        device.webaudio = undefined;

        /* Can't forget to free the intermediary buffer. This is the buffer that's shared between JavaScript and C. */
        if (device.intermediaryBuffer !== undefined) {
            Module._free(device.intermediaryBuffer);
            device.intermediaryBuffer = undefined;
            device.intermediaryBufferView = undefined;
            device.intermediaryBufferSizeInBytes = undefined;
        }

        /* Make sure the device is untracked so the slot can be reused later. */
        mal.untrack_device_by_index($0);
    }, deviceIndex, deviceType);
}

void mal_device_uninit__webaudio(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        mal_device_uninit_by_index__webaudio(pDevice, mal_device_type_capture, pDevice->webaudio.indexCapture);
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        mal_device_uninit_by_index__webaudio(pDevice, mal_device_type_playback, pDevice->webaudio.indexPlayback);
    }

    if (pDevice->type == mal_device_type_duplex) {
        mal_pcm_rb_uninit(&pDevice->webaudio.duplexRB);
    }
}

mal_result mal_device_init_by_type__webaudio(mal_context* pContext, const mal_device_config* pConfig, mal_device_type deviceType, mal_device* pDevice)
{
    int deviceIndex;
    mal_uint32 internalBufferSizeInFrames;

    mal_assert(pContext   != NULL);
    mal_assert(pConfig    != NULL);
    mal_assert(deviceType != mal_device_type_duplex);
    mal_assert(pDevice    != NULL);

    if (deviceType == mal_device_type_capture && !mal_is_capture_supported__webaudio()) {
        return MAL_NO_DEVICE;
    }

    /* Try calculating an appropriate buffer size. */
    internalBufferSizeInFrames = pConfig->bufferSizeInFrames;
    if (internalBufferSizeInFrames == 0) {
        internalBufferSizeInFrames = mal_calculate_buffer_size_in_frames_from_milliseconds(pConfig->bufferSizeInMilliseconds, pConfig->sampleRate);
    }

    /* The size of the buffer must be a power of 2 and between 256 and 16384. */
    if (internalBufferSizeInFrames < 256) {
        internalBufferSizeInFrames = 256;
    } else if (internalBufferSizeInFrames > 16384) {
        internalBufferSizeInFrames = 16384;
    } else {
        internalBufferSizeInFrames = mal_next_power_of_2(internalBufferSizeInFrames);
    }

    /* We create the device on the JavaScript side and reference it using an index. We use this to make it possible to reference the device between JavaScript and C. */
    deviceIndex = EM_ASM_INT({
        var channels   = $0;
        var sampleRate = $1;
        var bufferSize = $2;    /* In PCM frames. */
        var isCapture  = $3;
        var pDevice    = $4;

        if (typeof(mal) === 'undefined') {
            return -1;  /* Context not initialized. */
        }

        var device = {};

        /* The AudioContext must be created in a suspended state. */
        device.webaudio = new (window.AudioContext || window.webkitAudioContext)({sampleRate:sampleRate});
        device.webaudio.suspend();

        /*
        We need an intermediary buffer which we use for JavaScript and C interop. This buffer stores interleaved f32 PCM data. Because it's passed between
        JavaScript and C it needs to be allocated and freed using Module._malloc() and Module._free().
        */
        device.intermediaryBufferSizeInBytes = channels * bufferSize * 4;
        device.intermediaryBuffer = Module._malloc(device.intermediaryBufferSizeInBytes);
        device.intermediaryBufferView = new Float32Array(Module.HEAPF32.buffer, device.intermediaryBuffer, device.intermediaryBufferSizeInBytes);

        /*
        Both playback and capture devices use a ScriptProcessorNode for performing per-sample operations.

        ScriptProcessorNode is actually deprecated so this is likely to be temporary. The way this works for playback is very simple. You just set a callback
        that's periodically fired, just like a normal audio callback function. But apparently this design is "flawed" and is now deprecated in favour of
        something called AudioWorklets which _forces_ you to load a _separate_ .js file at run time... nice... Hopefully ScriptProcessorNode will continue to
        work for years to come, but this may need to change to use AudioSourceBufferNode instead, which I think is what Emscripten uses for it's built-in SDL
        implementation. I'll be avoiding that insane AudioWorklet API like the plague...

        For capture it is a bit unintuitive. We use the ScriptProccessorNode _only_ to get the raw PCM data. It is connected to an AudioContext just like the
        playback case, however we just output silence to the AudioContext instead of passing any real data. It would make more sense to me to use the
        MediaRecorder API, but unfortunately you need to specify a MIME time (Opus, Vorbis, etc.) for the binary blob that's returned to the client, but I've
        been unable to figure out how to get this as raw PCM. The closes I can think is to use the MIME type for WAV files and just parse it, but I don't know
        how well this would work. Although ScriptProccessorNode is deprecated, in practice it seems to have pretty good browser support so I'm leaving it like
        this for now. If anything knows how I could get raw PCM data using the MediaRecorder API please let me know!
        */
        device.scriptNode = device.webaudio.createScriptProcessor(bufferSize, channels, channels);

        if (isCapture) {
            device.scriptNode.onaudioprocess = function(e) {
                if (device.intermediaryBuffer === undefined) {
                    return; /* This means the device has been uninitialized. */
                }

                /* Make sure silence it output to the AudioContext destination. Not doing this will cause sound to come out of the speakers! */
                for (var iChannel = 0; iChannel < e.outputBuffer.numberOfChannels; ++iChannel) {
                    e.outputBuffer.getChannelData(iChannel).fill(0.0);
                }

                /* There are some situations where we may want to send silence to the client. */
                var sendSilence = false;
                if (device.streamNode === undefined) {
                    sendSilence = true;
                }

                /* Sanity check. This will never happen, right? */
                if (e.inputBuffer.numberOfChannels != channels) {
                    console.log("Capture: Channel count mismatch. " + e.inputBufer.numberOfChannels + " != " + channels + ". Sending silence.");
                    sendSilence = true;
                }

                /* This looped design guards against the situation where e.inputBuffer is a different size to the original buffer size. Should never happen in practice. */
                var totalFramesProcessed = 0;
                while (totalFramesProcessed < e.inputBuffer.length) {
                    var framesRemaining = e.inputBuffer.length - totalFramesProcessed;
                    var framesToProcess = framesRemaining;
                    if (framesToProcess > (device.intermediaryBufferSizeInBytes/channels/4)) {
                        framesToProcess = (device.intermediaryBufferSizeInBytes/channels/4);
                    }

                    /* We need to do the reverse of the playback case. We need to interleave the input data and copy it into the intermediary buffer. Then we send it to the client. */
                    if (sendSilence) {
                        device.intermediaryBufferView.fill(0.0);
                    } else {
                        for (var iFrame = 0; iFrame < framesToProcess; ++iFrame) {
                            for (var iChannel = 0; iChannel < e.inputBuffer.numberOfChannels; ++iChannel) {
                                device.intermediaryBufferView[iFrame*channels + iChannel] = e.inputBuffer.getChannelData(iChannel)[totalFramesProcessed + iFrame];
                            }
                        }
                    }

                    /* Send data to the client from our intermediary buffer. */
                    ccall("mal_device_process_pcm_frames_capture__webaudio", "undefined", ["number", "number", "number"], [pDevice, framesToProcess, device.intermediaryBuffer]);

                    totalFramesProcessed += framesToProcess;
                }
            };

            navigator.mediaDevices.getUserMedia({audio:true, video:false})
                .then(function(stream) {
                    device.streamNode = device.webaudio.createMediaStreamSource(stream);
                    device.streamNode.connect(device.scriptNode);
                    device.scriptNode.connect(device.webaudio.destination);
                })
                .catch(function(error) {
                    /* I think this should output silence... */
                    device.scriptNode.connect(device.webaudio.destination);
                });
        } else {
            device.scriptNode.onaudioprocess = function(e) {
                if (device.intermediaryBuffer === undefined) {
                    return; /* This means the device has been uninitialized. */
                }

                var outputSilence = false;

                /* Sanity check. This will never happen, right? */
                if (e.outputBuffer.numberOfChannels != channels) {
                    console.log("Playback: Channel count mismatch. " + e.outputBufer.numberOfChannels + " != " + channels + ". Outputting silence.");
                    outputSilence = true;
                    return;
                }

                /* This looped design guards against the situation where e.outputBuffer is a different size to the original buffer size. Should never happen in practice. */
                var totalFramesProcessed = 0;
                while (totalFramesProcessed < e.outputBuffer.length) {
                    var framesRemaining = e.outputBuffer.length - totalFramesProcessed;
                    var framesToProcess = framesRemaining;
                    if (framesToProcess > (device.intermediaryBufferSizeInBytes/channels/4)) {
                        framesToProcess = (device.intermediaryBufferSizeInBytes/channels/4);
                    }

                    /* Read data from the client into our intermediary buffer. */
                    ccall("mal_device_process_pcm_frames_playback__webaudio", "undefined", ["number", "number", "number"], [pDevice, framesToProcess, device.intermediaryBuffer]);

                    /* At this point we'll have data in our intermediary buffer which we now need to deinterleave and copy over to the output buffers. */
                    if (outputSilence) {
                        for (var iChannel = 0; iChannel < e.outputBuffer.numberOfChannels; ++iChannel) {
                            e.outputBuffer.getChannelData(iChannel).fill(0.0);
                        }
                    } else {
                        for (var iChannel = 0; iChannel < e.outputBuffer.numberOfChannels; ++iChannel) {
                            for (var iFrame = 0; iFrame < framesToProcess; ++iFrame) {
                                e.outputBuffer.getChannelData(iChannel)[totalFramesProcessed + iFrame] = device.intermediaryBufferView[iFrame*channels + iChannel];
                            }
                        }
                    }

                    totalFramesProcessed += framesToProcess;
                }
            };

            device.scriptNode.connect(device.webaudio.destination);
        }

        return mal.track_device(device);
    }, (deviceType == mal_device_type_capture) ? pConfig->capture.channels : pConfig->playback.channels, pConfig->sampleRate, internalBufferSizeInFrames, deviceType == mal_device_type_capture, pDevice);

    if (deviceIndex < 0) {
        return MAL_FAILED_TO_OPEN_BACKEND_DEVICE;
    }

    if (deviceType == mal_device_type_capture) {
        pDevice->webaudio.indexCapture               = deviceIndex;
        pDevice->capture.internalFormat              = mal_format_f32;
        pDevice->capture.internalChannels            = pConfig->capture.channels;
        mal_get_standard_channel_map(mal_standard_channel_map_webaudio, pDevice->capture.internalChannels, pDevice->capture.internalChannelMap);
        pDevice->capture.internalSampleRate          = EM_ASM_INT({ return mal.get_device_by_index($0).webaudio.sampleRate; }, deviceIndex);
        pDevice->capture.internalBufferSizeInFrames  = internalBufferSizeInFrames;
        pDevice->capture.internalPeriods             = 1;
    } else {
        pDevice->webaudio.indexPlayback              = deviceIndex;
        pDevice->playback.internalFormat             = mal_format_f32;
        pDevice->playback.internalChannels           = pConfig->playback.channels;
        mal_get_standard_channel_map(mal_standard_channel_map_webaudio, pDevice->playback.internalChannels, pDevice->playback.internalChannelMap);
        pDevice->playback.internalSampleRate         = EM_ASM_INT({ return mal.get_device_by_index($0).webaudio.sampleRate; }, deviceIndex);
        pDevice->playback.internalBufferSizeInFrames = internalBufferSizeInFrames;
        pDevice->playback.internalPeriods            = 1;
    }

    return MAL_SUCCESS;
}

mal_result mal_device_init__webaudio(mal_context* pContext, const mal_device_config* pConfig, mal_device* pDevice)
{
    mal_result result;

    /* No exclusive mode with Web Audio. */
    if (((pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) && pConfig->playback.shareMode == mal_share_mode_exclusive) ||
        ((pConfig->deviceType == mal_device_type_capture  || pConfig->deviceType == mal_device_type_duplex) && pConfig->capture.shareMode  == mal_share_mode_exclusive)) {
        return MAL_SHARE_MODE_NOT_SUPPORTED;
    }

    if (pConfig->deviceType == mal_device_type_capture || pConfig->deviceType == mal_device_type_duplex) {
        result = mal_device_init_by_type__webaudio(pContext, pConfig, mal_device_type_capture, pDevice);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    if (pConfig->deviceType == mal_device_type_playback || pConfig->deviceType == mal_device_type_duplex) {
        result = mal_device_init_by_type__webaudio(pContext, pConfig, mal_device_type_playback, pDevice);
        if (result != MAL_SUCCESS) {
            if (pConfig->deviceType == mal_device_type_duplex) {
                mal_device_uninit_by_index__webaudio(pDevice, mal_device_type_capture, pDevice->webaudio.indexCapture);
            }
            return result;
        }
    }

    /*
    We need a ring buffer for moving data from the capture device to the playback device. The capture callback is the producer
    and the playback callback is the consumer. The buffer needs to be large enough to hold internalBufferSizeInFrames based on
    the external sample rate.
    */
    if (pConfig->deviceType == mal_device_type_duplex) {
        mal_uint32 rbSizeInFrames = (mal_uint32)mal_calculate_frame_count_after_src(pDevice->sampleRate, pDevice->capture.internalSampleRate, pDevice->capture.internalBufferSizeInFrames) * 2;
        result = mal_pcm_rb_init(pDevice->capture.format, pDevice->capture.channels, rbSizeInFrames, NULL, &pDevice->webaudio.duplexRB);
        if (result != MAL_SUCCESS) {
            if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
                mal_device_uninit_by_index__webaudio(pDevice, mal_device_type_capture, pDevice->webaudio.indexCapture);
            }
            if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
                mal_device_uninit_by_index__webaudio(pDevice, mal_device_type_playback, pDevice->webaudio.indexPlayback);
            }
            return result;
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_device_start__webaudio(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        EM_ASM({
            mal.get_device_by_index($0).webaudio.resume();
        }, pDevice->webaudio.indexCapture);
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        EM_ASM({
            mal.get_device_by_index($0).webaudio.resume();
        }, pDevice->webaudio.indexPlayback);
    }

    return MAL_SUCCESS;
}

mal_result mal_device_stop__webaudio(mal_device* pDevice)
{
    mal_assert(pDevice != NULL);

    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        EM_ASM({
            mal.get_device_by_index($0).webaudio.suspend();
        }, pDevice->webaudio.indexCapture);
    }

    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        EM_ASM({
            mal.get_device_by_index($0).webaudio.suspend();
        }, pDevice->webaudio.indexPlayback);
    }

    mal_stop_proc onStop = pDevice->onStop;
    if (onStop) {
        onStop(pDevice);
    }

    return MAL_SUCCESS;
}

mal_result mal_context_uninit__webaudio(mal_context* pContext)
{
    mal_assert(pContext != NULL);
    mal_assert(pContext->backend == mal_backend_webaudio);

    /* Nothing needs to be done here. */
    (void)pContext;

    return MAL_SUCCESS;
}

mal_result mal_context_init__webaudio(mal_context* pContext)
{
    mal_assert(pContext != NULL);

    /* Here is where our global JavaScript object is initialized. */
    int resultFromJS = EM_ASM_INT({
        if ((window.AudioContext || window.webkitAudioContext) === undefined) {
            return 0;   /* Web Audio not supported. */
        }

        if (typeof(mal) === 'undefined') {
            mal = {};
            mal.devices = [];   /* Device cache for mapping devices to indexes for JavaScript/C interop. */
                    
            mal.track_device = function(device) {
                /* Try inserting into a free slot first. */
                for (var iDevice = 0; iDevice < mal.devices.length; ++iDevice) {
                    if (mal.devices[iDevice] == null) {
                        mal.devices[iDevice] = device;
                        return iDevice;
                    }
                }
                        
                /* Getting here means there is no empty slots in the array so we just push to the end. */
                mal.devices.push(device);
                return mal.devices.length - 1;
            };
                    
            mal.untrack_device_by_index = function(deviceIndex) {
                /* We just set the device's slot to null. The slot will get reused in the next call to mal_track_device. */
                mal.devices[deviceIndex] = null;
                        
                /* Trim the array if possible. */
                while (mal.devices.length > 0) {
                    if (mal.devices[mal.devices.length-1] == null) {
                        mal.devices.pop();
                    } else {
                        break;
                    }
                }
            };
                    
            mal.untrack_device = function(device) {
                for (var iDevice = 0; iDevice < mal.devices.length; ++iDevice) {
                    if (mal.devices[iDevice] == device) {
                        return mal.untrack_device_by_index(iDevice);
                    }
                }
            };
                    
            mal.get_device_by_index = function(deviceIndex) {
                return mal.devices[deviceIndex];
            };
        }
                
        return 1;
    }, 0);  /* Must pass in a dummy argument for C99 compatibility. */

    if (resultFromJS != 1) {
        return MAL_FAILED_TO_INIT_BACKEND;
    }


    pContext->isBackendAsynchronous = MAL_TRUE;

    pContext->onUninit              = mal_context_uninit__webaudio;
    pContext->onDeviceIDEqual       = mal_context_is_device_id_equal__webaudio;
    pContext->onEnumDevices         = mal_context_enumerate_devices__webaudio;
    pContext->onGetDeviceInfo       = mal_context_get_device_info__webaudio;
    pContext->onDeviceInit          = mal_device_init__webaudio;
    pContext->onDeviceUninit        = mal_device_uninit__webaudio;
    pContext->onDeviceStart         = mal_device_start__webaudio;
    pContext->onDeviceStop          = mal_device_stop__webaudio;

    return MAL_SUCCESS;
}
#endif  // Web Audio



mal_bool32 mal__is_channel_map_valid(const mal_channel* channelMap, mal_uint32 channels)
{
    // A blank channel map should be allowed, in which case it should use an appropriate default which will depend on context.
    if (channelMap[0] != MAL_CHANNEL_NONE) {
        if (channels == 0) {
            return MAL_FALSE;   // No channels.
        }

        // A channel cannot be present in the channel map more than once.
        for (mal_uint32 iChannel = 0; iChannel < channels; ++iChannel) {
            for (mal_uint32 jChannel = iChannel + 1; jChannel < channels; ++jChannel) {
                if (channelMap[iChannel] == channelMap[jChannel]) {
                    return MAL_FALSE;
                }
            }
        }
    }

    return MAL_TRUE;
}


void mal_device__post_init_setup(mal_device* pDevice, mal_device_type deviceType)
{
    mal_assert(pDevice != NULL);

    if (deviceType == mal_device_type_capture || deviceType == mal_device_type_duplex) {
        if (pDevice->capture.usingDefaultFormat) {
            pDevice->capture.format = pDevice->capture.internalFormat;
        }
        if (pDevice->capture.usingDefaultChannels) {
            pDevice->capture.channels = pDevice->capture.internalChannels;
        }
        if (pDevice->capture.usingDefaultChannelMap) {
            mal_channel_map_copy(pDevice->capture.channelMap, pDevice->capture.internalChannelMap, pDevice->capture.channels);
        }
    }

    if (deviceType == mal_device_type_playback || deviceType == mal_device_type_duplex) {
        if (pDevice->playback.usingDefaultFormat) {
            pDevice->playback.format = pDevice->playback.internalFormat;
        }
        if (pDevice->playback.usingDefaultChannels) {
            pDevice->playback.channels = pDevice->playback.internalChannels;
        }
        if (pDevice->playback.usingDefaultChannelMap) {
            mal_channel_map_copy(pDevice->playback.channelMap, pDevice->playback.internalChannelMap, pDevice->playback.channels);
        }
    }

    if (pDevice->usingDefaultSampleRate) {
        if (deviceType == mal_device_type_capture || deviceType == mal_device_type_duplex) {
            pDevice->sampleRate = pDevice->capture.internalSampleRate;
        } else {
            pDevice->sampleRate = pDevice->playback.internalSampleRate;
        }
    }

    /* PCM converters. */
    if (deviceType == mal_device_type_capture || deviceType == mal_device_type_duplex) {
        /* Converting from internal device format to public format. */
        mal_pcm_converter_config converterConfig = mal_pcm_converter_config_init_new();
        converterConfig.neverConsumeEndOfInput = MAL_TRUE;
        converterConfig.pUserData              = pDevice;
        converterConfig.formatIn               = pDevice->capture.internalFormat;
        converterConfig.channelsIn             = pDevice->capture.internalChannels;
        converterConfig.sampleRateIn           = pDevice->capture.internalSampleRate;
        mal_channel_map_copy(converterConfig.channelMapIn, pDevice->capture.internalChannelMap, pDevice->capture.internalChannels);
        converterConfig.formatOut              = pDevice->capture.format;
        converterConfig.channelsOut            = pDevice->capture.channels;
        converterConfig.sampleRateOut          = pDevice->sampleRate;
        mal_channel_map_copy(converterConfig.channelMapOut, pDevice->capture.channelMap, pDevice->capture.channels);
        converterConfig.onRead = mal_device__pcm_converter__on_read_from_buffer_capture;
        mal_pcm_converter_init(&converterConfig, &pDevice->capture.converter);
    }

    if (deviceType == mal_device_type_playback || deviceType == mal_device_type_duplex) {
        /* Converting from public format to device format. */
        mal_pcm_converter_config converterConfig = mal_pcm_converter_config_init_new();
        converterConfig.neverConsumeEndOfInput = MAL_TRUE;
        converterConfig.pUserData              = pDevice;
        converterConfig.formatIn               = pDevice->playback.format;
        converterConfig.channelsIn             = pDevice->playback.channels;
        converterConfig.sampleRateIn           = pDevice->sampleRate;
        mal_channel_map_copy(converterConfig.channelMapIn, pDevice->playback.channelMap, pDevice->playback.channels);
        converterConfig.formatOut              = pDevice->playback.internalFormat;
        converterConfig.channelsOut            = pDevice->playback.internalChannels;
        converterConfig.sampleRateOut          = pDevice->playback.internalSampleRate;
        mal_channel_map_copy(converterConfig.channelMapOut, pDevice->playback.internalChannelMap, pDevice->playback.internalChannels);
        if (deviceType == mal_device_type_playback) {
            if (pDevice->type == mal_device_type_playback) {
                converterConfig.onRead = mal_device__on_read_from_client;
            } else {
                converterConfig.onRead = mal_device__pcm_converter__on_read_from_buffer_playback;
            }
        } else {
            converterConfig.onRead = mal_device__pcm_converter__on_read_from_buffer_playback;
        }
        mal_pcm_converter_init(&converterConfig, &pDevice->playback.converter);
    }
}


mal_thread_result MAL_THREADCALL mal_worker_thread(void* pData)
{
    mal_device* pDevice = (mal_device*)pData;
    mal_assert(pDevice != NULL);

#ifdef MAL_WIN32
    mal_CoInitializeEx(pDevice->pContext, NULL, MAL_COINIT_VALUE);
#endif

    // When the device is being initialized it's initial state is set to MAL_STATE_UNINITIALIZED. Before returning from
    // mal_device_init(), the state needs to be set to something valid. In mini_al the device's default state immediately
    // after initialization is stopped, so therefore we need to mark the device as such. mini_al will wait on the worker
    // thread to signal an event to know when the worker thread is ready for action.
    mal_device__set_state(pDevice, MAL_STATE_STOPPED);
    mal_event_signal(&pDevice->stopEvent);

    for (;;) {  /* <-- This loop just keeps the thread alive. The main audio loop is inside. */
        // We wait on an event to know when something has requested that the device be started and the main loop entered.
        mal_event_wait(&pDevice->wakeupEvent);

        // Default result code.
        pDevice->workResult = MAL_SUCCESS;

        // If the reason for the wake up is that we are terminating, just break from the loop.
        if (mal_device__get_state(pDevice) == MAL_STATE_UNINITIALIZED) {
            break;
        }

        // Getting to this point means the device is wanting to get started. The function that has requested that the device
        // be started will be waiting on an event (pDevice->startEvent) which means we need to make sure we signal the event
        // in both the success and error case. It's important that the state of the device is set _before_ signaling the event.
        mal_assert(mal_device__get_state(pDevice) == MAL_STATE_STARTING);

        /* Make sure the state is set appropriately. */
        mal_device__set_state(pDevice, MAL_STATE_STARTED);
        mal_event_signal(&pDevice->startEvent);

        if (pDevice->pContext->onDeviceMainLoop != NULL) {
            pDevice->pContext->onDeviceMainLoop(pDevice);
        } else {
            /* When a device is using mini_al's generic worker thread they must implement onDeviceRead or onDeviceWrite, depending on the device type. */
            mal_assert(
                (pDevice->type == mal_device_type_playback && pDevice->pContext->onDeviceWrite != NULL) ||
                (pDevice->type == mal_device_type_capture  && pDevice->pContext->onDeviceRead  != NULL) ||
                (pDevice->type == mal_device_type_duplex   && pDevice->pContext->onDeviceWrite != NULL && pDevice->pContext->onDeviceRead != NULL)
            );

            mal_uint32 periodSizeInFrames;
            if (pDevice->type == mal_device_type_capture) {
                mal_assert(pDevice->capture.internalBufferSizeInFrames >= pDevice->capture.internalPeriods);
                periodSizeInFrames = pDevice->capture.internalBufferSizeInFrames / pDevice->capture.internalPeriods;
            } else if (pDevice->type == mal_device_type_playback) {
                mal_assert(pDevice->playback.internalBufferSizeInFrames >= pDevice->playback.internalPeriods);
                periodSizeInFrames = pDevice->playback.internalBufferSizeInFrames / pDevice->playback.internalPeriods;
            } else {
                mal_assert(pDevice->capture.internalBufferSizeInFrames >= pDevice->capture.internalPeriods);
                mal_assert(pDevice->playback.internalBufferSizeInFrames >= pDevice->playback.internalPeriods);
                periodSizeInFrames = mal_min(
                    pDevice->capture.internalBufferSizeInFrames / pDevice->capture.internalPeriods,
                    pDevice->playback.internalBufferSizeInFrames / pDevice->playback.internalPeriods
                );
            }

            /*
            With the blocking API, the device is started automatically in read()/write(). All we need to do is enter the loop and just keep reading
            or writing based on the period size.
            */
            
            /* Main Loop */
            mal_assert(periodSizeInFrames >= 1);
            while (mal_device__get_state(pDevice) == MAL_STATE_STARTED) {
                mal_result result = MAL_SUCCESS;
                mal_uint32 totalFramesProcessed = 0;

                if (pDevice->type == mal_device_type_duplex) {
                    /* The process is device_read -> convert -> callback -> convert -> device_write. */
                    mal_uint8  captureDeviceData[4096];
                    mal_uint32 captureDeviceDataCapInFrames = sizeof(captureDeviceData) / mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);

                    while (totalFramesProcessed < periodSizeInFrames) {
                        mal_uint32 framesRemaining = periodSizeInFrames - totalFramesProcessed;
                        mal_uint32 framesToProcess = framesRemaining;
                        if (framesToProcess > captureDeviceDataCapInFrames) {
                            framesToProcess = captureDeviceDataCapInFrames;
                        }

                        result = pDevice->pContext->onDeviceRead(pDevice, captureDeviceData, framesToProcess);
                        if (result != MAL_SUCCESS) {
                            break;
                        }
                    
                        mal_device_callback_proc onData = pDevice->onData;
                        if (onData != NULL) {
                            pDevice->capture._dspFrameCount = framesToProcess;
                            pDevice->capture._dspFrames     = captureDeviceData;

                            /* We need to process every input frame. */
                            for (;;) {
                                mal_uint8 capturedData[4096];   // In capture.format/channels format
                                mal_uint8 playbackData[4096];   // In playback.format/channels format

                                mal_uint32 capturedDataCapInFrames = sizeof(capturedData) / mal_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels);
                                mal_uint32 playbackDataCapInFrames = sizeof(playbackData) / mal_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels);

                                mal_uint32 capturedFramesToTryProcessing = mal_min(capturedDataCapInFrames, playbackDataCapInFrames);
                                mal_uint32 capturedFramesToProcess = (mal_uint32)mal_pcm_converter_read(&pDevice->capture.converter, capturedData, capturedFramesToTryProcessing);
                                if (capturedFramesToProcess == 0) {
                                    break;  /* Don't fire the data callback with zero frames. */
                                }
                            
                                onData(pDevice, playbackData, capturedData, capturedFramesToProcess);

                                /* At this point the playbackData buffer should be holding data that needs to be written to the device. */
                                pDevice->playback._dspFrameCount = capturedFramesToProcess;
                                pDevice->playback._dspFrames     = playbackData;
                                for (;;) {
                                    mal_uint8 playbackDeviceData[4096];

                                    mal_uint32 playbackDeviceDataCapInFrames = sizeof(playbackDeviceData) / mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
                                    mal_uint32 playbackDeviceFramesCount = (mal_uint32)mal_pcm_converter_read(&pDevice->playback.converter, playbackDeviceData, playbackDeviceDataCapInFrames);
                                    if (playbackDeviceFramesCount == 0) {
                                        break;
                                    }

                                    result = pDevice->pContext->onDeviceWrite(pDevice, playbackDeviceData, playbackDeviceFramesCount);
                                    if (result != MAL_SUCCESS) {
                                        break;
                                    }

                                    if (playbackDeviceFramesCount < playbackDeviceDataCapInFrames) {
                                        break;
                                    }
                                }

                                if (capturedFramesToProcess < capturedFramesToTryProcessing) {
                                    break;
                                }

                                /* In case an error happened from onDeviceWrite()... */
                                if (result != MAL_SUCCESS) {
                                    break;
                                }
                            }
                        }

                        totalFramesProcessed += framesToProcess;
                    }
                } else {
                    mal_uint8  buffer[4096];
                    mal_uint32 bufferSizeInFrames;
                    if (pDevice->type == mal_device_type_capture) {
                        bufferSizeInFrames = sizeof(buffer) / mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
                    } else {
                        bufferSizeInFrames = sizeof(buffer) / mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
                    }

                    while (totalFramesProcessed < periodSizeInFrames) {
                        mal_uint32 framesRemaining = periodSizeInFrames - totalFramesProcessed;
                        mal_uint32 framesToProcess = framesRemaining;
                        if (framesToProcess > bufferSizeInFrames) {
                            framesToProcess = bufferSizeInFrames;
                        }

                        if (pDevice->type == mal_device_type_playback) {
                            mal_device__read_frames_from_client(pDevice, framesToProcess, buffer);
                            result = pDevice->pContext->onDeviceWrite(pDevice, buffer, framesToProcess);
                        } else {
                            result = pDevice->pContext->onDeviceRead(pDevice, buffer, framesToProcess);
                            mal_device__send_frames_to_client(pDevice, framesToProcess, buffer);
                        }

                        totalFramesProcessed += framesToProcess;
                    }
                }

                /* Get out of the loop if read()/write() returned an error. It probably means the device has been stopped. */
                if (result != MAL_SUCCESS) {
                    break;
                }
            }
        }


        // Getting here means we have broken from the main loop which happens the application has requested that device be stopped. Note that this
        // may have actually already happened above if the device was lost and mini_al has attempted to re-initialize the device. In this case we
        // don't want to be doing this a second time.
        if (mal_device__get_state(pDevice) != MAL_STATE_UNINITIALIZED) {
            pDevice->pContext->onDeviceStop(pDevice);
        }

        // After the device has stopped, make sure an event is posted.
        mal_stop_proc onStop = pDevice->onStop;
        if (onStop) {
            onStop(pDevice);
        }

        // A function somewhere is waiting for the device to have stopped for real so we need to signal an event to allow it to continue. Note that
        // it's possible that the device has been uninitialized which means we need to _not_ change the status to stopped. We cannot go from an
        // uninitialized state to stopped state.
        if (mal_device__get_state(pDevice) != MAL_STATE_UNINITIALIZED) {
            mal_device__set_state(pDevice, MAL_STATE_STOPPED);
            mal_event_signal(&pDevice->stopEvent);
        }
    }

    // Make sure we aren't continuously waiting on a stop event.
    mal_event_signal(&pDevice->stopEvent);  // <-- Is this still needed?

#ifdef MAL_WIN32
    mal_CoUninitialize(pDevice->pContext);
#endif

    return (mal_thread_result)0;
}


// Helper for determining whether or not the given device is initialized.
mal_bool32 mal_device__is_initialized(mal_device* pDevice)
{
    if (pDevice == NULL) return MAL_FALSE;
    return mal_device__get_state(pDevice) != MAL_STATE_UNINITIALIZED;
}


#ifdef MAL_WIN32
mal_result mal_context_uninit_backend_apis__win32(mal_context* pContext)
{
    mal_CoUninitialize(pContext);
    mal_dlclose(pContext->win32.hUser32DLL);
    mal_dlclose(pContext->win32.hOle32DLL);
    mal_dlclose(pContext->win32.hAdvapi32DLL);

    return MAL_SUCCESS;
}

mal_result mal_context_init_backend_apis__win32(mal_context* pContext)
{
#ifdef MAL_WIN32_DESKTOP
    // Ole32.dll
    pContext->win32.hOle32DLL = mal_dlopen("ole32.dll");
    if (pContext->win32.hOle32DLL == NULL) {
        return MAL_FAILED_TO_INIT_BACKEND;
    }

    pContext->win32.CoInitializeEx   = (mal_proc)mal_dlsym(pContext->win32.hOle32DLL, "CoInitializeEx");
    pContext->win32.CoUninitialize   = (mal_proc)mal_dlsym(pContext->win32.hOle32DLL, "CoUninitialize");
    pContext->win32.CoCreateInstance = (mal_proc)mal_dlsym(pContext->win32.hOle32DLL, "CoCreateInstance");
    pContext->win32.CoTaskMemFree    = (mal_proc)mal_dlsym(pContext->win32.hOle32DLL, "CoTaskMemFree");
    pContext->win32.PropVariantClear = (mal_proc)mal_dlsym(pContext->win32.hOle32DLL, "PropVariantClear");
    pContext->win32.StringFromGUID2  = (mal_proc)mal_dlsym(pContext->win32.hOle32DLL, "StringFromGUID2");


    // User32.dll
    pContext->win32.hUser32DLL = mal_dlopen("user32.dll");
    if (pContext->win32.hUser32DLL == NULL) {
        return MAL_FAILED_TO_INIT_BACKEND;
    }

    pContext->win32.GetForegroundWindow = (mal_proc)mal_dlsym(pContext->win32.hUser32DLL, "GetForegroundWindow");
    pContext->win32.GetDesktopWindow    = (mal_proc)mal_dlsym(pContext->win32.hUser32DLL, "GetDesktopWindow");


    // Advapi32.dll
    pContext->win32.hAdvapi32DLL = mal_dlopen("advapi32.dll");
    if (pContext->win32.hAdvapi32DLL == NULL) {
        return MAL_FAILED_TO_INIT_BACKEND;
    }

    pContext->win32.RegOpenKeyExA    = (mal_proc)mal_dlsym(pContext->win32.hAdvapi32DLL, "RegOpenKeyExA");
    pContext->win32.RegCloseKey      = (mal_proc)mal_dlsym(pContext->win32.hAdvapi32DLL, "RegCloseKey");
    pContext->win32.RegQueryValueExA = (mal_proc)mal_dlsym(pContext->win32.hAdvapi32DLL, "RegQueryValueExA");
#endif

    mal_CoInitializeEx(pContext, NULL, MAL_COINIT_VALUE);
    return MAL_SUCCESS;
}
#else
mal_result mal_context_uninit_backend_apis__nix(mal_context* pContext)
{
#if defined(MAL_USE_RUNTIME_LINKING_FOR_PTHREAD) && !defined(MAL_NO_RUNTIME_LINKING)
    mal_dlclose(pContext->posix.pthreadSO);
#else
    (void)pContext;
#endif

    return MAL_SUCCESS;
}

mal_result mal_context_init_backend_apis__nix(mal_context* pContext)
{
    // pthread
#if defined(MAL_USE_RUNTIME_LINKING_FOR_PTHREAD) && !defined(MAL_NO_RUNTIME_LINKING)
    const char* libpthreadFileNames[] = {
        "libpthread.so",
        "libpthread.so.0",
        "libpthread.dylib"
    };

    for (size_t i = 0; i < sizeof(libpthreadFileNames) / sizeof(libpthreadFileNames[0]); ++i) {
        pContext->posix.pthreadSO = mal_dlopen(libpthreadFileNames[i]);
        if (pContext->posix.pthreadSO != NULL) {
            break;
        }
    }

    if (pContext->posix.pthreadSO == NULL) {
        return MAL_FAILED_TO_INIT_BACKEND;
    }

    pContext->posix.pthread_create              = (mal_proc)mal_dlsym(pContext->posix.pthreadSO, "pthread_create");
    pContext->posix.pthread_join                = (mal_proc)mal_dlsym(pContext->posix.pthreadSO, "pthread_join");
    pContext->posix.pthread_mutex_init          = (mal_proc)mal_dlsym(pContext->posix.pthreadSO, "pthread_mutex_init");
    pContext->posix.pthread_mutex_destroy       = (mal_proc)mal_dlsym(pContext->posix.pthreadSO, "pthread_mutex_destroy");
    pContext->posix.pthread_mutex_lock          = (mal_proc)mal_dlsym(pContext->posix.pthreadSO, "pthread_mutex_lock");
    pContext->posix.pthread_mutex_unlock        = (mal_proc)mal_dlsym(pContext->posix.pthreadSO, "pthread_mutex_unlock");
    pContext->posix.pthread_cond_init           = (mal_proc)mal_dlsym(pContext->posix.pthreadSO, "pthread_cond_init");
    pContext->posix.pthread_cond_destroy        = (mal_proc)mal_dlsym(pContext->posix.pthreadSO, "pthread_cond_destroy");
    pContext->posix.pthread_cond_wait           = (mal_proc)mal_dlsym(pContext->posix.pthreadSO, "pthread_cond_wait");
    pContext->posix.pthread_cond_signal         = (mal_proc)mal_dlsym(pContext->posix.pthreadSO, "pthread_cond_signal");
    pContext->posix.pthread_attr_init           = (mal_proc)mal_dlsym(pContext->posix.pthreadSO, "pthread_attr_init");
    pContext->posix.pthread_attr_destroy        = (mal_proc)mal_dlsym(pContext->posix.pthreadSO, "pthread_attr_destroy");
    pContext->posix.pthread_attr_setschedpolicy = (mal_proc)mal_dlsym(pContext->posix.pthreadSO, "pthread_attr_setschedpolicy");
    pContext->posix.pthread_attr_getschedparam  = (mal_proc)mal_dlsym(pContext->posix.pthreadSO, "pthread_attr_getschedparam");
    pContext->posix.pthread_attr_setschedparam  = (mal_proc)mal_dlsym(pContext->posix.pthreadSO, "pthread_attr_setschedparam");
#else
    pContext->posix.pthread_create              = (mal_proc)pthread_create;
    pContext->posix.pthread_join                = (mal_proc)pthread_join;
    pContext->posix.pthread_mutex_init          = (mal_proc)pthread_mutex_init;
    pContext->posix.pthread_mutex_destroy       = (mal_proc)pthread_mutex_destroy;
    pContext->posix.pthread_mutex_lock          = (mal_proc)pthread_mutex_lock;
    pContext->posix.pthread_mutex_unlock        = (mal_proc)pthread_mutex_unlock;
    pContext->posix.pthread_cond_init           = (mal_proc)pthread_cond_init;
    pContext->posix.pthread_cond_destroy        = (mal_proc)pthread_cond_destroy;
    pContext->posix.pthread_cond_wait           = (mal_proc)pthread_cond_wait;
    pContext->posix.pthread_cond_signal         = (mal_proc)pthread_cond_signal;
    pContext->posix.pthread_attr_init           = (mal_proc)pthread_attr_init;
    pContext->posix.pthread_attr_destroy        = (mal_proc)pthread_attr_destroy;
#if !defined(__EMSCRIPTEN__)
    pContext->posix.pthread_attr_setschedpolicy = (mal_proc)pthread_attr_setschedpolicy;
    pContext->posix.pthread_attr_getschedparam  = (mal_proc)pthread_attr_getschedparam;
    pContext->posix.pthread_attr_setschedparam  = (mal_proc)pthread_attr_setschedparam;
#endif
#endif

    return MAL_SUCCESS;
}
#endif

mal_result mal_context_init_backend_apis(mal_context* pContext)
{
    mal_result result;
#ifdef MAL_WIN32
    result = mal_context_init_backend_apis__win32(pContext);
#else
    result = mal_context_init_backend_apis__nix(pContext);
#endif

    return result;
}

mal_result mal_context_uninit_backend_apis(mal_context* pContext)
{
    mal_result result;
#ifdef MAL_WIN32
    result = mal_context_uninit_backend_apis__win32(pContext);
#else
    result = mal_context_uninit_backend_apis__nix(pContext);
#endif

    return result;
}


mal_bool32 mal_context_is_backend_asynchronous(mal_context* pContext)
{
    return pContext->isBackendAsynchronous;
}

mal_result mal_context_init(const mal_backend backends[], mal_uint32 backendCount, const mal_context_config* pConfig, mal_context* pContext)
{
    if (pContext == NULL) {
        return MAL_INVALID_ARGS;
    }

    mal_zero_object(pContext);

    // Always make sure the config is set first to ensure properties are available as soon as possible.
    if (pConfig != NULL) {
        pContext->config = *pConfig;
    } else {
        pContext->config = mal_context_config_init();
    }

    // Backend APIs need to be initialized first. This is where external libraries will be loaded and linked.
    mal_result result = mal_context_init_backend_apis(pContext);
    if (result != MAL_SUCCESS) {
        return result;
    }

    mal_backend defaultBackends[mal_backend_null+1];
    for (int i = 0; i <= mal_backend_null; ++i) {
        defaultBackends[i] = (mal_backend)i;
    }

    mal_backend* pBackendsToIterate = (mal_backend*)backends;
    mal_uint32 backendsToIterateCount = backendCount;
    if (pBackendsToIterate == NULL) {
        pBackendsToIterate = (mal_backend*)defaultBackends;
        backendsToIterateCount = mal_countof(defaultBackends);
    }

    mal_assert(pBackendsToIterate != NULL);

    for (mal_uint32 iBackend = 0; iBackend < backendsToIterateCount; ++iBackend) {
        mal_backend backend = pBackendsToIterate[iBackend];

        result = MAL_NO_BACKEND;
        switch (backend) {
        #ifdef MAL_HAS_WASAPI
            case mal_backend_wasapi:
            {
                result = mal_context_init__wasapi(pContext);
            } break;
        #endif
        #ifdef MAL_HAS_DSOUND
            case mal_backend_dsound:
            {
                result = mal_context_init__dsound(pContext);
            } break;
        #endif
        #ifdef MAL_HAS_WINMM
            case mal_backend_winmm:
            {
                result = mal_context_init__winmm(pContext);
            } break;
        #endif
        #ifdef MAL_HAS_ALSA
            case mal_backend_alsa:
            {
                result = mal_context_init__alsa(pContext);
            } break;
        #endif
        #ifdef MAL_HAS_PULSEAUDIO
            case mal_backend_pulseaudio:
            {
                result = mal_context_init__pulse(pContext);
            } break;
        #endif
        #ifdef MAL_HAS_JACK
            case mal_backend_jack:
            {
                result = mal_context_init__jack(pContext);
            } break;
        #endif
        #ifdef MAL_HAS_COREAUDIO
            case mal_backend_coreaudio:
            {
                result = mal_context_init__coreaudio(pContext);
            } break;
        #endif
        #ifdef MAL_HAS_SNDIO
            case mal_backend_sndio:
            {
                result = mal_context_init__sndio(pContext);
            } break;
        #endif
        #ifdef MAL_HAS_AUDIO4
            case mal_backend_audio4:
            {
                result = mal_context_init__audio4(pContext);
            } break;
        #endif
        #ifdef MAL_HAS_OSS
            case mal_backend_oss:
            {
                result = mal_context_init__oss(pContext);
            } break;
        #endif
        #ifdef MAL_HAS_AAUDIO
            case mal_backend_aaudio:
            {
                result = mal_context_init__aaudio(pContext);
            } break;
        #endif
        #ifdef MAL_HAS_OPENSL
            case mal_backend_opensl:
            {
                result = mal_context_init__opensl(pContext);
            } break;
        #endif
        #ifdef MAL_HAS_WEBAUDIO
            case mal_backend_webaudio:
            {
                result = mal_context_init__webaudio(pContext);
            } break;
        #endif
        #ifdef MAL_HAS_NULL
            case mal_backend_null:
            {
                result = mal_context_init__null(pContext);
            } break;
        #endif

            default: break;
        }

        // If this iteration was successful, return.
        if (result == MAL_SUCCESS) {
            result = mal_mutex_init(pContext, &pContext->deviceEnumLock);
            if (result != MAL_SUCCESS) {
                mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_WARNING, "Failed to initialize mutex for device enumeration. mal_context_get_devices() is not thread safe.", MAL_FAILED_TO_CREATE_MUTEX);
            }
            result = mal_mutex_init(pContext, &pContext->deviceInfoLock);
            if (result != MAL_SUCCESS) {
                mal_context_post_error(pContext, NULL, MAL_LOG_LEVEL_WARNING, "Failed to initialize mutex for device info retrieval. mal_context_get_device_info() is not thread safe.", MAL_FAILED_TO_CREATE_MUTEX);
            }

#ifdef MAL_DEBUG_OUTPUT
            printf("[mini_al] Endian:  %s\n", mal_is_little_endian() ? "LE" : "BE");
            printf("[mini_al] SSE2:    %s\n", mal_has_sse2()    ? "YES" : "NO");
            printf("[mini_al] AVX2:    %s\n", mal_has_avx2()    ? "YES" : "NO");
            printf("[mini_al] AVX512F: %s\n", mal_has_avx512f() ? "YES" : "NO");
            printf("[mini_al] NEON:    %s\n", mal_has_neon()    ? "YES" : "NO");
#endif

            pContext->backend = backend;
            return result;
        }
    }

    // If we get here it means an error occurred.
    mal_zero_object(pContext);  // Safety.
    return MAL_NO_BACKEND;
}

mal_result mal_context_uninit(mal_context* pContext)
{
    if (pContext == NULL) {
        return MAL_INVALID_ARGS;
    }

    pContext->onUninit(pContext);

    mal_context_uninit_backend_apis(pContext);
    mal_mutex_uninit(&pContext->deviceEnumLock);
    mal_mutex_uninit(&pContext->deviceInfoLock);
    mal_free(pContext->pDeviceInfos);

    return MAL_SUCCESS;
}


mal_result mal_context_enumerate_devices(mal_context* pContext, mal_enum_devices_callback_proc callback, void* pUserData)
{
    if (pContext == NULL || pContext->onEnumDevices == NULL || callback == NULL) {
        return MAL_INVALID_ARGS;
    }

    mal_result result;
    mal_mutex_lock(&pContext->deviceEnumLock);
    {
        result = pContext->onEnumDevices(pContext, callback, pUserData);
    }
    mal_mutex_unlock(&pContext->deviceEnumLock);

    return result;
}


mal_bool32 mal_context_get_devices__enum_callback(mal_context* pContext, mal_device_type deviceType, const mal_device_info* pInfo, void* pUserData)
{
    (void)pUserData;

    // We need to insert the device info into our main internal buffer. Where it goes depends on the device type. If it's a capture device
    // it's just appended to the end. If it's a playback device it's inserted just before the first capture device.

    // First make sure we have room. Since the number of devices we add to the list is usually relatively small I've decided to use a
    // simple fixed size increment for buffer expansion.
    const mal_uint32 bufferExpansionCount = 2;
    const mal_uint32 totalDeviceInfoCount = pContext->playbackDeviceInfoCount + pContext->captureDeviceInfoCount;

    if (pContext->deviceInfoCapacity >= totalDeviceInfoCount) {
        mal_uint32 newCapacity = totalDeviceInfoCount + bufferExpansionCount;
        mal_device_info* pNewInfos = (mal_device_info*)mal_realloc(pContext->pDeviceInfos, sizeof(*pContext->pDeviceInfos)*newCapacity);
        if (pNewInfos == NULL) {
            return MAL_FALSE;   // Out of memory.
        }

        pContext->pDeviceInfos = pNewInfos;
        pContext->deviceInfoCapacity = newCapacity;
    }

    if (deviceType == mal_device_type_playback) {
        // Playback. Insert just before the first capture device.

        // The first thing to do is move all of the capture devices down a slot.
        mal_uint32 iFirstCaptureDevice = pContext->playbackDeviceInfoCount;
        for (size_t iCaptureDevice = totalDeviceInfoCount; iCaptureDevice > iFirstCaptureDevice; --iCaptureDevice) {
            pContext->pDeviceInfos[iCaptureDevice] = pContext->pDeviceInfos[iCaptureDevice-1];
        }

        // Now just insert where the first capture device was before moving it down a slot.
        pContext->pDeviceInfos[iFirstCaptureDevice] = *pInfo;
        pContext->playbackDeviceInfoCount += 1;
    } else {
        // Capture. Insert at the end.
        pContext->pDeviceInfos[totalDeviceInfoCount] = *pInfo;
        pContext->captureDeviceInfoCount += 1;
    }

    return MAL_TRUE;
}

mal_result mal_context_get_devices(mal_context* pContext, mal_device_info** ppPlaybackDeviceInfos, mal_uint32* pPlaybackDeviceCount, mal_device_info** ppCaptureDeviceInfos, mal_uint32* pCaptureDeviceCount)
{
    // Safety.
    if (ppPlaybackDeviceInfos != NULL) *ppPlaybackDeviceInfos = NULL;
    if (pPlaybackDeviceCount  != NULL) *pPlaybackDeviceCount  = 0;
    if (ppCaptureDeviceInfos  != NULL) *ppCaptureDeviceInfos  = NULL;
    if (pCaptureDeviceCount   != NULL) *pCaptureDeviceCount   = 0;

    if (pContext == NULL || pContext->onEnumDevices == NULL) {
        return MAL_INVALID_ARGS;
    }

    // Note that we don't use mal_context_enumerate_devices() here because we want to do locking at a higher level.
    mal_result result;
    mal_mutex_lock(&pContext->deviceEnumLock);
    {
        // Reset everything first.
        pContext->playbackDeviceInfoCount = 0;
        pContext->captureDeviceInfoCount = 0;

        // Now enumerate over available devices.
        result = pContext->onEnumDevices(pContext, mal_context_get_devices__enum_callback, NULL);
        if (result == MAL_SUCCESS) {
            // Playback devices.
            if (ppPlaybackDeviceInfos != NULL) {
                *ppPlaybackDeviceInfos = pContext->pDeviceInfos;
            }
            if (pPlaybackDeviceCount != NULL) {
                *pPlaybackDeviceCount = pContext->playbackDeviceInfoCount;
            }

            // Capture devices.
            if (ppCaptureDeviceInfos != NULL) {
                *ppCaptureDeviceInfos = pContext->pDeviceInfos + pContext->playbackDeviceInfoCount; // Capture devices come after playback devices.
            }
            if (pCaptureDeviceCount != NULL) {
                *pCaptureDeviceCount = pContext->captureDeviceInfoCount;
            }
        }
    }
    mal_mutex_unlock(&pContext->deviceEnumLock);

    return result;
}

mal_result mal_context_get_device_info(mal_context* pContext, mal_device_type deviceType, const mal_device_id* pDeviceID, mal_share_mode shareMode, mal_device_info* pDeviceInfo)
{
    // NOTE: Do not clear pDeviceInfo on entry. The reason is the pDeviceID may actually point to pDeviceInfo->id which will break things.
    if (pContext == NULL || pDeviceInfo == NULL) {
        return MAL_INVALID_ARGS;
    }

    mal_device_info deviceInfo;
    mal_zero_object(&deviceInfo);

    // Help the backend out by copying over the device ID if we have one.
    if (pDeviceID != NULL) {
        mal_copy_memory(&deviceInfo.id, pDeviceID, sizeof(*pDeviceID));
    }

    // The backend may have an optimized device info retrieval function. If so, try that first.
    if (pContext->onGetDeviceInfo != NULL) {
        mal_result result;
        mal_mutex_lock(&pContext->deviceInfoLock);
        {
            result = pContext->onGetDeviceInfo(pContext, deviceType, pDeviceID, shareMode, &deviceInfo);
        }
        mal_mutex_unlock(&pContext->deviceInfoLock);

        // Clamp ranges.
        deviceInfo.minChannels   = mal_max(deviceInfo.minChannels,   MAL_MIN_CHANNELS);
        deviceInfo.maxChannels   = mal_min(deviceInfo.maxChannels,   MAL_MAX_CHANNELS);
        deviceInfo.minSampleRate = mal_max(deviceInfo.minSampleRate, MAL_MIN_SAMPLE_RATE);
        deviceInfo.maxSampleRate = mal_min(deviceInfo.maxSampleRate, MAL_MAX_SAMPLE_RATE);

        *pDeviceInfo = deviceInfo;
        return result;
    }

    // Getting here means onGetDeviceInfo has not been set.
    return MAL_ERROR;
}


mal_result mal_device_init(mal_context* pContext, const mal_device_config* pConfig, mal_device* pDevice)
{
    if (pContext == NULL) {
        return mal_device_init_ex(NULL, 0, NULL, pConfig, pDevice);
    }
    if (pDevice == NULL) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "mal_device_init() called with invalid arguments (pDevice == NULL).", MAL_INVALID_ARGS);
    }
    if (pConfig == NULL) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "mal_device_init() called with invalid arguments (pConfig == NULL).", MAL_INVALID_ARGS);
    }

    /* We need to make a copy of the config so we can set default values if they were left unset in the input config. */
    mal_device_config config = *pConfig;

    /* Basic config validation. */
    if (config.deviceType != mal_device_type_playback && config.deviceType != mal_device_type_capture && config.deviceType != mal_device_type_duplex) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "mal_device_init() called with an invalid config. Device type is invalid. Make sure the device type has been set in the config.", MAL_INVALID_DEVICE_CONFIG);
    }

    if (config.deviceType == mal_device_type_capture || config.deviceType == mal_device_type_duplex) {
        if (config.capture.channels > MAL_MAX_CHANNELS) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "mal_device_init() called with an invalid config. Capture channel count cannot exceed 32.", MAL_INVALID_DEVICE_CONFIG);
        }
        if (!mal__is_channel_map_valid(config.capture.channelMap, config.capture.channels)) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "mal_device_init() called with invalid config. Capture channel map is invalid.", MAL_INVALID_DEVICE_CONFIG);
        }
    }

    if (config.deviceType == mal_device_type_playback || config.deviceType == mal_device_type_duplex) {
        if (config.playback.channels > MAL_MAX_CHANNELS) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "mal_device_init() called with an invalid config. Playback channel count cannot exceed 32.", MAL_INVALID_DEVICE_CONFIG);
        }
        if (!mal__is_channel_map_valid(config.playback.channelMap, config.playback.channels)) {
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "mal_device_init() called with invalid config. Playback channel map is invalid.", MAL_INVALID_DEVICE_CONFIG);
        }
    }


    mal_zero_object(pDevice);
    pDevice->pContext = pContext;

    // Set the user data and log callback ASAP to ensure it is available for the entire initialization process.
    pDevice->pUserData = config.pUserData;
    pDevice->onData = config.dataCallback;
    pDevice->onStop = config.stopCallback;

    if (((mal_uintptr)pDevice % sizeof(pDevice)) != 0) {
        if (pContext->config.logCallback) {
            pContext->config.logCallback(pContext, pDevice, MAL_LOG_LEVEL_WARNING, "WARNING: mal_device_init() called for a device that is not properly aligned. Thread safety is not supported.");
        }
    }

    // When passing in 0 for the format/channels/rate/chmap it means the device will be using whatever is chosen by the backend. If everything is set
    // to defaults it means the format conversion pipeline will run on a fast path where data transfer is just passed straight through to the backend.
    if (config.sampleRate == 0) {
        config.sampleRate = MAL_DEFAULT_SAMPLE_RATE;
        pDevice->usingDefaultSampleRate = MAL_TRUE;
    }

    if (config.capture.format == mal_format_unknown) {
        config.capture.format = MAL_DEFAULT_FORMAT;
        pDevice->capture.usingDefaultFormat = MAL_TRUE;
    }
    if (config.capture.channels == 0) {
        config.capture.channels = MAL_DEFAULT_CHANNELS;
        pDevice->capture.usingDefaultChannels = MAL_TRUE;
    }
    if (config.capture.channelMap[0] == MAL_CHANNEL_NONE) {
        pDevice->capture.usingDefaultChannelMap = MAL_TRUE;
    }

    if (config.playback.format == mal_format_unknown) {
        config.playback.format = MAL_DEFAULT_FORMAT;
        pDevice->playback.usingDefaultFormat = MAL_TRUE;
    }
    if (config.playback.channels == 0) {
        config.playback.channels = MAL_DEFAULT_CHANNELS;
        pDevice->playback.usingDefaultChannels = MAL_TRUE;
    }
    if (config.playback.channelMap[0] == MAL_CHANNEL_NONE) {
        pDevice->playback.usingDefaultChannelMap = MAL_TRUE;
    }


    // Default buffer size.
    if (config.bufferSizeInMilliseconds == 0 && config.bufferSizeInFrames == 0) {
        config.bufferSizeInMilliseconds = (config.performanceProfile == mal_performance_profile_low_latency) ? MAL_BASE_BUFFER_SIZE_IN_MILLISECONDS_LOW_LATENCY : MAL_BASE_BUFFER_SIZE_IN_MILLISECONDS_CONSERVATIVE;
        pDevice->usingDefaultBufferSize = MAL_TRUE;
    }

    // Default periods.
    if (config.periods == 0) {
        config.periods = MAL_DEFAULT_PERIODS;
        pDevice->usingDefaultPeriods = MAL_TRUE;
    }

    /*
    Must have at least 3 periods for full-duplex mode. The idea is that the playback and capture positions hang out in the middle period, with the surrounding
    periods acting as a buffer in case the capture and playback devices get's slightly out of sync.
    */
    if (config.deviceType == mal_device_type_duplex && config.periods < 3) {
        config.periods = 3;
    }


    pDevice->type = config.deviceType;
    pDevice->sampleRate = config.sampleRate;

    pDevice->capture.shareMode   = config.capture.shareMode;
    pDevice->capture.format      = config.capture.format;
    pDevice->capture.channels    = config.capture.channels;
    mal_channel_map_copy(pDevice->capture.channelMap, config.capture.channelMap, config.capture.channels);

    pDevice->playback.shareMode  = config.playback.shareMode;
    pDevice->playback.format     = config.playback.format;
    pDevice->playback.channels   = config.playback.channels;
    mal_channel_map_copy(pDevice->playback.channelMap, config.playback.channelMap, config.playback.channels);


    // The internal format, channel count and sample rate can be modified by the backend.
    pDevice->capture.internalFormat      = pDevice->capture.format;
    pDevice->capture.internalChannels    = pDevice->capture.channels;
    pDevice->capture.internalSampleRate  = pDevice->sampleRate;
    mal_channel_map_copy(pDevice->capture.internalChannelMap, pDevice->capture.channelMap, pDevice->capture.channels);

    pDevice->playback.internalFormat     = pDevice->playback.format;
    pDevice->playback.internalChannels   = pDevice->playback.channels;
    pDevice->playback.internalSampleRate = pDevice->sampleRate;
    mal_channel_map_copy(pDevice->playback.internalChannelMap, pDevice->playback.channelMap, pDevice->playback.channels);
    

    if (mal_mutex_init(pContext, &pDevice->lock) != MAL_SUCCESS) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "Failed to create mutex.", MAL_FAILED_TO_CREATE_MUTEX);
    }

    // When the device is started, the worker thread is the one that does the actual startup of the backend device. We
    // use a semaphore to wait for the background thread to finish the work. The same applies for stopping the device.
    //
    // Each of these semaphores is released internally by the worker thread when the work is completed. The start
    // semaphore is also used to wake up the worker thread.
    if (mal_event_init(pContext, &pDevice->wakeupEvent) != MAL_SUCCESS) {
        mal_mutex_uninit(&pDevice->lock);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "Failed to create worker thread wakeup event.", MAL_FAILED_TO_CREATE_EVENT);
    }
    if (mal_event_init(pContext, &pDevice->startEvent) != MAL_SUCCESS) {
        mal_event_uninit(&pDevice->wakeupEvent);
        mal_mutex_uninit(&pDevice->lock);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "Failed to create worker thread start event.", MAL_FAILED_TO_CREATE_EVENT);
    }
    if (mal_event_init(pContext, &pDevice->stopEvent) != MAL_SUCCESS) {
        mal_event_uninit(&pDevice->startEvent);
        mal_event_uninit(&pDevice->wakeupEvent);
        mal_mutex_uninit(&pDevice->lock);
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "Failed to create worker thread stop event.", MAL_FAILED_TO_CREATE_EVENT);
    }


    mal_result result = pContext->onDeviceInit(pContext, &config, pDevice);
    if (result != MAL_SUCCESS) {
        return MAL_NO_BACKEND;  // The error message will have been posted with mal_post_error() by the source of the error so don't bother calling it here.
    }

    mal_device__post_init_setup(pDevice, pConfig->deviceType);


    // If the backend did not fill out a name for the device, try a generic method.
    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        if (pDevice->capture.name[0] == '\0') {
            if (mal_context__try_get_device_name_by_id(pContext, mal_device_type_capture, config.capture.pDeviceID, pDevice->capture.name, sizeof(pDevice->capture.name)) != MAL_SUCCESS) {
                mal_strncpy_s(pDevice->capture.name, sizeof(pDevice->capture.name), (config.capture.pDeviceID == NULL)  ? MAL_DEFAULT_CAPTURE_DEVICE_NAME : "Capture Device", (size_t)-1);
            }
        }
    }
    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        if (pDevice->playback.name[0] == '\0') {
            if (mal_context__try_get_device_name_by_id(pContext, mal_device_type_playback, config.playback.pDeviceID, pDevice->playback.name, sizeof(pDevice->playback.name)) != MAL_SUCCESS) {
                mal_strncpy_s(pDevice->playback.name, sizeof(pDevice->playback.name), (config.playback.pDeviceID == NULL)  ? MAL_DEFAULT_PLAYBACK_DEVICE_NAME : "Playback Device", (size_t)-1);
            }
        }
    }


    // Some backends don't require the worker thread.
    if (!mal_context_is_backend_asynchronous(pContext)) {
        // The worker thread.
        if (mal_thread_create(pContext, &pDevice->thread, mal_worker_thread, pDevice) != MAL_SUCCESS) {
            mal_device_uninit(pDevice);
            return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "Failed to create worker thread.", MAL_FAILED_TO_CREATE_THREAD);
        }

        // Wait for the worker thread to put the device into it's stopped state for real.
        mal_event_wait(&pDevice->stopEvent);
    } else {
        mal_device__set_state(pDevice, MAL_STATE_STOPPED);
    }


#ifdef MAL_DEBUG_OUTPUT
    printf("[%s]\n", mal_get_backend_name(pDevice->pContext->backend));
    if (pDevice->type == mal_device_type_capture || pDevice->type == mal_device_type_duplex) {
        printf("  %s (%s)\n", pDevice->capture.name, "Capture");
        printf("    Format:      %s -> %s\n", mal_get_format_name(pDevice->capture.format), mal_get_format_name(pDevice->capture.internalFormat));
        printf("    Channels:    %d -> %d\n", pDevice->capture.channels, pDevice->capture.internalChannels);
        printf("    Sample Rate: %d -> %d\n", pDevice->sampleRate, pDevice->capture.internalSampleRate);
        printf("    Buffer Size: %d/%d (%d)\n", pDevice->capture.internalBufferSizeInFrames, pDevice->capture.internalPeriods, (pDevice->capture.internalBufferSizeInFrames / pDevice->capture.internalPeriods));
        printf("    Conversion:\n");
        printf("      Pre Format Conversion:    %s\n", pDevice->capture.converter.isPreFormatConversionRequired  ? "YES" : "NO");
        printf("      Post Format Conversion:   %s\n", pDevice->capture.converter.isPostFormatConversionRequired ? "YES" : "NO");
        printf("      Channel Routing:          %s\n", pDevice->capture.converter.isChannelRoutingRequired       ? "YES" : "NO");
        printf("      SRC:                      %s\n", pDevice->capture.converter.isSRCRequired                  ? "YES" : "NO");
        printf("      Channel Routing at Start: %s\n", pDevice->capture.converter.isChannelRoutingAtStart        ? "YES" : "NO");
        printf("      Passthrough:              %s\n", pDevice->capture.converter.isPassthrough                  ? "YES" : "NO");
    }
    if (pDevice->type == mal_device_type_playback || pDevice->type == mal_device_type_duplex) {
        printf("  %s (%s)\n", pDevice->playback.name, "Playback");
        printf("    Format:      %s -> %s\n", mal_get_format_name(pDevice->playback.format), mal_get_format_name(pDevice->playback.internalFormat));
        printf("    Channels:    %d -> %d\n", pDevice->playback.channels, pDevice->playback.internalChannels);
        printf("    Sample Rate: %d -> %d\n", pDevice->sampleRate, pDevice->playback.internalSampleRate);
        printf("    Buffer Size: %d/%d (%d)\n", pDevice->playback.internalBufferSizeInFrames, pDevice->playback.internalPeriods, (pDevice->playback.internalBufferSizeInFrames / pDevice->playback.internalPeriods));
        printf("    Conversion:\n");
        printf("      Pre Format Conversion:    %s\n", pDevice->playback.converter.isPreFormatConversionRequired  ? "YES" : "NO");
        printf("      Post Format Conversion:   %s\n", pDevice->playback.converter.isPostFormatConversionRequired ? "YES" : "NO");
        printf("      Channel Routing:          %s\n", pDevice->playback.converter.isChannelRoutingRequired       ? "YES" : "NO");
        printf("      SRC:                      %s\n", pDevice->playback.converter.isSRCRequired                  ? "YES" : "NO");
        printf("      Channel Routing at Start: %s\n", pDevice->playback.converter.isChannelRoutingAtStart        ? "YES" : "NO");
        printf("      Passthrough:              %s\n", pDevice->playback.converter.isPassthrough                  ? "YES" : "NO");
    }
#endif


    mal_assert(mal_device__get_state(pDevice) == MAL_STATE_STOPPED);
    return MAL_SUCCESS;
}

mal_result mal_device_init_ex(const mal_backend backends[], mal_uint32 backendCount, const mal_context_config* pContextConfig, const mal_device_config* pConfig, mal_device* pDevice)
{
    if (pConfig == NULL) {
        return MAL_INVALID_ARGS;
    }

    mal_context* pContext = (mal_context*)mal_malloc(sizeof(*pContext));
    if (pContext == NULL) {
        return MAL_OUT_OF_MEMORY;
    }

    mal_backend defaultBackends[mal_backend_null+1];
    for (int i = 0; i <= mal_backend_null; ++i) {
        defaultBackends[i] = (mal_backend)i;
    }

    mal_backend* pBackendsToIterate = (mal_backend*)backends;
    mal_uint32 backendsToIterateCount = backendCount;
    if (pBackendsToIterate == NULL) {
        pBackendsToIterate = (mal_backend*)defaultBackends;
        backendsToIterateCount = mal_countof(defaultBackends);
    }

    mal_result result = MAL_NO_BACKEND;

    for (mal_uint32 iBackend = 0; iBackend < backendsToIterateCount; ++iBackend) {
        result = mal_context_init(&pBackendsToIterate[iBackend], 1, pContextConfig, pContext);
        if (result == MAL_SUCCESS) {
            result = mal_device_init(pContext, pConfig, pDevice);
            if (result == MAL_SUCCESS) {
                break;  // Success.
            } else {
                mal_context_uninit(pContext);   // Failure.
            }
        }
    }

    if (result != MAL_SUCCESS) {
        mal_free(pContext);
        return result;
    }

    pDevice->isOwnerOfContext = MAL_TRUE;
    return result;
}

void mal_device_uninit(mal_device* pDevice)
{
    if (!mal_device__is_initialized(pDevice)) {
        return;
    }

    // Make sure the device is stopped first. The backends will probably handle this naturally,
    // but I like to do it explicitly for my own sanity.
    if (mal_device_is_started(pDevice)) {
        mal_device_stop(pDevice);
    }

    // Putting the device into an uninitialized state will make the worker thread return.
    mal_device__set_state(pDevice, MAL_STATE_UNINITIALIZED);

    // Wake up the worker thread and wait for it to properly terminate.
    if (!mal_context_is_backend_asynchronous(pDevice->pContext)) {
        mal_event_signal(&pDevice->wakeupEvent);
        mal_thread_wait(&pDevice->thread);
    }

    pDevice->pContext->onDeviceUninit(pDevice);

    mal_event_uninit(&pDevice->stopEvent);
    mal_event_uninit(&pDevice->startEvent);
    mal_event_uninit(&pDevice->wakeupEvent);
    mal_mutex_uninit(&pDevice->lock);

    if (pDevice->isOwnerOfContext) {
        mal_context_uninit(pDevice->pContext);
        mal_free(pDevice->pContext);
    }

    mal_zero_object(pDevice);
}

/*
Writes PCM frames to the device.
*/
mal_result mal_device_write(mal_device* pDevice, const void* pPCMFrames, mal_uint32 frameCount)
{
    mal_result result;
    mal_uint32 totalFramesWritten = 0;

    if (mal_device__is_async(pDevice)) {
        return MAL_INVALID_ARGS;
    }

    /* Backend must supporting synchronous writes. */
    if (pDevice->pContext->onDeviceWrite == NULL) {
        return MAL_INVALID_OPERATION;
    }

    /* If it's a passthrough we can call the backend directly, otherwise we need a data conversion into an intermediary buffer. */
    if (pDevice->playback.converter.isPassthrough) {
        /* Fast path. Write directly to the device. */
        result = pDevice->pContext->onDeviceWrite(pDevice, pPCMFrames, frameCount);
    } else {
        /* Slow path. Perform a data conversion. */

        /* TODO: Implement me. */
        result = MAL_SUCCESS;

        /* NOTE: Only doing format conversion for now just while testing. */
        mal_uint8 buffer[4096];
        mal_uint32 bufferSizeInFrames = sizeof(buffer) / mal_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);

        while (totalFramesWritten < frameCount) {
            mal_uint32 framesRemaining = (frameCount - totalFramesWritten);
            mal_uint32 framesToProcess = framesRemaining;
            if (framesToProcess > bufferSizeInFrames) {
                framesToProcess = bufferSizeInFrames;
            }

            mal_pcm_convert(
                buffer,
                pDevice->playback.internalFormat,
                mal_offset_ptr(pPCMFrames, totalFramesWritten * mal_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels)),
                pDevice->playback.format,
                framesToProcess*pDevice->playback.channels,
                mal_dither_mode_none);

            result = pDevice->pContext->onDeviceWrite(pDevice, buffer, framesToProcess);
            totalFramesWritten += framesToProcess;

            if (result != MAL_SUCCESS) {
                break;
            }
        }
    }

    return result;
}

/*
Reads PCM frames from the device.
*/
mal_result mal_device_read(mal_device* pDevice, void* pPCMFrames, mal_uint32 frameCount)
{
    mal_result result;
    mal_uint32 totalFramesRead = 0;

    if (pDevice == NULL || pPCMFrames == NULL) {
        return MAL_INVALID_ARGS;
    }

    /* Not allowed to call this in asynchronous mode. */
    if (mal_device__is_async(pDevice)) {
        return MAL_INVALID_OPERATION;
    }

    /* Backend must supporting synchronous reads. */
    if (pDevice->pContext->onDeviceRead == NULL) {
        return MAL_INVALID_OPERATION;
    }

    /* If it's a passthrough we can call the backend directly, otherwise we need a data conversion into an intermediary buffer. */
    if (pDevice->capture.converter.isPassthrough) {
        /* Fast path. Write directly to the device. */
        result = pDevice->pContext->onDeviceRead(pDevice, pPCMFrames, frameCount);
    } else {
        /* Slow path. Perform a data conversion. */

        /* TODO: Implement me. */
        result = MAL_SUCCESS;

        /* NOTE: Only doing format conversion for now just while testing. */
        mal_uint8 buffer[4096];
        mal_uint32 bufferSizeInFrames = sizeof(buffer) / mal_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);

        while (totalFramesRead < frameCount) {
            mal_uint32 framesRemaining = (frameCount - totalFramesRead);
            mal_uint32 framesToProcess = framesRemaining;
            if (framesToProcess > bufferSizeInFrames) {
                framesToProcess = bufferSizeInFrames;
            }

            result = pDevice->pContext->onDeviceRead(pDevice, buffer, framesToProcess);

            mal_pcm_convert(
                mal_offset_ptr(pPCMFrames, totalFramesRead * mal_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels)),
                pDevice->capture.format,
                buffer,
                pDevice->capture.internalFormat,
                framesToProcess*pDevice->capture.channels,
                mal_dither_mode_none);

            totalFramesRead += framesToProcess;
            if (result != MAL_SUCCESS) {
                break;
            }
        }
    }

    return result;
}

void mal_device_set_stop_callback(mal_device* pDevice, mal_stop_proc proc)
{
    if (pDevice == NULL) return;
    mal_atomic_exchange_ptr(&pDevice->onStop, proc);
}

mal_result mal_device_start(mal_device* pDevice)
{
    if (pDevice == NULL) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "mal_device_start() called with invalid arguments (pDevice == NULL).", MAL_INVALID_ARGS);
    }

    if (mal_device__get_state(pDevice) == MAL_STATE_UNINITIALIZED) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "mal_device_start() called for an uninitialized device.", MAL_DEVICE_NOT_INITIALIZED);
    }

    /*
    Starting the device doesn't do anything in synchronous mode because in that case it's started automatically with
    mal_device_write() and mal_device_read(). It's best to return an error so that the application can be aware that
    it's not doing it right.
    */
    if (!mal_device__is_async(pDevice)) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "mal_device_start() called in synchronous mode. This should only be used in asynchronous/callback mode.", MAL_DEVICE_NOT_INITIALIZED);
    }

    mal_result result = MAL_ERROR;
    mal_mutex_lock(&pDevice->lock);
    {
        // Starting and stopping are wrapped in a mutex which means we can assert that the device is in a stopped or paused state.
        mal_assert(mal_device__get_state(pDevice) == MAL_STATE_STOPPED);

        mal_device__set_state(pDevice, MAL_STATE_STARTING);

        // Asynchronous backends need to be handled differently.
        if (mal_context_is_backend_asynchronous(pDevice->pContext)) {
            result = pDevice->pContext->onDeviceStart(pDevice);
            if (result == MAL_SUCCESS) {
                mal_device__set_state(pDevice, MAL_STATE_STARTED);
            }
        } else {
            // Synchronous backends are started by signaling an event that's being waited on in the worker thread. We first wake up the
            // thread and then wait for the start event.
            mal_event_signal(&pDevice->wakeupEvent);

            // Wait for the worker thread to finish starting the device. Note that the worker thread will be the one
            // who puts the device into the started state. Don't call mal_device__set_state() here.
            mal_event_wait(&pDevice->startEvent);
            result = pDevice->workResult;
        }
    }
    mal_mutex_unlock(&pDevice->lock);

    return result;
}

mal_result mal_device_stop(mal_device* pDevice)
{
    if (pDevice == NULL) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "mal_device_stop() called with invalid arguments (pDevice == NULL).", MAL_INVALID_ARGS);
    }

    if (mal_device__get_state(pDevice) == MAL_STATE_UNINITIALIZED) {
        return mal_post_error(pDevice, MAL_LOG_LEVEL_ERROR, "mal_device_stop() called for an uninitialized device.", MAL_DEVICE_NOT_INITIALIZED);
    }

    /*
    Stopping is slightly different for synchronous mode. In this case it just tells the driver to stop the internal processing of the device. Also,
    stopping in synchronous mode does not require state checking.
    */
    if (!mal_device__is_async(pDevice)) {
        return pDevice->pContext->onDeviceStop(pDevice);
    }

    mal_result result = MAL_ERROR;
    mal_mutex_lock(&pDevice->lock);
    {
        // Starting and stopping are wrapped in a mutex which means we can assert that the device is in a started or paused state.
        mal_assert(mal_device__get_state(pDevice) == MAL_STATE_STARTED);

        mal_device__set_state(pDevice, MAL_STATE_STOPPING);

        // There's no need to wake up the thread like we do when starting.

        // Asynchronous backends need to be handled differently.
        if (mal_context_is_backend_asynchronous(pDevice->pContext)) {
            result = pDevice->pContext->onDeviceStop(pDevice);
            mal_device__set_state(pDevice, MAL_STATE_STOPPED);
        } else {
            // Synchronous backends.

            // We need to wait for the worker thread to become available for work before returning. Note that the worker thread will be
            // the one who puts the device into the stopped state. Don't call mal_device__set_state() here.
            mal_event_wait(&pDevice->stopEvent);
            result = MAL_SUCCESS;
        }
    }
    mal_mutex_unlock(&pDevice->lock);

    return result;
}

mal_bool32 mal_device_is_started(mal_device* pDevice)
{
    if (pDevice == NULL) return MAL_FALSE;
    return mal_device__get_state(pDevice) == MAL_STATE_STARTED;
}


mal_context_config mal_context_config_init()
{
    mal_context_config config;
    mal_zero_object(&config);

    return config;
}

mal_device_config mal_device_config_init(mal_device_type deviceType)
{
    mal_device_config config;
    mal_zero_object(&config);
    config.deviceType = deviceType;

    return config;
}
#endif  // MAL_NO_DEVICE_IO


void mal_get_standard_channel_map_microsoft(mal_uint32 channels, mal_channel channelMap[MAL_MAX_CHANNELS])
{
    // Based off the speaker configurations mentioned here: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ksmedia/ns-ksmedia-ksaudio_channel_config
    switch (channels)
    {
        case 1:
        {
            channelMap[0] = MAL_CHANNEL_MONO;
        } break;

        case 2:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
        } break;

        case 3: // Not defined, but best guess.
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_FRONT_CENTER;
        } break;

        case 4:
        {
#ifndef MAL_USE_QUAD_MICROSOFT_CHANNEL_MAP
            // Surround. Using the Surround profile has the advantage of the 3rd channel (MAL_CHANNEL_FRONT_CENTER) mapping nicely
            // with higher channel counts.
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[3] = MAL_CHANNEL_BACK_CENTER;
#else
            // Quad.
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_BACK_LEFT;
            channelMap[3] = MAL_CHANNEL_BACK_RIGHT;
#endif
        } break;

        case 5: // Not defined, but best guess.
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[3] = MAL_CHANNEL_BACK_LEFT;
            channelMap[4] = MAL_CHANNEL_BACK_RIGHT;
        } break;

        case 6:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[3] = MAL_CHANNEL_LFE;
            channelMap[4] = MAL_CHANNEL_SIDE_LEFT;
            channelMap[5] = MAL_CHANNEL_SIDE_RIGHT;
        } break;

        case 7: // Not defined, but best guess.
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[3] = MAL_CHANNEL_LFE;
            channelMap[4] = MAL_CHANNEL_BACK_CENTER;
            channelMap[5] = MAL_CHANNEL_SIDE_LEFT;
            channelMap[6] = MAL_CHANNEL_SIDE_RIGHT;
        } break;

        case 8:
        default:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[3] = MAL_CHANNEL_LFE;
            channelMap[4] = MAL_CHANNEL_BACK_LEFT;
            channelMap[5] = MAL_CHANNEL_BACK_RIGHT;
            channelMap[6] = MAL_CHANNEL_SIDE_LEFT;
            channelMap[7] = MAL_CHANNEL_SIDE_RIGHT;
        } break;
    }

    // Remainder.
    if (channels > 8) {
        for (mal_uint32 iChannel = 8; iChannel < MAL_MAX_CHANNELS; ++iChannel) {
            channelMap[iChannel] = (mal_channel)(MAL_CHANNEL_AUX_0 + (iChannel-8));
        }
    }
}

void mal_get_standard_channel_map_alsa(mal_uint32 channels, mal_channel channelMap[MAL_MAX_CHANNELS])
{
    switch (channels)
    {
        case 1:
        {
            channelMap[0] = MAL_CHANNEL_MONO;
        } break;

        case 2:
        {
            channelMap[0] = MAL_CHANNEL_LEFT;
            channelMap[1] = MAL_CHANNEL_RIGHT;
        } break;

        case 3:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_FRONT_CENTER;
        } break;

        case 4:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_BACK_LEFT;
            channelMap[3] = MAL_CHANNEL_BACK_RIGHT;
        } break;

        case 5:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_BACK_LEFT;
            channelMap[3] = MAL_CHANNEL_BACK_RIGHT;
            channelMap[4] = MAL_CHANNEL_FRONT_CENTER;
        } break;

        case 6:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_BACK_LEFT;
            channelMap[3] = MAL_CHANNEL_BACK_RIGHT;
            channelMap[4] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[5] = MAL_CHANNEL_LFE;
        } break;

        case 7:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_BACK_LEFT;
            channelMap[3] = MAL_CHANNEL_BACK_RIGHT;
            channelMap[4] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[5] = MAL_CHANNEL_LFE;
            channelMap[6] = MAL_CHANNEL_BACK_CENTER;
        } break;

        case 8:
        default:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_BACK_LEFT;
            channelMap[3] = MAL_CHANNEL_BACK_RIGHT;
            channelMap[4] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[5] = MAL_CHANNEL_LFE;
            channelMap[6] = MAL_CHANNEL_SIDE_LEFT;
            channelMap[7] = MAL_CHANNEL_SIDE_RIGHT;
        } break;
    }

    // Remainder.
    if (channels > 8) {
        for (mal_uint32 iChannel = 8; iChannel < MAL_MAX_CHANNELS; ++iChannel) {
            channelMap[iChannel] = (mal_channel)(MAL_CHANNEL_AUX_0 + (iChannel-8));
        }
    }
}

void mal_get_standard_channel_map_rfc3551(mal_uint32 channels, mal_channel channelMap[MAL_MAX_CHANNELS])
{
    switch (channels)
    {
        case 1:
        {
            channelMap[0] = MAL_CHANNEL_MONO;
        } break;

        case 2:
        {
            channelMap[0] = MAL_CHANNEL_LEFT;
            channelMap[1] = MAL_CHANNEL_RIGHT;
        } break;

        case 3:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_FRONT_CENTER;
        } break;

        case 4:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[2] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[3] = MAL_CHANNEL_BACK_CENTER;
        } break;

        case 5:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[3] = MAL_CHANNEL_BACK_LEFT;
            channelMap[4] = MAL_CHANNEL_BACK_RIGHT;
        } break;

        case 6:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_SIDE_LEFT;
            channelMap[2] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[3] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[4] = MAL_CHANNEL_SIDE_RIGHT;
            channelMap[5] = MAL_CHANNEL_BACK_CENTER;
        } break;
    }

    // Remainder.
    if (channels > 8) {
        for (mal_uint32 iChannel = 6; iChannel < MAL_MAX_CHANNELS; ++iChannel) {
            channelMap[iChannel] = (mal_channel)(MAL_CHANNEL_AUX_0 + (iChannel-6));
        }
    }
}

void mal_get_standard_channel_map_flac(mal_uint32 channels, mal_channel channelMap[MAL_MAX_CHANNELS])
{
    switch (channels)
    {
        case 1:
        {
            channelMap[0] = MAL_CHANNEL_MONO;
        } break;

        case 2:
        {
            channelMap[0] = MAL_CHANNEL_LEFT;
            channelMap[1] = MAL_CHANNEL_RIGHT;
        } break;

        case 3:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_FRONT_CENTER;
        } break;

        case 4:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_BACK_LEFT;
            channelMap[3] = MAL_CHANNEL_BACK_RIGHT;
        } break;

        case 5:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[3] = MAL_CHANNEL_BACK_LEFT;
            channelMap[4] = MAL_CHANNEL_BACK_RIGHT;
        } break;

        case 6:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[3] = MAL_CHANNEL_LFE;
            channelMap[4] = MAL_CHANNEL_BACK_LEFT;
            channelMap[5] = MAL_CHANNEL_BACK_RIGHT;
        } break;

        case 7:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[3] = MAL_CHANNEL_LFE;
            channelMap[4] = MAL_CHANNEL_BACK_CENTER;
            channelMap[5] = MAL_CHANNEL_SIDE_LEFT;
            channelMap[6] = MAL_CHANNEL_SIDE_RIGHT;
        } break;

        case 8:
        default:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[3] = MAL_CHANNEL_LFE;
            channelMap[4] = MAL_CHANNEL_BACK_LEFT;
            channelMap[5] = MAL_CHANNEL_BACK_RIGHT;
            channelMap[6] = MAL_CHANNEL_SIDE_LEFT;
            channelMap[7] = MAL_CHANNEL_SIDE_RIGHT;
        } break;
    }

    // Remainder.
    if (channels > 8) {
        for (mal_uint32 iChannel = 8; iChannel < MAL_MAX_CHANNELS; ++iChannel) {
            channelMap[iChannel] = (mal_channel)(MAL_CHANNEL_AUX_0 + (iChannel-8));
        }
    }
}

void mal_get_standard_channel_map_vorbis(mal_uint32 channels, mal_channel channelMap[MAL_MAX_CHANNELS])
{
    // In Vorbis' type 0 channel mapping, the first two channels are not always the standard left/right - it
    // will have the center speaker where the right usually goes. Why?!
    switch (channels)
    {
        case 1:
        {
            channelMap[0] = MAL_CHANNEL_MONO;
        } break;

        case 2:
        {
            channelMap[0] = MAL_CHANNEL_LEFT;
            channelMap[1] = MAL_CHANNEL_RIGHT;
        } break;

        case 3:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[2] = MAL_CHANNEL_FRONT_RIGHT;
        } break;

        case 4:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_BACK_LEFT;
            channelMap[3] = MAL_CHANNEL_BACK_RIGHT;
        } break;

        case 5:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[2] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[3] = MAL_CHANNEL_BACK_LEFT;
            channelMap[4] = MAL_CHANNEL_BACK_RIGHT;
        } break;

        case 6:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[2] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[3] = MAL_CHANNEL_BACK_LEFT;
            channelMap[4] = MAL_CHANNEL_BACK_RIGHT;
            channelMap[5] = MAL_CHANNEL_LFE;
        } break;

        case 7:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[2] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[3] = MAL_CHANNEL_SIDE_LEFT;
            channelMap[4] = MAL_CHANNEL_SIDE_RIGHT;
            channelMap[5] = MAL_CHANNEL_BACK_CENTER;
            channelMap[6] = MAL_CHANNEL_LFE;
        } break;

        case 8:
        default:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[2] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[3] = MAL_CHANNEL_SIDE_LEFT;
            channelMap[4] = MAL_CHANNEL_SIDE_RIGHT;
            channelMap[5] = MAL_CHANNEL_BACK_LEFT;
            channelMap[6] = MAL_CHANNEL_BACK_RIGHT;
            channelMap[7] = MAL_CHANNEL_LFE;
        } break;
    }

    // Remainder.
    if (channels > 8) {
        for (mal_uint32 iChannel = 8; iChannel < MAL_MAX_CHANNELS; ++iChannel) {
            channelMap[iChannel] = (mal_channel)(MAL_CHANNEL_AUX_0 + (iChannel-8));
        }
    }
}

void mal_get_standard_channel_map_sound4(mal_uint32 channels, mal_channel channelMap[MAL_MAX_CHANNELS])
{
    switch (channels)
    {
        case 1:
        {
            channelMap[0] = MAL_CHANNEL_MONO;
        } break;

        case 2:
        {
            channelMap[0] = MAL_CHANNEL_LEFT;
            channelMap[1] = MAL_CHANNEL_RIGHT;
        } break;

        case 3:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_BACK_CENTER;
        } break;

        case 4:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_BACK_LEFT;
            channelMap[3] = MAL_CHANNEL_BACK_RIGHT;
        } break;

        case 5:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_BACK_LEFT;
            channelMap[3] = MAL_CHANNEL_BACK_RIGHT;
            channelMap[4] = MAL_CHANNEL_FRONT_CENTER;
        } break;

        case 6:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_BACK_LEFT;
            channelMap[3] = MAL_CHANNEL_BACK_RIGHT;
            channelMap[4] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[5] = MAL_CHANNEL_LFE;
        } break;

        case 7:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_BACK_LEFT;
            channelMap[3] = MAL_CHANNEL_BACK_RIGHT;
            channelMap[4] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[5] = MAL_CHANNEL_BACK_CENTER;
            channelMap[6] = MAL_CHANNEL_LFE;
        } break;

        case 8:
        default:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_BACK_LEFT;
            channelMap[3] = MAL_CHANNEL_BACK_RIGHT;
            channelMap[4] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[5] = MAL_CHANNEL_LFE;
            channelMap[6] = MAL_CHANNEL_SIDE_LEFT;
            channelMap[7] = MAL_CHANNEL_SIDE_RIGHT;
        } break;
    }

    // Remainder.
    if (channels > 8) {
        for (mal_uint32 iChannel = 8; iChannel < MAL_MAX_CHANNELS; ++iChannel) {
            channelMap[iChannel] = (mal_channel)(MAL_CHANNEL_AUX_0 + (iChannel-8));
        }
    }
}

void mal_get_standard_channel_map_sndio(mal_uint32 channels, mal_channel channelMap[MAL_MAX_CHANNELS])
{
    switch (channels)
    {
        case 1:
        {
            channelMap[0] = MAL_CHANNEL_MONO;
        } break;

        case 2:
        {
            channelMap[0] = MAL_CHANNEL_LEFT;
            channelMap[1] = MAL_CHANNEL_RIGHT;
        } break;

        case 3:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_FRONT_CENTER;
        } break;

        case 4:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_BACK_LEFT;
            channelMap[3] = MAL_CHANNEL_BACK_RIGHT;
        } break;

        case 5:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_BACK_LEFT;
            channelMap[3] = MAL_CHANNEL_BACK_RIGHT;
            channelMap[4] = MAL_CHANNEL_FRONT_CENTER;
        } break;

        case 6:
        default:
        {
            channelMap[0] = MAL_CHANNEL_FRONT_LEFT;
            channelMap[1] = MAL_CHANNEL_FRONT_RIGHT;
            channelMap[2] = MAL_CHANNEL_BACK_LEFT;
            channelMap[3] = MAL_CHANNEL_BACK_RIGHT;
            channelMap[4] = MAL_CHANNEL_FRONT_CENTER;
            channelMap[5] = MAL_CHANNEL_LFE;
        } break;
    }

    // Remainder.
    if (channels > 6) {
        for (mal_uint32 iChannel = 6; iChannel < MAL_MAX_CHANNELS; ++iChannel) {
            channelMap[iChannel] = (mal_channel)(MAL_CHANNEL_AUX_0 + (iChannel-6));
        }
    }
}

void mal_get_standard_channel_map(mal_standard_channel_map standardChannelMap, mal_uint32 channels, mal_channel channelMap[MAL_MAX_CHANNELS])
{
    switch (standardChannelMap)
    {
        case mal_standard_channel_map_alsa:
        {
            mal_get_standard_channel_map_alsa(channels, channelMap);
        } break;

        case mal_standard_channel_map_rfc3551:
        {
            mal_get_standard_channel_map_rfc3551(channels, channelMap);
        } break;

        case mal_standard_channel_map_flac:
        {
            mal_get_standard_channel_map_flac(channels, channelMap);
        } break;

        case mal_standard_channel_map_vorbis:
        {
            mal_get_standard_channel_map_vorbis(channels, channelMap);
        } break;

        case mal_standard_channel_map_sound4:
        {
            mal_get_standard_channel_map_sound4(channels, channelMap);
        } break;
        
        case mal_standard_channel_map_sndio:
        {
            mal_get_standard_channel_map_sndio(channels, channelMap);
        } break;

        case mal_standard_channel_map_microsoft:
        default:
        {
            mal_get_standard_channel_map_microsoft(channels, channelMap);
        } break;
    }
}

void mal_channel_map_copy(mal_channel* pOut, const mal_channel* pIn, mal_uint32 channels)
{
    if (pOut != NULL && pIn != NULL && channels > 0) {
        mal_copy_memory(pOut, pIn, sizeof(*pOut) * channels);
    }
}

mal_bool32 mal_channel_map_valid(mal_uint32 channels, const mal_channel channelMap[MAL_MAX_CHANNELS])
{
    if (channelMap == NULL) {
        return MAL_FALSE;
    }

    // A channel count of 0 is invalid.
    if (channels == 0) {
        return MAL_FALSE;
    }

    // It does not make sense to have a mono channel when there is more than 1 channel.
    if (channels > 1) {
        for (mal_uint32 iChannel = 0; iChannel < channels; ++iChannel) {
            if (channelMap[iChannel] == MAL_CHANNEL_MONO) {
                return MAL_FALSE;
            }
        }
    }

    return MAL_TRUE;
}

mal_bool32 mal_channel_map_equal(mal_uint32 channels, const mal_channel channelMapA[MAL_MAX_CHANNELS], const mal_channel channelMapB[MAL_MAX_CHANNELS])
{
    if (channelMapA == channelMapB) {
        return MAL_FALSE;
    }

    if (channels == 0 || channels > MAL_MAX_CHANNELS) {
        return MAL_FALSE;
    }

    for (mal_uint32 iChannel = 0; iChannel < channels; ++iChannel) {
        if (channelMapA[iChannel] != channelMapB[iChannel]) {
            return MAL_FALSE;
        }
    }

    return MAL_TRUE;
}

mal_bool32 mal_channel_map_blank(mal_uint32 channels, const mal_channel channelMap[MAL_MAX_CHANNELS])
{
    for (mal_uint32 iChannel = 0; iChannel < channels; ++iChannel) {
        if (channelMap[iChannel] != MAL_CHANNEL_NONE) {
            return MAL_FALSE;
        }
    }

    return MAL_TRUE;
}

mal_bool32 mal_channel_map_contains_channel_position(mal_uint32 channels, const mal_channel channelMap[MAL_MAX_CHANNELS], mal_channel channelPosition)
{
    for (mal_uint32 iChannel = 0; iChannel < channels; ++iChannel) {
        if (channelMap[iChannel] == channelPosition) {
            return MAL_TRUE;
        }
    }

    return MAL_FALSE;
}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Format Conversion.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//#define MAL_USE_REFERENCE_CONVERSION_APIS   1
//#define MAL_USE_SSE

void mal_copy_memory_64(void* dst, const void* src, mal_uint64 sizeInBytes)
{
#if 0xFFFFFFFFFFFFFFFF <= MAL_SIZE_MAX
    mal_copy_memory(dst, src, (size_t)sizeInBytes);
#else
    while (sizeInBytes > 0) {
        mal_uint64 bytesToCopyNow = sizeInBytes;
        if (bytesToCopyNow > MAL_SIZE_MAX) {
            bytesToCopyNow = MAL_SIZE_MAX;
        }

        mal_copy_memory(dst, src, (size_t)bytesToCopyNow);  // Safe cast to size_t.

        sizeInBytes -= bytesToCopyNow;
        dst = (      void*)((      mal_uint8*)dst + bytesToCopyNow);
        src = (const void*)((const mal_uint8*)src + bytesToCopyNow);
    }
#endif
}

void mal_zero_memory_64(void* dst, mal_uint64 sizeInBytes)
{
#if 0xFFFFFFFFFFFFFFFF <= MAL_SIZE_MAX
    mal_zero_memory(dst, (size_t)sizeInBytes);
#else
    while (sizeInBytes > 0) {
        mal_uint64 bytesToZeroNow = sizeInBytes;
        if (bytesToZeroNow > MAL_SIZE_MAX) {
            bytesToZeroNow = MAL_SIZE_MAX;
        }

        mal_zero_memory(dst, (size_t)bytesToZeroNow);  // Safe cast to size_t.

        sizeInBytes -= bytesToZeroNow;
        dst = (void*)((mal_uint8*)dst + bytesToZeroNow);
    }
#endif
}


// u8
void mal_pcm_u8_to_u8(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;
    mal_copy_memory_64(dst, src, count * sizeof(mal_uint8));
}


void mal_pcm_u8_to_s16__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;

    mal_int16* dst_s16 = (mal_int16*)dst;
    const mal_uint8* src_u8 = (const mal_uint8*)src;

    mal_uint64 i;
    for (i = 0; i < count; i += 1) {
        mal_int16 x = src_u8[i];
        x = x - 128;
        x = x << 8;
        dst_s16[i] = x;
    }
}

void mal_pcm_u8_to_s16__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_s16__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_u8_to_s16__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_u8_to_s16__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_u8_to_s16__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_s16__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_u8_to_s16__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_s16__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_u8_to_s16(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_u8_to_s16__reference(dst, src, count, ditherMode);
#else
    mal_pcm_u8_to_s16__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_u8_to_s24__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;

    mal_uint8* dst_s24 = (mal_uint8*)dst;
    const mal_uint8* src_u8 = (const mal_uint8*)src;

    mal_uint64 i;
    for (i = 0; i < count; i += 1) {
        mal_int16 x = src_u8[i];
        x = x - 128;

        dst_s24[i*3+0] = 0;
        dst_s24[i*3+1] = 0;
        dst_s24[i*3+2] = (mal_uint8)((mal_int8)x);
    }
}

void mal_pcm_u8_to_s24__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_s24__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_u8_to_s24__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_u8_to_s24__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_u8_to_s24__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_s24__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_u8_to_s24__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_s24__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_u8_to_s24(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_u8_to_s24__reference(dst, src, count, ditherMode);
#else
    mal_pcm_u8_to_s24__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_u8_to_s32__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;

    mal_int32* dst_s32 = (mal_int32*)dst;
    const mal_uint8* src_u8 = (const mal_uint8*)src;

    mal_uint64 i;
    for (i = 0; i < count; i += 1) {
        mal_int32 x = src_u8[i];
        x = x - 128;
        x = x << 24;
        dst_s32[i] = x;
    }
}

void mal_pcm_u8_to_s32__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_s32__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_u8_to_s32__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_u8_to_s32__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_u8_to_s32__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_s32__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_u8_to_s32__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_s32__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_u8_to_s32(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_u8_to_s32__reference(dst, src, count, ditherMode);
#else
    mal_pcm_u8_to_s32__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_u8_to_f32__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;

    float* dst_f32 = (float*)dst;
    const mal_uint8* src_u8 = (const mal_uint8*)src;

    mal_uint64 i;
    for (i = 0; i < count; i += 1) {
        float x = (float)src_u8[i];
        x = x * 0.00784313725490196078f;    // 0..255 to 0..2
        x = x - 1;                          // 0..2 to -1..1

        dst_f32[i] = x;
    }
}

void mal_pcm_u8_to_f32__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_f32__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_u8_to_f32__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_u8_to_f32__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_u8_to_f32__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_f32__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_u8_to_f32__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_u8_to_f32__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_u8_to_f32(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_u8_to_f32__reference(dst, src, count, ditherMode);
#else
    mal_pcm_u8_to_f32__optimized(dst, src, count, ditherMode);
#endif
}



void mal_pcm_interleave_u8__reference(void* dst, const void** src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_uint8* dst_u8 = (mal_uint8*)dst;
    const mal_uint8** src_u8 = (const mal_uint8**)src;

    mal_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        mal_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst_u8[iFrame*channels + iChannel] = src_u8[iChannel][iFrame];
        }
    }
}

void mal_pcm_interleave_u8__optimized(void* dst, const void** src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_uint8* dst_u8 = (mal_uint8*)dst;
    const mal_uint8** src_u8 = (const mal_uint8**)src;

    if (channels == 1) {
        mal_copy_memory_64(dst, src[0], frameCount * sizeof(mal_uint8));
    } else if (channels == 2) {
        mal_uint64 iFrame;
        for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
            dst_u8[iFrame*2 + 0] = src_u8[0][iFrame];
            dst_u8[iFrame*2 + 1] = src_u8[1][iFrame];
        }
    } else {
        mal_uint64 iFrame;
        for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
            mal_uint32 iChannel;
            for (iChannel = 0; iChannel < channels; iChannel += 1) {
                dst_u8[iFrame*channels + iChannel] = src_u8[iChannel][iFrame];
            }
        }
    }
}

void mal_pcm_interleave_u8(void* dst, const void** src, mal_uint64 frameCount, mal_uint32 channels)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_interleave_u8__reference(dst, src, frameCount, channels);
#else
    mal_pcm_interleave_u8__optimized(dst, src, frameCount, channels);
#endif
}


void mal_pcm_deinterleave_u8__reference(void** dst, const void* src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_uint8** dst_u8 = (mal_uint8**)dst;
    const mal_uint8* src_u8 = (const mal_uint8*)src;

    mal_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        mal_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst_u8[iChannel][iFrame] = src_u8[iFrame*channels + iChannel];
        }
    }
}

void mal_pcm_deinterleave_u8__optimized(void** dst, const void* src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_pcm_deinterleave_u8__reference(dst, src, frameCount, channels);
}

void mal_pcm_deinterleave_u8(void** dst, const void* src, mal_uint64 frameCount, mal_uint32 channels)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_deinterleave_u8__reference(dst, src, frameCount, channels);
#else
    mal_pcm_deinterleave_u8__optimized(dst, src, frameCount, channels);
#endif
}


// s16
void mal_pcm_s16_to_u8__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_uint8* dst_u8 = (mal_uint8*)dst;
    const mal_int16* src_s16 = (const mal_int16*)src;

    if (ditherMode == mal_dither_mode_none) {
        mal_uint64 i;
        for (i = 0; i < count; i += 1) {
            mal_int16 x = src_s16[i];
            x = x >> 8;
            x = x + 128;
            dst_u8[i] = (mal_uint8)x;
        }
    } else {
        mal_uint64 i;
        for (i = 0; i < count; i += 1) {
            mal_int16 x = src_s16[i];

            // Dither. Don't overflow.
            mal_int32 dither = mal_dither_s32(ditherMode, -0x80, 0x7F);
            if ((x + dither) <= 0x7FFF) {
                x = (mal_int16)(x + dither);
            } else {
                x = 0x7FFF;
            }

            x = x >> 8;
            x = x + 128;
            dst_u8[i] = (mal_uint8)x;
        }
    }
}

void mal_pcm_s16_to_u8__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_u8__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_s16_to_u8__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_s16_to_u8__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_s16_to_u8__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_u8__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_s16_to_u8__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_u8__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_s16_to_u8(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_s16_to_u8__reference(dst, src, count, ditherMode);
#else
    mal_pcm_s16_to_u8__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_s16_to_s16(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;
    mal_copy_memory_64(dst, src, count * sizeof(mal_int16));
}


void mal_pcm_s16_to_s24__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;

    mal_uint8* dst_s24 = (mal_uint8*)dst;
    const mal_int16* src_s16 = (const mal_int16*)src;

    mal_uint64 i;
    for (i = 0; i < count; i += 1) {
        dst_s24[i*3+0] = 0;
        dst_s24[i*3+1] = (mal_uint8)(src_s16[i] & 0xFF);
        dst_s24[i*3+2] = (mal_uint8)(src_s16[i] >> 8);
    }
}

void mal_pcm_s16_to_s24__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_s24__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_s16_to_s24__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_s16_to_s24__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_s16_to_s24__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_s24__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_s16_to_s24__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_s24__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_s16_to_s24(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_s16_to_s24__reference(dst, src, count, ditherMode);
#else
    mal_pcm_s16_to_s24__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_s16_to_s32__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;

    mal_int32* dst_s32 = (mal_int32*)dst;
    const mal_int16* src_s16 = (const mal_int16*)src;

    mal_uint64 i;
    for (i = 0; i < count; i += 1) {
        dst_s32[i] = src_s16[i] << 16;
    }
}

void mal_pcm_s16_to_s32__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_s32__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_s16_to_s32__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_s16_to_s32__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_s16_to_s32__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_s32__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_s16_to_s32__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_s32__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_s16_to_s32(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_s16_to_s32__reference(dst, src, count, ditherMode);
#else
    mal_pcm_s16_to_s32__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_s16_to_f32__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;

    float* dst_f32 = (float*)dst;
    const mal_int16* src_s16 = (const mal_int16*)src;

    mal_uint64 i;
    for (i = 0; i < count; i += 1) {
        float x = (float)src_s16[i];

#if 0
        // The accurate way.
        x = x + 32768.0f;                   // -32768..32767 to 0..65535
        x = x * 0.00003051804379339284f;    // 0..65536 to 0..2
        x = x - 1;                          // 0..2 to -1..1
#else
        // The fast way.
        x = x * 0.000030517578125f;         // -32768..32767 to -1..0.999969482421875
#endif

        dst_f32[i] = x;
    }
}

void mal_pcm_s16_to_f32__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_f32__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_s16_to_f32__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_s16_to_f32__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_s16_to_f32__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_f32__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_s16_to_f32__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s16_to_f32__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_s16_to_f32(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_s16_to_f32__reference(dst, src, count, ditherMode);
#else
    mal_pcm_s16_to_f32__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_interleave_s16__reference(void* dst, const void** src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_int16* dst_s16 = (mal_int16*)dst;
    const mal_int16** src_s16 = (const mal_int16**)src;

    mal_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        mal_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst_s16[iFrame*channels + iChannel] = src_s16[iChannel][iFrame];
        }
    }
}

void mal_pcm_interleave_s16__optimized(void* dst, const void** src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_pcm_interleave_s16__reference(dst, src, frameCount, channels);
}

void mal_pcm_interleave_s16(void* dst, const void** src, mal_uint64 frameCount, mal_uint32 channels)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_interleave_s16__reference(dst, src, frameCount, channels);
#else
    mal_pcm_interleave_s16__optimized(dst, src, frameCount, channels);
#endif
}


void mal_pcm_deinterleave_s16__reference(void** dst, const void* src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_int16** dst_s16 = (mal_int16**)dst;
    const mal_int16* src_s16 = (const mal_int16*)src;

    mal_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        mal_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst_s16[iChannel][iFrame] = src_s16[iFrame*channels + iChannel];
        }
    }
}

void mal_pcm_deinterleave_s16__optimized(void** dst, const void* src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_pcm_deinterleave_s16__reference(dst, src, frameCount, channels);
}

void mal_pcm_deinterleave_s16(void** dst, const void* src, mal_uint64 frameCount, mal_uint32 channels)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_deinterleave_s16__reference(dst, src, frameCount, channels);
#else
    mal_pcm_deinterleave_s16__optimized(dst, src, frameCount, channels);
#endif
}


// s24
void mal_pcm_s24_to_u8__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_uint8* dst_u8 = (mal_uint8*)dst;
    const mal_uint8* src_s24 = (const mal_uint8*)src;

    if (ditherMode == mal_dither_mode_none) {
        mal_uint64 i;
        for (i = 0; i < count; i += 1) {
            mal_int8 x = (mal_int8)src_s24[i*3 + 2] + 128;
            dst_u8[i] = (mal_uint8)x;
        }
    } else {
        mal_uint64 i;
        for (i = 0; i < count; i += 1) {
            mal_int32 x = (mal_int32)(((mal_uint32)(src_s24[i*3+0]) << 8) | ((mal_uint32)(src_s24[i*3+1]) << 16) | ((mal_uint32)(src_s24[i*3+2])) << 24);

            // Dither. Don't overflow.
            mal_int32 dither = mal_dither_s32(ditherMode, -0x800000, 0x7FFFFF);
            if ((mal_int64)x + dither <= 0x7FFFFFFF) {
                x = x + dither;
            } else {
                x = 0x7FFFFFFF;
            }
            
            x = x >> 24;
            x = x + 128;
            dst_u8[i] = (mal_uint8)x;
        }
    }
}

void mal_pcm_s24_to_u8__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_u8__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_s24_to_u8__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_s24_to_u8__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_s24_to_u8__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_u8__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_s24_to_u8__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_u8__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_s24_to_u8(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_s24_to_u8__reference(dst, src, count, ditherMode);
#else
    mal_pcm_s24_to_u8__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_s24_to_s16__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_int16* dst_s16 = (mal_int16*)dst;
    const mal_uint8* src_s24 = (const mal_uint8*)src;

    if (ditherMode == mal_dither_mode_none) {
        mal_uint64 i;
        for (i = 0; i < count; i += 1) {
            mal_uint16 dst_lo = ((mal_uint16)src_s24[i*3 + 1]);
            mal_uint16 dst_hi = ((mal_uint16)src_s24[i*3 + 2]) << 8;
            dst_s16[i] = (mal_int16)dst_lo | dst_hi;
        }
    } else {
        mal_uint64 i;
        for (i = 0; i < count; i += 1) {
            mal_int32 x = (mal_int32)(((mal_uint32)(src_s24[i*3+0]) << 8) | ((mal_uint32)(src_s24[i*3+1]) << 16) | ((mal_uint32)(src_s24[i*3+2])) << 24);

            // Dither. Don't overflow.
            mal_int32 dither = mal_dither_s32(ditherMode, -0x8000, 0x7FFF);
            if ((mal_int64)x + dither <= 0x7FFFFFFF) {
                x = x + dither;
            } else {
                x = 0x7FFFFFFF;
            }

            x = x >> 16;
            dst_s16[i] = (mal_int16)x;
        }
    }
}

void mal_pcm_s24_to_s16__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_s16__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_s24_to_s16__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_s24_to_s16__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_s24_to_s16__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_s16__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_s24_to_s16__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_s16__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_s24_to_s16(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_s24_to_s16__reference(dst, src, count, ditherMode);
#else
    mal_pcm_s24_to_s16__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_s24_to_s24(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;

    mal_copy_memory_64(dst, src, count * 3);
}


void mal_pcm_s24_to_s32__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;

    mal_int32* dst_s32 = (mal_int32*)dst;
    const mal_uint8* src_s24 = (const mal_uint8*)src;

    mal_uint64 i;
    for (i = 0; i < count; i += 1) {
        dst_s32[i] = (mal_int32)(((mal_uint32)(src_s24[i*3+0]) << 8) | ((mal_uint32)(src_s24[i*3+1]) << 16) | ((mal_uint32)(src_s24[i*3+2])) << 24);
    }
}

void mal_pcm_s24_to_s32__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_s32__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_s24_to_s32__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_s24_to_s32__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_s24_to_s32__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_s32__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_s24_to_s32__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_s32__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_s24_to_s32(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_s24_to_s32__reference(dst, src, count, ditherMode);
#else
    mal_pcm_s24_to_s32__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_s24_to_f32__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;

    float* dst_f32 = (float*)dst;
    const mal_uint8* src_s24 = (const mal_uint8*)src;

    mal_uint64 i;
    for (i = 0; i < count; i += 1) {
        float x = (float)(((mal_int32)(((mal_uint32)(src_s24[i*3+0]) << 8) | ((mal_uint32)(src_s24[i*3+1]) << 16) | ((mal_uint32)(src_s24[i*3+2])) << 24)) >> 8);

#if 0
        // The accurate way.
        x = x + 8388608.0f;                 // -8388608..8388607 to 0..16777215
        x = x * 0.00000011920929665621f;    // 0..16777215 to 0..2
        x = x - 1;                          // 0..2 to -1..1
#else
        // The fast way.
        x = x * 0.00000011920928955078125f; // -8388608..8388607 to -1..0.999969482421875
#endif

        dst_f32[i] = x;
    }
}

void mal_pcm_s24_to_f32__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_f32__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_s24_to_f32__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_s24_to_f32__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_s24_to_f32__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_f32__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_s24_to_f32__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s24_to_f32__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_s24_to_f32(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_s24_to_f32__reference(dst, src, count, ditherMode);
#else
    mal_pcm_s24_to_f32__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_interleave_s24__reference(void* dst, const void** src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_uint8* dst8 = (mal_uint8*)dst;
    const mal_uint8** src8 = (const mal_uint8**)src;

    mal_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        mal_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst8[iFrame*3*channels + iChannel*3 + 0] = src8[iChannel][iFrame*3 + 0];
            dst8[iFrame*3*channels + iChannel*3 + 1] = src8[iChannel][iFrame*3 + 1];
            dst8[iFrame*3*channels + iChannel*3 + 2] = src8[iChannel][iFrame*3 + 2];
        }
    }
}

void mal_pcm_interleave_s24__optimized(void* dst, const void** src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_pcm_interleave_s24__reference(dst, src, frameCount, channels);
}

void mal_pcm_interleave_s24(void* dst, const void** src, mal_uint64 frameCount, mal_uint32 channels)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_interleave_s24__reference(dst, src, frameCount, channels);
#else
    mal_pcm_interleave_s24__optimized(dst, src, frameCount, channels);
#endif
}


void mal_pcm_deinterleave_s24__reference(void** dst, const void* src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_uint8** dst8 = (mal_uint8**)dst;
    const mal_uint8* src8 = (const mal_uint8*)src;

    mal_uint32 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        mal_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst8[iChannel][iFrame*3 + 0] = src8[iFrame*3*channels + iChannel*3 + 0];
            dst8[iChannel][iFrame*3 + 1] = src8[iFrame*3*channels + iChannel*3 + 1];
            dst8[iChannel][iFrame*3 + 2] = src8[iFrame*3*channels + iChannel*3 + 2];
        }
    }
}

void mal_pcm_deinterleave_s24__optimized(void** dst, const void* src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_pcm_deinterleave_s24__reference(dst, src, frameCount, channels);
}

void mal_pcm_deinterleave_s24(void** dst, const void* src, mal_uint64 frameCount, mal_uint32 channels)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_deinterleave_s24__reference(dst, src, frameCount, channels);
#else
    mal_pcm_deinterleave_s24__optimized(dst, src, frameCount, channels);
#endif
}



// s32
void mal_pcm_s32_to_u8__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_uint8* dst_u8 = (mal_uint8*)dst;
    const mal_int32* src_s32 = (const mal_int32*)src;

    if (ditherMode == mal_dither_mode_none) {
        mal_uint64 i;
        for (i = 0; i < count; i += 1) {
            mal_int32 x = src_s32[i];
            x = x >> 24;
            x = x + 128;
            dst_u8[i] = (mal_uint8)x;
        }
    } else {
        mal_uint64 i;
        for (i = 0; i < count; i += 1) {
            mal_int32 x = src_s32[i];

            // Dither. Don't overflow.
            mal_int32 dither = mal_dither_s32(ditherMode, -0x800000, 0x7FFFFF);
            if ((mal_int64)x + dither <= 0x7FFFFFFF) {
                x = x + dither;
            } else {
                x = 0x7FFFFFFF;
            }
            
            x = x >> 24;
            x = x + 128;
            dst_u8[i] = (mal_uint8)x;
        }
    }
}

void mal_pcm_s32_to_u8__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_u8__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_s32_to_u8__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_s32_to_u8__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_s32_to_u8__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_u8__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_s32_to_u8__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_s32_to_u8(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_s32_to_u8__reference(dst, src, count, ditherMode);
#else
    mal_pcm_s32_to_u8__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_s32_to_s16__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_int16* dst_s16 = (mal_int16*)dst;
    const mal_int32* src_s32 = (const mal_int32*)src;

    if (ditherMode == mal_dither_mode_none) {
        mal_uint64 i;
        for (i = 0; i < count; i += 1) {
            mal_int32 x = src_s32[i];
            x = x >> 16;
            dst_s16[i] = (mal_int16)x;
        }
    } else {
        mal_uint64 i;
        for (i = 0; i < count; i += 1) {
            mal_int32 x = src_s32[i];

            // Dither. Don't overflow.
            mal_int32 dither = mal_dither_s32(ditherMode, -0x8000, 0x7FFF);
            if ((mal_int64)x + dither <= 0x7FFFFFFF) {
                x = x + dither;
            } else {
                x = 0x7FFFFFFF;
            }
            
            x = x >> 16;
            dst_s16[i] = (mal_int16)x;
        }
    }
}

void mal_pcm_s32_to_s16__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_s16__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_s32_to_s16__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_s32_to_s16__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_s32_to_s16__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_s16__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_s32_to_s16__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_s16__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_s32_to_s16(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_s32_to_s16__reference(dst, src, count, ditherMode);
#else
    mal_pcm_s32_to_s16__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_s32_to_s24__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;   // No dithering for s32 -> s24.

    mal_uint8* dst_s24 = (mal_uint8*)dst;
    const mal_int32* src_s32 = (const mal_int32*)src;

    mal_uint64 i;
    for (i = 0; i < count; i += 1) {
        mal_uint32 x = (mal_uint32)src_s32[i];
        dst_s24[i*3+0] = (mal_uint8)((x & 0x0000FF00) >>  8);
        dst_s24[i*3+1] = (mal_uint8)((x & 0x00FF0000) >> 16);
        dst_s24[i*3+2] = (mal_uint8)((x & 0xFF000000) >> 24);
    }
}

void mal_pcm_s32_to_s24__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_s24__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_s32_to_s24__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_s32_to_s24__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_s32_to_s24__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_s24__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_s32_to_s24__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_s32_to_s24(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_s32_to_s24__reference(dst, src, count, ditherMode);
#else
    mal_pcm_s32_to_s24__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_s32_to_s32(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;

    mal_copy_memory_64(dst, src, count * sizeof(mal_int32));
}


void mal_pcm_s32_to_f32__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;   // No dithering for s32 -> f32.

    float* dst_f32 = (float*)dst;
    const mal_int32* src_s32 = (const mal_int32*)src;

    mal_uint64 i;
    for (i = 0; i < count; i += 1) {
        double x = src_s32[i];

#if 0
        x = x + 2147483648.0;
        x = x * 0.0000000004656612873077392578125;
        x = x - 1;
#else
        x = x / 2147483648.0;
#endif

        dst_f32[i] = (float)x;
    }
}

void mal_pcm_s32_to_f32__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_f32__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_s32_to_f32__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_s32_to_f32__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_s32_to_f32__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_f32__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_s32_to_f32__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_s32_to_f32__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_s32_to_f32(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_s32_to_f32__reference(dst, src, count, ditherMode);
#else
    mal_pcm_s32_to_f32__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_interleave_s32__reference(void* dst, const void** src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_int32* dst_s32 = (mal_int32*)dst;
    const mal_int32** src_s32 = (const mal_int32**)src;

    mal_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        mal_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst_s32[iFrame*channels + iChannel] = src_s32[iChannel][iFrame];
        }
    }
}

void mal_pcm_interleave_s32__optimized(void* dst, const void** src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_pcm_interleave_s32__reference(dst, src, frameCount, channels);
}

void mal_pcm_interleave_s32(void* dst, const void** src, mal_uint64 frameCount, mal_uint32 channels)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_interleave_s32__reference(dst, src, frameCount, channels);
#else
    mal_pcm_interleave_s32__optimized(dst, src, frameCount, channels);
#endif
}


void mal_pcm_deinterleave_s32__reference(void** dst, const void* src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_int32** dst_s32 = (mal_int32**)dst;
    const mal_int32* src_s32 = (const mal_int32*)src;

    mal_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        mal_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst_s32[iChannel][iFrame] = src_s32[iFrame*channels + iChannel];
        }
    }
}

void mal_pcm_deinterleave_s32__optimized(void** dst, const void* src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_pcm_deinterleave_s32__reference(dst, src, frameCount, channels);
}

void mal_pcm_deinterleave_s32(void** dst, const void* src, mal_uint64 frameCount, mal_uint32 channels)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_deinterleave_s32__reference(dst, src, frameCount, channels);
#else
    mal_pcm_deinterleave_s32__optimized(dst, src, frameCount, channels);
#endif
}


// f32
void mal_pcm_f32_to_u8__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_uint8* dst_u8 = (mal_uint8*)dst;
    const float* src_f32 = (const float*)src;

    float ditherMin = 0;
    float ditherMax = 0;
    if (ditherMode != mal_dither_mode_none) {
        ditherMin = 1.0f / -128;
        ditherMax = 1.0f /  127;
    }

    mal_uint64 i;
    for (i = 0; i < count; i += 1) {
        float x = src_f32[i];
        x = x + mal_dither_f32(ditherMode, ditherMin, ditherMax);
        x = ((x < -1) ? -1 : ((x > 1) ? 1 : x));    // clip
        x = x + 1;                                  // -1..1 to 0..2
        x = x * 127.5f;                             // 0..2 to 0..255

        dst_u8[i] = (mal_uint8)x;
    }
}

void mal_pcm_f32_to_u8__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_f32_to_u8__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_f32_to_u8__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_f32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_f32_to_u8__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_f32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_f32_to_u8__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_f32_to_u8__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_f32_to_u8__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_f32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_f32_to_u8(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_f32_to_u8__reference(dst, src, count, ditherMode);
#else
    mal_pcm_f32_to_u8__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_f32_to_s16__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_int16* dst_s16 = (mal_int16*)dst;
    const float* src_f32 = (const float*)src;

    float ditherMin = 0;
    float ditherMax = 0;
    if (ditherMode != mal_dither_mode_none) {
        ditherMin = 1.0f / -32768;
        ditherMax = 1.0f /  32767;
    }

    mal_uint64 i;
    for (i = 0; i < count; i += 1) {
        float x = src_f32[i];
        x = x + mal_dither_f32(ditherMode, ditherMin, ditherMax);
        x = ((x < -1) ? -1 : ((x > 1) ? 1 : x));    // clip

#if 0
        // The accurate way.
        x = x + 1;                                  // -1..1 to 0..2
        x = x * 32767.5f;                           // 0..2 to 0..65535
        x = x - 32768.0f;                           // 0...65535 to -32768..32767
#else
        // The fast way.
        x = x * 32767.0f;                           // -1..1 to -32767..32767
#endif

        dst_s16[i] = (mal_int16)x;
    }
}

void mal_pcm_f32_to_s16__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_int16* dst_s16 = (mal_int16*)dst;
    const float* src_f32 = (const float*)src;

    float ditherMin = 0;
    float ditherMax = 0;
    if (ditherMode != mal_dither_mode_none) {
        ditherMin = 1.0f / -32768;
        ditherMax = 1.0f /  32767;
    }

    mal_uint64 i = 0;

    // Unrolled.
    mal_uint64 count4 = count >> 2;
    for (mal_uint64 i4 = 0; i4 < count4; i4 += 1) {
        float d0 = mal_dither_f32(ditherMode, ditherMin, ditherMax);
        float d1 = mal_dither_f32(ditherMode, ditherMin, ditherMax);
        float d2 = mal_dither_f32(ditherMode, ditherMin, ditherMax);
        float d3 = mal_dither_f32(ditherMode, ditherMin, ditherMax);
        
        float x0 = src_f32[i+0];
        float x1 = src_f32[i+1];
        float x2 = src_f32[i+2];
        float x3 = src_f32[i+3];

        x0 = x0 + d0;
        x1 = x1 + d1;
        x2 = x2 + d2;
        x3 = x3 + d3;

        x0 = ((x0 < -1) ? -1 : ((x0 > 1) ? 1 : x0));
        x1 = ((x1 < -1) ? -1 : ((x1 > 1) ? 1 : x1));
        x2 = ((x2 < -1) ? -1 : ((x2 > 1) ? 1 : x2));
        x3 = ((x3 < -1) ? -1 : ((x3 > 1) ? 1 : x3));

        x0 = x0 * 32767.0f;
        x1 = x1 * 32767.0f;
        x2 = x2 * 32767.0f;
        x3 = x3 * 32767.0f;

        dst_s16[i+0] = (mal_int16)x0;
        dst_s16[i+1] = (mal_int16)x1;
        dst_s16[i+2] = (mal_int16)x2;
        dst_s16[i+3] = (mal_int16)x3;

        i += 4;
    }

    // Leftover.
    for (; i < count; i += 1) {
        float x = src_f32[i];
        x = x + mal_dither_f32(ditherMode, ditherMin, ditherMax);
        x = ((x < -1) ? -1 : ((x > 1) ? 1 : x));    // clip
        x = x * 32767.0f;                           // -1..1 to -32767..32767

        dst_s16[i] = (mal_int16)x;
    }
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_f32_to_s16__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    // Both the input and output buffers need to be aligned to 16 bytes.
    if ((((mal_uintptr)dst & 15) != 0) || (((mal_uintptr)src & 15) != 0)) {
        mal_pcm_f32_to_s16__optimized(dst, src, count, ditherMode);
        return;
    }

    mal_int16* dst_s16 = (mal_int16*)dst;
    const float* src_f32 = (const float*)src;

    float ditherMin = 0;
    float ditherMax = 0;
    if (ditherMode != mal_dither_mode_none) {
        ditherMin = 1.0f / -32768;
        ditherMax = 1.0f /  32767;
    }

    mal_uint64 i = 0;

    // SSE2. SSE allows us to output 8 s16's at a time which means our loop is unrolled 8 times.
    mal_uint64 count8 = count >> 3;
    for (mal_uint64 i8 = 0; i8 < count8; i8 += 1) {
        __m128 d0;
        __m128 d1;
        if (ditherMode == mal_dither_mode_none) {
            d0 = _mm_set1_ps(0);
            d1 = _mm_set1_ps(0);
        } else if (ditherMode == mal_dither_mode_rectangle) {
            d0 = _mm_set_ps(
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax)
            );
            d1 = _mm_set_ps(
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax)
            );
        } else {
            d0 = _mm_set_ps(
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax)
            );
            d1 = _mm_set_ps(
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax)
            );
        }

        __m128 x0 = *((__m128*)(src_f32 + i) + 0);
        __m128 x1 = *((__m128*)(src_f32 + i) + 1);

        x0 = _mm_add_ps(x0, d0);
        x1 = _mm_add_ps(x1, d1);

        x0 = _mm_mul_ps(x0, _mm_set1_ps(32767.0f));
        x1 = _mm_mul_ps(x1, _mm_set1_ps(32767.0f));

        _mm_stream_si128(((__m128i*)(dst_s16 + i)), _mm_packs_epi32(_mm_cvttps_epi32(x0), _mm_cvttps_epi32(x1)));
        
        i += 8;
    }


    // Leftover.
    for (; i < count; i += 1) {
        float x = src_f32[i];
        x = x + mal_dither_f32(ditherMode, ditherMin, ditherMax);
        x = ((x < -1) ? -1 : ((x > 1) ? 1 : x));    // clip
        x = x * 32767.0f;                           // -1..1 to -32767..32767

        dst_s16[i] = (mal_int16)x;
    }
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_f32_to_s16__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    // Both the input and output buffers need to be aligned to 32 bytes.
    if ((((mal_uintptr)dst & 31) != 0) || (((mal_uintptr)src & 31) != 0)) {
        mal_pcm_f32_to_s16__optimized(dst, src, count, ditherMode);
        return;
    }

    mal_int16* dst_s16 = (mal_int16*)dst;
    const float* src_f32 = (const float*)src;

    float ditherMin = 0;
    float ditherMax = 0;
    if (ditherMode != mal_dither_mode_none) {
        ditherMin = 1.0f / -32768;
        ditherMax = 1.0f /  32767;
    }

    mal_uint64 i = 0;

    // AVX2. AVX2 allows us to output 16 s16's at a time which means our loop is unrolled 16 times.
    mal_uint64 count16 = count >> 4;
    for (mal_uint64 i16 = 0; i16 < count16; i16 += 1) {
        __m256 d0;
        __m256 d1;
        if (ditherMode == mal_dither_mode_none) {
            d0 = _mm256_set1_ps(0);
            d1 = _mm256_set1_ps(0);
        } else if (ditherMode == mal_dither_mode_rectangle) {
            d0 = _mm256_set_ps(
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax)
            );
            d1 = _mm256_set_ps(
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax),
                mal_dither_f32_rectangle(ditherMin, ditherMax)
            );
        } else {
            d0 = _mm256_set_ps(
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax)
            );
            d1 = _mm256_set_ps(
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax),
                mal_dither_f32_triangle(ditherMin, ditherMax)
            );
        }

        __m256 x0 = *((__m256*)(src_f32 + i) + 0);
        __m256 x1 = *((__m256*)(src_f32 + i) + 1);

        x0 = _mm256_add_ps(x0, d0);
        x1 = _mm256_add_ps(x1, d1);

        x0 = _mm256_mul_ps(x0, _mm256_set1_ps(32767.0f));
        x1 = _mm256_mul_ps(x1, _mm256_set1_ps(32767.0f));

        // Computing the final result is a little more complicated for AVX2 than SSE2.
        __m256i i0 = _mm256_cvttps_epi32(x0);
        __m256i i1 = _mm256_cvttps_epi32(x1);
        __m256i p0 = _mm256_permute2x128_si256(i0, i1, 0 | 32);
        __m256i p1 = _mm256_permute2x128_si256(i0, i1, 1 | 48);
        __m256i r  = _mm256_packs_epi32(p0, p1);

        _mm256_stream_si256(((__m256i*)(dst_s16 + i)), r);

        i += 16;
    }


    // Leftover.
    for (; i < count; i += 1) {
        float x = src_f32[i];
        x = x + mal_dither_f32(ditherMode, ditherMin, ditherMax);
        x = ((x < -1) ? -1 : ((x > 1) ? 1 : x));    // clip
        x = x * 32767.0f;                           // -1..1 to -32767..32767

        dst_s16[i] = (mal_int16)x;
    }
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_f32_to_s16__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    // TODO: Convert this from AVX to AVX-512.
    mal_pcm_f32_to_s16__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_f32_to_s16__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    // Both the input and output buffers need to be aligned to 16 bytes.
    if ((((mal_uintptr)dst & 15) != 0) || (((mal_uintptr)src & 15) != 0)) {
        mal_pcm_f32_to_s16__optimized(dst, src, count, ditherMode);
        return;
    }

    mal_int16* dst_s16 = (mal_int16*)dst;
    const float* src_f32 = (const float*)src;

    float ditherMin = 0;
    float ditherMax = 0;
    if (ditherMode != mal_dither_mode_none) {
        ditherMin = 1.0f / -32768;
        ditherMax = 1.0f /  32767;
    }

    mal_uint64 i = 0;

    // NEON. NEON allows us to output 8 s16's at a time which means our loop is unrolled 8 times.
    mal_uint64 count8 = count >> 3;
    for (mal_uint64 i8 = 0; i8 < count8; i8 += 1) {
        float32x4_t d0;
        float32x4_t d1;
        if (ditherMode == mal_dither_mode_none) {
            d0 = vmovq_n_f32(0);
            d1 = vmovq_n_f32(0);
        } else if (ditherMode == mal_dither_mode_rectangle) {
            float d0v[4];
            d0v[0] = mal_dither_f32_rectangle(ditherMin, ditherMax);
            d0v[1] = mal_dither_f32_rectangle(ditherMin, ditherMax);
            d0v[2] = mal_dither_f32_rectangle(ditherMin, ditherMax);
            d0v[3] = mal_dither_f32_rectangle(ditherMin, ditherMax);
            d0 = vld1q_f32(d0v);

            float d1v[4];
            d1v[0] = mal_dither_f32_rectangle(ditherMin, ditherMax);
            d1v[1] = mal_dither_f32_rectangle(ditherMin, ditherMax);
            d1v[2] = mal_dither_f32_rectangle(ditherMin, ditherMax);
            d1v[3] = mal_dither_f32_rectangle(ditherMin, ditherMax);
            d1 = vld1q_f32(d1v);
        } else {
            float d0v[4];
            d0v[0] = mal_dither_f32_triangle(ditherMin, ditherMax);
            d0v[1] = mal_dither_f32_triangle(ditherMin, ditherMax);
            d0v[2] = mal_dither_f32_triangle(ditherMin, ditherMax);
            d0v[3] = mal_dither_f32_triangle(ditherMin, ditherMax);
            d0 = vld1q_f32(d0v);

            float d1v[4];
            d1v[0] = mal_dither_f32_triangle(ditherMin, ditherMax);
            d1v[1] = mal_dither_f32_triangle(ditherMin, ditherMax);
            d1v[2] = mal_dither_f32_triangle(ditherMin, ditherMax);
            d1v[3] = mal_dither_f32_triangle(ditherMin, ditherMax);
            d1 = vld1q_f32(d1v);
        }

        float32x4_t x0 = *((float32x4_t*)(src_f32 + i) + 0);
        float32x4_t x1 = *((float32x4_t*)(src_f32 + i) + 1);

        x0 = vaddq_f32(x0, d0);
        x1 = vaddq_f32(x1, d1);

        x0 = vmulq_n_f32(x0, 32767.0f);
        x1 = vmulq_n_f32(x1, 32767.0f);

        int32x4_t i0 = vcvtq_s32_f32(x0);
        int32x4_t i1 = vcvtq_s32_f32(x1);
        *((int16x8_t*)(dst_s16 + i)) = vcombine_s16(vqmovn_s32(i0), vqmovn_s32(i1));

        i += 8;
    }


    // Leftover.
    for (; i < count; i += 1) {
        float x = src_f32[i];
        x = x + mal_dither_f32(ditherMode, ditherMin, ditherMax);
        x = ((x < -1) ? -1 : ((x > 1) ? 1 : x));    // clip
        x = x * 32767.0f;                           // -1..1 to -32767..32767

        dst_s16[i] = (mal_int16)x;
    }
}
#endif

void mal_pcm_f32_to_s16(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_f32_to_s16__reference(dst, src, count, ditherMode);
#else
    mal_pcm_f32_to_s16__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_f32_to_s24__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;   // No dithering for f32 -> s24.

    mal_uint8* dst_s24 = (mal_uint8*)dst;
    const float* src_f32 = (const float*)src;

    mal_uint64 i;
    for (i = 0; i < count; i += 1) {
        float x = src_f32[i];
        x = ((x < -1) ? -1 : ((x > 1) ? 1 : x));    // clip

#if 0
        // The accurate way.
        x = x + 1;                                  // -1..1 to 0..2
        x = x * 8388607.5f;                         // 0..2 to 0..16777215
        x = x - 8388608.0f;                         // 0..16777215 to -8388608..8388607
#else
        // The fast way.
        x = x * 8388607.0f;                         // -1..1 to -8388607..8388607
#endif

        mal_int32 r = (mal_int32)x;
        dst_s24[(i*3)+0] = (mal_uint8)((r & 0x0000FF) >>  0);
        dst_s24[(i*3)+1] = (mal_uint8)((r & 0x00FF00) >>  8);
        dst_s24[(i*3)+2] = (mal_uint8)((r & 0xFF0000) >> 16);
    }
}

void mal_pcm_f32_to_s24__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_f32_to_s24__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_f32_to_s24__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_f32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_f32_to_s24__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_f32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_f32_to_s24__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_f32_to_s24__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_f32_to_s24__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_f32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_f32_to_s24(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_f32_to_s24__reference(dst, src, count, ditherMode);
#else
    mal_pcm_f32_to_s24__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_f32_to_s32__reference(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;   // No dithering for f32 -> s32.

    mal_int32* dst_s32 = (mal_int32*)dst;
    const float* src_f32 = (const float*)src;

    mal_uint32 i;
    for (i = 0; i < count; i += 1) {
        double x = src_f32[i];
        x = ((x < -1) ? -1 : ((x > 1) ? 1 : x));    // clip

#if 0
        // The accurate way.
        x = x + 1;                                  // -1..1 to 0..2
        x = x * 2147483647.5;                       // 0..2 to 0..4294967295
        x = x - 2147483648.0;                       // 0...4294967295 to -2147483648..2147483647
#else
        // The fast way.
        x = x * 2147483647.0;                       // -1..1 to -2147483647..2147483647
#endif

        dst_s32[i] = (mal_int32)x;
    }
}

void mal_pcm_f32_to_s32__optimized(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_f32_to_s32__reference(dst, src, count, ditherMode);
}

#if defined(MAL_SUPPORT_SSE2)
void mal_pcm_f32_to_s32__sse2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_f32_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX2)
void mal_pcm_f32_to_s32__avx2(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_f32_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_AVX512)
void mal_pcm_f32_to_s32__avx512(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_f32_to_s32__avx2(dst, src, count, ditherMode);
}
#endif
#if defined(MAL_SUPPORT_NEON)
void mal_pcm_f32_to_s32__neon(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    mal_pcm_f32_to_s32__optimized(dst, src, count, ditherMode);
}
#endif

void mal_pcm_f32_to_s32(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_f32_to_s32__reference(dst, src, count, ditherMode);
#else
    mal_pcm_f32_to_s32__optimized(dst, src, count, ditherMode);
#endif
}


void mal_pcm_f32_to_f32(void* dst, const void* src, mal_uint64 count, mal_dither_mode ditherMode)
{
    (void)ditherMode;

    mal_copy_memory_64(dst, src, count * sizeof(float));
}


void mal_pcm_interleave_f32__reference(void* dst, const void** src, mal_uint64 frameCount, mal_uint32 channels)
{
    float* dst_f32 = (float*)dst;
    const float** src_f32 = (const float**)src;

    mal_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        mal_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst_f32[iFrame*channels + iChannel] = src_f32[iChannel][iFrame];
        }
    }
}

void mal_pcm_interleave_f32__optimized(void* dst, const void** src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_pcm_interleave_f32__reference(dst, src, frameCount, channels);
}

void mal_pcm_interleave_f32(void* dst, const void** src, mal_uint64 frameCount, mal_uint32 channels)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_interleave_f32__reference(dst, src, frameCount, channels);
#else
    mal_pcm_interleave_f32__optimized(dst, src, frameCount, channels);
#endif
}


void mal_pcm_deinterleave_f32__reference(void** dst, const void* src, mal_uint64 frameCount, mal_uint32 channels)
{
    float** dst_f32 = (float**)dst;
    const float* src_f32 = (const float*)src;

    mal_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        mal_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst_f32[iChannel][iFrame] = src_f32[iFrame*channels + iChannel];
        }
    }
}

void mal_pcm_deinterleave_f32__optimized(void** dst, const void* src, mal_uint64 frameCount, mal_uint32 channels)
{
    mal_pcm_deinterleave_f32__reference(dst, src, frameCount, channels);
}

void mal_pcm_deinterleave_f32(void** dst, const void* src, mal_uint64 frameCount, mal_uint32 channels)
{
#ifdef MAL_USE_REFERENCE_CONVERSION_APIS
    mal_pcm_deinterleave_f32__reference(dst, src, frameCount, channels);
#else
    mal_pcm_deinterleave_f32__optimized(dst, src, frameCount, channels);
#endif
}


void mal_format_converter_init_callbacks__default(mal_format_converter* pConverter)
{
    mal_assert(pConverter != NULL);

    switch (pConverter->config.formatIn)
    {
        case mal_format_u8:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_u8_to_u8;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_u8_to_s16;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_u8_to_s24;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_u8_to_s32;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_u8_to_f32;
            }
        } break;

        case mal_format_s16:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_s16_to_u8;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_s16_to_s16;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_s16_to_s24;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_s16_to_s32;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_s16_to_f32;
            }
        } break;

        case mal_format_s24:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_s24_to_u8;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_s24_to_s16;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_s24_to_s24;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_s24_to_s32;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_s24_to_f32;
            }
        } break;

        case mal_format_s32:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_s32_to_u8;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_s32_to_s16;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_s32_to_s24;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_s32_to_s32;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_s32_to_f32;
            }
        } break;

        case mal_format_f32:
        default:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_f32_to_u8;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_f32_to_s16;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_f32_to_s24;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_f32_to_s32;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_f32_to_f32;
            }
        } break;
    }
}

#if defined(MAL_SUPPORT_SSE2)
void mal_format_converter_init_callbacks__sse2(mal_format_converter* pConverter)
{
    mal_assert(pConverter != NULL);

    switch (pConverter->config.formatIn)
    {
        case mal_format_u8:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_u8_to_u8;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_u8_to_s16__sse2;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_u8_to_s24__sse2;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_u8_to_s32__sse2;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_u8_to_f32__sse2;
            }
        } break;

        case mal_format_s16:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_s16_to_u8__sse2;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_s16_to_s16;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_s16_to_s24__sse2;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_s16_to_s32__sse2;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_s16_to_f32__sse2;
            }
        } break;

        case mal_format_s24:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_s24_to_u8__sse2;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_s24_to_s16__sse2;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_s24_to_s24;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_s24_to_s32__sse2;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_s24_to_f32__sse2;
            }
        } break;

        case mal_format_s32:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_s32_to_u8__sse2;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_s32_to_s16__sse2;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_s32_to_s24__sse2;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_s32_to_s32;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_s32_to_f32__sse2;
            }
        } break;

        case mal_format_f32:
        default:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_f32_to_u8__sse2;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_f32_to_s16__sse2;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_f32_to_s24__sse2;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_f32_to_s32__sse2;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_f32_to_f32;
            }
        } break;
    }
}
#endif

#if defined(MAL_SUPPORT_AVX2)
void mal_format_converter_init_callbacks__avx2(mal_format_converter* pConverter)
{
    mal_assert(pConverter != NULL);

    switch (pConverter->config.formatIn)
    {
        case mal_format_u8:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_u8_to_u8;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_u8_to_s16__avx2;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_u8_to_s24__avx2;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_u8_to_s32__avx2;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_u8_to_f32__avx2;
            }
        } break;

        case mal_format_s16:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_s16_to_u8__avx2;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_s16_to_s16;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_s16_to_s24__avx2;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_s16_to_s32__avx2;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_s16_to_f32__avx2;
            }
        } break;

        case mal_format_s24:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_s24_to_u8__avx2;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_s24_to_s16__avx2;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_s24_to_s24;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_s24_to_s32__avx2;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_s24_to_f32__avx2;
            }
        } break;

        case mal_format_s32:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_s32_to_u8__avx2;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_s32_to_s16__avx2;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_s32_to_s24__avx2;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_s32_to_s32;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_s32_to_f32__avx2;
            }
        } break;

        case mal_format_f32:
        default:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_f32_to_u8__avx2;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_f32_to_s16__avx2;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_f32_to_s24__avx2;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_f32_to_s32__avx2;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_f32_to_f32;
            }
        } break;
    }
}
#endif

#if defined(MAL_SUPPORT_AVX512)
void mal_format_converter_init_callbacks__avx512(mal_format_converter* pConverter)
{
    mal_assert(pConverter != NULL);

    switch (pConverter->config.formatIn)
    {
        case mal_format_u8:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_u8_to_u8;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_u8_to_s16__avx512;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_u8_to_s24__avx512;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_u8_to_s32__avx512;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_u8_to_f32__avx512;
            }
        } break;

        case mal_format_s16:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_s16_to_u8__avx512;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_s16_to_s16;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_s16_to_s24__avx512;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_s16_to_s32__avx512;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_s16_to_f32__avx512;
            }
        } break;

        case mal_format_s24:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_s24_to_u8__avx512;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_s24_to_s16__avx512;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_s24_to_s24;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_s24_to_s32__avx512;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_s24_to_f32__avx512;
            }
        } break;

        case mal_format_s32:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_s32_to_u8__avx512;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_s32_to_s16__avx512;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_s32_to_s24__avx512;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_s32_to_s32;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_s32_to_f32__avx512;
            }
        } break;

        case mal_format_f32:
        default:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_f32_to_u8__avx512;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_f32_to_s16__avx512;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_f32_to_s24__avx512;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_f32_to_s32__avx512;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_f32_to_f32;
            }
        } break;
    }
}
#endif

#if defined(MAL_SUPPORT_NEON)
void mal_format_converter_init_callbacks__neon(mal_format_converter* pConverter)
{
    mal_assert(pConverter != NULL);

    switch (pConverter->config.formatIn)
    {
        case mal_format_u8:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_u8_to_u8;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_u8_to_s16__neon;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_u8_to_s24__neon;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_u8_to_s32__neon;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_u8_to_f32__neon;
            }
        } break;

        case mal_format_s16:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_s16_to_u8__neon;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_s16_to_s16;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_s16_to_s24__neon;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_s16_to_s32__neon;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_s16_to_f32__neon;
            }
        } break;

        case mal_format_s24:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_s24_to_u8__neon;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_s24_to_s16__neon;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_s24_to_s24;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_s24_to_s32__neon;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_s24_to_f32__neon;
            }
        } break;

        case mal_format_s32:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_s32_to_u8__neon;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_s32_to_s16__neon;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_s32_to_s24__neon;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_s32_to_s32;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_s32_to_f32__neon;
            }
        } break;

        case mal_format_f32:
        default:
        {
            if (pConverter->config.formatOut == mal_format_u8) {
                pConverter->onConvertPCM = mal_pcm_f32_to_u8__neon;
            } else if (pConverter->config.formatOut == mal_format_s16) {
                pConverter->onConvertPCM = mal_pcm_f32_to_s16__neon;
            } else if (pConverter->config.formatOut == mal_format_s24) {
                pConverter->onConvertPCM = mal_pcm_f32_to_s24__neon;
            } else if (pConverter->config.formatOut == mal_format_s32) {
                pConverter->onConvertPCM = mal_pcm_f32_to_s32__neon;
            } else if (pConverter->config.formatOut == mal_format_f32) {
                pConverter->onConvertPCM = mal_pcm_f32_to_f32;
            }
        } break;
    }
}
#endif

mal_result mal_format_converter_init(const mal_format_converter_config* pConfig, mal_format_converter* pConverter)
{
    if (pConverter == NULL) {
        return MAL_INVALID_ARGS;
    }
    mal_zero_object(pConverter);

    if (pConfig == NULL) {
        return MAL_INVALID_ARGS;
    }

    pConverter->config = *pConfig;

    // SIMD
    pConverter->useSSE2   = mal_has_sse2()    && !pConfig->noSSE2;
    pConverter->useAVX2   = mal_has_avx2()    && !pConfig->noAVX2;
    pConverter->useAVX512 = mal_has_avx512f() && !pConfig->noAVX512;
    pConverter->useNEON   = mal_has_neon()    && !pConfig->noNEON;

#if defined(MAL_SUPPORT_AVX512)
    if (pConverter->useAVX512) {
        mal_format_converter_init_callbacks__avx512(pConverter);
    } else
#endif
#if defined(MAL_SUPPORT_AVX2)
    if (pConverter->useAVX2) {
        mal_format_converter_init_callbacks__avx2(pConverter);
    } else
#endif
#if defined(MAL_SUPPORT_SSE2)
    if (pConverter->useSSE2) {
        mal_format_converter_init_callbacks__sse2(pConverter);
    } else
#endif
#if defined(MAL_SUPPORT_NEON)
    if (pConverter->useNEON) {
        mal_format_converter_init_callbacks__neon(pConverter);
    } else
#endif
    {
        mal_format_converter_init_callbacks__default(pConverter);
    }

    switch (pConfig->formatOut)
    {
        case mal_format_u8:
        {
            pConverter->onInterleavePCM   = mal_pcm_interleave_u8;
            pConverter->onDeinterleavePCM = mal_pcm_deinterleave_u8;
        } break;
        case mal_format_s16:
        {
            pConverter->onInterleavePCM   = mal_pcm_interleave_s16;
            pConverter->onDeinterleavePCM = mal_pcm_deinterleave_s16;
        } break;
        case mal_format_s24:
        {
            pConverter->onInterleavePCM   = mal_pcm_interleave_s24;
            pConverter->onDeinterleavePCM = mal_pcm_deinterleave_s24;
        } break;
        case mal_format_s32:
        {
            pConverter->onInterleavePCM   = mal_pcm_interleave_s32;
            pConverter->onDeinterleavePCM = mal_pcm_deinterleave_s32;
        } break;
        case mal_format_f32:
        default:
        {
            pConverter->onInterleavePCM   = mal_pcm_interleave_f32;
            pConverter->onDeinterleavePCM = mal_pcm_deinterleave_f32;
        } break;
    }

    return MAL_SUCCESS;
}

mal_uint64 mal_format_converter_read(mal_format_converter* pConverter, mal_uint64 frameCount, void* pFramesOut, void* pUserData)
{
    if (pConverter == NULL || pFramesOut == NULL) {
        return 0;
    }

    mal_uint64 totalFramesRead = 0;
    mal_uint32 sampleSizeIn    = mal_get_bytes_per_sample(pConverter->config.formatIn);
    mal_uint32 sampleSizeOut   = mal_get_bytes_per_sample(pConverter->config.formatOut);
    //mal_uint32 frameSizeIn     = sampleSizeIn  * pConverter->config.channels;
    mal_uint32 frameSizeOut    = sampleSizeOut * pConverter->config.channels;
    mal_uint8* pNextFramesOut  = (mal_uint8*)pFramesOut;

    if (pConverter->config.onRead != NULL) {
        // Input data is interleaved.
        if (pConverter->config.formatIn == pConverter->config.formatOut) {
            // Pass through.
            while (totalFramesRead < frameCount) {
                mal_uint64 framesRemaining = (frameCount - totalFramesRead);
                mal_uint64 framesToReadRightNow = framesRemaining;
                if (framesToReadRightNow > 0xFFFFFFFF) {
                    framesToReadRightNow = 0xFFFFFFFF;
                }

                mal_uint32 framesJustRead = (mal_uint32)pConverter->config.onRead(pConverter, (mal_uint32)framesToReadRightNow, pNextFramesOut, pUserData);
                if (framesJustRead == 0) {
                    break;
                }

                totalFramesRead += framesJustRead;
                pNextFramesOut  += framesJustRead * frameSizeOut;

                if (framesJustRead < framesToReadRightNow) {
                    break;
                }
            }
        } else {
            // Conversion required.
            MAL_ALIGN(MAL_SIMD_ALIGNMENT) mal_uint8 temp[MAL_MAX_CHANNELS * MAL_MAX_PCM_SAMPLE_SIZE_IN_BYTES * 128];
            mal_assert(sizeof(temp) <= 0xFFFFFFFF);

            mal_uint32 maxFramesToReadAtATime = sizeof(temp) / sampleSizeIn / pConverter->config.channels;

            while (totalFramesRead < frameCount) {
                mal_uint64 framesRemaining = (frameCount - totalFramesRead);
                mal_uint64 framesToReadRightNow = framesRemaining;
                if (framesToReadRightNow > maxFramesToReadAtATime) {
                    framesToReadRightNow = maxFramesToReadAtATime;
                }

                mal_uint32 framesJustRead = (mal_uint32)pConverter->config.onRead(pConverter, (mal_uint32)framesToReadRightNow, temp, pUserData);
                if (framesJustRead == 0) {
                    break;
                }

                pConverter->onConvertPCM(pNextFramesOut, temp, framesJustRead*pConverter->config.channels, pConverter->config.ditherMode);

                totalFramesRead += framesJustRead;
                pNextFramesOut  += framesJustRead * frameSizeOut;

                if (framesJustRead < framesToReadRightNow) {
                    break;
                }
            }
        }
    } else {
        // Input data is deinterleaved. If a conversion is required we need to do an intermediary step.
        MAL_ALIGN(MAL_SIMD_ALIGNMENT) mal_uint8 tempSamplesOfOutFormat[MAL_MAX_CHANNELS * MAL_MAX_PCM_SAMPLE_SIZE_IN_BYTES * 128];
        mal_assert(sizeof(tempSamplesOfOutFormat) <= 0xFFFFFFFFF);

        void* ppTempSamplesOfOutFormat[MAL_MAX_CHANNELS];
        size_t splitBufferSizeOut;
        mal_split_buffer(tempSamplesOfOutFormat, sizeof(tempSamplesOfOutFormat), pConverter->config.channels, MAL_SIMD_ALIGNMENT, (void**)&ppTempSamplesOfOutFormat, &splitBufferSizeOut);

        mal_uint32 maxFramesToReadAtATime = (mal_uint32)(splitBufferSizeOut / sampleSizeIn);

        while (totalFramesRead < frameCount) {
            mal_uint64 framesRemaining = (frameCount - totalFramesRead);
            mal_uint64 framesToReadRightNow = framesRemaining;
            if (framesToReadRightNow > maxFramesToReadAtATime) {
                framesToReadRightNow = maxFramesToReadAtATime;
            }

            mal_uint32 framesJustRead = 0;

            if (pConverter->config.formatIn == pConverter->config.formatOut) {
                // Only interleaving.
                framesJustRead = (mal_uint32)pConverter->config.onReadDeinterleaved(pConverter, (mal_uint32)framesToReadRightNow, ppTempSamplesOfOutFormat, pUserData);
                if (framesJustRead == 0) {
                    break;
                }
            } else {
                // Interleaving + Conversion. Convert first, then interleave.
                MAL_ALIGN(MAL_SIMD_ALIGNMENT) mal_uint8 tempSamplesOfInFormat[MAL_MAX_CHANNELS * MAL_MAX_PCM_SAMPLE_SIZE_IN_BYTES * 128];

                void* ppTempSamplesOfInFormat[MAL_MAX_CHANNELS];
                size_t splitBufferSizeIn;
                mal_split_buffer(tempSamplesOfInFormat, sizeof(tempSamplesOfInFormat), pConverter->config.channels, MAL_SIMD_ALIGNMENT, (void**)&ppTempSamplesOfInFormat, &splitBufferSizeIn);

                if (framesToReadRightNow > (splitBufferSizeIn / sampleSizeIn)) {
                    framesToReadRightNow = (splitBufferSizeIn / sampleSizeIn);
                }

                framesJustRead = (mal_uint32)pConverter->config.onReadDeinterleaved(pConverter, (mal_uint32)framesToReadRightNow, ppTempSamplesOfInFormat, pUserData);
                if (framesJustRead == 0) {
                    break;
                }

                for (mal_uint32 iChannel = 0; iChannel < pConverter->config.channels; iChannel += 1) {
                    pConverter->onConvertPCM(ppTempSamplesOfOutFormat[iChannel], ppTempSamplesOfInFormat[iChannel], framesJustRead, pConverter->config.ditherMode);
                }
            }

            pConverter->onInterleavePCM(pNextFramesOut, (const void**)ppTempSamplesOfOutFormat, framesJustRead, pConverter->config.channels);

            totalFramesRead += framesJustRead;
            pNextFramesOut  += framesJustRead * frameSizeOut;

            if (framesJustRead < framesToReadRightNow) {
                break;
            }
        }
    }

    return totalFramesRead;
}

mal_uint64 mal_format_converter_read_deinterleaved(mal_format_converter* pConverter, mal_uint64 frameCount, void** ppSamplesOut, void* pUserData)
{
    if (pConverter == NULL || ppSamplesOut == NULL) {
        return 0;
    }

    mal_uint64 totalFramesRead = 0;
    mal_uint32 sampleSizeIn = mal_get_bytes_per_sample(pConverter->config.formatIn);
    mal_uint32 sampleSizeOut = mal_get_bytes_per_sample(pConverter->config.formatOut);

    mal_uint8* ppNextSamplesOut[MAL_MAX_CHANNELS];
    mal_copy_memory(ppNextSamplesOut, ppSamplesOut, sizeof(void*) * pConverter->config.channels);

    if (pConverter->config.onRead != NULL) {
        // Input data is interleaved.
        MAL_ALIGN(MAL_SIMD_ALIGNMENT) mal_uint8 tempSamplesOfOutFormat[MAL_MAX_CHANNELS * MAL_MAX_PCM_SAMPLE_SIZE_IN_BYTES * 128];
        mal_assert(sizeof(tempSamplesOfOutFormat) <= 0xFFFFFFFF);

        mal_uint32 maxFramesToReadAtATime = sizeof(tempSamplesOfOutFormat) / sampleSizeIn / pConverter->config.channels;

        while (totalFramesRead < frameCount) {
            mal_uint64 framesRemaining = (frameCount - totalFramesRead);
            mal_uint64 framesToReadRightNow = framesRemaining;
            if (framesToReadRightNow > maxFramesToReadAtATime) {
                framesToReadRightNow = maxFramesToReadAtATime;
            }

            mal_uint32 framesJustRead = 0;

            if (pConverter->config.formatIn == pConverter->config.formatOut) {
                // Only de-interleaving.
                framesJustRead = (mal_uint32)pConverter->config.onRead(pConverter, (mal_uint32)framesToReadRightNow, tempSamplesOfOutFormat, pUserData);
                if (framesJustRead == 0) {
                    break;
                }
            } else {
                // De-interleaving + Conversion. Convert first, then de-interleave.
                MAL_ALIGN(MAL_SIMD_ALIGNMENT) mal_uint8 tempSamplesOfInFormat[sizeof(tempSamplesOfOutFormat)];

                framesJustRead = (mal_uint32)pConverter->config.onRead(pConverter, (mal_uint32)framesToReadRightNow, tempSamplesOfInFormat, pUserData);
                if (framesJustRead == 0) {
                    break;
                }

                pConverter->onConvertPCM(tempSamplesOfOutFormat, tempSamplesOfInFormat, framesJustRead * pConverter->config.channels, pConverter->config.ditherMode);
            }

            pConverter->onDeinterleavePCM((void**)ppNextSamplesOut, tempSamplesOfOutFormat, framesJustRead, pConverter->config.channels);

            totalFramesRead += framesJustRead;
            for (mal_uint32 iChannel = 0; iChannel < pConverter->config.channels; ++iChannel) {
                ppNextSamplesOut[iChannel] += framesJustRead * sampleSizeOut;
            }

            if (framesJustRead < framesToReadRightNow) {
                break;
            }
        }
    } else {
        // Input data is deinterleaved.
        if (pConverter->config.formatIn == pConverter->config.formatOut) {
            // Pass through.
            while (totalFramesRead < frameCount) {
                mal_uint64 framesRemaining = (frameCount - totalFramesRead);
                mal_uint64 framesToReadRightNow = framesRemaining;
                if (framesToReadRightNow > 0xFFFFFFFF) {
                    framesToReadRightNow = 0xFFFFFFFF;
                }

                mal_uint32 framesJustRead = (mal_uint32)pConverter->config.onReadDeinterleaved(pConverter, (mal_uint32)framesToReadRightNow, (void**)ppNextSamplesOut, pUserData);
                if (framesJustRead == 0) {
                    break;
                }

                totalFramesRead += framesJustRead;
                for (mal_uint32 iChannel = 0; iChannel < pConverter->config.channels; ++iChannel) {
                    ppNextSamplesOut[iChannel] += framesJustRead * sampleSizeOut;
                }

                if (framesJustRead < framesToReadRightNow) {
                    break;
                }
            }
        } else {
            // Conversion required.
            MAL_ALIGN(MAL_SIMD_ALIGNMENT) mal_uint8 temp[MAL_MAX_CHANNELS][MAL_MAX_PCM_SAMPLE_SIZE_IN_BYTES * 128];
            mal_assert(sizeof(temp) <= 0xFFFFFFFF);

            void* ppTemp[MAL_MAX_CHANNELS];
            size_t splitBufferSize;
            mal_split_buffer(temp, sizeof(temp), pConverter->config.channels, MAL_SIMD_ALIGNMENT, (void**)&ppTemp, &splitBufferSize);

            mal_uint32 maxFramesToReadAtATime = (mal_uint32)(splitBufferSize / sampleSizeIn);

            while (totalFramesRead < frameCount) {
                mal_uint64 framesRemaining = (frameCount - totalFramesRead);
                mal_uint64 framesToReadRightNow = framesRemaining;
                if (framesToReadRightNow > maxFramesToReadAtATime) {
                    framesToReadRightNow = maxFramesToReadAtATime;
                }

                mal_uint32 framesJustRead = (mal_uint32)pConverter->config.onReadDeinterleaved(pConverter, (mal_uint32)framesToReadRightNow, ppTemp, pUserData);
                if (framesJustRead == 0) {
                    break;
                }

                for (mal_uint32 iChannel = 0; iChannel < pConverter->config.channels; iChannel += 1) {
                    pConverter->onConvertPCM(ppNextSamplesOut[iChannel], ppTemp[iChannel], framesJustRead, pConverter->config.ditherMode);
                    ppNextSamplesOut[iChannel] += framesJustRead * sampleSizeOut;
                }

                totalFramesRead += framesJustRead;

                if (framesJustRead < framesToReadRightNow) {
                    break;
                }
            }
        }
    }

    return totalFramesRead;
}


mal_format_converter_config mal_format_converter_config_init_new()
{
    mal_format_converter_config config;
    mal_zero_object(&config);

    return config;
}

mal_format_converter_config mal_format_converter_config_init(mal_format formatIn, mal_format formatOut, mal_uint32 channels, mal_format_converter_read_proc onRead, void* pUserData)
{
    mal_format_converter_config config = mal_format_converter_config_init_new();
    config.formatIn = formatIn;
    config.formatOut = formatOut;
    config.channels = channels;
    config.onRead = onRead;
    config.onReadDeinterleaved = NULL;
    config.pUserData = pUserData;

    return config;
}

mal_format_converter_config mal_format_converter_config_init_deinterleaved(mal_format formatIn, mal_format formatOut, mal_uint32 channels, mal_format_converter_read_deinterleaved_proc onReadDeinterleaved, void* pUserData)
{
    mal_format_converter_config config = mal_format_converter_config_init(formatIn, formatOut, channels, NULL, pUserData);
    config.onReadDeinterleaved = onReadDeinterleaved;

    return config;
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Channel Routing
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// -X = Left,   +X = Right
// -Y = Bottom, +Y = Top
// -Z = Front,  +Z = Back
typedef struct
{
    float x;
    float y;
    float z;
} mal_vec3;

static MAL_INLINE mal_vec3 mal_vec3f(float x, float y, float z)
{
    mal_vec3 r;
    r.x = x;
    r.y = y;
    r.z = z;

    return r;
}

static MAL_INLINE mal_vec3 mal_vec3_add(mal_vec3 a, mal_vec3 b)
{
    return mal_vec3f(
        a.x + b.x,
        a.y + b.y,
        a.z + b.z
    );
}

static MAL_INLINE mal_vec3 mal_vec3_sub(mal_vec3 a, mal_vec3 b)
{
    return mal_vec3f(
        a.x - b.x,
        a.y - b.y,
        a.z - b.z
    );
}

static MAL_INLINE mal_vec3 mal_vec3_mul(mal_vec3 a, mal_vec3 b)
{
    return mal_vec3f(
        a.x * b.x,
        a.y * b.y,
        a.z * b.z
    );
}

static MAL_INLINE mal_vec3 mal_vec3_div(mal_vec3 a, mal_vec3 b)
{
    return mal_vec3f(
        a.x / b.x,
        a.y / b.y,
        a.z / b.z
    );
}

static MAL_INLINE float mal_vec3_dot(mal_vec3 a, mal_vec3 b)
{
    return a.x*b.x + a.y*b.y + a.z*b.z;
}

static MAL_INLINE float mal_vec3_length2(mal_vec3 a)
{
    return mal_vec3_dot(a, a);
}

static MAL_INLINE float mal_vec3_length(mal_vec3 a)
{
    return (float)sqrt(mal_vec3_length2(a));
}

static MAL_INLINE mal_vec3 mal_vec3_normalize(mal_vec3 a)
{
    float len = 1 / mal_vec3_length(a);

    mal_vec3 r;
    r.x = a.x * len;
    r.y = a.y * len;
    r.z = a.z * len;

    return r;
}

static MAL_INLINE float mal_vec3_distance(mal_vec3 a, mal_vec3 b)
{
    return mal_vec3_length(mal_vec3_sub(a, b));
}


#define MAL_PLANE_LEFT      0
#define MAL_PLANE_RIGHT     1
#define MAL_PLANE_FRONT     2
#define MAL_PLANE_BACK      3
#define MAL_PLANE_BOTTOM    4
#define MAL_PLANE_TOP       5

float g_malChannelPlaneRatios[MAL_CHANNEL_POSITION_COUNT][6] = {
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_NONE
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_MONO
    { 0.5f,  0.0f,  0.5f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_FRONT_LEFT
    { 0.0f,  0.5f,  0.5f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_FRONT_RIGHT
    { 0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_FRONT_CENTER
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_LFE
    { 0.5f,  0.0f,  0.0f,  0.5f,  0.0f,  0.0f},  // MAL_CHANNEL_BACK_LEFT
    { 0.0f,  0.5f,  0.0f,  0.5f,  0.0f,  0.0f},  // MAL_CHANNEL_BACK_RIGHT
    { 0.25f, 0.0f,  0.75f, 0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_FRONT_LEFT_CENTER
    { 0.0f,  0.25f, 0.75f, 0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_FRONT_RIGHT_CENTER
    { 0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f},  // MAL_CHANNEL_BACK_CENTER
    { 1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_SIDE_LEFT
    { 0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_SIDE_RIGHT
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f},  // MAL_CHANNEL_TOP_CENTER
    { 0.33f, 0.0f,  0.33f, 0.0f,  0.0f,  0.34f}, // MAL_CHANNEL_TOP_FRONT_LEFT
    { 0.0f,  0.0f,  0.5f,  0.0f,  0.0f,  0.5f},  // MAL_CHANNEL_TOP_FRONT_CENTER
    { 0.0f,  0.33f, 0.33f, 0.0f,  0.0f,  0.34f}, // MAL_CHANNEL_TOP_FRONT_RIGHT
    { 0.33f, 0.0f,  0.0f,  0.33f, 0.0f,  0.34f}, // MAL_CHANNEL_TOP_BACK_LEFT
    { 0.0f,  0.0f,  0.0f,  0.5f,  0.0f,  0.5f},  // MAL_CHANNEL_TOP_BACK_CENTER
    { 0.0f,  0.33f, 0.0f,  0.33f, 0.0f,  0.34f}, // MAL_CHANNEL_TOP_BACK_RIGHT
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_0
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_1
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_2
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_3
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_4
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_5
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_6
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_7
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_8
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_9
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_10
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_11
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_12
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_13
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_14
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_15
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_16
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_17
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_18
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_19
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_20
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_21
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_22
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_23
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_24
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_25
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_26
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_27
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_28
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_29
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_30
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  // MAL_CHANNEL_AUX_31
};

float mal_calculate_channel_position_planar_weight(mal_channel channelPositionA, mal_channel channelPositionB)
{
    // Imagine the following simplified example: You have a single input speaker which is the front/left speaker which you want to convert to
    // the following output configuration:
    //
    //  - front/left
    //  - side/left
    //  - back/left
    //
    // The front/left output is easy - it the same speaker position so it receives the full contribution of the front/left input. The amount
    // of contribution to apply to the side/left and back/left speakers, however, is a bit more complicated.
    //
    // Imagine the front/left speaker as emitting audio from two planes - the front plane and the left plane. You can think of the front/left
    // speaker emitting half of it's total volume from the front, and the other half from the left. Since part of it's volume is being emitted
    // from the left side, and the side/left and back/left channels also emit audio from the left plane, one would expect that they would
    // receive some amount of contribution from front/left speaker. The amount of contribution depends on how many planes are shared between
    // the two speakers. Note that in the examples below I've added a top/front/left speaker as an example just to show how the math works
    // across 3 spatial dimensions.
    //
    // The first thing to do is figure out how each speaker's volume is spread over each of plane:
    //  - front/left:     2 planes (front and left)      = 1/2 = half it's total volume on each plane
    //  - side/left:      1 plane (left only)            = 1/1 = entire volume from left plane
    //  - back/left:      2 planes (back and left)       = 1/2 = half it's total volume on each plane
    //  - top/front/left: 3 planes (top, front and left) = 1/3 = one third it's total volume on each plane
    //
    // The amount of volume each channel contributes to each of it's planes is what controls how much it is willing to given and take to other
    // channels on the same plane. The volume that is willing to the given by one channel is multiplied by the volume that is willing to be
    // taken by the other to produce the final contribution.

    // Contribution = Sum(Volume to Give * Volume to Take)
    float contribution = 
        g_malChannelPlaneRatios[channelPositionA][0] * g_malChannelPlaneRatios[channelPositionB][0] +
        g_malChannelPlaneRatios[channelPositionA][1] * g_malChannelPlaneRatios[channelPositionB][1] +
        g_malChannelPlaneRatios[channelPositionA][2] * g_malChannelPlaneRatios[channelPositionB][2] +
        g_malChannelPlaneRatios[channelPositionA][3] * g_malChannelPlaneRatios[channelPositionB][3] +
        g_malChannelPlaneRatios[channelPositionA][4] * g_malChannelPlaneRatios[channelPositionB][4] +
        g_malChannelPlaneRatios[channelPositionA][5] * g_malChannelPlaneRatios[channelPositionB][5];

    return contribution;
}

float mal_channel_router__calculate_input_channel_planar_weight(const mal_channel_router* pRouter, mal_channel channelPositionIn, mal_channel channelPositionOut)
{
    mal_assert(pRouter != NULL);
    (void)pRouter;

    return mal_calculate_channel_position_planar_weight(channelPositionIn, channelPositionOut);
}

mal_bool32 mal_channel_router__is_spatial_channel_position(const mal_channel_router* pRouter, mal_channel channelPosition)
{
    mal_assert(pRouter != NULL);
    (void)pRouter;

    if (channelPosition == MAL_CHANNEL_NONE || channelPosition == MAL_CHANNEL_MONO || channelPosition == MAL_CHANNEL_LFE) {
        return MAL_FALSE;
    }

    for (int i = 0; i < 6; ++i) {
        if (g_malChannelPlaneRatios[channelPosition][i] != 0) {
            return MAL_TRUE;
        }
    }

    return MAL_FALSE;
}

mal_result mal_channel_router_init(const mal_channel_router_config* pConfig, mal_channel_router* pRouter)
{
    if (pRouter == NULL) {
        return MAL_INVALID_ARGS;
    }

    mal_zero_object(pRouter);

    if (pConfig == NULL) {
        return MAL_INVALID_ARGS;
    }
    if (pConfig->onReadDeinterleaved == NULL) {
        return MAL_INVALID_ARGS;
    }

    if (!mal_channel_map_valid(pConfig->channelsIn, pConfig->channelMapIn)) {
        return MAL_INVALID_ARGS;    // Invalid input channel map.
    }
    if (!mal_channel_map_valid(pConfig->channelsOut, pConfig->channelMapOut)) {
        return MAL_INVALID_ARGS;    // Invalid output channel map.
    }

    pRouter->config = *pConfig;

    // SIMD
    pRouter->useSSE2   = mal_has_sse2()    && !pConfig->noSSE2;
    pRouter->useAVX2   = mal_has_avx2()    && !pConfig->noAVX2;
    pRouter->useAVX512 = mal_has_avx512f() && !pConfig->noAVX512;
    pRouter->useNEON   = mal_has_neon()    && !pConfig->noNEON;

    // If the input and output channels and channel maps are the same we should use a passthrough.
    if (pRouter->config.channelsIn == pRouter->config.channelsOut) {
        if (mal_channel_map_equal(pRouter->config.channelsIn, pRouter->config.channelMapIn, pRouter->config.channelMapOut)) {
            pRouter->isPassthrough = MAL_TRUE;
        }
        if (mal_channel_map_blank(pRouter->config.channelsIn, pRouter->config.channelMapIn) || mal_channel_map_blank(pRouter->config.channelsOut, pRouter->config.channelMapOut)) {
            pRouter->isPassthrough = MAL_TRUE;
        }
    }

    // Here is where we do a bit of pre-processing to know how each channel should be combined to make up the output. Rules:
    //
    // 1) If it's a passthrough, do nothing - it's just a simple memcpy().
    // 2) If the channel counts are the same and every channel position in the input map is present in the output map, use a
    //    simple shuffle. An example might be different 5.1 channel layouts.
    // 3) Otherwise channels are blended based on spatial locality.
    if (!pRouter->isPassthrough) {
        if (pRouter->config.channelsIn == pRouter->config.channelsOut) {
            mal_bool32 areAllChannelPositionsPresent = MAL_TRUE;
            for (mal_uint32 iChannelIn = 0; iChannelIn < pRouter->config.channelsIn; ++iChannelIn) {
                mal_bool32 isInputChannelPositionInOutput = MAL_FALSE;
                for (mal_uint32 iChannelOut = 0; iChannelOut < pRouter->config.channelsOut; ++iChannelOut) {
                    if (pRouter->config.channelMapIn[iChannelIn] == pRouter->config.channelMapOut[iChannelOut]) {
                        isInputChannelPositionInOutput = MAL_TRUE;
                        break;
                    }
                }

                if (!isInputChannelPositionInOutput) {
                    areAllChannelPositionsPresent = MAL_FALSE;
                    break;
                }
            }

            if (areAllChannelPositionsPresent) {
                pRouter->isSimpleShuffle = MAL_TRUE;

                // All the router will be doing is rearranging channels which means all we need to do is use a shuffling table which is just
                // a mapping between the index of the input channel to the index of the output channel.
                for (mal_uint32 iChannelIn = 0; iChannelIn < pRouter->config.channelsIn; ++iChannelIn) {
                    for (mal_uint32 iChannelOut = 0; iChannelOut < pRouter->config.channelsOut; ++iChannelOut) {
                        if (pRouter->config.channelMapIn[iChannelIn] == pRouter->config.channelMapOut[iChannelOut]) {
                            pRouter->shuffleTable[iChannelIn] = (mal_uint8)iChannelOut;
                            break;
                        }
                    }
                }
            }
        }
    }


    // Here is where weights are calculated. Note that we calculate the weights at all times, even when using a passthrough and simple
    // shuffling. We use different algorithms for calculating weights depending on our mixing mode.
    //
    // In simple mode we don't do any blending (except for converting between mono, which is done in a later step). Instead we just
    // map 1:1 matching channels. In this mode, if no channels in the input channel map correspond to anything in the output channel
    // map, nothing will be heard!

    // In all cases we need to make sure all channels that are present in both channel maps have a 1:1 mapping.
    for (mal_uint32 iChannelIn = 0; iChannelIn < pRouter->config.channelsIn; ++iChannelIn) {
        mal_channel channelPosIn = pRouter->config.channelMapIn[iChannelIn];

        for (mal_uint32 iChannelOut = 0; iChannelOut < pRouter->config.channelsOut; ++iChannelOut) {
            mal_channel channelPosOut = pRouter->config.channelMapOut[iChannelOut];

            if (channelPosIn == channelPosOut) {
                pRouter->config.weights[iChannelIn][iChannelOut] = 1;
            }
        }
    }

    // The mono channel is accumulated on all other channels, except LFE. Make sure in this loop we exclude output mono channels since
    // they were handled in the pass above.
    for (mal_uint32 iChannelIn = 0; iChannelIn < pRouter->config.channelsIn; ++iChannelIn) {
        mal_channel channelPosIn = pRouter->config.channelMapIn[iChannelIn];

        if (channelPosIn == MAL_CHANNEL_MONO) {
            for (mal_uint32 iChannelOut = 0; iChannelOut < pRouter->config.channelsOut; ++iChannelOut) {
                mal_channel channelPosOut = pRouter->config.channelMapOut[iChannelOut];

                if (channelPosOut != MAL_CHANNEL_NONE && channelPosOut != MAL_CHANNEL_MONO && channelPosOut != MAL_CHANNEL_LFE) {
                    pRouter->config.weights[iChannelIn][iChannelOut] = 1;
                }
            }
        }
    }

    // The output mono channel is the average of all non-none, non-mono and non-lfe input channels.
    {
        mal_uint32 len = 0;
        for (mal_uint32 iChannelIn = 0; iChannelIn < pRouter->config.channelsIn; ++iChannelIn) {
            mal_channel channelPosIn = pRouter->config.channelMapIn[iChannelIn];

            if (channelPosIn != MAL_CHANNEL_NONE && channelPosIn != MAL_CHANNEL_MONO && channelPosIn != MAL_CHANNEL_LFE) {
                len += 1;
            }
        }

        if (len > 0) {
            float monoWeight = 1.0f / len;

            for (mal_uint32 iChannelOut = 0; iChannelOut < pRouter->config.channelsOut; ++iChannelOut) {
                mal_channel channelPosOut = pRouter->config.channelMapOut[iChannelOut];

                if (channelPosOut == MAL_CHANNEL_MONO) {
                    for (mal_uint32 iChannelIn = 0; iChannelIn < pRouter->config.channelsIn; ++iChannelIn) {
                        mal_channel channelPosIn = pRouter->config.channelMapIn[iChannelIn];

                        if (channelPosIn != MAL_CHANNEL_NONE && channelPosIn != MAL_CHANNEL_MONO && channelPosIn != MAL_CHANNEL_LFE) {
                            pRouter->config.weights[iChannelIn][iChannelOut] += monoWeight;
                        }
                    }
                }
            }
        }
    }


    // Input and output channels that are not present on the other side need to be blended in based on spatial locality.
    switch (pRouter->config.mixingMode)
    {
        case mal_channel_mix_mode_rectangular:
        {
            // Unmapped input channels.
            for (mal_uint32 iChannelIn = 0; iChannelIn < pRouter->config.channelsIn; ++iChannelIn) {
                mal_channel channelPosIn = pRouter->config.channelMapIn[iChannelIn];

                if (mal_channel_router__is_spatial_channel_position(pRouter, channelPosIn)) {
                    if (!mal_channel_map_contains_channel_position(pRouter->config.channelsOut, pRouter->config.channelMapOut, channelPosIn)) {
                        for (mal_uint32 iChannelOut = 0; iChannelOut < pRouter->config.channelsOut; ++iChannelOut) {
                            mal_channel channelPosOut = pRouter->config.channelMapOut[iChannelOut];

                            if (mal_channel_router__is_spatial_channel_position(pRouter, channelPosOut)) {
                                float weight = 0;
                                if (pRouter->config.mixingMode == mal_channel_mix_mode_planar_blend) {
                                    weight = mal_channel_router__calculate_input_channel_planar_weight(pRouter, channelPosIn, channelPosOut);
                                }

                                // Only apply the weight if we haven't already got some contribution from the respective channels.
                                if (pRouter->config.weights[iChannelIn][iChannelOut] == 0) {
                                    pRouter->config.weights[iChannelIn][iChannelOut] = weight;
                                }
                            }
                        }
                    }
                }
            }

            // Unmapped output channels.
            for (mal_uint32 iChannelOut = 0; iChannelOut < pRouter->config.channelsOut; ++iChannelOut) {
                mal_channel channelPosOut = pRouter->config.channelMapOut[iChannelOut];

                if (mal_channel_router__is_spatial_channel_position(pRouter, channelPosOut)) {
                    if (!mal_channel_map_contains_channel_position(pRouter->config.channelsIn, pRouter->config.channelMapIn, channelPosOut)) {
                        for (mal_uint32 iChannelIn = 0; iChannelIn < pRouter->config.channelsIn; ++iChannelIn) {
                            mal_channel channelPosIn = pRouter->config.channelMapIn[iChannelIn];

                            if (mal_channel_router__is_spatial_channel_position(pRouter, channelPosIn)) {
                                float weight = 0;
                                if (pRouter->config.mixingMode == mal_channel_mix_mode_planar_blend) {
                                    weight = mal_channel_router__calculate_input_channel_planar_weight(pRouter, channelPosIn, channelPosOut);
                                }

                                // Only apply the weight if we haven't already got some contribution from the respective channels.
                                if (pRouter->config.weights[iChannelIn][iChannelOut] == 0) {
                                    pRouter->config.weights[iChannelIn][iChannelOut] = weight;
                                }
                            }
                        }
                    }
                }
            }
        } break;

        case mal_channel_mix_mode_custom_weights:
        case mal_channel_mix_mode_simple:
        default:
        {
            /* Fallthrough. */
        } break;
    }

    return MAL_SUCCESS;
}

static MAL_INLINE mal_bool32 mal_channel_router__can_use_sse2(mal_channel_router* pRouter, const float* pSamplesOut, const float* pSamplesIn)
{
    return pRouter->useSSE2 && (((mal_uintptr)pSamplesOut & 15) == 0) && (((mal_uintptr)pSamplesIn & 15) == 0);
}

static MAL_INLINE mal_bool32 mal_channel_router__can_use_avx2(mal_channel_router* pRouter, const float* pSamplesOut, const float* pSamplesIn)
{
    return pRouter->useAVX2 && (((mal_uintptr)pSamplesOut & 31) == 0) && (((mal_uintptr)pSamplesIn & 31) == 0);
}

static MAL_INLINE mal_bool32 mal_channel_router__can_use_avx512(mal_channel_router* pRouter, const float* pSamplesOut, const float* pSamplesIn)
{
    return pRouter->useAVX512 && (((mal_uintptr)pSamplesOut & 63) == 0) && (((mal_uintptr)pSamplesIn & 63) == 0);
}

static MAL_INLINE mal_bool32 mal_channel_router__can_use_neon(mal_channel_router* pRouter, const float* pSamplesOut, const float* pSamplesIn)
{
    return pRouter->useNEON && (((mal_uintptr)pSamplesOut & 15) == 0) && (((mal_uintptr)pSamplesIn & 15) == 0);
}

void mal_channel_router__do_routing(mal_channel_router* pRouter, mal_uint64 frameCount, float** ppSamplesOut, const float** ppSamplesIn)
{
    mal_assert(pRouter != NULL);
    mal_assert(pRouter->isPassthrough == MAL_FALSE);

    if (pRouter->isSimpleShuffle) {
        // A shuffle is just a re-arrangement of channels and does not require any arithmetic.
        mal_assert(pRouter->config.channelsIn == pRouter->config.channelsOut);
        for (mal_uint32 iChannelIn = 0; iChannelIn < pRouter->config.channelsIn; ++iChannelIn) {
            mal_uint32 iChannelOut = pRouter->shuffleTable[iChannelIn];
            mal_copy_memory_64(ppSamplesOut[iChannelOut], ppSamplesIn[iChannelIn], frameCount * sizeof(float));
        }
    } else {
        // This is the more complicated case. Each of the output channels is accumulated with 0 or more input channels.

        // Clear.
        for (mal_uint32 iChannelOut = 0; iChannelOut < pRouter->config.channelsOut; ++iChannelOut) {
            mal_zero_memory_64(ppSamplesOut[iChannelOut], frameCount * sizeof(float));
        }

        // Accumulate.
        for (mal_uint32 iChannelIn = 0; iChannelIn < pRouter->config.channelsIn; ++iChannelIn) {
            for (mal_uint32 iChannelOut = 0; iChannelOut < pRouter->config.channelsOut; ++iChannelOut) {
                mal_uint64 iFrame = 0;
#if defined(MAL_SUPPORT_NEON)
                if (mal_channel_router__can_use_neon(pRouter, ppSamplesOut[iChannelOut], ppSamplesIn[iChannelIn])) {
                    float32x4_t weight = vmovq_n_f32(pRouter->config.weights[iChannelIn][iChannelOut]);

                    mal_uint64 frameCount4 = frameCount/4;
                    for (mal_uint64 iFrame4 = 0; iFrame4 < frameCount4; iFrame4 += 1) {
                        float32x4_t* pO = (float32x4_t*)ppSamplesOut[iChannelOut] + iFrame4;
                        float32x4_t* pI = (float32x4_t*)ppSamplesIn [iChannelIn ] + iFrame4;
                        *pO = vaddq_f32(*pO, vmulq_f32(*pI, weight));
                    }

                    iFrame += frameCount4*4;
                }
                else
#endif
#if defined(MAL_SUPPORT_AVX512)
                if (mal_channel_router__can_use_avx512(pRouter, ppSamplesOut[iChannelOut], ppSamplesIn[iChannelIn])) {
                    __m512 weight = _mm512_set1_ps(pRouter->config.weights[iChannelIn][iChannelOut]);

                    mal_uint64 frameCount16 = frameCount/16;
                    for (mal_uint64 iFrame16 = 0; iFrame16 < frameCount16; iFrame16 += 1) {
                        __m512* pO = (__m512*)ppSamplesOut[iChannelOut] + iFrame16;
                        __m512* pI = (__m512*)ppSamplesIn [iChannelIn ] + iFrame16;
                        *pO = _mm512_add_ps(*pO, _mm512_mul_ps(*pI, weight));
                    }

                    iFrame += frameCount16*16;
                }
                else
#endif
#if defined(MAL_SUPPORT_AVX2)
                if (mal_channel_router__can_use_avx2(pRouter, ppSamplesOut[iChannelOut], ppSamplesIn[iChannelIn])) {
                    __m256 weight = _mm256_set1_ps(pRouter->config.weights[iChannelIn][iChannelOut]);

                    mal_uint64 frameCount8 = frameCount/8;
                    for (mal_uint64 iFrame8 = 0; iFrame8 < frameCount8; iFrame8 += 1) {
                        __m256* pO = (__m256*)ppSamplesOut[iChannelOut] + iFrame8;
                        __m256* pI = (__m256*)ppSamplesIn [iChannelIn ] + iFrame8;
                        *pO = _mm256_add_ps(*pO, _mm256_mul_ps(*pI, weight));
                    }

                    iFrame += frameCount8*8;
                }
                else
#endif
#if defined(MAL_SUPPORT_SSE2)
                if (mal_channel_router__can_use_sse2(pRouter, ppSamplesOut[iChannelOut], ppSamplesIn[iChannelIn])) {
                    __m128 weight = _mm_set1_ps(pRouter->config.weights[iChannelIn][iChannelOut]);

                    mal_uint64 frameCount4 = frameCount/4;
                    for (mal_uint64 iFrame4 = 0; iFrame4 < frameCount4; iFrame4 += 1) {
                        __m128* pO = (__m128*)ppSamplesOut[iChannelOut] + iFrame4;
                        __m128* pI = (__m128*)ppSamplesIn [iChannelIn ] + iFrame4;
                        *pO = _mm_add_ps(*pO, _mm_mul_ps(*pI, weight));
                    }

                    iFrame += frameCount4*4;
                } else 
#endif
                {   // Reference.
                    float weight0 = pRouter->config.weights[iChannelIn][iChannelOut];
                    float weight1 = pRouter->config.weights[iChannelIn][iChannelOut];
                    float weight2 = pRouter->config.weights[iChannelIn][iChannelOut];
                    float weight3 = pRouter->config.weights[iChannelIn][iChannelOut];

                    mal_uint64 frameCount4 = frameCount/4;
                    for (mal_uint64 iFrame4 = 0; iFrame4 < frameCount4; iFrame4 += 1) {
                        ppSamplesOut[iChannelOut][iFrame+0] += ppSamplesIn[iChannelIn][iFrame+0] * weight0;
                        ppSamplesOut[iChannelOut][iFrame+1] += ppSamplesIn[iChannelIn][iFrame+1] * weight1;
                        ppSamplesOut[iChannelOut][iFrame+2] += ppSamplesIn[iChannelIn][iFrame+2] * weight2;
                        ppSamplesOut[iChannelOut][iFrame+3] += ppSamplesIn[iChannelIn][iFrame+3] * weight3;
                        iFrame += 4;
                    }
                }

                // Leftover.
                for (; iFrame < frameCount; ++iFrame) {
                    ppSamplesOut[iChannelOut][iFrame] += ppSamplesIn[iChannelIn][iFrame] * pRouter->config.weights[iChannelIn][iChannelOut];
                }
            }
        }
    }
}

mal_uint64 mal_channel_router_read_deinterleaved(mal_channel_router* pRouter, mal_uint64 frameCount, void** ppSamplesOut, void* pUserData)
{
    if (pRouter == NULL || ppSamplesOut == NULL) {
        return 0;
    }

    // Fast path for a passthrough.
    if (pRouter->isPassthrough) {
        if (frameCount <= 0xFFFFFFFF) {
            return (mal_uint32)pRouter->config.onReadDeinterleaved(pRouter, (mal_uint32)frameCount, ppSamplesOut, pUserData);
        } else {
            float* ppNextSamplesOut[MAL_MAX_CHANNELS];
            mal_copy_memory(ppNextSamplesOut, ppSamplesOut, sizeof(float*) * pRouter->config.channelsOut);

            mal_uint64 totalFramesRead = 0;
            while (totalFramesRead < frameCount) {
                mal_uint64 framesRemaining = (frameCount - totalFramesRead);
                mal_uint64 framesToReadRightNow = framesRemaining;
                if (framesToReadRightNow > 0xFFFFFFFF) {
                    framesToReadRightNow = 0xFFFFFFFF;
                }

                mal_uint32 framesJustRead = (mal_uint32)pRouter->config.onReadDeinterleaved(pRouter, (mal_uint32)framesToReadRightNow, (void**)ppNextSamplesOut, pUserData);
                if (framesJustRead == 0) {
                    break;
                }

                totalFramesRead += framesJustRead;
                for (mal_uint32 iChannel = 0; iChannel < pRouter->config.channelsOut; ++iChannel) {
                    ppNextSamplesOut[iChannel] += framesJustRead;
                }

                if (framesJustRead < framesToReadRightNow) {
                    break;
                }
            }
        }
    }

    // Slower path for a non-passthrough.
    float* ppNextSamplesOut[MAL_MAX_CHANNELS];
    mal_copy_memory(ppNextSamplesOut, ppSamplesOut, sizeof(float*) * pRouter->config.channelsOut);

    MAL_ALIGN(MAL_SIMD_ALIGNMENT) float temp[MAL_MAX_CHANNELS * 256];
    mal_assert(sizeof(temp) <= 0xFFFFFFFF);

    float* ppTemp[MAL_MAX_CHANNELS];
    size_t maxBytesToReadPerFrameEachIteration;
    mal_split_buffer(temp, sizeof(temp), pRouter->config.channelsIn, MAL_SIMD_ALIGNMENT, (void**)&ppTemp, &maxBytesToReadPerFrameEachIteration);

    size_t maxFramesToReadEachIteration = maxBytesToReadPerFrameEachIteration/sizeof(float);

    mal_uint64 totalFramesRead = 0;
    while (totalFramesRead < frameCount) {
        mal_uint64 framesRemaining = (frameCount - totalFramesRead);
        mal_uint64 framesToReadRightNow = framesRemaining;
        if (framesToReadRightNow > maxFramesToReadEachIteration) {
            framesToReadRightNow = maxFramesToReadEachIteration;
        }

        mal_uint32 framesJustRead = pRouter->config.onReadDeinterleaved(pRouter, (mal_uint32)framesToReadRightNow, (void**)ppTemp, pUserData);
        if (framesJustRead == 0) {
            break;
        }

        mal_channel_router__do_routing(pRouter, framesJustRead, (float**)ppNextSamplesOut, (const float**)ppTemp);  // <-- Real work is done here.

        totalFramesRead += framesJustRead;
        if (totalFramesRead < frameCount) {
            for (mal_uint32 iChannel = 0; iChannel < pRouter->config.channelsIn; iChannel += 1) {
                ppNextSamplesOut[iChannel] += framesJustRead;
            }
        }

        if (framesJustRead < framesToReadRightNow) {
            break;
        }
    }

    return totalFramesRead;
}

mal_channel_router_config mal_channel_router_config_init(mal_uint32 channelsIn, const mal_channel channelMapIn[MAL_MAX_CHANNELS], mal_uint32 channelsOut, const mal_channel channelMapOut[MAL_MAX_CHANNELS], mal_channel_mix_mode mixingMode, mal_channel_router_read_deinterleaved_proc onRead, void* pUserData)
{
    mal_channel_router_config config;
    mal_zero_object(&config);

    config.channelsIn = channelsIn;
    for (mal_uint32 iChannel = 0; iChannel < channelsIn; ++iChannel) {
        config.channelMapIn[iChannel] = channelMapIn[iChannel];
    }

    config.channelsOut = channelsOut;
    for (mal_uint32 iChannel = 0; iChannel < channelsOut; ++iChannel) {
        config.channelMapOut[iChannel] = channelMapOut[iChannel];
    }

    config.mixingMode = mixingMode;
    config.onReadDeinterleaved = onRead;
    config.pUserData = pUserData;

    return config;
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// SRC
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define mal_floorf(x) ((float)floor((double)(x)))
#define mal_sinf(x)   ((float)sin((double)(x)))
#define mal_cosf(x)   ((float)cos((double)(x)))

static MAL_INLINE double mal_sinc(double x)
{
    if (x != 0) {
        return sin(MAL_PI_D*x) / (MAL_PI_D*x);
    } else {
        return 1;
    }
}

#define mal_sincf(x) ((float)mal_sinc((double)(x)))


mal_uint64 mal_src_read_deinterleaved__passthrough(mal_src* pSRC, mal_uint64 frameCount, void** ppSamplesOut, void* pUserData);
mal_uint64 mal_src_read_deinterleaved__linear(mal_src* pSRC, mal_uint64 frameCount, void** ppSamplesOut, void* pUserData);
mal_uint64 mal_src_read_deinterleaved__sinc(mal_src* pSRC, mal_uint64 frameCount, void** ppSamplesOut, void* pUserData);

void mal_src__build_sinc_table__sinc(mal_src* pSRC)
{
    mal_assert(pSRC != NULL);

    pSRC->sinc.table[0] = 1.0f;
    for (mal_uint32 i = 1; i < mal_countof(pSRC->sinc.table); i += 1) {
        double x = i*MAL_PI_D / MAL_SRC_SINC_LOOKUP_TABLE_RESOLUTION;
        pSRC->sinc.table[i] = (float)(sin(x)/x);
    }
}

void mal_src__build_sinc_table__rectangular(mal_src* pSRC)
{
    // This is the same as the base sinc table.
    mal_src__build_sinc_table__sinc(pSRC);
}

void mal_src__build_sinc_table__hann(mal_src* pSRC)
{
    mal_src__build_sinc_table__sinc(pSRC);

    for (mal_uint32 i = 0; i < mal_countof(pSRC->sinc.table); i += 1) {
        double x = pSRC->sinc.table[i];
        double N = MAL_SRC_SINC_MAX_WINDOW_WIDTH*2;
        double n = ((double)(i) / MAL_SRC_SINC_LOOKUP_TABLE_RESOLUTION) + MAL_SRC_SINC_MAX_WINDOW_WIDTH;
        double w = 0.5 * (1 - cos((2*MAL_PI_D*n) / (N)));

        pSRC->sinc.table[i] = (float)(x * w);
    }
}

mal_result mal_src_init(const mal_src_config* pConfig, mal_src* pSRC)
{
    if (pSRC == NULL) {
        return MAL_INVALID_ARGS;
    }

    mal_zero_object(pSRC);

    if (pConfig == NULL || pConfig->onReadDeinterleaved == NULL) {
        return MAL_INVALID_ARGS;
    }
    if (pConfig->channels == 0 || pConfig->channels > MAL_MAX_CHANNELS) {
        return MAL_INVALID_ARGS;
    }

    pSRC->config = *pConfig;

    // SIMD
    pSRC->useSSE2   = mal_has_sse2()    && !pConfig->noSSE2;
    pSRC->useAVX2   = mal_has_avx2()    && !pConfig->noAVX2;
    pSRC->useAVX512 = mal_has_avx512f() && !pConfig->noAVX512;
    pSRC->useNEON   = mal_has_neon()    && !pConfig->noNEON;

    if (pSRC->config.algorithm == mal_src_algorithm_sinc) {
        // Make sure the window width within bounds.
        if (pSRC->config.sinc.windowWidth == 0) {
            pSRC->config.sinc.windowWidth = MAL_SRC_SINC_DEFAULT_WINDOW_WIDTH;
        }
        if (pSRC->config.sinc.windowWidth < MAL_SRC_SINC_MIN_WINDOW_WIDTH) {
            pSRC->config.sinc.windowWidth = MAL_SRC_SINC_MIN_WINDOW_WIDTH;
        }
        if (pSRC->config.sinc.windowWidth > MAL_SRC_SINC_MAX_WINDOW_WIDTH) {
            pSRC->config.sinc.windowWidth = MAL_SRC_SINC_MAX_WINDOW_WIDTH;
        }

        // Set up the lookup table.
        switch (pSRC->config.sinc.windowFunction) {
            case mal_src_sinc_window_function_hann:        mal_src__build_sinc_table__hann(pSRC);        break;
            case mal_src_sinc_window_function_rectangular: mal_src__build_sinc_table__rectangular(pSRC); break;
            default: return MAL_INVALID_ARGS;   // <-- Hitting this means the window function is unknown to mini_al.
        }
    }

    return MAL_SUCCESS;
}

mal_result mal_src_set_sample_rate(mal_src* pSRC, mal_uint32 sampleRateIn, mal_uint32 sampleRateOut)
{
    if (pSRC == NULL) {
        return MAL_INVALID_ARGS;
    }

    // Must have a sample rate of > 0.
    if (sampleRateIn == 0 || sampleRateOut == 0) {
        return MAL_INVALID_ARGS;
    }

    mal_atomic_exchange_32(&pSRC->config.sampleRateIn, sampleRateIn);
    mal_atomic_exchange_32(&pSRC->config.sampleRateOut, sampleRateOut);

    return MAL_SUCCESS;
}

mal_uint64 mal_src_read_deinterleaved(mal_src* pSRC, mal_uint64 frameCount, void** ppSamplesOut, void* pUserData)
{
    if (pSRC == NULL || frameCount == 0 || ppSamplesOut == NULL) {
        return 0;
    }

    mal_src_algorithm algorithm = pSRC->config.algorithm;

    // Can use a function pointer for this.
    switch (algorithm) {
        case mal_src_algorithm_none:   return mal_src_read_deinterleaved__passthrough(pSRC, frameCount, ppSamplesOut, pUserData);
        case mal_src_algorithm_linear: return mal_src_read_deinterleaved__linear(     pSRC, frameCount, ppSamplesOut, pUserData);
        case mal_src_algorithm_sinc:   return mal_src_read_deinterleaved__sinc(       pSRC, frameCount, ppSamplesOut, pUserData);
        default: break;
    }

    // Should never get here.
    return 0;
}

mal_uint64 mal_src_read_deinterleaved__passthrough(mal_src* pSRC, mal_uint64 frameCount, void** ppSamplesOut, void* pUserData)
{
    if (frameCount <= 0xFFFFFFFF) {
        return pSRC->config.onReadDeinterleaved(pSRC, (mal_uint32)frameCount, ppSamplesOut, pUserData);
    } else {
        float* ppNextSamplesOut[MAL_MAX_CHANNELS];
        for (mal_uint32 iChannel = 0; iChannel < pSRC->config.channels; ++iChannel) {
            ppNextSamplesOut[iChannel] = (float*)ppSamplesOut[iChannel];
        }

        mal_uint64 totalFramesRead = 0;
        while (totalFramesRead < frameCount) {
            mal_uint64 framesRemaining = frameCount - totalFramesRead;
            mal_uint64 framesToReadRightNow = framesRemaining;
            if (framesToReadRightNow > 0xFFFFFFFF) {
                framesToReadRightNow = 0xFFFFFFFF;
            }

            mal_uint32 framesJustRead = (mal_uint32)pSRC->config.onReadDeinterleaved(pSRC, (mal_uint32)framesToReadRightNow, (void**)ppNextSamplesOut, pUserData);
            if (framesJustRead == 0) {
                break;
            }

            totalFramesRead += framesJustRead;
            for (mal_uint32 iChannel = 0; iChannel < pSRC->config.channels; ++iChannel) {
                ppNextSamplesOut[iChannel] += framesJustRead;
            }

            if (framesJustRead < framesToReadRightNow) {
                break;
            }
        }

        return totalFramesRead;
    }
}

mal_uint64 mal_src_read_deinterleaved__linear(mal_src* pSRC, mal_uint64 frameCount, void** ppSamplesOut, void* pUserData)
{
    mal_assert(pSRC != NULL);
    mal_assert(frameCount > 0);
    mal_assert(ppSamplesOut != NULL);

    float* ppNextSamplesOut[MAL_MAX_CHANNELS];
    mal_copy_memory(ppNextSamplesOut, ppSamplesOut, sizeof(void*) * pSRC->config.channels);


    float factor = (float)pSRC->config.sampleRateIn / pSRC->config.sampleRateOut;

    mal_uint32 maxFrameCountPerChunkIn = mal_countof(pSRC->linear.input[0]);

    mal_uint64 totalFramesRead = 0;
    while (totalFramesRead < frameCount) {
        mal_uint64 framesRemaining = frameCount - totalFramesRead;
        mal_uint64 framesToRead = framesRemaining;
        if (framesToRead > 16384) {
            framesToRead = 16384;    // <-- Keep this small because we're using 32-bit floats for calculating sample positions and I don't want to run out of precision with huge sample counts.
        }


        // Read Input Data
        // ===============
        float tBeg = pSRC->linear.timeIn;
        float tEnd = tBeg + (framesToRead*factor);

        mal_uint32 framesToReadFromClient = (mal_uint32)(tEnd) + 1 + 1;   // +1 to make tEnd 1-based and +1 because we always need to an extra sample for interpolation.
        if (framesToReadFromClient >= maxFrameCountPerChunkIn) {
            framesToReadFromClient  = maxFrameCountPerChunkIn;
        }

        float* ppSamplesFromClient[MAL_MAX_CHANNELS];
        for (mal_uint32 iChannel = 0; iChannel < pSRC->config.channels; ++iChannel) {
            ppSamplesFromClient[iChannel] = pSRC->linear.input[iChannel] + pSRC->linear.leftoverFrames;
        }
        
        mal_uint32 framesReadFromClient = 0;
        if (framesToReadFromClient > pSRC->linear.leftoverFrames) {
            framesReadFromClient = (mal_uint32)pSRC->config.onReadDeinterleaved(pSRC, (mal_uint32)framesToReadFromClient - pSRC->linear.leftoverFrames, (void**)ppSamplesFromClient, pUserData);
        }

        framesReadFromClient += pSRC->linear.leftoverFrames;  // <-- You can sort of think of it as though we've re-read the leftover samples from the client.
        if (framesReadFromClient < 2) {
            break;
        }

        for (mal_uint32 iChannel = 0; iChannel < pSRC->config.channels; ++iChannel) {
            ppSamplesFromClient[iChannel] = pSRC->linear.input[iChannel];
        }


        // Write Output Data
        // =================

        // At this point we have a bunch of frames that the client has given to us for processing. From this we can determine the maximum number of output frames
        // that can be processed from this input. We want to output as many samples as possible from our input data.
        float tAvailable = framesReadFromClient - tBeg - 1; // Subtract 1 because the last input sample is needed for interpolation and cannot be included in the output sample count calculation.

        mal_uint32 maxOutputFramesToRead = (mal_uint32)(tAvailable / factor);
        if (maxOutputFramesToRead == 0) {
            maxOutputFramesToRead = 1;
        }
        if (maxOutputFramesToRead > framesToRead) {
            maxOutputFramesToRead = (mal_uint32)framesToRead;
        }

        // Output frames are always read in groups of 4 because I'm planning on using this as a reference for some SIMD-y stuff later.
        mal_uint32 maxOutputFramesToRead4 = maxOutputFramesToRead/4;
        for (mal_uint32 iChannel = 0; iChannel < pSRC->config.channels; ++iChannel) {
            float t0 = pSRC->linear.timeIn + factor*0;
            float t1 = pSRC->linear.timeIn + factor*1;
            float t2 = pSRC->linear.timeIn + factor*2;
            float t3 = pSRC->linear.timeIn + factor*3;

            for (mal_uint32 iFrameOut = 0; iFrameOut < maxOutputFramesToRead4; iFrameOut += 1) {
                float iPrevSample0 = (float)floor(t0);
                float iPrevSample1 = (float)floor(t1);
                float iPrevSample2 = (float)floor(t2);
                float iPrevSample3 = (float)floor(t3);
                
                float iNextSample0 = iPrevSample0 + 1;
                float iNextSample1 = iPrevSample1 + 1;
                float iNextSample2 = iPrevSample2 + 1;
                float iNextSample3 = iPrevSample3 + 1;

                float alpha0 = t0 - iPrevSample0;
                float alpha1 = t1 - iPrevSample1;
                float alpha2 = t2 - iPrevSample2;
                float alpha3 = t3 - iPrevSample3;

                float prevSample0 = ppSamplesFromClient[iChannel][(mal_uint32)iPrevSample0];
                float prevSample1 = ppSamplesFromClient[iChannel][(mal_uint32)iPrevSample1];
                float prevSample2 = ppSamplesFromClient[iChannel][(mal_uint32)iPrevSample2];
                float prevSample3 = ppSamplesFromClient[iChannel][(mal_uint32)iPrevSample3];
                
                float nextSample0 = ppSamplesFromClient[iChannel][(mal_uint32)iNextSample0];
                float nextSample1 = ppSamplesFromClient[iChannel][(mal_uint32)iNextSample1];
                float nextSample2 = ppSamplesFromClient[iChannel][(mal_uint32)iNextSample2];
                float nextSample3 = ppSamplesFromClient[iChannel][(mal_uint32)iNextSample3];

                ppNextSamplesOut[iChannel][iFrameOut*4 + 0] = mal_mix_f32_fast(prevSample0, nextSample0, alpha0);
                ppNextSamplesOut[iChannel][iFrameOut*4 + 1] = mal_mix_f32_fast(prevSample1, nextSample1, alpha1);
                ppNextSamplesOut[iChannel][iFrameOut*4 + 2] = mal_mix_f32_fast(prevSample2, nextSample2, alpha2);
                ppNextSamplesOut[iChannel][iFrameOut*4 + 3] = mal_mix_f32_fast(prevSample3, nextSample3, alpha3);

                t0 += factor*4;
                t1 += factor*4;
                t2 += factor*4;
                t3 += factor*4;
            }

            float t = pSRC->linear.timeIn + (factor*maxOutputFramesToRead4*4);
            for (mal_uint32 iFrameOut = (maxOutputFramesToRead4*4); iFrameOut < maxOutputFramesToRead; iFrameOut += 1) {
                float iPrevSample = (float)floor(t);
                float iNextSample = iPrevSample + 1;
                float alpha = t - iPrevSample;

                mal_assert(iPrevSample < mal_countof(pSRC->linear.input[iChannel]));
                mal_assert(iNextSample < mal_countof(pSRC->linear.input[iChannel]));

                float prevSample = ppSamplesFromClient[iChannel][(mal_uint32)iPrevSample];
                float nextSample = ppSamplesFromClient[iChannel][(mal_uint32)iNextSample];

                ppNextSamplesOut[iChannel][iFrameOut] = mal_mix_f32_fast(prevSample, nextSample, alpha);

                t += factor;
            }

            ppNextSamplesOut[iChannel] += maxOutputFramesToRead;
        }

        totalFramesRead += maxOutputFramesToRead;


        // Residual
        // ========
        float tNext = pSRC->linear.timeIn + (maxOutputFramesToRead*factor);

        pSRC->linear.timeIn = tNext;
        mal_assert(tNext <= framesReadFromClient+1);

        mal_uint32 iNextFrame = (mal_uint32)floor(tNext);
        pSRC->linear.leftoverFrames = framesReadFromClient - iNextFrame;
        pSRC->linear.timeIn = tNext - iNextFrame;

        for (mal_uint32 iChannel = 0; iChannel < pSRC->config.channels; ++iChannel) {
            for (mal_uint32 iFrame = 0; iFrame < pSRC->linear.leftoverFrames; ++iFrame) {
                float sample = ppSamplesFromClient[iChannel][framesReadFromClient-pSRC->linear.leftoverFrames + iFrame];
                ppSamplesFromClient[iChannel][iFrame] = sample;
            }
        }

        
        // Exit the loop if we've found everything from the client.
        if (framesReadFromClient < framesToReadFromClient) {
            break;
        }
    }

    return totalFramesRead;
}


mal_src_config mal_src_config_init_new()
{
    mal_src_config config;
    mal_zero_object(&config);

    return config;
}

mal_src_config mal_src_config_init(mal_uint32 sampleRateIn, mal_uint32 sampleRateOut, mal_uint32 channels, mal_src_read_deinterleaved_proc onReadDeinterleaved, void* pUserData)
{
    mal_src_config config = mal_src_config_init_new();
    config.sampleRateIn = sampleRateIn;
    config.sampleRateOut = sampleRateOut;
    config.channels = channels;
    config.onReadDeinterleaved = onReadDeinterleaved;
    config.pUserData = pUserData;

    return config;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Sinc Sample Rate Conversion
// ===========================
//
// The sinc SRC algorithm uses a windowed sinc to perform interpolation of samples. Currently, mini_al's implementation supports rectangular and Hann window
// methods.
//
// Whenever an output sample is being computed, it looks at a sub-section of the input samples. I've called this sub-section in the code below the "window",
// which I realize is a bit ambigous with the mathematical "window", but it works for me when I need to conceptualize things in my head. The window is made up
// of two halves. The first half contains past input samples (initialized to zero), and the second half contains future input samples. As time moves forward
// and input samples are consumed, the window moves forward. The larger the window, the better the quality at the expense of slower processing. The window is
// limited the range [MAL_SRC_SINC_MIN_WINDOW_WIDTH, MAL_SRC_SINC_MAX_WINDOW_WIDTH] and defaults to MAL_SRC_SINC_DEFAULT_WINDOW_WIDTH.
//
// Input samples are cached for efficiency (to prevent frequently requesting tiny numbers of samples from the client). When the window gets to the end of the
// cache, it's moved back to the start, and more samples are read from the client. If the client has no more data to give, the cache is filled with zeros and
// the last of the input samples will be consumed. Once the last of the input samples have been consumed, no more samples will be output.
//
//
// When reading output samples, we always first read whatever is already in the input cache. Only when the cache has been fully consumed do we read more data
// from the client.
//
// To access samples in the input buffer you do so relative to the window. When the window itself is at position 0, the first item in the buffer is accessed
// with "windowPos + windowWidth". Generally, to access any sample relative to the window you do "windowPos + windowWidth + sampleIndexRelativeToWindow".
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Comment this to disable interpolation of table lookups. Less accurate, but faster.
#define MAL_USE_SINC_TABLE_INTERPOLATION

// Retrieves a sample from the input buffer's window. Values >= 0 retrieve future samples. Negative values return past samples.
static MAL_INLINE float mal_src_sinc__get_input_sample_from_window(const mal_src* pSRC, mal_uint32 channel, mal_uint32 windowPosInSamples, mal_int32 sampleIndex)
{
    mal_assert(pSRC != NULL);
    mal_assert(channel < pSRC->config.channels);
    mal_assert(sampleIndex >= -(mal_int32)pSRC->config.sinc.windowWidth);
    mal_assert(sampleIndex <   (mal_int32)pSRC->config.sinc.windowWidth);

    // The window should always be contained within the input cache.
    mal_assert(windowPosInSamples <  mal_countof(pSRC->sinc.input[0]) - pSRC->config.sinc.windowWidth);
    
    return pSRC->sinc.input[channel][windowPosInSamples + pSRC->config.sinc.windowWidth + sampleIndex];
}

static MAL_INLINE float mal_src_sinc__interpolation_factor(const mal_src* pSRC, float x)
{
    mal_assert(pSRC != NULL);

    float xabs = (float)fabs(x);
    //if (xabs >= MAL_SRC_SINC_MAX_WINDOW_WIDTH /*pSRC->config.sinc.windowWidth*/) {
    //    xabs = 1;   // <-- A non-zero integer will always return 0.
    //}

    xabs = xabs * MAL_SRC_SINC_LOOKUP_TABLE_RESOLUTION;
    mal_int32 ixabs = (mal_int32)xabs;

#if defined(MAL_USE_SINC_TABLE_INTERPOLATION)
    float a = xabs - ixabs;
    return mal_mix_f32_fast(pSRC->sinc.table[ixabs], pSRC->sinc.table[ixabs+1], a);
#else
    return pSRC->sinc.table[ixabs];
#endif
}

#if defined(MAL_SUPPORT_SSE2)
static MAL_INLINE __m128 mal_fabsf_sse2(__m128 x)
{
    return _mm_and_ps(_mm_castsi128_ps(_mm_set1_epi32(0x7FFFFFFF)), x);
}

static MAL_INLINE __m128 mal_truncf_sse2(__m128 x)
{
    return _mm_cvtepi32_ps(_mm_cvttps_epi32(x));
}

static MAL_INLINE __m128 mal_src_sinc__interpolation_factor__sse2(const mal_src* pSRC, __m128 x)
{
    //__m128 windowWidth128 = _mm_set1_ps(MAL_SRC_SINC_MAX_WINDOW_WIDTH);
    __m128 resolution128  = _mm_set1_ps(MAL_SRC_SINC_LOOKUP_TABLE_RESOLUTION);
    //__m128 one            = _mm_set1_ps(1);

    __m128 xabs = mal_fabsf_sse2(x);

    // if (MAL_SRC_SINC_MAX_WINDOW_WIDTH <= xabs) xabs = 1 else xabs = xabs;
    //__m128 xcmp = _mm_cmp_ps(windowWidth128, xabs, 2);                      // 2 = Less than or equal = _mm_cmple_ps.
    //xabs = _mm_or_ps(_mm_and_ps(one, xcmp), _mm_andnot_ps(xcmp, xabs));     // xabs = (xcmp) ? 1 : xabs;

    xabs = _mm_mul_ps(xabs, resolution128);
    __m128i ixabs = _mm_cvttps_epi32(xabs);

    int* ixabsv = (int*)&ixabs;
    
    __m128 lo = _mm_set_ps(
        pSRC->sinc.table[ixabsv[3]],
        pSRC->sinc.table[ixabsv[2]],
        pSRC->sinc.table[ixabsv[1]],
        pSRC->sinc.table[ixabsv[0]]
    );

    __m128 hi = _mm_set_ps(
        pSRC->sinc.table[ixabsv[3]+1],
        pSRC->sinc.table[ixabsv[2]+1],
        pSRC->sinc.table[ixabsv[1]+1],
        pSRC->sinc.table[ixabsv[0]+1]
    );

    __m128 a = _mm_sub_ps(xabs, _mm_cvtepi32_ps(ixabs));
    __m128 r = mal_mix_f32_fast__sse2(lo, hi, a);

    return r;
}
#endif

#if defined(MAL_SUPPORT_AVX2)
static MAL_INLINE __m256 mal_fabsf_avx2(__m256 x)
{
    return _mm256_and_ps(_mm256_castsi256_ps(_mm256_set1_epi32(0x7FFFFFFF)), x);
}

#if 0
static MAL_INLINE __m256 mal_src_sinc__interpolation_factor__avx2(const mal_src* pSRC, __m256 x)
{
    //__m256 windowWidth256 = _mm256_set1_ps(MAL_SRC_SINC_MAX_WINDOW_WIDTH);
    __m256 resolution256  = _mm256_set1_ps(MAL_SRC_SINC_LOOKUP_TABLE_RESOLUTION);
    //__m256 one            = _mm256_set1_ps(1);

    __m256 xabs = mal_fabsf_avx2(x);

    // if (MAL_SRC_SINC_MAX_WINDOW_WIDTH <= xabs) xabs = 1 else xabs = xabs;
    //__m256 xcmp = _mm256_cmp_ps(windowWidth256, xabs, 2);                      // 2 = Less than or equal = _mm_cmple_ps.
    //xabs = _mm256_or_ps(_mm256_and_ps(one, xcmp), _mm256_andnot_ps(xcmp, xabs));     // xabs = (xcmp) ? 1 : xabs;

    xabs = _mm256_mul_ps(xabs, resolution256);

    __m256i ixabs = _mm256_cvttps_epi32(xabs);
    __m256 a = _mm256_sub_ps(xabs, _mm256_cvtepi32_ps(ixabs));

    
    int* ixabsv = (int*)&ixabs;

    __m256 lo = _mm256_set_ps(
        pSRC->sinc.table[ixabsv[7]],
        pSRC->sinc.table[ixabsv[6]],
        pSRC->sinc.table[ixabsv[5]],
        pSRC->sinc.table[ixabsv[4]],
        pSRC->sinc.table[ixabsv[3]],
        pSRC->sinc.table[ixabsv[2]],
        pSRC->sinc.table[ixabsv[1]],
        pSRC->sinc.table[ixabsv[0]]
    );
    
    __m256 hi = _mm256_set_ps(
        pSRC->sinc.table[ixabsv[7]+1],
        pSRC->sinc.table[ixabsv[6]+1],
        pSRC->sinc.table[ixabsv[5]+1],
        pSRC->sinc.table[ixabsv[4]+1],
        pSRC->sinc.table[ixabsv[3]+1],
        pSRC->sinc.table[ixabsv[2]+1],
        pSRC->sinc.table[ixabsv[1]+1],
        pSRC->sinc.table[ixabsv[0]+1]
    );

    __m256 r = mal_mix_f32_fast__avx2(lo, hi, a);

    return r;
}
#endif

#endif

#if defined(MAL_SUPPORT_NEON)
static MAL_INLINE float32x4_t mal_fabsf_neon(float32x4_t x)
{
    return vabdq_f32(vmovq_n_f32(0), x);
}

static MAL_INLINE float32x4_t mal_src_sinc__interpolation_factor__neon(const mal_src* pSRC, float32x4_t x)
{
    float32x4_t xabs = mal_fabsf_neon(x);
    xabs = vmulq_n_f32(xabs, MAL_SRC_SINC_LOOKUP_TABLE_RESOLUTION);

    int32x4_t ixabs = vcvtq_s32_f32(xabs);

    int* ixabsv = (int*)&ixabs;
    
    float lo[4];
    lo[0] = pSRC->sinc.table[ixabsv[0]];
    lo[1] = pSRC->sinc.table[ixabsv[1]];
    lo[2] = pSRC->sinc.table[ixabsv[2]];
    lo[3] = pSRC->sinc.table[ixabsv[3]];

    float hi[4];
    hi[0] = pSRC->sinc.table[ixabsv[0]+1];
    hi[1] = pSRC->sinc.table[ixabsv[1]+1];
    hi[2] = pSRC->sinc.table[ixabsv[2]+1];
    hi[3] = pSRC->sinc.table[ixabsv[3]+1];

    float32x4_t a = vsubq_f32(xabs, vcvtq_f32_s32(ixabs));
    float32x4_t r = mal_mix_f32_fast__neon(vld1q_f32(lo), vld1q_f32(hi), a);

    return r;
}
#endif

mal_uint64 mal_src_read_deinterleaved__sinc(mal_src* pSRC, mal_uint64 frameCount, void** ppSamplesOut, void* pUserData)
{
    mal_assert(pSRC != NULL);
    mal_assert(frameCount > 0);
    mal_assert(ppSamplesOut != NULL);

    float factor = (float)pSRC->config.sampleRateIn / pSRC->config.sampleRateOut;
    float inverseFactor = 1/factor;

    mal_int32 windowWidth  = (mal_int32)pSRC->config.sinc.windowWidth;
    mal_int32 windowWidth2 = windowWidth*2;

    // There are cases where it's actually more efficient to increase the window width so that it's aligned with the respective
    // SIMD pipeline being used.
    mal_int32 windowWidthSIMD = windowWidth;
    if (pSRC->useNEON) {
        windowWidthSIMD = (windowWidthSIMD + 1) & ~(1);
    } else  if (pSRC->useAVX512) {
        windowWidthSIMD = (windowWidthSIMD + 7) & ~(7);
    } else if (pSRC->useAVX2) {
        windowWidthSIMD = (windowWidthSIMD + 3) & ~(3);
    } else if (pSRC->useSSE2) {
        windowWidthSIMD = (windowWidthSIMD + 1) & ~(1);
    }

    mal_int32 windowWidthSIMD2 = windowWidthSIMD*2;
    (void)windowWidthSIMD2; // <-- Silence a warning when SIMD is disabled.

    float* ppNextSamplesOut[MAL_MAX_CHANNELS];
    mal_copy_memory(ppNextSamplesOut, ppSamplesOut, sizeof(void*) * pSRC->config.channels);

    float _windowSamplesUnaligned[MAL_SRC_SINC_MAX_WINDOW_WIDTH*2 + MAL_SIMD_ALIGNMENT];
    float* windowSamples = (float*)(((mal_uintptr)_windowSamplesUnaligned + MAL_SIMD_ALIGNMENT-1) & ~(MAL_SIMD_ALIGNMENT-1));
    mal_zero_memory(windowSamples, MAL_SRC_SINC_MAX_WINDOW_WIDTH*2 * sizeof(float));

    float _iWindowFUnaligned[MAL_SRC_SINC_MAX_WINDOW_WIDTH*2 + MAL_SIMD_ALIGNMENT];
    float* iWindowF = (float*)(((mal_uintptr)_iWindowFUnaligned + MAL_SIMD_ALIGNMENT-1) & ~(MAL_SIMD_ALIGNMENT-1));
    mal_zero_memory(iWindowF, MAL_SRC_SINC_MAX_WINDOW_WIDTH*2 * sizeof(float));
    for (mal_int32 i = 0; i < windowWidth2; ++i) {
        iWindowF[i] = (float)(i - windowWidth);
    }

    mal_uint64 totalOutputFramesRead = 0;
    while (totalOutputFramesRead < frameCount) {
        // The maximum number of frames we can read this iteration depends on how many input samples we have available to us. This is the number
        // of input samples between the end of the window and the end of the cache.
        mal_uint32 maxInputSamplesAvailableInCache = mal_countof(pSRC->sinc.input[0]) - (pSRC->config.sinc.windowWidth*2) - pSRC->sinc.windowPosInSamples;
        if (maxInputSamplesAvailableInCache > pSRC->sinc.inputFrameCount) {
            maxInputSamplesAvailableInCache = pSRC->sinc.inputFrameCount;
        }

        // Never consume the tail end of the input data if requested.
        if (pSRC->config.neverConsumeEndOfInput) {
            if (maxInputSamplesAvailableInCache >= pSRC->config.sinc.windowWidth) {
                maxInputSamplesAvailableInCache -= pSRC->config.sinc.windowWidth;
            } else {
                maxInputSamplesAvailableInCache  = 0;
            }
        }

        float timeInBeg = pSRC->sinc.timeIn;
        float timeInEnd = (float)(pSRC->sinc.windowPosInSamples + maxInputSamplesAvailableInCache);

        mal_assert(timeInBeg >= 0);
        mal_assert(timeInBeg <= timeInEnd);

        mal_uint64 maxOutputFramesToRead = (mal_uint64)(((timeInEnd - timeInBeg) * inverseFactor));

        mal_uint64 outputFramesRemaining = frameCount - totalOutputFramesRead;
        mal_uint64 outputFramesToRead = outputFramesRemaining;
        if (outputFramesToRead > maxOutputFramesToRead) {
            outputFramesToRead = maxOutputFramesToRead;
        }

        for (mal_uint32 iChannel = 0; iChannel < pSRC->config.channels; iChannel += 1) {
            // Do SRC.
            float timeIn = timeInBeg;
            for (mal_uint32 iSample = 0; iSample < outputFramesToRead; iSample += 1) {
                float sampleOut    = 0;
                float iTimeInF     = mal_floorf(timeIn);
                mal_uint32 iTimeIn = (mal_uint32)iTimeInF;

                mal_int32 iWindow = 0;

                // Pre-load the window samples into an aligned buffer to begin with. Need to put these into an aligned buffer to make SIMD easier.
                windowSamples[0] = 0;   // <-- The first sample is always zero.
                for (mal_int32 i = 1; i < windowWidth2; ++i) {
                    windowSamples[i] = pSRC->sinc.input[iChannel][iTimeIn + i];
                }

#if defined(MAL_SUPPORT_AVX2) || defined(MAL_SUPPORT_AVX512)
                if (pSRC->useAVX2 || pSRC->useAVX512) {
                    __m256i ixabs[MAL_SRC_SINC_MAX_WINDOW_WIDTH*2/8];
                    __m256      a[MAL_SRC_SINC_MAX_WINDOW_WIDTH*2/8];
                    __m256 resolution256 = _mm256_set1_ps(MAL_SRC_SINC_LOOKUP_TABLE_RESOLUTION);

                    __m256 t = _mm256_set1_ps((timeIn - iTimeInF));
                    __m256 r = _mm256_set1_ps(0);

                    mal_int32 windowWidth8 = windowWidthSIMD2 >> 3;
                    for (mal_int32 iWindow8 = 0; iWindow8 < windowWidth8; iWindow8 += 1) {
                        __m256 w = *((__m256*)iWindowF + iWindow8);

                        __m256 xabs = _mm256_sub_ps(t, w);
                        xabs = mal_fabsf_avx2(xabs);
                        xabs = _mm256_mul_ps(xabs, resolution256);

                        ixabs[iWindow8] = _mm256_cvttps_epi32(xabs);
                            a[iWindow8] = _mm256_sub_ps(xabs, _mm256_cvtepi32_ps(ixabs[iWindow8]));
                    }
                    
                    for (mal_int32 iWindow8 = 0; iWindow8 < windowWidth8; iWindow8 += 1) {
                        int* ixabsv = (int*)&ixabs[iWindow8];

                        __m256 lo = _mm256_set_ps(
                            pSRC->sinc.table[ixabsv[7]],
                            pSRC->sinc.table[ixabsv[6]],
                            pSRC->sinc.table[ixabsv[5]],
                            pSRC->sinc.table[ixabsv[4]],
                            pSRC->sinc.table[ixabsv[3]],
                            pSRC->sinc.table[ixabsv[2]],
                            pSRC->sinc.table[ixabsv[1]],
                            pSRC->sinc.table[ixabsv[0]]
                        );
    
                        __m256 hi = _mm256_set_ps(
                            pSRC->sinc.table[ixabsv[7]+1],
                            pSRC->sinc.table[ixabsv[6]+1],
                            pSRC->sinc.table[ixabsv[5]+1],
                            pSRC->sinc.table[ixabsv[4]+1],
                            pSRC->sinc.table[ixabsv[3]+1],
                            pSRC->sinc.table[ixabsv[2]+1],
                            pSRC->sinc.table[ixabsv[1]+1],
                            pSRC->sinc.table[ixabsv[0]+1]
                        );

                        __m256 s = *((__m256*)windowSamples + iWindow8);
                        r = _mm256_add_ps(r, _mm256_mul_ps(s, mal_mix_f32_fast__avx2(lo, hi, a[iWindow8])));
                    }

                    // Horizontal add.
                    __m256 x = _mm256_hadd_ps(r, _mm256_permute2f128_ps(r, r, 1));
                           x = _mm256_hadd_ps(x, x);
                           x = _mm256_hadd_ps(x, x);
                    sampleOut += _mm_cvtss_f32(_mm256_castps256_ps128(x));

                    iWindow += windowWidth8 * 8;
                }
                else
#endif
#if defined(MAL_SUPPORT_SSE2)
                if (pSRC->useSSE2) {
                    __m128 t = _mm_set1_ps((timeIn - iTimeInF));
                    __m128 r = _mm_set1_ps(0);

                    mal_int32 windowWidth4 = windowWidthSIMD2 >> 2;
                    for (mal_int32 iWindow4 = 0; iWindow4 < windowWidth4; iWindow4 += 1) {
                        __m128* s = (__m128*)windowSamples + iWindow4;
                        __m128* w = (__m128*)iWindowF + iWindow4;

                        __m128 a = mal_src_sinc__interpolation_factor__sse2(pSRC, _mm_sub_ps(t, *w));
                        r = _mm_add_ps(r, _mm_mul_ps(*s, a));
                    }

                    sampleOut += ((float*)(&r))[0];
                    sampleOut += ((float*)(&r))[1];
                    sampleOut += ((float*)(&r))[2];
                    sampleOut += ((float*)(&r))[3];

                    iWindow += windowWidth4 * 4;
                }
                else
#endif
#if defined(MAL_SUPPORT_NEON)
                if (pSRC->useNEON) {
                    float32x4_t t = vmovq_n_f32((timeIn - iTimeInF));
                    float32x4_t r = vmovq_n_f32(0);

                    mal_int32 windowWidth4 = windowWidthSIMD2 >> 2;
                    for (mal_int32 iWindow4 = 0; iWindow4 < windowWidth4; iWindow4 += 1) {
                        float32x4_t* s = (float32x4_t*)windowSamples + iWindow4;
                        float32x4_t* w = (float32x4_t*)iWindowF + iWindow4;

                        float32x4_t a = mal_src_sinc__interpolation_factor__neon(pSRC, vsubq_f32(t, *w));
                        r = vaddq_f32(r, vmulq_f32(*s, a));
                    }

                    sampleOut += ((float*)(&r))[0];
                    sampleOut += ((float*)(&r))[1];
                    sampleOut += ((float*)(&r))[2];
                    sampleOut += ((float*)(&r))[3];

                    iWindow += windowWidth4 * 4;
                }
                else
#endif
                {
                    iWindow += 1;   // The first one is a dummy for SIMD alignment purposes. Skip it.
                }

                // Non-SIMD/Reference implementation. 
                float t = (timeIn - iTimeIn);
                for (; iWindow < windowWidth2; iWindow += 1) {
                    float s = windowSamples[iWindow];
                    float w = iWindowF[iWindow];

                    float a = mal_src_sinc__interpolation_factor(pSRC, (t - w));
                    float r = s * a;

                    sampleOut += r;
                }

                ppNextSamplesOut[iChannel][iSample] = (float)sampleOut;

                timeIn += factor;
            }

            ppNextSamplesOut[iChannel] += outputFramesToRead;
        }

        totalOutputFramesRead += outputFramesToRead;

        mal_uint32 prevWindowPosInSamples = pSRC->sinc.windowPosInSamples;

        pSRC->sinc.timeIn            += (outputFramesToRead * factor);
        pSRC->sinc.windowPosInSamples = (mal_uint32)pSRC->sinc.timeIn;
        pSRC->sinc.inputFrameCount   -= pSRC->sinc.windowPosInSamples - prevWindowPosInSamples;

        // If the window has reached a point where we cannot read a whole output sample it needs to be moved back to the start.
        mal_uint32 availableOutputFrames = (mal_uint32)((timeInEnd - pSRC->sinc.timeIn) * inverseFactor);

        if (availableOutputFrames == 0) {
            size_t samplesToMove = mal_countof(pSRC->sinc.input[0]) - pSRC->sinc.windowPosInSamples;

            pSRC->sinc.timeIn            -= mal_floorf(pSRC->sinc.timeIn);
            pSRC->sinc.windowPosInSamples = 0;

            // Move everything from the end of the cache up to the front.
            for (mal_uint32 iChannel = 0; iChannel < pSRC->config.channels; iChannel += 1) {
                memmove(pSRC->sinc.input[iChannel], pSRC->sinc.input[iChannel] + mal_countof(pSRC->sinc.input[iChannel]) - samplesToMove, samplesToMove * sizeof(*pSRC->sinc.input[iChannel]));
            }
        }

        // Read more data from the client if required.
        if (pSRC->isEndOfInputLoaded) {
            pSRC->isEndOfInputLoaded = MAL_FALSE;
            break;
        }

        // Everything beyond this point is reloading. If we're at the end of the input data we do _not_ want to try reading any more in this function call. If the
        // caller wants to keep trying, they can reload their internal data sources and call this function again. We should never be 
        mal_assert(pSRC->isEndOfInputLoaded == MAL_FALSE);

        if (pSRC->sinc.inputFrameCount <= pSRC->config.sinc.windowWidth || availableOutputFrames == 0) {
            float* ppInputDst[MAL_MAX_CHANNELS] = {0};
            for (mal_uint32 iChannel = 0; iChannel < pSRC->config.channels; iChannel += 1) {
                ppInputDst[iChannel] = pSRC->sinc.input[iChannel] + pSRC->config.sinc.windowWidth + pSRC->sinc.inputFrameCount;
            }

            // Now read data from the client.
            mal_uint32 framesToReadFromClient = mal_countof(pSRC->sinc.input[0]) - (pSRC->config.sinc.windowWidth + pSRC->sinc.inputFrameCount);

            mal_uint32 framesReadFromClient = 0;
            if (framesToReadFromClient > 0) {
                framesReadFromClient = pSRC->config.onReadDeinterleaved(pSRC, framesToReadFromClient, (void**)ppInputDst, pUserData);
            }

            if (framesReadFromClient != framesToReadFromClient) {
                pSRC->isEndOfInputLoaded = MAL_TRUE;
            } else {
                pSRC->isEndOfInputLoaded = MAL_FALSE;
            }

            if (framesReadFromClient != 0) {
                pSRC->sinc.inputFrameCount += framesReadFromClient;
            } else {
                // We couldn't get anything more from the client. If no more output samples can be computed from the available input samples
                // we need to return.
                if (pSRC->config.neverConsumeEndOfInput) {
                    if ((pSRC->sinc.inputFrameCount * inverseFactor) <= pSRC->config.sinc.windowWidth) {
                        break;
                    }
                } else {
                    if ((pSRC->sinc.inputFrameCount * inverseFactor) < 1) {
                        break;
                    }
                }
            }

            // Anything left over in the cache must be set to zero.
            mal_uint32 leftoverFrames = mal_countof(pSRC->sinc.input[0]) - (pSRC->config.sinc.windowWidth + pSRC->sinc.inputFrameCount);
            if (leftoverFrames > 0) {
                for (mal_uint32 iChannel = 0; iChannel < pSRC->config.channels; iChannel += 1) {
                    mal_zero_memory(pSRC->sinc.input[iChannel] + pSRC->config.sinc.windowWidth + pSRC->sinc.inputFrameCount, leftoverFrames * sizeof(float));
                }
            }
        }
    }

    return totalOutputFramesRead;
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// FORMAT CONVERSION
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void mal_pcm_convert(void* pOut, mal_format formatOut, const void* pIn, mal_format formatIn, mal_uint64 sampleCount, mal_dither_mode ditherMode)
{
    if (formatOut == formatIn) {
        mal_copy_memory_64(pOut, pIn, sampleCount * mal_get_bytes_per_sample(formatOut));
        return;
    }

    switch (formatIn)
    {
        case mal_format_u8:
        {
            switch (formatOut)
            {
                case mal_format_s16: mal_pcm_u8_to_s16(pOut, pIn, sampleCount, ditherMode); return;
                case mal_format_s24: mal_pcm_u8_to_s24(pOut, pIn, sampleCount, ditherMode); return;
                case mal_format_s32: mal_pcm_u8_to_s32(pOut, pIn, sampleCount, ditherMode); return;
                case mal_format_f32: mal_pcm_u8_to_f32(pOut, pIn, sampleCount, ditherMode); return;
                default: break;
            }
        } break;

        case mal_format_s16:
        {
            switch (formatOut)
            {
                case mal_format_u8:  mal_pcm_s16_to_u8( pOut, pIn, sampleCount, ditherMode); return;
                case mal_format_s24: mal_pcm_s16_to_s24(pOut, pIn, sampleCount, ditherMode); return;
                case mal_format_s32: mal_pcm_s16_to_s32(pOut, pIn, sampleCount, ditherMode); return;
                case mal_format_f32: mal_pcm_s16_to_f32(pOut, pIn, sampleCount, ditherMode); return;
                default: break;
            }
        } break;

        case mal_format_s24:
        {
            switch (formatOut)
            {
                case mal_format_u8:  mal_pcm_s24_to_u8( pOut, pIn, sampleCount, ditherMode); return;
                case mal_format_s16: mal_pcm_s24_to_s16(pOut, pIn, sampleCount, ditherMode); return;
                case mal_format_s32: mal_pcm_s24_to_s32(pOut, pIn, sampleCount, ditherMode); return;
                case mal_format_f32: mal_pcm_s24_to_f32(pOut, pIn, sampleCount, ditherMode); return;
                default: break;
            }
        } break;

        case mal_format_s32:
        {
            switch (formatOut)
            {
                case mal_format_u8:  mal_pcm_s32_to_u8( pOut, pIn, sampleCount, ditherMode); return;
                case mal_format_s16: mal_pcm_s32_to_s16(pOut, pIn, sampleCount, ditherMode); return;
                case mal_format_s24: mal_pcm_s32_to_s24(pOut, pIn, sampleCount, ditherMode); return;
                case mal_format_f32: mal_pcm_s32_to_f32(pOut, pIn, sampleCount, ditherMode); return;
                default: break;
            }
        } break;

        case mal_format_f32:
        {
            switch (formatOut)
            {
                case mal_format_u8:  mal_pcm_f32_to_u8( pOut, pIn, sampleCount, ditherMode); return;
                case mal_format_s16: mal_pcm_f32_to_s16(pOut, pIn, sampleCount, ditherMode); return;
                case mal_format_s24: mal_pcm_f32_to_s24(pOut, pIn, sampleCount, ditherMode); return;
                case mal_format_s32: mal_pcm_f32_to_s32(pOut, pIn, sampleCount, ditherMode); return;
                default: break;
            }
        } break;

        default: break;
    }
}

void mal_deinterleave_pcm_frames(mal_format format, mal_uint32 channels, mal_uint64 frameCount, const void* pInterleavedPCMFrames, void** ppDeinterleavedPCMFrames)
{
    if (pInterleavedPCMFrames == NULL || ppDeinterleavedPCMFrames == NULL) {
        return; // Invalid args.
    }

    // For efficiency we do this per format.
    switch (format) {
        case mal_format_s16:
        {
            const mal_int16* pSrcS16 = (const mal_int16*)pInterleavedPCMFrames;
            for (mal_uint64 iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
                for (mal_uint32 iChannel = 0; iChannel < channels; ++iChannel) {
                    mal_int16* pDstS16 = (mal_int16*)ppDeinterleavedPCMFrames[iChannel];
                    pDstS16[iPCMFrame] = pSrcS16[iPCMFrame*channels+iChannel];
                }
            }
        } break;
        
        case mal_format_f32:
        {
            const float* pSrcF32 = (const float*)pInterleavedPCMFrames;
            for (mal_uint64 iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
                for (mal_uint32 iChannel = 0; iChannel < channels; ++iChannel) {
                    float* pDstF32 = (float*)ppDeinterleavedPCMFrames[iChannel];
                    pDstF32[iPCMFrame] = pSrcF32[iPCMFrame*channels+iChannel];
                }
            }
        } break;
        
        default:
        {
            mal_uint32 sampleSizeInBytes = mal_get_bytes_per_sample(format);

            for (mal_uint64 iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
                for (mal_uint32 iChannel = 0; iChannel < channels; ++iChannel) {
                          void* pDst = mal_offset_ptr(ppDeinterleavedPCMFrames[iChannel], iPCMFrame*sampleSizeInBytes);
                    const void* pSrc = mal_offset_ptr(pInterleavedPCMFrames, (iPCMFrame*channels+iChannel)*sampleSizeInBytes);
                    memcpy(pDst, pSrc, sampleSizeInBytes);
                }
            }
        } break;
    }
}

void mal_interleave_pcm_frames(mal_format format, mal_uint32 channels, mal_uint64 frameCount, const void** ppDeinterleavedPCMFrames, void* pInterleavedPCMFrames)
{
    switch (format)
    {
        case mal_format_s16:
        {
            mal_int16* pDstS16 = (mal_int16*)pInterleavedPCMFrames;
            for (mal_uint64 iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
                for (mal_uint32 iChannel = 0; iChannel < channels; ++iChannel) {
                    const mal_int16* pSrcS16 = (const mal_int16*)ppDeinterleavedPCMFrames[iChannel];
                    pDstS16[iPCMFrame*channels+iChannel] = pSrcS16[iPCMFrame];
                }
            }
        } break;
        
        case mal_format_f32:
        {
            float* pDstF32 = (float*)pInterleavedPCMFrames;
            for (mal_uint64 iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
                for (mal_uint32 iChannel = 0; iChannel < channels; ++iChannel) {
                    const float* pSrcF32 = (const float*)ppDeinterleavedPCMFrames[iChannel];
                    pDstF32[iPCMFrame*channels+iChannel] = pSrcF32[iPCMFrame];
                }
            }
        } break;
    
        default:
        {
            mal_uint32 sampleSizeInBytes = mal_get_bytes_per_sample(format);

            for (mal_uint64 iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
                for (mal_uint32 iChannel = 0; iChannel < channels; ++iChannel) {
                          void* pDst = mal_offset_ptr(pInterleavedPCMFrames, (iPCMFrame*channels+iChannel)*sampleSizeInBytes);
                    const void* pSrc = mal_offset_ptr(ppDeinterleavedPCMFrames[iChannel], iPCMFrame*sampleSizeInBytes);
                    memcpy(pDst, pSrc, sampleSizeInBytes);
                }
            }
        } break;
    }
}



typedef struct
{
    mal_pcm_converter* pDSP;
    void* pUserDataForClient;
} mal_pcm_converter_callback_data;

mal_uint32 mal_pcm_converter__pre_format_converter_on_read(mal_format_converter* pConverter, mal_uint32 frameCount, void* pFramesOut, void* pUserData)
{
    (void)pConverter;

    mal_pcm_converter_callback_data* pData = (mal_pcm_converter_callback_data*)pUserData;
    mal_assert(pData != NULL);

    mal_pcm_converter* pDSP = pData->pDSP;
    mal_assert(pDSP != NULL);

    return pDSP->onRead(pDSP, pFramesOut, frameCount, pData->pUserDataForClient);
}

mal_uint32 mal_pcm_converter__post_format_converter_on_read(mal_format_converter* pConverter, mal_uint32 frameCount, void* pFramesOut, void* pUserData)
{
    (void)pConverter;

    mal_pcm_converter_callback_data* pData = (mal_pcm_converter_callback_data*)pUserData;
    mal_assert(pData != NULL);

    mal_pcm_converter* pDSP = pData->pDSP;
    mal_assert(pDSP != NULL);

    // When this version of this callback is used it means we're reading directly from the client.
    mal_assert(pDSP->isPreFormatConversionRequired == MAL_FALSE);
    mal_assert(pDSP->isChannelRoutingRequired == MAL_FALSE);
    mal_assert(pDSP->isSRCRequired == MAL_FALSE);

    return pDSP->onRead(pDSP, pFramesOut, frameCount, pData->pUserDataForClient);
}

mal_uint32 mal_pcm_converter__post_format_converter_on_read_deinterleaved(mal_format_converter* pConverter, mal_uint32 frameCount, void** ppSamplesOut, void* pUserData)
{
    (void)pConverter;

    mal_pcm_converter_callback_data* pData = (mal_pcm_converter_callback_data*)pUserData;
    mal_assert(pData != NULL);

    mal_pcm_converter* pDSP = pData->pDSP;
    mal_assert(pDSP != NULL);

    if (!pDSP->isChannelRoutingAtStart) {
        return (mal_uint32)mal_channel_router_read_deinterleaved(&pDSP->channelRouter, frameCount, ppSamplesOut, pUserData);
    } else {
        if (pDSP->isSRCRequired) {
            return (mal_uint32)mal_src_read_deinterleaved(&pDSP->src, frameCount, ppSamplesOut, pUserData);
        } else {
            return (mal_uint32)mal_channel_router_read_deinterleaved(&pDSP->channelRouter, frameCount, ppSamplesOut, pUserData);
        }
    }
}

mal_uint32 mal_pcm_converter__src_on_read_deinterleaved(mal_src* pSRC, mal_uint32 frameCount, void** ppSamplesOut, void* pUserData)
{
    (void)pSRC;

    mal_pcm_converter_callback_data* pData = (mal_pcm_converter_callback_data*)pUserData;
    mal_assert(pData != NULL);

    mal_pcm_converter* pDSP = pData->pDSP;
    mal_assert(pDSP != NULL);

    // If the channel routing stage is at the front we need to read from that. Otherwise we read from the pre format converter.
    if (pDSP->isChannelRoutingAtStart) {
        return (mal_uint32)mal_channel_router_read_deinterleaved(&pDSP->channelRouter, frameCount, ppSamplesOut, pUserData);
    } else {
        return (mal_uint32)mal_format_converter_read_deinterleaved(&pDSP->formatConverterIn, frameCount, ppSamplesOut, pUserData);
    }
}

mal_uint32 mal_pcm_converter__channel_router_on_read_deinterleaved(mal_channel_router* pRouter, mal_uint32 frameCount, void** ppSamplesOut, void* pUserData)
{
    (void)pRouter;

    mal_pcm_converter_callback_data* pData = (mal_pcm_converter_callback_data*)pUserData;
    mal_assert(pData != NULL);

    mal_pcm_converter* pDSP = pData->pDSP;
    mal_assert(pDSP != NULL);

    // If the channel routing stage is at the front of the pipeline we read from the pre format converter. Otherwise we read from the sample rate converter.
    if (pDSP->isChannelRoutingAtStart) {
        return (mal_uint32)mal_format_converter_read_deinterleaved(&pDSP->formatConverterIn, frameCount, ppSamplesOut, pUserData);
    } else {
        if (pDSP->isSRCRequired) {
            return (mal_uint32)mal_src_read_deinterleaved(&pDSP->src, frameCount, ppSamplesOut, pUserData);
        } else {
            return (mal_uint32)mal_format_converter_read_deinterleaved(&pDSP->formatConverterIn, frameCount, ppSamplesOut, pUserData);
        }
    }
}

mal_result mal_pcm_converter_init(const mal_pcm_converter_config* pConfig, mal_pcm_converter* pDSP)
{
    if (pDSP == NULL) {
        return MAL_INVALID_ARGS;
    }

    mal_zero_object(pDSP);
    pDSP->onRead = pConfig->onRead;
    pDSP->pUserData = pConfig->pUserData;
    pDSP->isDynamicSampleRateAllowed = pConfig->allowDynamicSampleRate;


    // In general, this is the pipeline used for data conversion. Note that this can actually change which is explained later.
    //
    //   Pre Format Conversion -> Sample Rate Conversion -> Channel Routing -> Post Format Conversion
    //
    // Pre Format Conversion
    // ---------------------
    // This is where the sample data is converted to a format that's usable by the later stages in the pipeline. Input data
    // is converted to deinterleaved floating-point.
    //
    // Channel Routing
    // ---------------
    // Channel routing is where stereo is converted to 5.1, mono is converted to stereo, etc. This stage depends on the
    // pre format conversion stage.
    //
    // Sample Rate Conversion
    // ----------------------
    // Sample rate conversion depends on the pre format conversion stage and as the name implies performs sample rate conversion.
    //
    // Post Format Conversion
    // ----------------------
    // This stage is where our deinterleaved floating-point data from the previous stages are converted to the requested output
    // format.
    //
    //
    // Optimizations
    // -------------
    // Sometimes the conversion pipeline is rearranged for efficiency. The first obvious optimization is to eliminate unnecessary
    // stages in the pipeline. When no channel routing nor sample rate conversion is necessary, the entire pipeline is optimized
    // down to just this:
    //
    //   Post Format Conversion
    //
    // When sample rate conversion is not unnecessary:
    //
    //   Pre Format Conversion -> Channel Routing -> Post Format Conversion
    //
    // When channel routing is unnecessary:
    //
    //   Pre Format Conversion -> Sample Rate Conversion -> Post Format Conversion
    //
    // A slightly less obvious optimization is used depending on whether or not we are increasing or decreasing the number of
    // channels. Because everything in the pipeline works on a per-channel basis, the efficiency of the pipeline is directly
    // proportionate to the number of channels that need to be processed. Therefore, it's can be more efficient to move the
    // channel conversion stage to an earlier or later stage. When the channel count is being reduced, we move the channel
    // conversion stage to the start of the pipeline so that later stages can work on a smaller number of channels at a time.
    // Otherwise, we move the channel conversion stage to the end of the pipeline. When reducing the channel count, the pipeline
    // will look like this:
    //
    //   Pre Format Conversion -> Channel Routing -> Sample Rate Conversion -> Post Format Conversion
    //
    // Notice how the Channel Routing and Sample Rate Conversion stages are swapped so that the SRC stage has less data to process.

    // First we need to determine what's required and what's not.
    if (pConfig->sampleRateIn != pConfig->sampleRateOut || pConfig->allowDynamicSampleRate) {
        pDSP->isSRCRequired = MAL_TRUE;
    }
    if (pConfig->channelsIn != pConfig->channelsOut || !mal_channel_map_equal(pConfig->channelsIn, pConfig->channelMapIn, pConfig->channelMapOut)) {
        pDSP->isChannelRoutingRequired = MAL_TRUE;
    }

    // If neither a sample rate conversion nor channel conversion is necessary we can skip the pre format conversion.
    if (!pDSP->isSRCRequired && !pDSP->isChannelRoutingRequired) {
        // We don't need a pre format conversion stage, but we may still need a post format conversion stage.
        if (pConfig->formatIn != pConfig->formatOut) {
            pDSP->isPostFormatConversionRequired = MAL_TRUE;
        }
    } else {
        pDSP->isPreFormatConversionRequired  = MAL_TRUE;
        pDSP->isPostFormatConversionRequired = MAL_TRUE;
    }

    // Use a passthrough if none of the stages are being used.
    if (!pDSP->isPreFormatConversionRequired && !pDSP->isPostFormatConversionRequired && !pDSP->isChannelRoutingRequired && !pDSP->isSRCRequired) {
        pDSP->isPassthrough = MAL_TRUE;
    }

    // Move the channel conversion stage to the start of the pipeline if we are reducing the channel count.
    if (pConfig->channelsOut < pConfig->channelsIn) {
        pDSP->isChannelRoutingAtStart = MAL_TRUE;
    }


    // We always initialize every stage of the pipeline regardless of whether or not the stage is used because it simplifies
    // a few things when it comes to dynamically changing properties post-initialization.
    mal_result result = MAL_SUCCESS;

    // Pre format conversion.
    {
        mal_format_converter_config preFormatConverterConfig = mal_format_converter_config_init(
            pConfig->formatIn,
            mal_format_f32,
            pConfig->channelsIn,
            mal_pcm_converter__pre_format_converter_on_read,
            pDSP
        );
        preFormatConverterConfig.ditherMode = pConfig->ditherMode;
        preFormatConverterConfig.noSSE2     = pConfig->noSSE2;
        preFormatConverterConfig.noAVX2     = pConfig->noAVX2;
        preFormatConverterConfig.noAVX512   = pConfig->noAVX512;
        preFormatConverterConfig.noNEON     = pConfig->noNEON;

        result = mal_format_converter_init(&preFormatConverterConfig, &pDSP->formatConverterIn);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    // Post format conversion. The exact configuration for this depends on whether or not we are reading data directly from the client
    // or from an earlier stage in the pipeline.
    {
        mal_format_converter_config postFormatConverterConfig = mal_format_converter_config_init_new();
        postFormatConverterConfig.formatIn   = pConfig->formatIn;
        postFormatConverterConfig.formatOut  = pConfig->formatOut;
        postFormatConverterConfig.channels   = pConfig->channelsOut;
        postFormatConverterConfig.ditherMode = pConfig->ditherMode;
        postFormatConverterConfig.noSSE2     = pConfig->noSSE2;
        postFormatConverterConfig.noAVX2     = pConfig->noAVX2;
        postFormatConverterConfig.noAVX512   = pConfig->noAVX512;
        postFormatConverterConfig.noNEON     = pConfig->noNEON;
        if (pDSP->isPreFormatConversionRequired) {
            postFormatConverterConfig.onReadDeinterleaved = mal_pcm_converter__post_format_converter_on_read_deinterleaved;
            postFormatConverterConfig.formatIn = mal_format_f32;
        } else {
            postFormatConverterConfig.onRead = mal_pcm_converter__post_format_converter_on_read;
        }

        result = mal_format_converter_init(&postFormatConverterConfig, &pDSP->formatConverterOut);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    // SRC
    {
        mal_src_config srcConfig = mal_src_config_init(
            pConfig->sampleRateIn,
            pConfig->sampleRateOut,
            ((pConfig->channelsIn < pConfig->channelsOut) ? pConfig->channelsIn : pConfig->channelsOut),
            mal_pcm_converter__src_on_read_deinterleaved,
            pDSP
        );
        srcConfig.algorithm              = pConfig->srcAlgorithm;
        srcConfig.neverConsumeEndOfInput = pConfig->neverConsumeEndOfInput;
        srcConfig.noSSE2                 = pConfig->noSSE2;
        srcConfig.noAVX2                 = pConfig->noAVX2;
        srcConfig.noAVX512               = pConfig->noAVX512;
        srcConfig.noNEON                 = pConfig->noNEON;
        mal_copy_memory(&srcConfig.sinc, &pConfig->sinc, sizeof(pConfig->sinc));

        result = mal_src_init(&srcConfig, &pDSP->src);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    // Channel conversion
    {
        mal_channel_router_config routerConfig = mal_channel_router_config_init(
            pConfig->channelsIn,
            pConfig->channelMapIn,
            pConfig->channelsOut,
            pConfig->channelMapOut,
            pConfig->channelMixMode,
            mal_pcm_converter__channel_router_on_read_deinterleaved,
            pDSP);
        routerConfig.noSSE2   = pConfig->noSSE2;
        routerConfig.noAVX2   = pConfig->noAVX2;
        routerConfig.noAVX512 = pConfig->noAVX512;
        routerConfig.noNEON   = pConfig->noNEON;

        result = mal_channel_router_init(&routerConfig, &pDSP->channelRouter);
        if (result != MAL_SUCCESS) {
            return result;
        }
    }

    return MAL_SUCCESS;
}


mal_result mal_pcm_converter_refresh_sample_rate(mal_pcm_converter* pDSP)
{
    // The SRC stage will already have been initialized so we can just set it there.
    mal_src_set_sample_rate(&pDSP->src, pDSP->src.config.sampleRateIn, pDSP->src.config.sampleRateOut);
    return MAL_SUCCESS;
}

mal_result mal_pcm_converter_set_input_sample_rate(mal_pcm_converter* pDSP, mal_uint32 sampleRateIn)
{
    if (pDSP == NULL) {
        return MAL_INVALID_ARGS;
    }

    // Must have a sample rate of > 0.
    if (sampleRateIn == 0) {
        return MAL_INVALID_ARGS;
    }

    // Must have been initialized with allowDynamicSampleRate.
    if (!pDSP->isDynamicSampleRateAllowed) {
        return MAL_INVALID_OPERATION;
    }

    mal_atomic_exchange_32(&pDSP->src.config.sampleRateIn, sampleRateIn);
    return mal_pcm_converter_refresh_sample_rate(pDSP);
}

mal_result mal_pcm_converter_set_output_sample_rate(mal_pcm_converter* pDSP, mal_uint32 sampleRateOut)
{
    if (pDSP == NULL) {
        return MAL_INVALID_ARGS;
    }

    // Must have a sample rate of > 0.
    if (sampleRateOut == 0) {
        return MAL_INVALID_ARGS;
    }

    // Must have been initialized with allowDynamicSampleRate.
    if (!pDSP->isDynamicSampleRateAllowed) {
        return MAL_INVALID_OPERATION;
    }

    mal_atomic_exchange_32(&pDSP->src.config.sampleRateOut, sampleRateOut);
    return mal_pcm_converter_refresh_sample_rate(pDSP);
}

mal_result mal_pcm_converter_set_sample_rate(mal_pcm_converter* pDSP, mal_uint32 sampleRateIn, mal_uint32 sampleRateOut)
{
    if (pDSP == NULL) {
        return MAL_INVALID_ARGS;
    }

    // Must have a sample rate of > 0.
    if (sampleRateIn == 0 || sampleRateOut == 0) {
        return MAL_INVALID_ARGS;
    }

    // Must have been initialized with allowDynamicSampleRate.
    if (!pDSP->isDynamicSampleRateAllowed) {
        return MAL_INVALID_OPERATION;
    }

    mal_atomic_exchange_32(&pDSP->src.config.sampleRateIn, sampleRateIn);
    mal_atomic_exchange_32(&pDSP->src.config.sampleRateOut, sampleRateOut);

    return mal_pcm_converter_refresh_sample_rate(pDSP);
}

mal_uint64 mal_pcm_converter_read(mal_pcm_converter* pDSP, void* pFramesOut, mal_uint64 frameCount)
{
    if (pDSP == NULL || pFramesOut == NULL) {
        return 0;
    }

    // Fast path.
    if (pDSP->isPassthrough) {
        if (frameCount <= 0xFFFFFFFF) {
            return (mal_uint32)pDSP->onRead(pDSP, pFramesOut, (mal_uint32)frameCount, pDSP->pUserData);
        } else {
            mal_uint8* pNextFramesOut = (mal_uint8*)pFramesOut;

            mal_uint64 totalFramesRead = 0;
            while (totalFramesRead < frameCount) {
                mal_uint64 framesRemaining = (frameCount - totalFramesRead);
                mal_uint64 framesToReadRightNow = framesRemaining;
                if (framesToReadRightNow > 0xFFFFFFFF) {
                    framesToReadRightNow = 0xFFFFFFFF;
                }

                mal_uint32 framesRead = pDSP->onRead(pDSP, pNextFramesOut, (mal_uint32)framesToReadRightNow, pDSP->pUserData);
                if (framesRead == 0) {
                    break;
                }

                pNextFramesOut  += framesRead * pDSP->channelRouter.config.channelsOut * mal_get_bytes_per_sample(pDSP->formatConverterOut.config.formatOut);
                totalFramesRead += framesRead;
            }

            return totalFramesRead;
        }
    }

    // Slower path. The real work is done here. To do this all we need to do is read from the last stage in the pipeline.
    mal_assert(pDSP->isPostFormatConversionRequired == MAL_TRUE);

    mal_pcm_converter_callback_data data;
    data.pDSP = pDSP;
    data.pUserDataForClient = pDSP->pUserData;
    return mal_format_converter_read(&pDSP->formatConverterOut, frameCount, pFramesOut, &data);
}


typedef struct
{
    const void* pDataIn;
    mal_format formatIn;
    mal_uint32 channelsIn;
    mal_uint64 totalFrameCount;
    mal_uint64 iNextFrame;
    mal_bool32 isFeedingZeros;  // When set to true, feeds the DSP zero samples.
} mal_convert_frames__data;

mal_uint32 mal_convert_frames__on_read(mal_pcm_converter* pDSP, void* pFramesOut, mal_uint32 frameCount, void* pUserData)
{
    (void)pDSP;

    mal_convert_frames__data* pData = (mal_convert_frames__data*)pUserData;
    mal_assert(pData != NULL);
    mal_assert(pData->totalFrameCount >= pData->iNextFrame);

    mal_uint32 framesToRead = frameCount;
    mal_uint64 framesRemaining = (pData->totalFrameCount - pData->iNextFrame);
    if (framesToRead > framesRemaining) {
        framesToRead = (mal_uint32)framesRemaining;
    }

    mal_uint32 frameSizeInBytes = mal_get_bytes_per_frame(pData->formatIn, pData->channelsIn);

    if (!pData->isFeedingZeros) {
        mal_copy_memory(pFramesOut, (const mal_uint8*)pData->pDataIn + (frameSizeInBytes * pData->iNextFrame), frameSizeInBytes * framesToRead);
    } else {
        mal_zero_memory(pFramesOut, frameSizeInBytes * framesToRead);
    }

    pData->iNextFrame += framesToRead;
    return framesToRead;
}

mal_pcm_converter_config mal_pcm_converter_config_init_new()
{
    mal_pcm_converter_config config;
    mal_zero_object(&config);

    return config;
}

mal_pcm_converter_config mal_pcm_converter_config_init(mal_format formatIn, mal_uint32 channelsIn, mal_uint32 sampleRateIn, mal_format formatOut, mal_uint32 channelsOut, mal_uint32 sampleRateOut, mal_pcm_converter_read_proc onRead, void* pUserData)
{
    return mal_pcm_converter_config_init_ex(formatIn, channelsIn, sampleRateIn, NULL, formatOut, channelsOut, sampleRateOut, NULL, onRead, pUserData);
}

mal_pcm_converter_config mal_pcm_converter_config_init_ex(mal_format formatIn, mal_uint32 channelsIn, mal_uint32 sampleRateIn, mal_channel channelMapIn[MAL_MAX_CHANNELS], mal_format formatOut, mal_uint32 channelsOut, mal_uint32 sampleRateOut,  mal_channel channelMapOut[MAL_MAX_CHANNELS], mal_pcm_converter_read_proc onRead, void* pUserData)
{
    mal_pcm_converter_config config;
    mal_zero_object(&config);
    config.formatIn = formatIn;
    config.channelsIn = channelsIn;
    config.sampleRateIn = sampleRateIn;
    config.formatOut = formatOut;
    config.channelsOut = channelsOut;
    config.sampleRateOut = sampleRateOut;
    if (channelMapIn != NULL) {
        mal_copy_memory(config.channelMapIn, channelMapIn, sizeof(config.channelMapIn));
    }
    if (channelMapOut != NULL) {
        mal_copy_memory(config.channelMapOut, channelMapOut, sizeof(config.channelMapOut));
    }
    config.onRead = onRead;
    config.pUserData = pUserData;

    return config;
}



mal_uint64 mal_convert_frames(void* pOut, mal_format formatOut, mal_uint32 channelsOut, mal_uint32 sampleRateOut, const void* pIn, mal_format formatIn, mal_uint32 channelsIn, mal_uint32 sampleRateIn, mal_uint64 frameCount)
{
    mal_channel channelMapOut[MAL_MAX_CHANNELS];
    mal_get_standard_channel_map(mal_standard_channel_map_default, channelsOut, channelMapOut);

    mal_channel channelMapIn[MAL_MAX_CHANNELS];
    mal_get_standard_channel_map(mal_standard_channel_map_default, channelsIn, channelMapIn);

    return mal_convert_frames_ex(pOut, formatOut, channelsOut, sampleRateOut, channelMapOut, pIn, formatIn, channelsIn, sampleRateIn, channelMapIn, frameCount);
}

mal_uint64 mal_convert_frames_ex(void* pOut, mal_format formatOut, mal_uint32 channelsOut, mal_uint32 sampleRateOut, mal_channel channelMapOut[MAL_MAX_CHANNELS], const void* pIn, mal_format formatIn, mal_uint32 channelsIn, mal_uint32 sampleRateIn, mal_channel channelMapIn[MAL_MAX_CHANNELS], mal_uint64 frameCount)
{
    if (frameCount == 0) {
        return 0;
    }

    mal_uint64 frameCountOut = mal_calculate_frame_count_after_src(sampleRateOut, sampleRateIn, frameCount);
    if (pOut == NULL) {
        return frameCountOut;
    }

    mal_convert_frames__data data;
    data.pDataIn = pIn;
    data.formatIn = formatIn;
    data.channelsIn = channelsIn;
    data.totalFrameCount = frameCount;
    data.iNextFrame = 0;
    data.isFeedingZeros = MAL_FALSE;

    mal_pcm_converter_config config;
    mal_zero_object(&config);

    config.formatIn = formatIn;
    config.channelsIn = channelsIn;
    config.sampleRateIn = sampleRateIn;
    if (channelMapIn != NULL) {
        mal_channel_map_copy(config.channelMapIn, channelMapIn, channelsIn);
    } else {
        mal_get_standard_channel_map(mal_standard_channel_map_default, config.channelsIn, config.channelMapIn);
    }
    
    config.formatOut = formatOut;
    config.channelsOut = channelsOut;
    config.sampleRateOut = sampleRateOut;
    if (channelMapOut != NULL) {
        mal_channel_map_copy(config.channelMapOut, channelMapOut, channelsOut);
    } else {
        mal_get_standard_channel_map(mal_standard_channel_map_default, config.channelsOut, config.channelMapOut);
    }

    config.onRead = mal_convert_frames__on_read;
    config.pUserData = &data;

    mal_pcm_converter dsp;
    if (mal_pcm_converter_init(&config, &dsp) != MAL_SUCCESS) {
        return 0;
    }

    // Always output our computed frame count. There is a chance the sample rate conversion routine may not output the last sample
    // due to precision issues with 32-bit floats, in which case we should feed the DSP zero samples so it can generate that last
    // frame.
    mal_uint64 totalFramesRead = mal_pcm_converter_read(&dsp, pOut, frameCountOut);
    if (totalFramesRead < frameCountOut) {
        mal_uint32 bpf = mal_get_bytes_per_frame(formatIn, channelsIn);

        data.isFeedingZeros = MAL_TRUE;
        data.totalFrameCount = 0xFFFFFFFFFFFFFFFF;
        data.pDataIn = NULL;

        while (totalFramesRead < frameCountOut) {
            mal_uint64 framesToRead = (frameCountOut - totalFramesRead);
            mal_assert(framesToRead > 0);

            mal_uint64 framesJustRead = mal_pcm_converter_read(&dsp, mal_offset_ptr(pOut, totalFramesRead * bpf), framesToRead);
            totalFramesRead += framesJustRead;

            if (framesJustRead < framesToRead) {
                break;
            }
        }

        // At this point we should have output every sample, but just to be super duper sure, just fill the rest with zeros.
        if (totalFramesRead < frameCountOut) {
            mal_zero_memory_64(mal_offset_ptr(pOut, totalFramesRead * bpf), ((frameCountOut - totalFramesRead) * bpf));
            totalFramesRead = frameCountOut;
        }
    }

    mal_assert(totalFramesRead == frameCountOut);
    return totalFramesRead;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Ring Buffer
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MAL_INLINE mal_uint32 mal_rb__extract_offset_in_bytes(mal_uint32 encodedOffset)
{
    return encodedOffset & 0x7FFFFFFF;
}

MAL_INLINE mal_uint32 mal_rb__extract_offset_loop_flag(mal_uint32 encodedOffset)
{
    return encodedOffset & 0x80000000;
}

MAL_INLINE void* mal_rb__get_read_ptr(mal_rb* pRB)
{
    mal_assert(pRB != NULL);
    return mal_offset_ptr(pRB->pBuffer, mal_rb__extract_offset_in_bytes(pRB->encodedReadOffset));
}

MAL_INLINE void* mal_rb__get_write_ptr(mal_rb* pRB)
{
    mal_assert(pRB != NULL);
    return mal_offset_ptr(pRB->pBuffer, mal_rb__extract_offset_in_bytes(pRB->encodedWriteOffset));
}

MAL_INLINE mal_uint32 mal_rb__construct_offset(mal_uint32 offsetInBytes, mal_uint32 offsetLoopFlag)
{
    return offsetLoopFlag | offsetInBytes;
}

MAL_INLINE void mal_rb__deconstruct_offset(mal_uint32 encodedOffset, mal_uint32* pOffsetInBytes, mal_uint32* pOffsetLoopFlag)
{
    mal_assert(pOffsetInBytes != NULL);
    mal_assert(pOffsetLoopFlag != NULL);

    *pOffsetInBytes  = mal_rb__extract_offset_in_bytes(encodedOffset);
    *pOffsetLoopFlag = mal_rb__extract_offset_loop_flag(encodedOffset);
}


mal_result mal_rb_init_ex(size_t subbufferSizeInBytes, size_t subbufferCount, size_t subbufferStrideInBytes, void* pOptionalPreallocatedBuffer, mal_rb* pRB)
{
    if (pRB == NULL) {
        return MAL_INVALID_ARGS;
    }

    if (subbufferSizeInBytes == 0 || subbufferCount == 0) {
        return MAL_INVALID_ARGS;
    }

    const mal_uint32 maxSubBufferSize = 0x7FFFFFFF - (MAL_SIMD_ALIGNMENT-1);
    if (subbufferSizeInBytes > maxSubBufferSize) {
        return MAL_INVALID_ARGS;    // Maximum buffer size is ~2GB. The most significant bit is a flag for use internally.
    }


    mal_zero_object(pRB);
    pRB->subbufferSizeInBytes = (mal_uint32)subbufferSizeInBytes;
    pRB->subbufferCount = (mal_uint32)subbufferCount;

    if (pOptionalPreallocatedBuffer != NULL) {
        pRB->subbufferStrideInBytes = (mal_uint32)subbufferStrideInBytes;
        pRB->pBuffer = pOptionalPreallocatedBuffer;
    } else {
        // Here is where we allocate our own buffer. We always want to align this to MAL_SIMD_ALIGNMENT for future SIMD optimization opportunity. To do this
        // we need to make sure the stride is a multiple of MAL_SIMD_ALIGNMENT.
        pRB->subbufferStrideInBytes = (pRB->subbufferSizeInBytes + (MAL_SIMD_ALIGNMENT-1)) & ~MAL_SIMD_ALIGNMENT;

        size_t bufferSizeInBytes = (size_t)pRB->subbufferCount*pRB->subbufferStrideInBytes;
        pRB->pBuffer = mal_aligned_malloc(bufferSizeInBytes, MAL_SIMD_ALIGNMENT);
        if (pRB->pBuffer == NULL) {
            return MAL_OUT_OF_MEMORY;
        }

        mal_zero_memory(pRB->pBuffer, bufferSizeInBytes);
        pRB->ownsBuffer = MAL_TRUE;
    }

    return MAL_SUCCESS;
}

mal_result mal_rb_init(size_t bufferSizeInBytes, void* pOptionalPreallocatedBuffer, mal_rb* pRB)
{
    return mal_rb_init_ex(bufferSizeInBytes, 1, 0, pOptionalPreallocatedBuffer, pRB);
}

void mal_rb_uninit(mal_rb* pRB)
{
    if (pRB == NULL) {
        return;
    }

    if (pRB->ownsBuffer) {
        mal_aligned_free(pRB->pBuffer);
    }
}

mal_result mal_rb_acquire_read(mal_rb* pRB, size_t* pSizeInBytes, void** ppBufferOut)
{
    if (pRB == NULL || pSizeInBytes == NULL || ppBufferOut == NULL) {
        return MAL_INVALID_ARGS;
    }

    // The returned buffer should never move ahead of the write pointer.
    mal_uint32 writeOffset = pRB->encodedWriteOffset;
    mal_uint32 writeOffsetInBytes;
    mal_uint32 writeOffsetLoopFlag;
    mal_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);

    mal_uint32 readOffset = pRB->encodedReadOffset;
    mal_uint32 readOffsetInBytes;
    mal_uint32 readOffsetLoopFlag;
    mal_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);

    // The number of bytes available depends on whether or not the read and write pointers are on the same loop iteration. If so, we
    // can only read up to the write pointer. If not, we can only read up to the end of the buffer.
    size_t bytesAvailable;
    if (readOffsetLoopFlag == writeOffsetLoopFlag) {
        bytesAvailable = writeOffsetInBytes - readOffsetInBytes;
    } else {
        bytesAvailable = pRB->subbufferSizeInBytes - readOffsetInBytes;
    }

    size_t bytesRequested = *pSizeInBytes;
    if (bytesRequested > bytesAvailable) {
        bytesRequested = bytesAvailable;
    }

    *pSizeInBytes = bytesRequested;
    (*ppBufferOut) = mal_rb__get_read_ptr(pRB);

    return MAL_SUCCESS;
}

mal_result mal_rb_commit_read(mal_rb* pRB, size_t sizeInBytes, void* pBufferOut)
{
    if (pRB == NULL) {
        return MAL_INVALID_ARGS;
    }

    // Validate the buffer.
    if (pBufferOut != mal_rb__get_read_ptr(pRB)) {
        return MAL_INVALID_ARGS;
    }

    mal_uint32 readOffset = pRB->encodedReadOffset;
    mal_uint32 readOffsetInBytes;
    mal_uint32 readOffsetLoopFlag;
    mal_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);

    // Check that sizeInBytes is correct. It should never go beyond the end of the buffer.
    mal_uint32 newReadOffsetInBytes = (mal_uint32)(readOffsetInBytes + sizeInBytes);
    if (newReadOffsetInBytes > pRB->subbufferSizeInBytes) {
        return MAL_INVALID_ARGS;    // <-- sizeInBytes will cause the read offset to overflow.
    }

    // Move the read pointer back to the start if necessary.
    mal_uint32 newReadOffsetLoopFlag = readOffsetLoopFlag;
    if (newReadOffsetInBytes == pRB->subbufferSizeInBytes) {
        newReadOffsetInBytes = 0;
        newReadOffsetLoopFlag ^= 0x80000000;
    }

    mal_atomic_exchange_32(&pRB->encodedReadOffset, mal_rb__construct_offset(newReadOffsetLoopFlag, newReadOffsetInBytes));
    return MAL_SUCCESS;
}

mal_result mal_rb_acquire_write(mal_rb* pRB, size_t* pSizeInBytes, void** ppBufferOut)
{
    if (pRB == NULL || pSizeInBytes == NULL || ppBufferOut == NULL) {
        return MAL_INVALID_ARGS;
    }

    // The returned buffer should never overtake the read buffer.
    mal_uint32 readOffset = pRB->encodedReadOffset;
    mal_uint32 readOffsetInBytes;
    mal_uint32 readOffsetLoopFlag;
    mal_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);

    mal_uint32 writeOffset = pRB->encodedWriteOffset;
    mal_uint32 writeOffsetInBytes;
    mal_uint32 writeOffsetLoopFlag;
    mal_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);

    // In the case of writing, if the write pointer and the read pointer are on the same loop iteration we can only
    // write up to the end of the buffer. Otherwise we can only write up to the read pointer. The write pointer should
    // never overtake the read pointer.
    size_t bytesAvailable;
    if (writeOffsetLoopFlag == readOffsetLoopFlag) {
        bytesAvailable = pRB->subbufferSizeInBytes - writeOffsetInBytes;
    } else {
        bytesAvailable = readOffsetInBytes - writeOffsetInBytes;
    }

    size_t bytesRequested = *pSizeInBytes;
    if (bytesRequested > bytesAvailable) {
        bytesRequested = bytesAvailable;
    }

    *pSizeInBytes = bytesRequested;
    *ppBufferOut  = mal_rb__get_write_ptr(pRB);

    // Clear the buffer if desired.
    if (pRB->clearOnWriteAcquire) {
        mal_zero_memory(*ppBufferOut, *pSizeInBytes);
    }

    return MAL_SUCCESS;
}

mal_result mal_rb_commit_write(mal_rb* pRB, size_t sizeInBytes, void* pBufferOut)
{
    if (pRB == NULL) {
        return MAL_INVALID_ARGS;
    }

    // Validate the buffer.
    if (pBufferOut != mal_rb__get_write_ptr(pRB)) {
        return MAL_INVALID_ARGS;
    }

    mal_uint32 writeOffset = pRB->encodedWriteOffset;
    mal_uint32 writeOffsetInBytes;
    mal_uint32 writeOffsetLoopFlag;
    mal_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);

    // Check that sizeInBytes is correct. It should never go beyond the end of the buffer.
    mal_uint32 newWriteOffsetInBytes = (mal_uint32)(writeOffsetInBytes + sizeInBytes);
    if (newWriteOffsetInBytes > pRB->subbufferSizeInBytes) {
        return MAL_INVALID_ARGS;    // <-- sizeInBytes will cause the read offset to overflow.
    }

    // Move the read pointer back to the start if necessary.
    mal_uint32 newWriteOffsetLoopFlag = writeOffsetLoopFlag;
    if (newWriteOffsetInBytes == pRB->subbufferSizeInBytes) {
        newWriteOffsetInBytes = 0;
        newWriteOffsetLoopFlag ^= 0x80000000;
    }

    mal_atomic_exchange_32(&pRB->encodedWriteOffset, mal_rb__construct_offset(newWriteOffsetLoopFlag, newWriteOffsetInBytes));
    return MAL_SUCCESS;
}

mal_result mal_rb_seek_read(mal_rb* pRB, size_t offsetInBytes)
{
    if (pRB == NULL || offsetInBytes > pRB->subbufferSizeInBytes) {
        return MAL_INVALID_ARGS;
    }

    mal_uint32 readOffset = pRB->encodedReadOffset;
    mal_uint32 readOffsetInBytes;
    mal_uint32 readOffsetLoopFlag;
    mal_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);

    mal_uint32 writeOffset = pRB->encodedWriteOffset;
    mal_uint32 writeOffsetInBytes;
    mal_uint32 writeOffsetLoopFlag;
    mal_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);

    mal_uint32 newReadOffsetInBytes = readOffsetInBytes;
    mal_uint32 newReadOffsetLoopFlag = readOffsetLoopFlag;

    // We cannot go past the write buffer.
    if (readOffsetLoopFlag == writeOffsetLoopFlag) {
        if ((readOffsetInBytes + offsetInBytes) > writeOffsetInBytes) {
            newReadOffsetInBytes = writeOffsetInBytes;
        } else {
            newReadOffsetInBytes = (mal_uint32)(readOffsetInBytes + offsetInBytes);
        }
    } else {
        // May end up looping.
        if ((readOffsetInBytes + offsetInBytes) >= pRB->subbufferSizeInBytes) {
            newReadOffsetInBytes = (mal_uint32)(readOffsetInBytes + offsetInBytes) - pRB->subbufferSizeInBytes;
            newReadOffsetLoopFlag ^= 0x80000000;    /* <-- Looped. */
        } else {
            newReadOffsetInBytes = (mal_uint32)(readOffsetInBytes + offsetInBytes);
        }
    }

    mal_atomic_exchange_32(&pRB->encodedReadOffset, mal_rb__construct_offset(newReadOffsetInBytes, newReadOffsetLoopFlag));
    return MAL_SUCCESS;
}

mal_result mal_rb_seek_write(mal_rb* pRB, size_t offsetInBytes)
{
    if (pRB == NULL) {
        return MAL_INVALID_ARGS;
    }

    mal_uint32 readOffset = pRB->encodedReadOffset;
    mal_uint32 readOffsetInBytes;
    mal_uint32 readOffsetLoopFlag;
    mal_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);

    mal_uint32 writeOffset = pRB->encodedWriteOffset;
    mal_uint32 writeOffsetInBytes;
    mal_uint32 writeOffsetLoopFlag;
    mal_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);

    mal_uint32 newWriteOffsetInBytes = writeOffsetInBytes;
    mal_uint32 newWriteOffsetLoopFlag = writeOffsetLoopFlag;

    // We cannot go past the write buffer.
    if (readOffsetLoopFlag == writeOffsetLoopFlag) {
        // May end up looping.
        if ((writeOffsetInBytes + offsetInBytes) >= pRB->subbufferSizeInBytes) {
            newWriteOffsetInBytes = (mal_uint32)(writeOffsetInBytes + offsetInBytes) - pRB->subbufferSizeInBytes;
            newWriteOffsetLoopFlag ^= 0x80000000;    /* <-- Looped. */
        } else {
            newWriteOffsetInBytes = (mal_uint32)(writeOffsetInBytes + offsetInBytes);
        }
    } else {
        if ((writeOffsetInBytes + offsetInBytes) > readOffsetInBytes) {
            newWriteOffsetInBytes = readOffsetInBytes;
        } else {
            newWriteOffsetInBytes = (mal_uint32)(writeOffsetInBytes + offsetInBytes);
        }
    }

    mal_atomic_exchange_32(&pRB->encodedWriteOffset, mal_rb__construct_offset(newWriteOffsetInBytes, newWriteOffsetLoopFlag));
    return MAL_SUCCESS;
}

mal_int32 mal_rb_pointer_distance(mal_rb* pRB)
{
    if (pRB == NULL) {
        return 0;
    }

    mal_uint32 readOffset = pRB->encodedReadOffset;
    mal_uint32 readOffsetInBytes;
    mal_uint32 readOffsetLoopFlag;
    mal_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);

    mal_uint32 writeOffset = pRB->encodedWriteOffset;
    mal_uint32 writeOffsetInBytes;
    mal_uint32 writeOffsetLoopFlag;
    mal_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);

    if (readOffsetLoopFlag == writeOffsetLoopFlag) {
        return writeOffsetInBytes - readOffsetInBytes;
    } else {
        return writeOffsetInBytes + (pRB->subbufferSizeInBytes - readOffsetInBytes);
    }
}

size_t mal_rb_get_subbuffer_size(mal_rb* pRB)
{
    if (pRB == NULL) {
        return 0;
    }

    return pRB->subbufferSizeInBytes;
}

size_t mal_rb_get_subbuffer_stride(mal_rb* pRB)
{
    if (pRB == NULL) {
        return 0;
    }

    if (pRB->subbufferStrideInBytes == 0) {
        return (size_t)pRB->subbufferSizeInBytes;
    }

    return (size_t)pRB->subbufferStrideInBytes;
}

size_t mal_rb_get_subbuffer_offset(mal_rb* pRB, size_t subbufferIndex)
{
    if (pRB == NULL) {
        return 0;
    }

    return subbufferIndex * mal_rb_get_subbuffer_stride(pRB);
}

void* mal_rb_get_subbuffer_ptr(mal_rb* pRB, size_t subbufferIndex, void* pBuffer)
{
    if (pRB == NULL) {
        return NULL;
    }

    return mal_offset_ptr(pBuffer, mal_rb_get_subbuffer_offset(pRB, subbufferIndex));
}


static MAL_INLINE mal_uint32 mal_pcm_rb_get_bpf(mal_pcm_rb* pRB)
{
    mal_assert(pRB != NULL);

    return mal_get_bytes_per_frame(pRB->format, pRB->channels);
}

mal_result mal_pcm_rb_init_ex(mal_format format, mal_uint32 channels, mal_uint32 subbufferSizeInFrames, mal_uint32 subbufferCount, mal_uint32 subbufferStrideInFrames, void* pOptionalPreallocatedBuffer, mal_pcm_rb* pRB)
{
    if (pRB == NULL) {
        return MAL_INVALID_ARGS;
    }

    mal_zero_object(pRB);

    mal_uint32 bpf = mal_get_bytes_per_frame(format, channels);
    if (bpf == 0) {
        return MAL_INVALID_ARGS;
    }

    mal_result result = mal_rb_init_ex(subbufferSizeInFrames*bpf, subbufferCount, subbufferStrideInFrames*bpf, pOptionalPreallocatedBuffer, &pRB->rb);
    if (result != MAL_SUCCESS) {
        return result;
    }

    pRB->format   = format;
    pRB->channels = channels;

    return MAL_SUCCESS;
}

mal_result mal_pcm_rb_init(mal_format format, mal_uint32 channels, mal_uint32 bufferSizeInFrames, void* pOptionalPreallocatedBuffer, mal_pcm_rb* pRB)
{
    return mal_pcm_rb_init_ex(format, channels, bufferSizeInFrames, 1, 0, pOptionalPreallocatedBuffer, pRB);
}

void mal_pcm_rb_uninit(mal_pcm_rb* pRB)
{
    if (pRB == NULL) {
        return;
    }

    mal_rb_uninit(&pRB->rb);
}

mal_result mal_pcm_rb_acquire_read(mal_pcm_rb* pRB, mal_uint32* pSizeInFrames, void** ppBufferOut)
{
    size_t sizeInBytes;
    mal_result result;

    if (pRB == NULL || pSizeInFrames == NULL) {
        return MAL_INVALID_ARGS;
    }

    sizeInBytes = *pSizeInFrames * mal_pcm_rb_get_bpf(pRB);

    result = mal_rb_acquire_read(&pRB->rb, &sizeInBytes, ppBufferOut);
    if (result != MAL_SUCCESS) {
        return result;
    }

    *pSizeInFrames = (mal_uint32)(sizeInBytes / (size_t)mal_pcm_rb_get_bpf(pRB));
    return MAL_SUCCESS;
}

mal_result mal_pcm_rb_commit_read(mal_pcm_rb* pRB, mal_uint32 sizeInFrames, void* pBufferOut)
{
    if (pRB == NULL) {
        return MAL_INVALID_ARGS;
    }

    return mal_rb_commit_read(&pRB->rb, sizeInFrames * mal_pcm_rb_get_bpf(pRB), pBufferOut);
}

mal_result mal_pcm_rb_acquire_write(mal_pcm_rb* pRB, mal_uint32* pSizeInFrames, void** ppBufferOut)
{
    size_t sizeInBytes;
    mal_result result;

    if (pRB == NULL) {
        return MAL_INVALID_ARGS;
    }

    sizeInBytes = *pSizeInFrames * mal_pcm_rb_get_bpf(pRB);

    result = mal_rb_acquire_write(&pRB->rb, &sizeInBytes, ppBufferOut);
    if (result != MAL_SUCCESS) {
        return result;
    }

    *pSizeInFrames = (mal_uint32)(sizeInBytes / mal_pcm_rb_get_bpf(pRB));
    return MAL_SUCCESS;
}

mal_result mal_pcm_rb_commit_write(mal_pcm_rb* pRB, mal_uint32 sizeInFrames, void* pBufferOut)
{
    if (pRB == NULL) {
        return MAL_INVALID_ARGS;
    }

    return mal_rb_commit_write(&pRB->rb, sizeInFrames * mal_pcm_rb_get_bpf(pRB), pBufferOut);
}

mal_result mal_pcm_rb_seek_read(mal_pcm_rb* pRB, mal_uint32 offsetInFrames)
{
    if (pRB == NULL) {
        return MAL_INVALID_ARGS;
    }

    return mal_rb_seek_read(&pRB->rb, offsetInFrames * mal_pcm_rb_get_bpf(pRB));
}

mal_result mal_pcm_rb_seek_write(mal_pcm_rb* pRB, mal_uint32 offsetInFrames)
{
    if (pRB == NULL) {
        return MAL_INVALID_ARGS;
    }

    return mal_rb_seek_write(&pRB->rb, offsetInFrames * mal_pcm_rb_get_bpf(pRB));
}

mal_int32 mal_pcm_rb_pointer_disance(mal_pcm_rb* pRB)
{
    if (pRB == NULL) {
        return MAL_INVALID_ARGS;
    }

    return mal_rb_pointer_distance(&pRB->rb) / mal_pcm_rb_get_bpf(pRB);
}

mal_uint32 mal_pcm_rb_get_subbuffer_size(mal_pcm_rb* pRB)
{
    if (pRB == NULL) {
        return 0;
    }

    return (mal_uint32)(mal_rb_get_subbuffer_size(&pRB->rb) / mal_pcm_rb_get_bpf(pRB));
}

mal_uint32 mal_pcm_rb_get_subbuffer_stride(mal_pcm_rb* pRB)
{
    if (pRB == NULL) {
        return 0;
    }

    return (mal_uint32)(mal_rb_get_subbuffer_stride(&pRB->rb) / mal_pcm_rb_get_bpf(pRB));
}

mal_uint32 mal_pcm_rb_get_subbuffer_offset(mal_pcm_rb* pRB, mal_uint32 subbufferIndex)
{
    if (pRB == NULL) {
        return 0;
    }

    return (mal_uint32)(mal_rb_get_subbuffer_offset(&pRB->rb, subbufferIndex) / mal_pcm_rb_get_bpf(pRB));
}

void* mal_pcm_rb_get_subbuffer_ptr(mal_pcm_rb* pRB, mal_uint32 subbufferIndex, void* pBuffer)
{
    if (pRB == NULL) {
        return NULL;
    }

    return mal_rb_get_subbuffer_ptr(&pRB->rb, subbufferIndex, pBuffer);
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Miscellaneous Helpers
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void* mal_malloc(size_t sz)
{
    return MAL_MALLOC(sz);
}

void* mal_realloc(void* p, size_t sz)
{
    return MAL_REALLOC(p, sz);
}

void mal_free(void* p)
{
    MAL_FREE(p);
}

void* mal_aligned_malloc(size_t sz, size_t alignment)
{
    if (alignment == 0) {
        return 0;
    }

    size_t extraBytes = alignment-1 + sizeof(void*);

    void* pUnaligned = mal_malloc(sz + extraBytes);
    if (pUnaligned == NULL) {
        return NULL;
    }

    void* pAligned = (void*)(((mal_uintptr)pUnaligned + extraBytes) & ~((mal_uintptr)(alignment-1)));
    ((void**)pAligned)[-1] = pUnaligned;

    return pAligned;
}

void mal_aligned_free(void* p)
{
    mal_free(((void**)p)[-1]);
}

const char* mal_get_format_name(mal_format format)
{
    switch (format)
    {
        case mal_format_unknown: return "Unknown";
        case mal_format_u8:      return "8-bit Unsigned Integer";
        case mal_format_s16:     return "16-bit Signed Integer";
        case mal_format_s24:     return "24-bit Signed Integer (Tightly Packed)";
        case mal_format_s32:     return "32-bit Signed Integer";
        case mal_format_f32:     return "32-bit IEEE Floating Point";
        default:                 return "Invalid";
    }
}

void mal_blend_f32(float* pOut, float* pInA, float* pInB, float factor, mal_uint32 channels)
{
    for (mal_uint32 i = 0; i < channels; ++i) {
        pOut[i] = mal_mix_f32(pInA[i], pInB[i], factor);
    }
}


mal_uint32 mal_get_bytes_per_sample(mal_format format)
{
    mal_uint32 sizes[] = {
        0,  // unknown
        1,  // u8
        2,  // s16
        3,  // s24
        4,  // s32
        4,  // f32
    };
    return sizes[format];
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// DECODING
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef MAL_NO_DECODING

mal_decoder_config mal_decoder_config_init(mal_format outputFormat, mal_uint32 outputChannels, mal_uint32 outputSampleRate)
{
    mal_decoder_config config;
    mal_zero_object(&config);
    config.format = outputFormat;
    config.channels = outputChannels;
    config.sampleRate = outputSampleRate;
    mal_get_standard_channel_map(mal_standard_channel_map_default, config.channels, config.channelMap);

    return config;
}

mal_decoder_config mal_decoder_config_init_copy(const mal_decoder_config* pConfig)
{
    mal_decoder_config config;
    if (pConfig != NULL) {
        config = *pConfig;
    } else {
        mal_zero_object(&config);
    }

    return config;
}

mal_result mal_decoder__init_dsp(mal_decoder* pDecoder, const mal_decoder_config* pConfig, mal_pcm_converter_read_proc onRead)
{
    mal_assert(pDecoder != NULL);

    // Output format.
    if (pConfig->format == mal_format_unknown) {
        pDecoder->outputFormat = pDecoder->internalFormat;
    } else {
        pDecoder->outputFormat = pConfig->format;
    }

    if (pConfig->channels == 0) {
        pDecoder->outputChannels = pDecoder->internalChannels;
    } else {
        pDecoder->outputChannels = pConfig->channels;
    }

    if (pConfig->sampleRate == 0) {
        pDecoder->outputSampleRate = pDecoder->internalSampleRate;
    } else {
        pDecoder->outputSampleRate = pConfig->sampleRate;
    }

    if (mal_channel_map_blank(pDecoder->outputChannels, pConfig->channelMap)) {
        mal_get_standard_channel_map(mal_standard_channel_map_default, pDecoder->outputChannels, pDecoder->outputChannelMap);
    } else {
        mal_copy_memory(pDecoder->outputChannelMap, pConfig->channelMap, sizeof(pConfig->channelMap));
    }


    // DSP.
    mal_pcm_converter_config dspConfig = mal_pcm_converter_config_init_ex(
        pDecoder->internalFormat, pDecoder->internalChannels, pDecoder->internalSampleRate, pDecoder->internalChannelMap,
        pDecoder->outputFormat,   pDecoder->outputChannels,   pDecoder->outputSampleRate,   pDecoder->outputChannelMap,
        onRead, pDecoder);
    dspConfig.channelMixMode = pConfig->channelMixMode;
    dspConfig.ditherMode = pConfig->ditherMode;
    dspConfig.srcAlgorithm = pConfig->srcAlgorithm;
    dspConfig.sinc = pConfig->src.sinc;

    return mal_pcm_converter_init(&dspConfig, &pDecoder->dsp);
}

// WAV
#ifdef dr_wav_h
#define MAL_HAS_WAV

size_t mal_decoder_internal_on_read__wav(void* pUserData, void* pBufferOut, size_t bytesToRead)
{
    mal_decoder* pDecoder = (mal_decoder*)pUserData;
    mal_assert(pDecoder != NULL);
    mal_assert(pDecoder->onRead != NULL);

    return pDecoder->onRead(pDecoder, pBufferOut, bytesToRead);
}

drwav_bool32 mal_decoder_internal_on_seek__wav(void* pUserData, int offset, drwav_seek_origin origin)
{
    mal_decoder* pDecoder = (mal_decoder*)pUserData;
    mal_assert(pDecoder != NULL);
    mal_assert(pDecoder->onSeek != NULL);

    return pDecoder->onSeek(pDecoder, offset, (origin == drwav_seek_origin_start) ? mal_seek_origin_start : mal_seek_origin_current);
}

mal_uint32 mal_decoder_internal_on_read_pcm_frames__wav(mal_pcm_converter* pDSP, void* pSamplesOut, mal_uint32 frameCount, void* pUserData)
{
    (void)pDSP;

    mal_decoder* pDecoder = (mal_decoder*)pUserData;
    mal_assert(pDecoder != NULL);

    drwav* pWav = (drwav*)pDecoder->pInternalDecoder;
    mal_assert(pWav != NULL);

    switch (pDecoder->internalFormat) {
        case mal_format_s16: return (mal_uint32)drwav_read_pcm_frames_s16(pWav, frameCount, (drwav_int16*)pSamplesOut);
        case mal_format_s32: return (mal_uint32)drwav_read_pcm_frames_s32(pWav, frameCount, (drwav_int32*)pSamplesOut);
        case mal_format_f32: return (mal_uint32)drwav_read_pcm_frames_f32(pWav, frameCount,       (float*)pSamplesOut);
        default: break;
    }

    // Should never get here. If we do, it means the internal format was not set correctly at initialization time.
    mal_assert(MAL_FALSE);
    return 0;
}

mal_result mal_decoder_internal_on_seek_to_pcm_frame__wav(mal_decoder* pDecoder, mal_uint64 frameIndex)
{
    drwav* pWav = (drwav*)pDecoder->pInternalDecoder;
    mal_assert(pWav != NULL);

    drwav_bool32 result = drwav_seek_to_pcm_frame(pWav, frameIndex);
    if (result) {
        return MAL_SUCCESS;
    } else {
        return MAL_ERROR;
    }
}

mal_result mal_decoder_internal_on_uninit__wav(mal_decoder* pDecoder)
{
    drwav_close((drwav*)pDecoder->pInternalDecoder);
    return MAL_SUCCESS;
}

mal_result mal_decoder_init_wav__internal(const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_assert(pConfig != NULL);
    mal_assert(pDecoder != NULL);

    // Try opening the decoder first.
    drwav* pWav = drwav_open(mal_decoder_internal_on_read__wav, mal_decoder_internal_on_seek__wav, pDecoder);
    if (pWav == NULL) {
        return MAL_ERROR;
    }

    // If we get here it means we successfully initialized the WAV decoder. We can now initialize the rest of the mal_decoder.
    pDecoder->onSeekToPCMFrame = mal_decoder_internal_on_seek_to_pcm_frame__wav;
    pDecoder->onUninit = mal_decoder_internal_on_uninit__wav;
    pDecoder->pInternalDecoder = pWav;

    // Try to be as optimal as possible for the internal format. If mini_al does not support a format we will fall back to f32.
    pDecoder->internalFormat = mal_format_unknown;
    switch (pWav->translatedFormatTag) {
        case DR_WAVE_FORMAT_PCM:
        {
            if (pWav->bitsPerSample == 8) {
                pDecoder->internalFormat = mal_format_s16;
            } else if (pWav->bitsPerSample == 16) {
                pDecoder->internalFormat = mal_format_s16;
            } else if (pWav->bitsPerSample == 32) {
                pDecoder->internalFormat = mal_format_s32;
            }
        } break;

        case DR_WAVE_FORMAT_IEEE_FLOAT:
        {
            if (pWav->bitsPerSample == 32) {
                pDecoder->internalFormat = mal_format_f32;
            }
        } break;

        case DR_WAVE_FORMAT_ALAW:
        case DR_WAVE_FORMAT_MULAW:
        case DR_WAVE_FORMAT_ADPCM:
        case DR_WAVE_FORMAT_DVI_ADPCM:
        {
            pDecoder->internalFormat = mal_format_s16;
        } break;
    }

    if (pDecoder->internalFormat == mal_format_unknown) {
        pDecoder->internalFormat = mal_format_f32;
    }

    pDecoder->internalChannels = pWav->channels;
    pDecoder->internalSampleRate = pWav->sampleRate;
    mal_get_standard_channel_map(mal_standard_channel_map_microsoft, pDecoder->internalChannels, pDecoder->internalChannelMap);

    mal_result result = mal_decoder__init_dsp(pDecoder, pConfig, mal_decoder_internal_on_read_pcm_frames__wav);
    if (result != MAL_SUCCESS) {
        drwav_close(pWav);
        return result;
    }

    return MAL_SUCCESS;
}
#endif

// FLAC
#ifdef dr_flac_h
#define MAL_HAS_FLAC

size_t mal_decoder_internal_on_read__flac(void* pUserData, void* pBufferOut, size_t bytesToRead)
{
    mal_decoder* pDecoder = (mal_decoder*)pUserData;
    mal_assert(pDecoder != NULL);
    mal_assert(pDecoder->onRead != NULL);

    return pDecoder->onRead(pDecoder, pBufferOut, bytesToRead);
}

drflac_bool32 mal_decoder_internal_on_seek__flac(void* pUserData, int offset, drflac_seek_origin origin)
{
    mal_decoder* pDecoder = (mal_decoder*)pUserData;
    mal_assert(pDecoder != NULL);
    mal_assert(pDecoder->onSeek != NULL);

    return pDecoder->onSeek(pDecoder, offset, (origin == drflac_seek_origin_start) ? mal_seek_origin_start : mal_seek_origin_current);
}

mal_uint32 mal_decoder_internal_on_read_pcm_frames__flac(mal_pcm_converter* pDSP, void* pSamplesOut, mal_uint32 frameCount, void* pUserData)
{
    (void)pDSP;

    mal_decoder* pDecoder = (mal_decoder*)pUserData;
    mal_assert(pDecoder != NULL);

    drflac* pFlac = (drflac*)pDecoder->pInternalDecoder;
    mal_assert(pFlac != NULL);

    switch (pDecoder->internalFormat) {
        case mal_format_s16: return (mal_uint32)drflac_read_pcm_frames_s16(pFlac, frameCount, (drflac_int16*)pSamplesOut);
        case mal_format_s32: return (mal_uint32)drflac_read_pcm_frames_s32(pFlac, frameCount, (drflac_int32*)pSamplesOut);
        case mal_format_f32: return (mal_uint32)drflac_read_pcm_frames_f32(pFlac, frameCount,        (float*)pSamplesOut);
        default: break;
    }

    // Should never get here. If we do, it means the internal format was not set correctly at initialization time.
    mal_assert(MAL_FALSE);
    return 0;
}

mal_result mal_decoder_internal_on_seek_to_pcm_frame__flac(mal_decoder* pDecoder, mal_uint64 frameIndex)
{
    drflac* pFlac = (drflac*)pDecoder->pInternalDecoder;
    mal_assert(pFlac != NULL);

    drflac_bool32 result = drflac_seek_to_pcm_frame(pFlac, frameIndex);
    if (result) {
        return MAL_SUCCESS;
    } else {
        return MAL_ERROR;
    }
}

mal_result mal_decoder_internal_on_uninit__flac(mal_decoder* pDecoder)
{
    drflac_close((drflac*)pDecoder->pInternalDecoder);
    return MAL_SUCCESS;
}

mal_result mal_decoder_init_flac__internal(const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_assert(pConfig != NULL);
    mal_assert(pDecoder != NULL);

    // Try opening the decoder first.
    drflac* pFlac = drflac_open(mal_decoder_internal_on_read__flac, mal_decoder_internal_on_seek__flac, pDecoder);
    if (pFlac == NULL) {
        return MAL_ERROR;
    }

    // If we get here it means we successfully initialized the FLAC decoder. We can now initialize the rest of the mal_decoder.
    pDecoder->onSeekToPCMFrame = mal_decoder_internal_on_seek_to_pcm_frame__flac;
    pDecoder->onUninit = mal_decoder_internal_on_uninit__flac;
    pDecoder->pInternalDecoder = pFlac;

    // dr_flac supports reading as s32, s16 and f32. Try to do a one-to-one mapping if possible, but fall back to s32 if not. s32 is the "native" FLAC format
    // since it's the only one that's truly lossless.
    pDecoder->internalFormat = mal_format_s32;
    if (pConfig->format == mal_format_s16) {
        pDecoder->internalFormat = mal_format_s16;
    } else if (pConfig->format == mal_format_f32) {
        pDecoder->internalFormat = mal_format_f32;
    }

    pDecoder->internalChannels = pFlac->channels;
    pDecoder->internalSampleRate = pFlac->sampleRate;
    mal_get_standard_channel_map(mal_standard_channel_map_flac, pDecoder->internalChannels, pDecoder->internalChannelMap);

    mal_result result = mal_decoder__init_dsp(pDecoder, pConfig, mal_decoder_internal_on_read_pcm_frames__flac);
    if (result != MAL_SUCCESS) {
        drflac_close(pFlac);
        return result;
    }

    return MAL_SUCCESS;
}
#endif

// Vorbis
#ifdef STB_VORBIS_INCLUDE_STB_VORBIS_H
#define MAL_HAS_VORBIS

// The size in bytes of each chunk of data to read from the Vorbis stream.
#define MAL_VORBIS_DATA_CHUNK_SIZE  4096

typedef struct
{
    stb_vorbis* pInternalVorbis;
    mal_uint8* pData;
    size_t dataSize;
    size_t dataCapacity;
    mal_uint32 framesConsumed;  // The number of frames consumed in ppPacketData.
    mal_uint32 framesRemaining; // The number of frames remaining in ppPacketData.
    float** ppPacketData;
} mal_vorbis_decoder;

mal_uint32 mal_vorbis_decoder_read_pcm_frames(mal_vorbis_decoder* pVorbis, mal_decoder* pDecoder, void* pSamplesOut, mal_uint32 frameCount)
{
    mal_assert(pVorbis != NULL);
    mal_assert(pDecoder != NULL);
    mal_assert(pDecoder->onRead != NULL);
    mal_assert(pDecoder->onSeek != NULL);

    float* pSamplesOutF = (float*)pSamplesOut;

    mal_uint32 totalFramesRead = 0;
    while (frameCount > 0) {
        // Read from the in-memory buffer first.
        while (pVorbis->framesRemaining > 0 && frameCount > 0) {
            for (mal_uint32 iChannel = 0; iChannel < pDecoder->internalChannels; ++iChannel) {
                pSamplesOutF[0] = pVorbis->ppPacketData[iChannel][pVorbis->framesConsumed];
                pSamplesOutF += 1;
            }

            pVorbis->framesConsumed += 1;
            pVorbis->framesRemaining -= 1;
            frameCount -= 1;
            totalFramesRead += 1;
        }

        if (frameCount == 0) {
            break;
        }

        mal_assert(pVorbis->framesRemaining == 0);

        // We've run out of cached frames, so decode the next packet and continue iteration.
        do
        {
            if (pVorbis->dataSize > INT_MAX) {
                break;  // Too big.
            }

            int samplesRead = 0;
            int consumedDataSize = stb_vorbis_decode_frame_pushdata(pVorbis->pInternalVorbis, pVorbis->pData, (int)pVorbis->dataSize, NULL, (float***)&pVorbis->ppPacketData, &samplesRead);
            if (consumedDataSize != 0) {
                size_t leftoverDataSize = (pVorbis->dataSize - (size_t)consumedDataSize);
                for (size_t i = 0; i < leftoverDataSize; ++i) {
                    pVorbis->pData[i] = pVorbis->pData[i + consumedDataSize];
                }

                pVorbis->dataSize = leftoverDataSize;
                pVorbis->framesConsumed = 0;
                pVorbis->framesRemaining = samplesRead;
                break;
            } else {
                // Need more data. If there's any room in the existing buffer allocation fill that first. Otherwise expand.
                if (pVorbis->dataCapacity == pVorbis->dataSize) {
                    // No room. Expand.
                    pVorbis->dataCapacity += MAL_VORBIS_DATA_CHUNK_SIZE;
                    mal_uint8* pNewData = (mal_uint8*)mal_realloc(pVorbis->pData, pVorbis->dataCapacity);
                    if (pNewData == NULL) {
                        return totalFramesRead; // Out of memory.
                    }

                    pVorbis->pData = pNewData;
                }

                // Fill in a chunk.
                size_t bytesRead = pDecoder->onRead(pDecoder, pVorbis->pData + pVorbis->dataSize, (pVorbis->dataCapacity - pVorbis->dataSize));
                if (bytesRead == 0) {
                    return totalFramesRead; // Error reading more data.
                }

                pVorbis->dataSize += bytesRead;
            }
        } while (MAL_TRUE);
    }

    return totalFramesRead;
}

mal_result mal_vorbis_decoder_seek_to_pcm_frame(mal_vorbis_decoder* pVorbis, mal_decoder* pDecoder, mal_uint64 frameIndex)
{
    mal_assert(pVorbis != NULL);
    mal_assert(pDecoder != NULL);
    mal_assert(pDecoder->onRead != NULL);
    mal_assert(pDecoder->onSeek != NULL);

    // This is terribly inefficient because stb_vorbis does not have a good seeking solution with it's push API. Currently this just performs
    // a full decode right from the start of the stream. Later on I'll need to write a layer that goes through all of the Ogg pages until we
    // find the one containing the sample we need. Then we know exactly where to seek for stb_vorbis.
    if (!pDecoder->onSeek(pDecoder, 0, mal_seek_origin_start)) {
        return MAL_ERROR;
    }

    stb_vorbis_flush_pushdata(pVorbis->pInternalVorbis);
    pVorbis->framesConsumed = 0;
    pVorbis->framesRemaining = 0;
    pVorbis->dataSize = 0;

    float buffer[4096];
    while (frameIndex > 0) {
        mal_uint32 framesToRead = mal_countof(buffer)/pDecoder->internalChannels;
        if (framesToRead > frameIndex) {
            framesToRead = (mal_uint32)frameIndex;
        }

        mal_uint32 framesRead = mal_vorbis_decoder_read_pcm_frames(pVorbis, pDecoder, buffer, framesToRead);
        if (framesRead == 0) {
            return MAL_ERROR;
        }

        frameIndex -= framesRead;
    }

    return MAL_SUCCESS;
}


mal_result mal_decoder_internal_on_seek_to_pcm_frame__vorbis(mal_decoder* pDecoder, mal_uint64 frameIndex)
{
    mal_assert(pDecoder != NULL);
    mal_assert(pDecoder->onRead != NULL);
    mal_assert(pDecoder->onSeek != NULL);

    mal_vorbis_decoder* pVorbis = (mal_vorbis_decoder*)pDecoder->pInternalDecoder;
    mal_assert(pVorbis != NULL);

    return mal_vorbis_decoder_seek_to_pcm_frame(pVorbis, pDecoder, frameIndex);
}

mal_result mal_decoder_internal_on_uninit__vorbis(mal_decoder* pDecoder)
{
    mal_vorbis_decoder* pVorbis = (mal_vorbis_decoder*)pDecoder->pInternalDecoder;
    mal_assert(pVorbis != NULL);

    stb_vorbis_close(pVorbis->pInternalVorbis);
    mal_free(pVorbis->pData);
    mal_free(pVorbis);

    return MAL_SUCCESS;
}

mal_uint32 mal_decoder_internal_on_read_pcm_frames__vorbis(mal_pcm_converter* pDSP, void* pSamplesOut, mal_uint32 frameCount, void* pUserData)
{
    (void)pDSP;

    mal_decoder* pDecoder = (mal_decoder*)pUserData;
    mal_assert(pDecoder != NULL);
    mal_assert(pDecoder->internalFormat == mal_format_f32);
    mal_assert(pDecoder->onRead != NULL);
    mal_assert(pDecoder->onSeek != NULL);

    mal_vorbis_decoder* pVorbis = (mal_vorbis_decoder*)pDecoder->pInternalDecoder;
    mal_assert(pVorbis != NULL);

    return mal_vorbis_decoder_read_pcm_frames(pVorbis, pDecoder, pSamplesOut, frameCount);
}

mal_result mal_decoder_init_vorbis__internal(const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_assert(pConfig != NULL);
    mal_assert(pDecoder != NULL);
    mal_assert(pDecoder->onRead != NULL);
    mal_assert(pDecoder->onSeek != NULL);

    stb_vorbis* pInternalVorbis = NULL;

    // We grow the buffer in chunks.
    size_t dataSize = 0;
    size_t dataCapacity = 0;
    mal_uint8* pData = NULL;
    do
    {
        // Allocate memory for a new chunk.
        dataCapacity += MAL_VORBIS_DATA_CHUNK_SIZE;
        mal_uint8* pNewData = (mal_uint8*)mal_realloc(pData, dataCapacity);
        if (pNewData == NULL) {
            mal_free(pData);
            return MAL_OUT_OF_MEMORY;
        }

        pData = pNewData;

        // Fill in a chunk.
        size_t bytesRead = pDecoder->onRead(pDecoder, pData + dataSize, (dataCapacity - dataSize));
        if (bytesRead == 0) {
            return MAL_ERROR;
        }

        dataSize += bytesRead;
        if (dataSize > INT_MAX) {
            return MAL_ERROR;   // Too big.
        }

        int vorbisError = 0;
        int consumedDataSize = 0;
        pInternalVorbis = stb_vorbis_open_pushdata(pData, (int)dataSize, &consumedDataSize, &vorbisError, NULL);
        if (pInternalVorbis != NULL) {
            // If we get here it means we were able to open the stb_vorbis decoder. There may be some leftover bytes in our buffer, so
            // we need to move those bytes down to the front of the buffer since they'll be needed for future decoding.
            size_t leftoverDataSize = (dataSize - (size_t)consumedDataSize);
            for (size_t i = 0; i < leftoverDataSize; ++i) {
                pData[i] = pData[i + consumedDataSize];
            }

            dataSize = leftoverDataSize;
            break;  // Success.
        } else {
            if (vorbisError == VORBIS_need_more_data) {
                continue;
            } else {
                return MAL_ERROR;   // Failed to open the stb_vorbis decoder.
            }
        }
    } while (MAL_TRUE);


    // If we get here it means we successfully opened the Vorbis decoder.
    stb_vorbis_info vorbisInfo = stb_vorbis_get_info(pInternalVorbis);

    // Don't allow more than MAL_MAX_CHANNELS channels.
    if (vorbisInfo.channels > MAL_MAX_CHANNELS) {
        stb_vorbis_close(pInternalVorbis);
        mal_free(pData);
        return MAL_ERROR;   // Too many channels.
    }

    size_t vorbisDataSize = sizeof(mal_vorbis_decoder) + sizeof(float)*vorbisInfo.max_frame_size;
    mal_vorbis_decoder* pVorbis = (mal_vorbis_decoder*)mal_malloc(vorbisDataSize);
    if (pVorbis == NULL) {
        stb_vorbis_close(pInternalVorbis);
        mal_free(pData);
        return MAL_OUT_OF_MEMORY;
    }

    mal_zero_memory(pVorbis, vorbisDataSize);
    pVorbis->pInternalVorbis = pInternalVorbis;
    pVorbis->pData = pData;
    pVorbis->dataSize = dataSize;
    pVorbis->dataCapacity = dataCapacity;

    pDecoder->onSeekToPCMFrame = mal_decoder_internal_on_seek_to_pcm_frame__vorbis;
    pDecoder->onUninit = mal_decoder_internal_on_uninit__vorbis;
    pDecoder->pInternalDecoder = pVorbis;

    // The internal format is always f32.
    pDecoder->internalFormat = mal_format_f32;
    pDecoder->internalChannels = vorbisInfo.channels;
    pDecoder->internalSampleRate = vorbisInfo.sample_rate;
    mal_get_standard_channel_map(mal_standard_channel_map_vorbis, pDecoder->internalChannels, pDecoder->internalChannelMap);

    mal_result result = mal_decoder__init_dsp(pDecoder, pConfig, mal_decoder_internal_on_read_pcm_frames__vorbis);
    if (result != MAL_SUCCESS) {
        stb_vorbis_close(pVorbis->pInternalVorbis);
        mal_free(pVorbis->pData);
        mal_free(pVorbis);
        return result;
    }

    return MAL_SUCCESS;
}
#endif

// MP3
#ifdef dr_mp3_h
#define MAL_HAS_MP3

size_t mal_decoder_internal_on_read__mp3(void* pUserData, void* pBufferOut, size_t bytesToRead)
{
    mal_decoder* pDecoder = (mal_decoder*)pUserData;
    mal_assert(pDecoder != NULL);
    mal_assert(pDecoder->onRead != NULL);

    return pDecoder->onRead(pDecoder, pBufferOut, bytesToRead);
}

drmp3_bool32 mal_decoder_internal_on_seek__mp3(void* pUserData, int offset, drmp3_seek_origin origin)
{
    mal_decoder* pDecoder = (mal_decoder*)pUserData;
    mal_assert(pDecoder != NULL);
    mal_assert(pDecoder->onSeek != NULL);

    return pDecoder->onSeek(pDecoder, offset, (origin == drmp3_seek_origin_start) ? mal_seek_origin_start : mal_seek_origin_current);
}

mal_uint32 mal_decoder_internal_on_read_pcm_frames__mp3(mal_pcm_converter* pDSP, void* pSamplesOut, mal_uint32 frameCount, void* pUserData)
{
    (void)pDSP;

    mal_decoder* pDecoder = (mal_decoder*)pUserData;
    mal_assert(pDecoder != NULL);
    mal_assert(pDecoder->internalFormat == mal_format_f32);

    drmp3* pMP3 = (drmp3*)pDecoder->pInternalDecoder;
    mal_assert(pMP3 != NULL);

    return (mal_uint32)drmp3_read_pcm_frames_f32(pMP3, frameCount, (float*)pSamplesOut);
}

mal_result mal_decoder_internal_on_seek_to_pcm_frame__mp3(mal_decoder* pDecoder, mal_uint64 frameIndex)
{
    drmp3* pMP3 = (drmp3*)pDecoder->pInternalDecoder;
    mal_assert(pMP3 != NULL);

    drmp3_bool32 result = drmp3_seek_to_pcm_frame(pMP3, frameIndex);
    if (result) {
        return MAL_SUCCESS;
    } else {
        return MAL_ERROR;
    }
}

mal_result mal_decoder_internal_on_uninit__mp3(mal_decoder* pDecoder)
{
    drmp3_uninit((drmp3*)pDecoder->pInternalDecoder);
    mal_free(pDecoder->pInternalDecoder);
    return MAL_SUCCESS;
}

mal_result mal_decoder_init_mp3__internal(const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_assert(pConfig != NULL);
    mal_assert(pDecoder != NULL);

    drmp3* pMP3 = (drmp3*)mal_malloc(sizeof(*pMP3));
    if (pMP3 == NULL) {
        return MAL_OUT_OF_MEMORY;
    }

    // Try opening the decoder first. MP3 can have variable sample rates (it's per frame/packet). We therefore need
    // to use some smarts to determine the most appropriate internal sample rate. These are the rules we're going
    // to use:
    //
    // Sample Rates
    // 1) If an output sample rate is specified in pConfig we just use that. Otherwise;
    // 2) Fall back to 44100.
    //
    // The internal channel count is always stereo, and the internal format is always f32.
    drmp3_config mp3Config;
    mal_zero_object(&mp3Config);
    mp3Config.outputChannels = 2;
    mp3Config.outputSampleRate = (pConfig->sampleRate != 0) ? pConfig->sampleRate : 44100;
    if (!drmp3_init(pMP3, mal_decoder_internal_on_read__mp3, mal_decoder_internal_on_seek__mp3, pDecoder, &mp3Config)) {
        return MAL_ERROR;
    }

    // If we get here it means we successfully initialized the MP3 decoder. We can now initialize the rest of the mal_decoder.
    pDecoder->onSeekToPCMFrame = mal_decoder_internal_on_seek_to_pcm_frame__mp3;
    pDecoder->onUninit = mal_decoder_internal_on_uninit__mp3;
    pDecoder->pInternalDecoder = pMP3;

    // Internal format.
    pDecoder->internalFormat = mal_format_f32;
    pDecoder->internalChannels = pMP3->channels;
    pDecoder->internalSampleRate = pMP3->sampleRate;
    mal_get_standard_channel_map(mal_standard_channel_map_default, pDecoder->internalChannels, pDecoder->internalChannelMap);

    mal_result result = mal_decoder__init_dsp(pDecoder, pConfig, mal_decoder_internal_on_read_pcm_frames__mp3);
    if (result != MAL_SUCCESS) {
        mal_free(pMP3);
        return result;
    }

    return MAL_SUCCESS;
}
#endif

// Raw
mal_uint32 mal_decoder_internal_on_read_pcm_frames__raw(mal_pcm_converter* pDSP, void* pSamplesOut, mal_uint32 frameCount, void* pUserData)
{
    (void)pDSP;

    mal_decoder* pDecoder = (mal_decoder*)pUserData;
    mal_assert(pDecoder != NULL);

    // For raw decoding we just read directly from the decoder's callbacks.
    mal_uint32 bpf = mal_get_bytes_per_frame(pDecoder->internalFormat, pDecoder->internalChannels);
    return (mal_uint32)pDecoder->onRead(pDecoder, pSamplesOut, frameCount * bpf) / bpf;
}

mal_result mal_decoder_internal_on_seek_to_pcm_frame__raw(mal_decoder* pDecoder, mal_uint64 frameIndex)
{
    mal_assert(pDecoder != NULL);

    if (pDecoder->onSeek == NULL) {
        return MAL_ERROR;
    }

    mal_bool32 result = MAL_FALSE;

    // The callback uses a 32 bit integer whereas we use a 64 bit unsigned integer. We just need to continuously seek until we're at the correct position.
    mal_uint64 totalBytesToSeek = frameIndex * mal_get_bytes_per_frame(pDecoder->internalFormat, pDecoder->internalChannels);
    if (totalBytesToSeek < 0x7FFFFFFF) {
        // Simple case.
        result = pDecoder->onSeek(pDecoder, (int)(frameIndex * mal_get_bytes_per_frame(pDecoder->internalFormat, pDecoder->internalChannels)), mal_seek_origin_start);
    } else {
        // Complex case. Start by doing a seek relative to the start. Then keep looping using offset seeking.
        result = pDecoder->onSeek(pDecoder, 0x7FFFFFFF, mal_seek_origin_start);
        if (result == MAL_TRUE) {
            totalBytesToSeek -= 0x7FFFFFFF;

            while (totalBytesToSeek > 0) {
                mal_uint64 bytesToSeekThisIteration = totalBytesToSeek;
                if (bytesToSeekThisIteration > 0x7FFFFFFF) {
                    bytesToSeekThisIteration = 0x7FFFFFFF;
                }

                result = pDecoder->onSeek(pDecoder, (int)bytesToSeekThisIteration, mal_seek_origin_current);
                if (result != MAL_TRUE) {
                    break;
                }

                totalBytesToSeek -= bytesToSeekThisIteration;
            }
        }
    }

    if (result) {
        return MAL_SUCCESS;
    } else {
        return MAL_ERROR;
    }
}

mal_result mal_decoder_internal_on_uninit__raw(mal_decoder* pDecoder)
{
    (void)pDecoder;
    return MAL_SUCCESS;
}

mal_result mal_decoder_init_raw__internal(const mal_decoder_config* pConfigIn, const mal_decoder_config* pConfigOut, mal_decoder* pDecoder)
{
    mal_assert(pConfigIn != NULL);
    mal_assert(pConfigOut != NULL);
    mal_assert(pDecoder != NULL);

    pDecoder->onSeekToPCMFrame = mal_decoder_internal_on_seek_to_pcm_frame__raw;
    pDecoder->onUninit = mal_decoder_internal_on_uninit__raw;

    // Internal format.
    pDecoder->internalFormat = pConfigIn->format;
    pDecoder->internalChannels = pConfigIn->channels;
    pDecoder->internalSampleRate = pConfigIn->sampleRate;
    mal_channel_map_copy(pDecoder->internalChannelMap, pConfigIn->channelMap, pConfigIn->channels);

    mal_result result = mal_decoder__init_dsp(pDecoder, pConfigOut, mal_decoder_internal_on_read_pcm_frames__raw);
    if (result != MAL_SUCCESS) {
        return result;
    }

    return MAL_SUCCESS;
}

mal_result mal_decoder__preinit(mal_decoder_read_proc onRead, mal_decoder_seek_proc onSeek, void* pUserData, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_assert(pConfig != NULL);

    if (pDecoder == NULL) {
        return MAL_INVALID_ARGS;
    }

    mal_zero_object(pDecoder);

    if (onRead == NULL || onSeek == NULL) {
        return MAL_INVALID_ARGS;
    }

    pDecoder->onRead = onRead;
    pDecoder->onSeek = onSeek;
    pDecoder->pUserData = pUserData;

    (void)pConfig;
    return MAL_SUCCESS;
}

mal_result mal_decoder_init_wav(mal_decoder_read_proc onRead, mal_decoder_seek_proc onSeek, void* pUserData, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_decoder_config config = mal_decoder_config_init_copy(pConfig);

    mal_result result = mal_decoder__preinit(onRead, onSeek, pUserData, &config, pDecoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

#ifdef MAL_HAS_WAV
    return mal_decoder_init_wav__internal(&config, pDecoder);
#else
    return MAL_NO_BACKEND;
#endif
}

mal_result mal_decoder_init_flac(mal_decoder_read_proc onRead, mal_decoder_seek_proc onSeek, void* pUserData, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_decoder_config config = mal_decoder_config_init_copy(pConfig);

    mal_result result = mal_decoder__preinit(onRead, onSeek, pUserData, &config, pDecoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

#ifdef MAL_HAS_FLAC
    return mal_decoder_init_flac__internal(&config, pDecoder);
#else
    return MAL_NO_BACKEND;
#endif
}

mal_result mal_decoder_init_vorbis(mal_decoder_read_proc onRead, mal_decoder_seek_proc onSeek, void* pUserData, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_decoder_config config = mal_decoder_config_init_copy(pConfig);

    mal_result result = mal_decoder__preinit(onRead, onSeek, pUserData, &config, pDecoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

#ifdef MAL_HAS_VORBIS
    return mal_decoder_init_vorbis__internal(&config, pDecoder);
#else
    return MAL_NO_BACKEND;
#endif
}

mal_result mal_decoder_init_mp3(mal_decoder_read_proc onRead, mal_decoder_seek_proc onSeek, void* pUserData, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_decoder_config config = mal_decoder_config_init_copy(pConfig);

    mal_result result = mal_decoder__preinit(onRead, onSeek, pUserData, &config, pDecoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

#ifdef MAL_HAS_MP3
    return mal_decoder_init_mp3__internal(&config, pDecoder);
#else
    return MAL_NO_BACKEND;
#endif
}

mal_result mal_decoder_init_raw(mal_decoder_read_proc onRead, mal_decoder_seek_proc onSeek, void* pUserData, const mal_decoder_config* pConfigIn, const mal_decoder_config* pConfigOut, mal_decoder* pDecoder)
{
    mal_decoder_config config = mal_decoder_config_init_copy(pConfigOut);

    mal_result result = mal_decoder__preinit(onRead, onSeek, pUserData, &config, pDecoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

    return mal_decoder_init_raw__internal(pConfigIn, &config, pDecoder);
}

mal_result mal_decoder_init__internal(mal_decoder_read_proc onRead, mal_decoder_seek_proc onSeek, void* pUserData, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_assert(pConfig != NULL);
    mal_assert(pDecoder != NULL);

    // Silence some warnings in the case that we don't have any decoder backends enabled.
    (void)onRead;
    (void)onSeek;
    (void)pUserData;
    (void)pConfig;
    (void)pDecoder;

    // We use trial and error to open a decoder.
    mal_result result = MAL_NO_BACKEND;

#ifdef MAL_HAS_WAV
    if (result != MAL_SUCCESS) {
        result = mal_decoder_init_wav__internal(pConfig, pDecoder);
        if (result != MAL_SUCCESS) {
            onSeek(pDecoder, 0, mal_seek_origin_start);
        }
    }
#endif
#ifdef MAL_HAS_FLAC
    if (result != MAL_SUCCESS) {
        result = mal_decoder_init_flac__internal(pConfig, pDecoder);
        if (result != MAL_SUCCESS) {
            onSeek(pDecoder, 0, mal_seek_origin_start);
        }
    }
#endif
#ifdef MAL_HAS_VORBIS
    if (result != MAL_SUCCESS) {
        result = mal_decoder_init_vorbis__internal(pConfig, pDecoder);
        if (result != MAL_SUCCESS) {
            onSeek(pDecoder, 0, mal_seek_origin_start);
        }
    }
#endif
#ifdef MAL_HAS_MP3
    if (result != MAL_SUCCESS) {
        result = mal_decoder_init_mp3__internal(pConfig, pDecoder);
        if (result != MAL_SUCCESS) {
            onSeek(pDecoder, 0, mal_seek_origin_start);
        }
    }
#endif

    if (result != MAL_SUCCESS) {
        return result;
    }

    return result;
}

mal_result mal_decoder_init(mal_decoder_read_proc onRead, mal_decoder_seek_proc onSeek, void* pUserData, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_decoder_config config = mal_decoder_config_init_copy(pConfig);

    mal_result result = mal_decoder__preinit(onRead, onSeek, pUserData, &config, pDecoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

    return mal_decoder_init__internal(onRead, onSeek, pUserData, &config, pDecoder);
}


size_t mal_decoder__on_read_memory(mal_decoder* pDecoder, void* pBufferOut, size_t bytesToRead)
{
    mal_assert(pDecoder->memory.dataSize >= pDecoder->memory.currentReadPos);

    size_t bytesRemaining = pDecoder->memory.dataSize - pDecoder->memory.currentReadPos;
    if (bytesToRead > bytesRemaining) {
        bytesToRead = bytesRemaining;
    }

    if (bytesToRead > 0) {
        mal_copy_memory(pBufferOut, pDecoder->memory.pData + pDecoder->memory.currentReadPos, bytesToRead);
        pDecoder->memory.currentReadPos += bytesToRead;
    }

    return bytesToRead;
}

mal_bool32 mal_decoder__on_seek_memory(mal_decoder* pDecoder, int byteOffset, mal_seek_origin origin)
{
    if (origin == mal_seek_origin_current) {
        if (byteOffset > 0) {
            if (pDecoder->memory.currentReadPos + byteOffset > pDecoder->memory.dataSize) {
                byteOffset = (int)(pDecoder->memory.dataSize - pDecoder->memory.currentReadPos);  // Trying to seek too far forward.
            }
        } else {
            if (pDecoder->memory.currentReadPos < (size_t)-byteOffset) {
                byteOffset = -(int)pDecoder->memory.currentReadPos;  // Trying to seek too far backwards.
            }
        }

        // This will never underflow thanks to the clamps above.
        pDecoder->memory.currentReadPos += byteOffset;
    } else {
        if ((mal_uint32)byteOffset <= pDecoder->memory.dataSize) {
            pDecoder->memory.currentReadPos = byteOffset;
        } else {
            pDecoder->memory.currentReadPos = pDecoder->memory.dataSize;  // Trying to seek too far forward.
        }
    }

    return MAL_TRUE;
}

mal_result mal_decoder__preinit_memory(const void* pData, size_t dataSize, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_result result = mal_decoder__preinit(mal_decoder__on_read_memory, mal_decoder__on_seek_memory, NULL, pConfig, pDecoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

    if (pData == NULL || dataSize == 0) {
        return MAL_INVALID_ARGS;
    }

    pDecoder->memory.pData = (const mal_uint8*)pData;
    pDecoder->memory.dataSize = dataSize;
    pDecoder->memory.currentReadPos = 0;

    (void)pConfig;
    return MAL_SUCCESS;
}

mal_result mal_decoder_init_memory(const void* pData, size_t dataSize, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_decoder_config config = mal_decoder_config_init_copy(pConfig);  // Make sure the config is not NULL.

    mal_result result = mal_decoder__preinit_memory(pData, dataSize, &config, pDecoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

    return mal_decoder_init__internal(mal_decoder__on_read_memory, mal_decoder__on_seek_memory, NULL, &config, pDecoder);
}

mal_result mal_decoder_init_memory_wav(const void* pData, size_t dataSize, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_decoder_config config = mal_decoder_config_init_copy(pConfig);  // Make sure the config is not NULL.

    mal_result result = mal_decoder__preinit_memory(pData, dataSize, &config, pDecoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

#ifdef MAL_HAS_WAV
    return mal_decoder_init_wav__internal(&config, pDecoder);
#else
    return MAL_NO_BACKEND;
#endif
}

mal_result mal_decoder_init_memory_flac(const void* pData, size_t dataSize, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_decoder_config config = mal_decoder_config_init_copy(pConfig);  // Make sure the config is not NULL.

    mal_result result = mal_decoder__preinit_memory(pData, dataSize, &config, pDecoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

#ifdef MAL_HAS_FLAC
    return mal_decoder_init_flac__internal(&config, pDecoder);
#else
    return MAL_NO_BACKEND;
#endif
}

mal_result mal_decoder_init_memory_vorbis(const void* pData, size_t dataSize, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_decoder_config config = mal_decoder_config_init_copy(pConfig);  // Make sure the config is not NULL.

    mal_result result = mal_decoder__preinit_memory(pData, dataSize, &config, pDecoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

#ifdef MAL_HAS_VORBIS
    return mal_decoder_init_vorbis__internal(&config, pDecoder);
#else
    return MAL_NO_BACKEND;
#endif
}

mal_result mal_decoder_init_memory_mp3(const void* pData, size_t dataSize, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_decoder_config config = mal_decoder_config_init_copy(pConfig);  // Make sure the config is not NULL.

    mal_result result = mal_decoder__preinit_memory(pData, dataSize, &config, pDecoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

#ifdef MAL_HAS_MP3
    return mal_decoder_init_mp3__internal(&config, pDecoder);
#else
    return MAL_NO_BACKEND;
#endif
}

mal_result mal_decoder_init_memory_raw(const void* pData, size_t dataSize, const mal_decoder_config* pConfigIn, const mal_decoder_config* pConfigOut, mal_decoder* pDecoder)
{
    mal_decoder_config config = mal_decoder_config_init_copy(pConfigOut);  // Make sure the config is not NULL.

    mal_result result = mal_decoder__preinit_memory(pData, dataSize, &config, pDecoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

    return mal_decoder_init_raw__internal(pConfigIn, &config, pDecoder);
}

#ifndef MAL_NO_STDIO
#include <stdio.h>
#if !defined(_MSC_VER) && !defined(__DMC__)
#include <strings.h>    // For strcasecmp().
#endif

const char* mal_path_file_name(const char* path)
{
    if (path == NULL) {
        return NULL;
    }

    const char* fileName = path;

    // We just loop through the path until we find the last slash.
    while (path[0] != '\0') {
        if (path[0] == '/' || path[0] == '\\') {
            fileName = path;
        }

        path += 1;
    }

    // At this point the file name is sitting on a slash, so just move forward.
    while (fileName[0] != '\0' && (fileName[0] == '/' || fileName[0] == '\\')) {
        fileName += 1;
    }

    return fileName;
}

const char* mal_path_extension(const char* path)
{
    if (path == NULL) {
        path = "";
    }

    const char* extension = mal_path_file_name(path);
    const char* lastOccurance = NULL;

    // Just find the last '.' and return.
    while (extension[0] != '\0') {
        if (extension[0] == '.') {
            extension += 1;
            lastOccurance = extension;
        }

        extension += 1;
    }

    return (lastOccurance != NULL) ? lastOccurance : extension;
}

mal_bool32 mal_path_extension_equal(const char* path, const char* extension)
{
    if (path == NULL || extension == NULL) {
        return MAL_FALSE;
    }

    const char* ext1 = extension;
    const char* ext2 = mal_path_extension(path);

#if defined(_MSC_VER) || defined(__DMC__)
    return _stricmp(ext1, ext2) == 0;
#else
    return strcasecmp(ext1, ext2) == 0;
#endif
}

size_t mal_decoder__on_read_stdio(mal_decoder* pDecoder, void* pBufferOut, size_t bytesToRead)
{
    return fread(pBufferOut, 1, bytesToRead, (FILE*)pDecoder->pUserData);
}

mal_bool32 mal_decoder__on_seek_stdio(mal_decoder* pDecoder, int byteOffset, mal_seek_origin origin)
{
    return fseek((FILE*)pDecoder->pUserData, byteOffset, (origin == mal_seek_origin_current) ? SEEK_CUR : SEEK_SET) == 0;
}

mal_result mal_decoder__preinit_file(const char* pFilePath, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    if (pDecoder == NULL) {
        return MAL_INVALID_ARGS;
    }

    mal_zero_object(pDecoder);

    if (pFilePath == NULL || pFilePath[0] == '\0') {
        return MAL_INVALID_ARGS;
    }

    FILE* pFile;
#if defined(_MSC_VER) && _MSC_VER >= 1400
    if (fopen_s(&pFile, pFilePath, "rb") != 0) {
        return MAL_ERROR;
    }
#else
    pFile = fopen(pFilePath, "rb");
    if (pFile == NULL) {
        return MAL_ERROR;
    }
#endif

    // We need to manually set the user data so the calls to mal_decoder__on_seek_stdio() succeed.
    pDecoder->pUserData = pFile;

    (void)pConfig;
    return MAL_SUCCESS;
}

mal_result mal_decoder_init_file(const char* pFilePath, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_result result = mal_decoder__preinit_file(pFilePath, pConfig, pDecoder);    // This sets pDecoder->pUserData to a FILE*.
    if (result != MAL_SUCCESS) {
        return result;
    }

    // WAV
    if (mal_path_extension_equal(pFilePath, "wav")) {
        result =  mal_decoder_init_wav(mal_decoder__on_read_stdio, mal_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
        if (result == MAL_SUCCESS) {
            return MAL_SUCCESS;
        }

        mal_decoder__on_seek_stdio(pDecoder, 0, mal_seek_origin_start);
    }

    // FLAC
    if (mal_path_extension_equal(pFilePath, "flac")) {
        result =  mal_decoder_init_flac(mal_decoder__on_read_stdio, mal_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
        if (result == MAL_SUCCESS) {
            return MAL_SUCCESS;
        }

        mal_decoder__on_seek_stdio(pDecoder, 0, mal_seek_origin_start);
    }

    // MP3
    if (mal_path_extension_equal(pFilePath, "mp3")) {
        result =  mal_decoder_init_mp3(mal_decoder__on_read_stdio, mal_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
        if (result == MAL_SUCCESS) {
            return MAL_SUCCESS;
        }

        mal_decoder__on_seek_stdio(pDecoder, 0, mal_seek_origin_start);
    }

    // Trial and error.
    return mal_decoder_init(mal_decoder__on_read_stdio, mal_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
}

mal_result mal_decoder_init_file_wav(const char* pFilePath, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_result result = mal_decoder__preinit_file(pFilePath, pConfig, pDecoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

    return mal_decoder_init_wav(mal_decoder__on_read_stdio, mal_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
}

mal_result mal_decoder_init_file_flac(const char* pFilePath, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_result result = mal_decoder__preinit_file(pFilePath, pConfig, pDecoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

    return mal_decoder_init_flac(mal_decoder__on_read_stdio, mal_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
}

mal_result mal_decoder_init_file_vorbis(const char* pFilePath, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_result result = mal_decoder__preinit_file(pFilePath, pConfig, pDecoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

    return mal_decoder_init_vorbis(mal_decoder__on_read_stdio, mal_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
}

mal_result mal_decoder_init_file_mp3(const char* pFilePath, const mal_decoder_config* pConfig, mal_decoder* pDecoder)
{
    mal_result result = mal_decoder__preinit_file(pFilePath, pConfig, pDecoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

    return mal_decoder_init_mp3(mal_decoder__on_read_stdio, mal_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
}
#endif

mal_result mal_decoder_uninit(mal_decoder* pDecoder)
{
    if (pDecoder == NULL) {
        return MAL_INVALID_ARGS;
    }

    if (pDecoder->onUninit) {
        pDecoder->onUninit(pDecoder);
    }

#ifndef MAL_NO_STDIO
    // If we have a file handle, close it.
    if (pDecoder->onRead == mal_decoder__on_read_stdio) {
        fclose((FILE*)pDecoder->pUserData);
    }
#endif

    return MAL_SUCCESS;
}

mal_uint64 mal_decoder_read_pcm_frames(mal_decoder* pDecoder, void* pFramesOut, mal_uint64 frameCount)
{
    if (pDecoder == NULL) return 0;

    return mal_pcm_converter_read(&pDecoder->dsp, pFramesOut, frameCount);
}

mal_result mal_decoder_seek_to_pcm_frame(mal_decoder* pDecoder, mal_uint64 frameIndex)
{
    if (pDecoder == NULL) return 0;

    if (pDecoder->onSeekToPCMFrame) {
        return pDecoder->onSeekToPCMFrame(pDecoder, frameIndex);
    }

    // Should never get here, but if we do it means onSeekToPCMFrame was not set by the backend.
    return MAL_INVALID_ARGS;
}


mal_result mal_decoder__full_decode_and_uninit(mal_decoder* pDecoder, mal_decoder_config* pConfigOut, mal_uint64* pFrameCountOut, void** ppPCMFramesOut)
{
    mal_assert(pDecoder != NULL);
    
    mal_uint64 totalFrameCount = 0;
    mal_uint64 bpf = mal_get_bytes_per_frame(pDecoder->outputFormat, pDecoder->outputChannels);

    // The frame count is unknown until we try reading. Thus, we just run in a loop.
    mal_uint64 dataCapInFrames = 0;
    void* pPCMFramesOut = NULL;
    for (;;) {
        // Make room if there's not enough.
        if (totalFrameCount == dataCapInFrames) {
            mal_uint64 newDataCapInFrames = dataCapInFrames*2;
            if (newDataCapInFrames == 0) {
                newDataCapInFrames = 4096;
            }

            if ((newDataCapInFrames * bpf) > MAL_SIZE_MAX) {
                mal_free(pPCMFramesOut);
                return MAL_TOO_LARGE;
            }


            void* pNewPCMFramesOut = (void*)mal_realloc(pPCMFramesOut, (size_t)(newDataCapInFrames * bpf));
            if (pNewPCMFramesOut == NULL) {
                mal_free(pPCMFramesOut);
                return MAL_OUT_OF_MEMORY;
            }

            dataCapInFrames = newDataCapInFrames;
            pPCMFramesOut = pNewPCMFramesOut;
        }

        mal_uint64 frameCountToTryReading = dataCapInFrames - totalFrameCount;
        mal_assert(frameCountToTryReading > 0);

        mal_uint64 framesJustRead = mal_decoder_read_pcm_frames(pDecoder, (mal_uint8*)pPCMFramesOut + (totalFrameCount * bpf), frameCountToTryReading);
        totalFrameCount += framesJustRead;

        if (framesJustRead < frameCountToTryReading) {
            break;
        }
    }

    
    if (pConfigOut != NULL) {
        pConfigOut->format = pDecoder->outputFormat;
        pConfigOut->channels = pDecoder->outputChannels;
        pConfigOut->sampleRate = pDecoder->outputSampleRate;
        mal_channel_map_copy(pConfigOut->channelMap, pDecoder->outputChannelMap, pDecoder->outputChannels);
    }

    if (ppPCMFramesOut != NULL) {
        *ppPCMFramesOut = pPCMFramesOut;
    } else {
        mal_free(pPCMFramesOut);
    }

    if (pFrameCountOut != NULL) {
        *pFrameCountOut = totalFrameCount;
    }

    mal_decoder_uninit(pDecoder);
    return MAL_SUCCESS;
}

#ifndef MAL_NO_STDIO
mal_result mal_decode_file(const char* pFilePath, mal_decoder_config* pConfig, mal_uint64* pFrameCountOut, void** ppPCMFramesOut)
{
    if (pFrameCountOut != NULL) {
        *pFrameCountOut = 0;
    }
    if (ppPCMFramesOut != NULL) {
        *ppPCMFramesOut = NULL;
    }

    if (pFilePath == NULL) {
        return MAL_INVALID_ARGS;
    }

    mal_decoder_config config = mal_decoder_config_init_copy(pConfig);
    
    mal_decoder decoder;
    mal_result result = mal_decoder_init_file(pFilePath, &config, &decoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

    return mal_decoder__full_decode_and_uninit(&decoder, pConfig, pFrameCountOut, ppPCMFramesOut);
}
#endif

mal_result mal_decode_memory(const void* pData, size_t dataSize, mal_decoder_config* pConfig, mal_uint64* pFrameCountOut, void** ppPCMFramesOut)
{
    if (pFrameCountOut != NULL) {
        *pFrameCountOut = 0;
    }
    if (ppPCMFramesOut != NULL) {
        *ppPCMFramesOut = NULL;
    }

    if (pData == NULL || dataSize == 0) {
        return MAL_INVALID_ARGS;
    }

    mal_decoder_config config = mal_decoder_config_init_copy(pConfig);
    
    mal_decoder decoder;
    mal_result result = mal_decoder_init_memory(pData, dataSize, &config, &decoder);
    if (result != MAL_SUCCESS) {
        return result;
    }

    return mal_decoder__full_decode_and_uninit(&decoder, pConfig, pFrameCountOut, ppPCMFramesOut);
}

#endif  // MAL_NO_DECODING




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// GENERATION
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

mal_result mal_sine_wave_init(double amplitude, double periodsPerSecond, mal_uint32 sampleRate, mal_sine_wave* pSineWave)
{
    if (pSineWave == NULL) {
        return MAL_INVALID_ARGS;
    }
    mal_zero_object(pSineWave);

    if (amplitude == 0 || periodsPerSecond == 0) {
        return MAL_INVALID_ARGS;
    }

    if (amplitude > 1) {
        amplitude = 1;
    }
    if (amplitude < -1) {
        amplitude = -1;
    }

    pSineWave->amplitude = amplitude;
    pSineWave->periodsPerSecond = periodsPerSecond;
    pSineWave->delta = MAL_TAU_D / sampleRate;
    pSineWave->time = 0;

    return MAL_SUCCESS;
}

mal_uint64 mal_sine_wave_read_f32(mal_sine_wave* pSineWave, mal_uint64 count, float* pSamples)
{
    return mal_sine_wave_read_f32_ex(pSineWave, count, 1, mal_stream_layout_interleaved, &pSamples);
}

mal_uint64 mal_sine_wave_read_f32_ex(mal_sine_wave* pSineWave, mal_uint64 frameCount, mal_uint32 channels, mal_stream_layout layout, float** ppFrames)
{
    if (pSineWave == NULL) {
        return 0;
    }

    if (ppFrames != NULL) {
        for (mal_uint64 iFrame = 0; iFrame < frameCount; iFrame += 1) {
            float s = (float)(sin(pSineWave->time * pSineWave->periodsPerSecond) * pSineWave->amplitude);
            pSineWave->time += pSineWave->delta;

            if (layout == mal_stream_layout_interleaved) {
                for (mal_uint32 iChannel = 0; iChannel < channels; iChannel += 1) {
                    ppFrames[0][iFrame*channels + iChannel] = s;
                }
            } else {
                for (mal_uint32 iChannel = 0; iChannel < channels; iChannel += 1) {
                    ppFrames[iChannel][iFrame] = s;
                }
            }
        }
    } else {
        pSineWave->time += pSineWave->delta * frameCount;
    }

    return frameCount;
}

#if defined(_MSC_VER)
    #pragma warning(pop)
#endif

#endif  /* MINI_AL_IMPLEMENTATION */

/*
BACKEND IMPLEMENTATION GUIDLINES
================================
Context
-------
- Run-time linking if possible.
- Set whether or not it's an asynchronous backend

Device
------
- If a full-duplex device is requested and the backend does not support full duplex devices, have mal_device_init__[backend]()
  return MAL_DEVICE_TYPE_NOT_SUPPORTED.
- If exclusive mode is requested, but the backend does not support it, return MAL_SHARE_MODE_NOT_SUPPORTED. If practical, try
  not to fall back to a different share mode - give the client exactly what they asked for. Some backends, such as ALSA, may
  not have a practical way to distinguish between the two.
- If pDevice->usingDefault* is set, prefer the device's native value if the backend supports it. Otherwise use the relevant
  value from the config.
- If the configs buffer size in frames is 0, set it based on the buffer size in milliseconds, keeping in mind to handle the
  case when the default sample rate is being used where practical.
- Backends must set the following members of pDevice before returning successfully from mal_device_init__[backend]():
  - internalFormat
  - internalChannels
  - internalSampleRate
  - internalChannelMap
  - bufferSizeInFrames
  - periods
*/

/*
REVISION HISTORY
================

v0.8.15 - 201x-xx-xx
  - Add Web Audio backend. This is used when compiling with Emscripten. The SDL backend, which was previously
    used for web support, will be removed in a future version.
  - Add AAudio backend (Android Audio). This is the new priority backend for Android. Support for AAudio starts
    with Android 8. OpenSL|ES is used as a fallback for older versions of Android.
  - Deprecate the OpenAL backend.
  - Deprecate the SDL backend.

v0.8.14 - 2018-12-16
  - Core Audio: Fix a bug where the device state is not set correctly after stopping.
  - Add support for custom weights to the channel router.
  - Update decoders to use updated APIs in dr_flac, dr_mp3 and dr_wav.

v0.8.13 - 2018-12-04
  - Core Audio: Fix a bug with channel mapping.
  - Fix a bug with channel routing where the back/left and back/right channels have the wrong weight.

v0.8.12 - 2018-11-27
  - Drop support for SDL 1.2. The Emscripten build now requires "-s USE_SDL=2".
  - Fix a linking error with ALSA.
  - Fix a bug on iOS where the device name is not set correctly.

v0.8.11 - 2018-11-21
  - iOS bug fixes.
  - Minor tweaks to PulseAudio.

v0.8.10 - 2018-10-21
  - Core Audio: Fix a hang when uninitializing a device.
  - Fix a bug where an incorrect value is returned from mal_device_stop().

v0.8.9 - 2018-09-28
  - Fix a bug with the SDL backend where device initialization fails.

v0.8.8 - 2018-09-14
  - Fix Linux build with the ALSA backend.
  - Minor documentation fix.

v0.8.7 - 2018-09-12
  - Fix a bug with UWP detection.

v0.8.6 - 2018-08-26
  - Automatically switch the internal device when the default device is unplugged. Note that this is still in the
    early stages and not all backends handle this the same way. As of this version, this will not detect a default
    device switch when changed from the operating system's audio preferences (unless the backend itself handles
    this automatically). This is not supported in exclusive mode.
  - WASAPI and Core Audio: Add support for stream routing. When the application is using a default device and the
    user switches the default device via the operating system's audio preferences, mini_al will automatically switch
    the internal device to the new default. This is not supported in exclusive mode.
  - WASAPI: Add support for hardware offloading via IAudioClient2. Only supported on Windows 8 and newer.
  - WASAPI: Add support for low-latency shared mode via IAudioClient3. Only supported on Windows 10 and newer.
  - Add support for compiling the UWP build as C.
  - mal_device_set_recv_callback() and mal_device_set_send_callback() have been deprecated. You must now set this
    when the device is initialized with mal_device_init*(). These will be removed in version 0.9.0.

v0.8.5 - 2018-08-12
  - Add support for specifying the size of a device's buffer in milliseconds. You can still set the buffer size in
    frames if that suits you. When bufferSizeInFrames is 0, bufferSizeInMilliseconds will be used. If both are non-0
    then bufferSizeInFrames will take priority. If both are set to 0 the default buffer size is used.
  - Add support for the audio(4) backend to OpenBSD.
  - Fix a bug with the ALSA backend that was causing problems on Raspberry Pi. This significantly improves the
    Raspberry Pi experience.
  - Fix a bug where an incorrect number of samples is returned from sinc resampling.
  - Add support for setting the value to be passed to internal calls to CoInitializeEx().
  - WASAPI and WinMM: Stop the device when it is unplugged.

v0.8.4 - 2018-08-06
  - Add sndio backend for OpenBSD.
  - Add audio(4) backend for NetBSD.
  - Drop support for the OSS backend on everything except FreeBSD and DragonFly BSD.
  - Formats are now native-endian (were previously little-endian).
  - Mark some APIs as deprecated:
    - mal_src_set_input_sample_rate() and mal_src_set_output_sample_rate() are replaced with mal_src_set_sample_rate().
    - mal_dsp_set_input_sample_rate() and mal_dsp_set_output_sample_rate() are replaced with mal_dsp_set_sample_rate().
  - Fix a bug when capturing using the WASAPI backend.
  - Fix some aliasing issues with resampling, specifically when increasing the sample rate.
  - Fix warnings.

v0.8.3 - 2018-07-15
  - Fix a crackling bug when resampling in capture mode.
  - Core Audio: Fix a bug where capture does not work.
  - ALSA: Fix a bug where the worker thread can get stuck in an infinite loop.
  - PulseAudio: Fix a bug where mal_context_init() succeeds when PulseAudio is unusable.
  - JACK: Fix a bug where mal_context_init() succeeds when JACK is unusable.

v0.8.2 - 2018-07-07
  - Fix a bug on macOS with Core Audio where the internal callback is not called.

v0.8.1 - 2018-07-06
  - Fix compilation errors and warnings.

v0.8 - 2018-07-05
  - Changed MAL_IMPLEMENTATION to MINI_AL_IMPLEMENTATION for consistency with other libraries. The old
    way is still supported for now, but you should update as it may be removed in the future.
  - API CHANGE: Replace device enumeration APIs. mal_enumerate_devices() has been replaced with
    mal_context_get_devices(). An additional low-level device enumration API has been introduced called
    mal_context_enumerate_devices() which uses a callback to report devices.
  - API CHANGE: Rename mal_get_sample_size_in_bytes() to mal_get_bytes_per_sample() and add
    mal_get_bytes_per_frame().
  - API CHANGE: Replace mal_device_config.preferExclusiveMode with mal_device_config.shareMode.
    - This new config can be set to mal_share_mode_shared (default) or mal_share_mode_exclusive.
  - API CHANGE: Remove excludeNullDevice from mal_context_config.alsa.
  - API CHANGE: Rename MAL_MAX_SAMPLE_SIZE_IN_BYTES to MAL_MAX_PCM_SAMPLE_SIZE_IN_BYTES.
  - API CHANGE: Change the default channel mapping to the standard Microsoft mapping.
  - API CHANGE: Remove backend-specific result codes.
  - API CHANGE: Changes to the format conversion APIs (mal_pcm_f32_to_s16(), etc.)
  - Add support for Core Audio (Apple).
  - Add support for PulseAudio.
    - This is the highest priority backend on Linux (higher priority than ALSA) since it is commonly
      installed by default on many of the popular distros and offer's more seamless integration on
      platforms where PulseAudio is used. In addition, if PulseAudio is installed and running (which
      is extremely common), it's better to just use PulseAudio directly rather than going through the
      "pulse" ALSA plugin (which is what the "default" ALSA device is likely set to).
  - Add support for JACK.
  - Remove dependency on asound.h for the ALSA backend. This means the ALSA development packages are no
    longer required to build mini_al.
  - Remove dependency on dsound.h for the DirectSound backend. This fixes build issues with some
    distributions of MinGW.
  - Remove dependency on audioclient.h for the WASAPI backend. This fixes build issues with some
    distributions of MinGW.
  - Add support for dithering to format conversion.
  - Add support for configuring the priority of the worker thread.
  - Add a sine wave generator.
  - Improve efficiency of sample rate conversion.
  - Introduce the notion of standard channel maps. Use mal_get_standard_channel_map().
  - Introduce the notion of default device configurations. A default config uses the same configuration
    as the backend's internal device, and as such results in a pass-through data transmission pipeline.
  - Add support for passing in NULL for the device config in mal_device_init(), which uses a default
    config. This requires manually calling mal_device_set_send/recv_callback().
  - Add support for decoding from raw PCM data (mal_decoder_init_raw(), etc.)
  - Make mal_device_init_ex() more robust.
  - Make some APIs more const-correct.
  - Fix errors with SDL detection on Apple platforms.
  - Fix errors with OpenAL detection.
  - Fix some memory leaks.
  - Fix a bug with opening decoders from memory.
  - Early work on SSE2, AVX2 and NEON optimizations.
  - Miscellaneous bug fixes.
  - Documentation updates.

v0.7 - 2018-02-25
  - API CHANGE: Change mal_src_read_frames() and mal_dsp_read_frames() to use 64-bit sample counts.
  - Add decoder APIs for loading WAV, FLAC, Vorbis and MP3 files.
  - Allow opening of devices without a context.
    - In this case the context is created and managed internally by the device.
  - Change the default channel mapping to the same as that used by FLAC.
  - Fix build errors with macOS.

v0.6c - 2018-02-12
  - Fix build errors with BSD/OSS.

v0.6b - 2018-02-03
  - Fix some warnings when compiling with Visual C++.

v0.6a - 2018-01-26
  - Fix errors with channel mixing when increasing the channel count.
  - Improvements to the build system for the OpenAL backend.
  - Documentation fixes.

v0.6 - 2017-12-08
  - API CHANGE: Expose and improve mutex APIs. If you were using the mutex APIs before this version you'll
    need to update.
  - API CHANGE: SRC and DSP callbacks now take a pointer to a mal_src and mal_dsp object respectively.
  - API CHANGE: Improvements to event and thread APIs. These changes make these APIs more consistent.
  - Add support for SDL and Emscripten.
  - Simplify the build system further for when development packages for various backends are not installed.
    With this change, when the compiler supports __has_include, backends without the relevant development
    packages installed will be ignored. This fixes the build for old versions of MinGW.
  - Fixes to the Android build.
  - Add mal_convert_frames(). This is a high-level helper API for performing a one-time, bulk conversion of
    audio data to a different format.
  - Improvements to f32 -> u8/s16/s24/s32 conversion routines.
  - Fix a bug where the wrong value is returned from mal_device_start() for the OpenSL backend.
  - Fixes and improvements for Raspberry Pi.
  - Warning fixes.

v0.5 - 2017-11-11
  - API CHANGE: The mal_context_init() function now takes a pointer to a mal_context_config object for
    configuring the context. The works in the same kind of way as the device config. The rationale for this
    change is to give applications better control over context-level properties, add support for backend-
    specific configurations, and support extensibility without breaking the API.
  - API CHANGE: The alsa.preferPlugHW device config variable has been removed since it's not really useful for
    anything anymore.
  - ALSA: By default, device enumeration will now only enumerate over unique card/device pairs. Applications
    can enable verbose device enumeration by setting the alsa.useVerboseDeviceEnumeration context config
    variable.
  - ALSA: When opening a device in shared mode (the default), the dmix/dsnoop plugin will be prioritized. If
    this fails it will fall back to the hw plugin. With this change the preferExclusiveMode config is now
    honored. Note that this does not happen when alsa.useVerboseDeviceEnumeration is set to true (see above)
    which is by design.
  - ALSA: Add support for excluding the "null" device using the alsa.excludeNullDevice context config variable.
  - ALSA: Fix a bug with channel mapping which causes an assertion to fail.
  - Fix errors with enumeration when pInfo is set to NULL.
  - OSS: Fix a bug when starting a device when the client sends 0 samples for the initial buffer fill.

v0.4 - 2017-11-05
  - API CHANGE: The log callback is now per-context rather than per-device and as is thus now passed to
    mal_context_init(). The rationale for this change is that it allows applications to capture diagnostic
    messages at the context level. Previously this was only available at the device level.
  - API CHANGE: The device config passed to mal_device_init() is now const.
  - Added support for OSS which enables support on BSD platforms.
  - Added support for WinMM (waveOut/waveIn).
  - Added support for UWP (Universal Windows Platform) applications. Currently C++ only.
  - Added support for exclusive mode for selected backends. Currently supported on WASAPI.
  - POSIX builds no longer require explicit linking to libpthread (-lpthread).
  - ALSA: Explicit linking to libasound (-lasound) is no longer required.
  - ALSA: Latency improvements.
  - ALSA: Use MMAP mode where available. This can be disabled with the alsa.noMMap config.
  - ALSA: Use "hw" devices instead of "plughw" devices by default. This can be disabled with the
    alsa.preferPlugHW config.
  - WASAPI is now the highest priority backend on Windows platforms.
  - Fixed an error with sample rate conversion which was causing crackling when capturing.
  - Improved error handling.
  - Improved compiler support.
  - Miscellaneous bug fixes.

v0.3 - 2017-06-19
  - API CHANGE: Introduced the notion of a context. The context is the highest level object and is required for
    enumerating and creating devices. Now, applications must first create a context, and then use that to
    enumerate and create devices. The reason for this change is to ensure device enumeration and creation is
    tied to the same backend. In addition, some backends are better suited to this design.
  - API CHANGE: Removed the rewinding APIs because they're too inconsistent across the different backends, hard
    to test and maintain, and just generally unreliable.
  - Added helper APIs for initializing mal_device_config objects.
  - Null Backend: Fixed a crash when recording.
  - Fixed build for UWP.
  - Added support for f32 formats to the OpenSL|ES backend.
  - Added initial implementation of the WASAPI backend.
  - Added initial implementation of the OpenAL backend.
  - Added support for low quality linear sample rate conversion.
  - Added early support for basic channel mapping.

v0.2 - 2016-10-28
  - API CHANGE: Add user data pointer as the last parameter to mal_device_init(). The rationale for this
    change is to ensure the logging callback has access to the user data during initialization.
  - API CHANGE: Have device configuration properties be passed to mal_device_init() via a structure. Rationale:
    1) The number of parameters is just getting too much.
    2) It makes it a bit easier to add new configuration properties in the future. In particular, there's a
       chance there will be support added for backend-specific properties.
  - Dropped support for f64, A-law and Mu-law formats since they just aren't common enough to justify the
    added maintenance cost.
  - DirectSound: Increased the default buffer size for capture devices.
  - Added initial implementation of the OpenSL|ES backend.

v0.1 - 2016-10-21
  - Initial versioned release.
*/


/*
This software is available as a choice of the following licenses. Choose
whichever you prefer.

===============================================================================
ALTERNATIVE 1 - Public Domain (www.unlicense.org)
===============================================================================
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.

In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org/>

===============================================================================
ALTERNATIVE 2 - MIT No Attribution
===============================================================================
Copyright 2019 David Reid

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
